"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseMetadataFromResponseHeaders = exports.parseTwirpErrorResponse = exports.createTwirpRequestHeader = void 0;
const runtime_1 = require("@protobuf-ts/runtime");
const runtime_rpc_1 = require("@protobuf-ts/runtime-rpc");
const twitch_twirp_error_code_1 = require("./twitch-twirp-error-code");
/**
 * Create fetch API headers for a Twirp request.
 */
function createTwirpRequestHeader(headers, sendJson, meta) {
    // add meta as headers
    if (meta) {
        for (let [k, v] of Object.entries(meta)) {
            if (typeof v == "string")
                headers.append(k, v);
            else
                for (let i of v)
                    headers.append(k, i);
        }
    }
    // set standard headers (possibly overwriting meta)
    headers.set('Content-Type', sendJson ? "application/json" : "application/protobuf");
    headers.set('Accept', sendJson ? "application/json" : "application/protobuf, application/json");
    return headers;
}
exports.createTwirpRequestHeader = createTwirpRequestHeader;
/**
 * Parse Twirp error message from JSON and create RpcError from the Twirp error.
 *
 * see https://twitchtv.github.io/twirp/docs/spec_v5.html
 */
function parseTwirpErrorResponse(json) {
    if (!runtime_1.isJsonObject(json) || typeof json.code !== "string" || typeof json.msg !== "string")
        return new runtime_rpc_1.RpcError('cannot read twirp error response', twitch_twirp_error_code_1.TwirpErrorCode[twitch_twirp_error_code_1.TwirpErrorCode.internal]);
    let meta = {};
    if (runtime_1.isJsonObject(json.meta)) {
        for (let [k, v] of Object.entries(json.meta)) {
            if (typeof v == "string")
                meta[k] = v;
        }
    }
    return new runtime_rpc_1.RpcError(json.msg, json.code, meta);
}
exports.parseTwirpErrorResponse = parseTwirpErrorResponse;
/**
 * Parses fetch API response headers to RpcMetaData.
 * Drops the headers Content-Type and Content-Length.
 */
function parseMetadataFromResponseHeaders(headers) {
    let meta = {};
    headers.forEach((value, key) => {
        if (key.toLowerCase() === 'content-type')
            return;
        if (key.toLowerCase() === 'content-length')
            return;
        if (meta.hasOwnProperty(key))
            meta[key].push(value);
        else
            meta[key] = value;
    });
    return meta;
}
exports.parseMetadataFromResponseHeaders = parseMetadataFromResponseHeaders;
