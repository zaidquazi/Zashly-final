import {
  __asyncGenerator,
  __asyncValues,
  __await,
  __awaiter,
  __extends,
  __generator,
  __read,
  __spreadArray,
  __values,
  clsx_default
} from "./chunk-DHBUYUGV.js";
import {
  require_react_dom
} from "./chunk-ODBTC7VH.js";
import {
  require_jsx_runtime
} from "./chunk-RTCDEPY5.js";
import {
  require_react
} from "./chunk-7EEON6PG.js";
import {
  AxiosError,
  axios_default
} from "./chunk-AY4HXCNU.js";
import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-4B2QHNJT.js";

// node_modules/sdp/sdp.js
var require_sdp = __commonJS({
  "node_modules/sdp/sdp.js"(exports, module) {
    "use strict";
    var SDPUtils2 = {};
    SDPUtils2.generateIdentifier = function() {
      return Math.random().toString(36).substring(2, 12);
    };
    SDPUtils2.localCName = SDPUtils2.generateIdentifier();
    SDPUtils2.splitLines = function(blob) {
      return blob.trim().split("\n").map((line) => line.trim());
    };
    SDPUtils2.splitSections = function(blob) {
      const parts = blob.split("\nm=");
      return parts.map((part, index3) => (index3 > 0 ? "m=" + part : part).trim() + "\r\n");
    };
    SDPUtils2.getDescription = function(blob) {
      const sections = SDPUtils2.splitSections(blob);
      return sections && sections[0];
    };
    SDPUtils2.getMediaSections = function(blob) {
      const sections = SDPUtils2.splitSections(blob);
      sections.shift();
      return sections;
    };
    SDPUtils2.matchPrefix = function(blob, prefix) {
      return SDPUtils2.splitLines(blob).filter((line) => line.indexOf(prefix) === 0);
    };
    SDPUtils2.parseCandidate = function(line) {
      let parts;
      if (line.indexOf("a=candidate:") === 0) {
        parts = line.substring(12).split(" ");
      } else {
        parts = line.substring(10).split(" ");
      }
      const candidate = {
        foundation: parts[0],
        component: { 1: "rtp", 2: "rtcp" }[parts[1]] || parts[1],
        protocol: parts[2].toLowerCase(),
        priority: parseInt(parts[3], 10),
        ip: parts[4],
        address: parts[4],
        // address is an alias for ip.
        port: parseInt(parts[5], 10),
        // skip parts[6] == 'typ'
        type: parts[7]
      };
      for (let i = 8; i < parts.length; i += 2) {
        switch (parts[i]) {
          case "raddr":
            candidate.relatedAddress = parts[i + 1];
            break;
          case "rport":
            candidate.relatedPort = parseInt(parts[i + 1], 10);
            break;
          case "tcptype":
            candidate.tcpType = parts[i + 1];
            break;
          case "ufrag":
            candidate.ufrag = parts[i + 1];
            candidate.usernameFragment = parts[i + 1];
            break;
          default:
            if (candidate[parts[i]] === void 0) {
              candidate[parts[i]] = parts[i + 1];
            }
            break;
        }
      }
      return candidate;
    };
    SDPUtils2.writeCandidate = function(candidate) {
      const sdp2 = [];
      sdp2.push(candidate.foundation);
      const component = candidate.component;
      if (component === "rtp") {
        sdp2.push(1);
      } else if (component === "rtcp") {
        sdp2.push(2);
      } else {
        sdp2.push(component);
      }
      sdp2.push(candidate.protocol.toUpperCase());
      sdp2.push(candidate.priority);
      sdp2.push(candidate.address || candidate.ip);
      sdp2.push(candidate.port);
      const type = candidate.type;
      sdp2.push("typ");
      sdp2.push(type);
      if (type !== "host" && candidate.relatedAddress && candidate.relatedPort) {
        sdp2.push("raddr");
        sdp2.push(candidate.relatedAddress);
        sdp2.push("rport");
        sdp2.push(candidate.relatedPort);
      }
      if (candidate.tcpType && candidate.protocol.toLowerCase() === "tcp") {
        sdp2.push("tcptype");
        sdp2.push(candidate.tcpType);
      }
      if (candidate.usernameFragment || candidate.ufrag) {
        sdp2.push("ufrag");
        sdp2.push(candidate.usernameFragment || candidate.ufrag);
      }
      return "candidate:" + sdp2.join(" ");
    };
    SDPUtils2.parseIceOptions = function(line) {
      return line.substring(14).split(" ");
    };
    SDPUtils2.parseRtpMap = function(line) {
      let parts = line.substring(9).split(" ");
      const parsed = {
        payloadType: parseInt(parts.shift(), 10)
        // was: id
      };
      parts = parts[0].split("/");
      parsed.name = parts[0];
      parsed.clockRate = parseInt(parts[1], 10);
      parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;
      parsed.numChannels = parsed.channels;
      return parsed;
    };
    SDPUtils2.writeRtpMap = function(codec) {
      let pt = codec.payloadType;
      if (codec.preferredPayloadType !== void 0) {
        pt = codec.preferredPayloadType;
      }
      const channels = codec.channels || codec.numChannels || 1;
      return "a=rtpmap:" + pt + " " + codec.name + "/" + codec.clockRate + (channels !== 1 ? "/" + channels : "") + "\r\n";
    };
    SDPUtils2.parseExtmap = function(line) {
      const parts = line.substring(9).split(" ");
      return {
        id: parseInt(parts[0], 10),
        direction: parts[0].indexOf("/") > 0 ? parts[0].split("/")[1] : "sendrecv",
        uri: parts[1],
        attributes: parts.slice(2).join(" ")
      };
    };
    SDPUtils2.writeExtmap = function(headerExtension) {
      return "a=extmap:" + (headerExtension.id || headerExtension.preferredId) + (headerExtension.direction && headerExtension.direction !== "sendrecv" ? "/" + headerExtension.direction : "") + " " + headerExtension.uri + (headerExtension.attributes ? " " + headerExtension.attributes : "") + "\r\n";
    };
    SDPUtils2.parseFmtp = function(line) {
      const parsed = {};
      let kv;
      const parts = line.substring(line.indexOf(" ") + 1).split(";");
      for (let j = 0; j < parts.length; j++) {
        kv = parts[j].trim().split("=");
        parsed[kv[0].trim()] = kv[1];
      }
      return parsed;
    };
    SDPUtils2.writeFmtp = function(codec) {
      let line = "";
      let pt = codec.payloadType;
      if (codec.preferredPayloadType !== void 0) {
        pt = codec.preferredPayloadType;
      }
      if (codec.parameters && Object.keys(codec.parameters).length) {
        const params = [];
        Object.keys(codec.parameters).forEach((param) => {
          if (codec.parameters[param] !== void 0) {
            params.push(param + "=" + codec.parameters[param]);
          } else {
            params.push(param);
          }
        });
        line += "a=fmtp:" + pt + " " + params.join(";") + "\r\n";
      }
      return line;
    };
    SDPUtils2.parseRtcpFb = function(line) {
      const parts = line.substring(line.indexOf(" ") + 1).split(" ");
      return {
        type: parts.shift(),
        parameter: parts.join(" ")
      };
    };
    SDPUtils2.writeRtcpFb = function(codec) {
      let lines = "";
      let pt = codec.payloadType;
      if (codec.preferredPayloadType !== void 0) {
        pt = codec.preferredPayloadType;
      }
      if (codec.rtcpFeedback && codec.rtcpFeedback.length) {
        codec.rtcpFeedback.forEach((fb) => {
          lines += "a=rtcp-fb:" + pt + " " + fb.type + (fb.parameter && fb.parameter.length ? " " + fb.parameter : "") + "\r\n";
        });
      }
      return lines;
    };
    SDPUtils2.parseSsrcMedia = function(line) {
      const sp = line.indexOf(" ");
      const parts = {
        ssrc: parseInt(line.substring(7, sp), 10)
      };
      const colon = line.indexOf(":", sp);
      if (colon > -1) {
        parts.attribute = line.substring(sp + 1, colon);
        parts.value = line.substring(colon + 1);
      } else {
        parts.attribute = line.substring(sp + 1);
      }
      return parts;
    };
    SDPUtils2.parseSsrcGroup = function(line) {
      const parts = line.substring(13).split(" ");
      return {
        semantics: parts.shift(),
        ssrcs: parts.map((ssrc) => parseInt(ssrc, 10))
      };
    };
    SDPUtils2.getMid = function(mediaSection) {
      const mid = SDPUtils2.matchPrefix(mediaSection, "a=mid:")[0];
      if (mid) {
        return mid.substring(6);
      }
    };
    SDPUtils2.parseFingerprint = function(line) {
      const parts = line.substring(14).split(" ");
      return {
        algorithm: parts[0].toLowerCase(),
        // algorithm is case-sensitive in Edge.
        value: parts[1].toUpperCase()
        // the definition is upper-case in RFC 4572.
      };
    };
    SDPUtils2.getDtlsParameters = function(mediaSection, sessionpart) {
      const lines = SDPUtils2.matchPrefix(
        mediaSection + sessionpart,
        "a=fingerprint:"
      );
      return {
        role: "auto",
        fingerprints: lines.map(SDPUtils2.parseFingerprint)
      };
    };
    SDPUtils2.writeDtlsParameters = function(params, setupType) {
      let sdp2 = "a=setup:" + setupType + "\r\n";
      params.fingerprints.forEach((fp) => {
        sdp2 += "a=fingerprint:" + fp.algorithm + " " + fp.value + "\r\n";
      });
      return sdp2;
    };
    SDPUtils2.parseCryptoLine = function(line) {
      const parts = line.substring(9).split(" ");
      return {
        tag: parseInt(parts[0], 10),
        cryptoSuite: parts[1],
        keyParams: parts[2],
        sessionParams: parts.slice(3)
      };
    };
    SDPUtils2.writeCryptoLine = function(parameters) {
      return "a=crypto:" + parameters.tag + " " + parameters.cryptoSuite + " " + (typeof parameters.keyParams === "object" ? SDPUtils2.writeCryptoKeyParams(parameters.keyParams) : parameters.keyParams) + (parameters.sessionParams ? " " + parameters.sessionParams.join(" ") : "") + "\r\n";
    };
    SDPUtils2.parseCryptoKeyParams = function(keyParams) {
      if (keyParams.indexOf("inline:") !== 0) {
        return null;
      }
      const parts = keyParams.substring(7).split("|");
      return {
        keyMethod: "inline",
        keySalt: parts[0],
        lifeTime: parts[1],
        mkiValue: parts[2] ? parts[2].split(":")[0] : void 0,
        mkiLength: parts[2] ? parts[2].split(":")[1] : void 0
      };
    };
    SDPUtils2.writeCryptoKeyParams = function(keyParams) {
      return keyParams.keyMethod + ":" + keyParams.keySalt + (keyParams.lifeTime ? "|" + keyParams.lifeTime : "") + (keyParams.mkiValue && keyParams.mkiLength ? "|" + keyParams.mkiValue + ":" + keyParams.mkiLength : "");
    };
    SDPUtils2.getCryptoParameters = function(mediaSection, sessionpart) {
      const lines = SDPUtils2.matchPrefix(
        mediaSection + sessionpart,
        "a=crypto:"
      );
      return lines.map(SDPUtils2.parseCryptoLine);
    };
    SDPUtils2.getIceParameters = function(mediaSection, sessionpart) {
      const ufrag = SDPUtils2.matchPrefix(
        mediaSection + sessionpart,
        "a=ice-ufrag:"
      )[0];
      const pwd = SDPUtils2.matchPrefix(
        mediaSection + sessionpart,
        "a=ice-pwd:"
      )[0];
      if (!(ufrag && pwd)) {
        return null;
      }
      return {
        usernameFragment: ufrag.substring(12),
        password: pwd.substring(10)
      };
    };
    SDPUtils2.writeIceParameters = function(params) {
      let sdp2 = "a=ice-ufrag:" + params.usernameFragment + "\r\na=ice-pwd:" + params.password + "\r\n";
      if (params.iceLite) {
        sdp2 += "a=ice-lite\r\n";
      }
      return sdp2;
    };
    SDPUtils2.parseRtpParameters = function(mediaSection) {
      const description = {
        codecs: [],
        headerExtensions: [],
        fecMechanisms: [],
        rtcp: []
      };
      const lines = SDPUtils2.splitLines(mediaSection);
      const mline = lines[0].split(" ");
      description.profile = mline[2];
      for (let i = 3; i < mline.length; i++) {
        const pt = mline[i];
        const rtpmapline = SDPUtils2.matchPrefix(
          mediaSection,
          "a=rtpmap:" + pt + " "
        )[0];
        if (rtpmapline) {
          const codec = SDPUtils2.parseRtpMap(rtpmapline);
          const fmtps = SDPUtils2.matchPrefix(
            mediaSection,
            "a=fmtp:" + pt + " "
          );
          codec.parameters = fmtps.length ? SDPUtils2.parseFmtp(fmtps[0]) : {};
          codec.rtcpFeedback = SDPUtils2.matchPrefix(
            mediaSection,
            "a=rtcp-fb:" + pt + " "
          ).map(SDPUtils2.parseRtcpFb);
          description.codecs.push(codec);
          switch (codec.name.toUpperCase()) {
            case "RED":
            case "ULPFEC":
              description.fecMechanisms.push(codec.name.toUpperCase());
              break;
            default:
              break;
          }
        }
      }
      SDPUtils2.matchPrefix(mediaSection, "a=extmap:").forEach((line) => {
        description.headerExtensions.push(SDPUtils2.parseExtmap(line));
      });
      const wildcardRtcpFb = SDPUtils2.matchPrefix(mediaSection, "a=rtcp-fb:* ").map(SDPUtils2.parseRtcpFb);
      description.codecs.forEach((codec) => {
        wildcardRtcpFb.forEach((fb) => {
          const duplicate = codec.rtcpFeedback.find((existingFeedback) => {
            return existingFeedback.type === fb.type && existingFeedback.parameter === fb.parameter;
          });
          if (!duplicate) {
            codec.rtcpFeedback.push(fb);
          }
        });
      });
      return description;
    };
    SDPUtils2.writeRtpDescription = function(kind, caps) {
      let sdp2 = "";
      sdp2 += "m=" + kind + " ";
      sdp2 += caps.codecs.length > 0 ? "9" : "0";
      sdp2 += " " + (caps.profile || "UDP/TLS/RTP/SAVPF") + " ";
      sdp2 += caps.codecs.map((codec) => {
        if (codec.preferredPayloadType !== void 0) {
          return codec.preferredPayloadType;
        }
        return codec.payloadType;
      }).join(" ") + "\r\n";
      sdp2 += "c=IN IP4 0.0.0.0\r\n";
      sdp2 += "a=rtcp:9 IN IP4 0.0.0.0\r\n";
      caps.codecs.forEach((codec) => {
        sdp2 += SDPUtils2.writeRtpMap(codec);
        sdp2 += SDPUtils2.writeFmtp(codec);
        sdp2 += SDPUtils2.writeRtcpFb(codec);
      });
      let maxptime = 0;
      caps.codecs.forEach((codec) => {
        if (codec.maxptime > maxptime) {
          maxptime = codec.maxptime;
        }
      });
      if (maxptime > 0) {
        sdp2 += "a=maxptime:" + maxptime + "\r\n";
      }
      if (caps.headerExtensions) {
        caps.headerExtensions.forEach((extension) => {
          sdp2 += SDPUtils2.writeExtmap(extension);
        });
      }
      return sdp2;
    };
    SDPUtils2.parseRtpEncodingParameters = function(mediaSection) {
      const encodingParameters = [];
      const description = SDPUtils2.parseRtpParameters(mediaSection);
      const hasRed = description.fecMechanisms.indexOf("RED") !== -1;
      const hasUlpfec = description.fecMechanisms.indexOf("ULPFEC") !== -1;
      const ssrcs = SDPUtils2.matchPrefix(mediaSection, "a=ssrc:").map((line) => SDPUtils2.parseSsrcMedia(line)).filter((parts) => parts.attribute === "cname");
      const primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;
      let secondarySsrc;
      const flows = SDPUtils2.matchPrefix(mediaSection, "a=ssrc-group:FID").map((line) => {
        const parts = line.substring(17).split(" ");
        return parts.map((part) => parseInt(part, 10));
      });
      if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {
        secondarySsrc = flows[0][1];
      }
      description.codecs.forEach((codec) => {
        if (codec.name.toUpperCase() === "RTX" && codec.parameters.apt) {
          let encParam = {
            ssrc: primarySsrc,
            codecPayloadType: parseInt(codec.parameters.apt, 10)
          };
          if (primarySsrc && secondarySsrc) {
            encParam.rtx = { ssrc: secondarySsrc };
          }
          encodingParameters.push(encParam);
          if (hasRed) {
            encParam = JSON.parse(JSON.stringify(encParam));
            encParam.fec = {
              ssrc: primarySsrc,
              mechanism: hasUlpfec ? "red+ulpfec" : "red"
            };
            encodingParameters.push(encParam);
          }
        }
      });
      if (encodingParameters.length === 0 && primarySsrc) {
        encodingParameters.push({
          ssrc: primarySsrc
        });
      }
      let bandwidth = SDPUtils2.matchPrefix(mediaSection, "b=");
      if (bandwidth.length) {
        if (bandwidth[0].indexOf("b=TIAS:") === 0) {
          bandwidth = parseInt(bandwidth[0].substring(7), 10);
        } else if (bandwidth[0].indexOf("b=AS:") === 0) {
          bandwidth = parseInt(bandwidth[0].substring(5), 10) * 1e3 * 0.95 - 50 * 40 * 8;
        } else {
          bandwidth = void 0;
        }
        encodingParameters.forEach((params) => {
          params.maxBitrate = bandwidth;
        });
      }
      return encodingParameters;
    };
    SDPUtils2.parseRtcpParameters = function(mediaSection) {
      const rtcpParameters = {};
      const remoteSsrc = SDPUtils2.matchPrefix(mediaSection, "a=ssrc:").map((line) => SDPUtils2.parseSsrcMedia(line)).filter((obj) => obj.attribute === "cname")[0];
      if (remoteSsrc) {
        rtcpParameters.cname = remoteSsrc.value;
        rtcpParameters.ssrc = remoteSsrc.ssrc;
      }
      const rsize = SDPUtils2.matchPrefix(mediaSection, "a=rtcp-rsize");
      rtcpParameters.reducedSize = rsize.length > 0;
      rtcpParameters.compound = rsize.length === 0;
      const mux = SDPUtils2.matchPrefix(mediaSection, "a=rtcp-mux");
      rtcpParameters.mux = mux.length > 0;
      return rtcpParameters;
    };
    SDPUtils2.writeRtcpParameters = function(rtcpParameters) {
      let sdp2 = "";
      if (rtcpParameters.reducedSize) {
        sdp2 += "a=rtcp-rsize\r\n";
      }
      if (rtcpParameters.mux) {
        sdp2 += "a=rtcp-mux\r\n";
      }
      if (rtcpParameters.ssrc !== void 0 && rtcpParameters.cname) {
        sdp2 += "a=ssrc:" + rtcpParameters.ssrc + " cname:" + rtcpParameters.cname + "\r\n";
      }
      return sdp2;
    };
    SDPUtils2.parseMsid = function(mediaSection) {
      let parts;
      const spec = SDPUtils2.matchPrefix(mediaSection, "a=msid:");
      if (spec.length === 1) {
        parts = spec[0].substring(7).split(" ");
        return { stream: parts[0], track: parts[1] };
      }
      const planB = SDPUtils2.matchPrefix(mediaSection, "a=ssrc:").map((line) => SDPUtils2.parseSsrcMedia(line)).filter((msidParts) => msidParts.attribute === "msid");
      if (planB.length > 0) {
        parts = planB[0].value.split(" ");
        return { stream: parts[0], track: parts[1] };
      }
    };
    SDPUtils2.parseSctpDescription = function(mediaSection) {
      const mline = SDPUtils2.parseMLine(mediaSection);
      const maxSizeLine = SDPUtils2.matchPrefix(mediaSection, "a=max-message-size:");
      let maxMessageSize;
      if (maxSizeLine.length > 0) {
        maxMessageSize = parseInt(maxSizeLine[0].substring(19), 10);
      }
      if (isNaN(maxMessageSize)) {
        maxMessageSize = 65536;
      }
      const sctpPort = SDPUtils2.matchPrefix(mediaSection, "a=sctp-port:");
      if (sctpPort.length > 0) {
        return {
          port: parseInt(sctpPort[0].substring(12), 10),
          protocol: mline.fmt,
          maxMessageSize
        };
      }
      const sctpMapLines = SDPUtils2.matchPrefix(mediaSection, "a=sctpmap:");
      if (sctpMapLines.length > 0) {
        const parts = sctpMapLines[0].substring(10).split(" ");
        return {
          port: parseInt(parts[0], 10),
          protocol: parts[1],
          maxMessageSize
        };
      }
    };
    SDPUtils2.writeSctpDescription = function(media, sctp) {
      let output = [];
      if (media.protocol !== "DTLS/SCTP") {
        output = [
          "m=" + media.kind + " 9 " + media.protocol + " " + sctp.protocol + "\r\n",
          "c=IN IP4 0.0.0.0\r\n",
          "a=sctp-port:" + sctp.port + "\r\n"
        ];
      } else {
        output = [
          "m=" + media.kind + " 9 " + media.protocol + " " + sctp.port + "\r\n",
          "c=IN IP4 0.0.0.0\r\n",
          "a=sctpmap:" + sctp.port + " " + sctp.protocol + " 65535\r\n"
        ];
      }
      if (sctp.maxMessageSize !== void 0) {
        output.push("a=max-message-size:" + sctp.maxMessageSize + "\r\n");
      }
      return output.join("");
    };
    SDPUtils2.generateSessionId = function() {
      return Math.random().toString().substr(2, 22);
    };
    SDPUtils2.writeSessionBoilerplate = function(sessId, sessVer, sessUser) {
      let sessionId;
      const version3 = sessVer !== void 0 ? sessVer : 2;
      if (sessId) {
        sessionId = sessId;
      } else {
        sessionId = SDPUtils2.generateSessionId();
      }
      const user = sessUser || "thisisadapterortc";
      return "v=0\r\no=" + user + " " + sessionId + " " + version3 + " IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n";
    };
    SDPUtils2.getDirection = function(mediaSection, sessionpart) {
      const lines = SDPUtils2.splitLines(mediaSection);
      for (let i = 0; i < lines.length; i++) {
        switch (lines[i]) {
          case "a=sendrecv":
          case "a=sendonly":
          case "a=recvonly":
          case "a=inactive":
            return lines[i].substring(2);
          default:
        }
      }
      if (sessionpart) {
        return SDPUtils2.getDirection(sessionpart);
      }
      return "sendrecv";
    };
    SDPUtils2.getKind = function(mediaSection) {
      const lines = SDPUtils2.splitLines(mediaSection);
      const mline = lines[0].split(" ");
      return mline[0].substring(2);
    };
    SDPUtils2.isRejected = function(mediaSection) {
      return mediaSection.split(" ", 2)[1] === "0";
    };
    SDPUtils2.parseMLine = function(mediaSection) {
      const lines = SDPUtils2.splitLines(mediaSection);
      const parts = lines[0].substring(2).split(" ");
      return {
        kind: parts[0],
        port: parseInt(parts[1], 10),
        protocol: parts[2],
        fmt: parts.slice(3).join(" ")
      };
    };
    SDPUtils2.parseOLine = function(mediaSection) {
      const line = SDPUtils2.matchPrefix(mediaSection, "o=")[0];
      const parts = line.substring(2).split(" ");
      return {
        username: parts[0],
        sessionId: parts[1],
        sessionVersion: parseInt(parts[2], 10),
        netType: parts[3],
        addressType: parts[4],
        address: parts[5]
      };
    };
    SDPUtils2.isValidSDP = function(blob) {
      if (typeof blob !== "string" || blob.length === 0) {
        return false;
      }
      const lines = SDPUtils2.splitLines(blob);
      for (let i = 0; i < lines.length; i++) {
        if (lines[i].length < 2 || lines[i].charAt(1) !== "=") {
          return false;
        }
      }
      return true;
    };
    if (typeof module === "object") {
      module.exports = SDPUtils2;
    }
  }
});

// node_modules/ua-parser-js/src/ua-parser.js
var require_ua_parser = __commonJS({
  "node_modules/ua-parser-js/src/ua-parser.js"(exports, module) {
    (function(window3, undefined2) {
      "use strict";
      var LIBVERSION = "1.0.40", EMPTY2 = "", UNKNOWN = "?", FUNC_TYPE = "function", UNDEF_TYPE = "undefined", OBJ_TYPE = "object", STR_TYPE = "string", MAJOR = "major", MODEL = "model", NAME = "name", TYPE = "type", VENDOR = "vendor", VERSION = "version", ARCHITECTURE = "architecture", CONSOLE = "console", MOBILE = "mobile", TABLET = "tablet", SMARTTV = "smarttv", WEARABLE = "wearable", EMBEDDED = "embedded", UA_MAX_LENGTH = 500;
      var AMAZON = "Amazon", APPLE = "Apple", ASUS = "ASUS", BLACKBERRY = "BlackBerry", BROWSER = "Browser", CHROME = "Chrome", EDGE = "Edge", FIREFOX = "Firefox", GOOGLE = "Google", HUAWEI = "Huawei", LG = "LG", MICROSOFT = "Microsoft", MOTOROLA = "Motorola", OPERA = "Opera", SAMSUNG = "Samsung", SHARP = "Sharp", SONY = "Sony", XIAOMI = "Xiaomi", ZEBRA = "Zebra", FACEBOOK = "Facebook", CHROMIUM_OS = "Chromium OS", MAC_OS = "Mac OS", SUFFIX_BROWSER = " Browser";
      var extend = function(regexes2, extensions) {
        var mergedRegexes = {};
        for (var i in regexes2) {
          if (extensions[i] && extensions[i].length % 2 === 0) {
            mergedRegexes[i] = extensions[i].concat(regexes2[i]);
          } else {
            mergedRegexes[i] = regexes2[i];
          }
        }
        return mergedRegexes;
      }, enumerize = function(arr) {
        var enums = {};
        for (var i = 0; i < arr.length; i++) {
          enums[arr[i].toUpperCase()] = arr[i];
        }
        return enums;
      }, has = function(str1, str2) {
        return typeof str1 === STR_TYPE ? lowerize(str2).indexOf(lowerize(str1)) !== -1 : false;
      }, lowerize = function(str) {
        return str.toLowerCase();
      }, majorize = function(version3) {
        return typeof version3 === STR_TYPE ? version3.replace(/[^\d\.]/g, EMPTY2).split(".")[0] : undefined2;
      }, trim = function(str, len) {
        if (typeof str === STR_TYPE) {
          str = str.replace(/^\s\s*/, EMPTY2);
          return typeof len === UNDEF_TYPE ? str : str.substring(0, UA_MAX_LENGTH);
        }
      };
      var rgxMapper = function(ua, arrays) {
        var i = 0, j, k, p, q, matches2, match;
        while (i < arrays.length && !matches2) {
          var regex = arrays[i], props = arrays[i + 1];
          j = k = 0;
          while (j < regex.length && !matches2) {
            if (!regex[j]) {
              break;
            }
            matches2 = regex[j++].exec(ua);
            if (!!matches2) {
              for (p = 0; p < props.length; p++) {
                match = matches2[++k];
                q = props[p];
                if (typeof q === OBJ_TYPE && q.length > 0) {
                  if (q.length === 2) {
                    if (typeof q[1] == FUNC_TYPE) {
                      this[q[0]] = q[1].call(this, match);
                    } else {
                      this[q[0]] = q[1];
                    }
                  } else if (q.length === 3) {
                    if (typeof q[1] === FUNC_TYPE && !(q[1].exec && q[1].test)) {
                      this[q[0]] = match ? q[1].call(this, match, q[2]) : undefined2;
                    } else {
                      this[q[0]] = match ? match.replace(q[1], q[2]) : undefined2;
                    }
                  } else if (q.length === 4) {
                    this[q[0]] = match ? q[3].call(this, match.replace(q[1], q[2])) : undefined2;
                  }
                } else {
                  this[q] = match ? match : undefined2;
                }
              }
            }
          }
          i += 2;
        }
      }, strMapper = function(str, map2) {
        for (var i in map2) {
          if (typeof map2[i] === OBJ_TYPE && map2[i].length > 0) {
            for (var j = 0; j < map2[i].length; j++) {
              if (has(map2[i][j], str)) {
                return i === UNKNOWN ? undefined2 : i;
              }
            }
          } else if (has(map2[i], str)) {
            return i === UNKNOWN ? undefined2 : i;
          }
        }
        return map2.hasOwnProperty("*") ? map2["*"] : str;
      };
      var oldSafariMap = {
        "1.0": "/8",
        "1.2": "/1",
        "1.3": "/3",
        "2.0": "/412",
        "2.0.2": "/416",
        "2.0.3": "/417",
        "2.0.4": "/419",
        "?": "/"
      }, windowsVersionMap = {
        "ME": "4.90",
        "NT 3.11": "NT3.51",
        "NT 4.0": "NT4.0",
        "2000": "NT 5.0",
        "XP": ["NT 5.1", "NT 5.2"],
        "Vista": "NT 6.0",
        "7": "NT 6.1",
        "8": "NT 6.2",
        "8.1": "NT 6.3",
        "10": ["NT 6.4", "NT 10.0"],
        "RT": "ARM"
      };
      var regexes = {
        browser: [
          [
            /\b(?:crmo|crios)\/([\w\.]+)/i
            // Chrome for Android/iOS
          ],
          [VERSION, [NAME, "Chrome"]],
          [
            /edg(?:e|ios|a)?\/([\w\.]+)/i
            // Microsoft Edge
          ],
          [VERSION, [NAME, "Edge"]],
          [
            // Presto based
            /(opera mini)\/([-\w\.]+)/i,
            // Opera Mini
            /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i,
            // Opera Mobi/Tablet
            /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i
            // Opera
          ],
          [NAME, VERSION],
          [
            /opios[\/ ]+([\w\.]+)/i
            // Opera mini on iphone >= 8.0
          ],
          [VERSION, [NAME, OPERA + " Mini"]],
          [
            /\bop(?:rg)?x\/([\w\.]+)/i
            // Opera GX
          ],
          [VERSION, [NAME, OPERA + " GX"]],
          [
            /\bopr\/([\w\.]+)/i
            // Opera Webkit
          ],
          [VERSION, [NAME, OPERA]],
          [
            // Mixed
            /\bb[ai]*d(?:uhd|[ub]*[aekoprswx]{5,6})[\/ ]?([\w\.]+)/i
            // Baidu
          ],
          [VERSION, [NAME, "Baidu"]],
          [
            /\b(?:mxbrowser|mxios|myie2)\/?([-\w\.]*)\b/i
            // Maxthon
          ],
          [VERSION, [NAME, "Maxthon"]],
          [
            /(kindle)\/([\w\.]+)/i,
            // Kindle
            /(lunascape|maxthon|netfront|jasmine|blazer|sleipnir)[\/ ]?([\w\.]*)/i,
            // Lunascape/Maxthon/Netfront/Jasmine/Blazer/Sleipnir
            // Trident based
            /(avant|iemobile|slim(?:browser|boat|jet))[\/ ]?([\d\.]*)/i,
            // Avant/IEMobile/SlimBrowser/SlimBoat/Slimjet
            /(?:ms|\()(ie) ([\w\.]+)/i,
            // Internet Explorer
            // Blink/Webkit/KHTML based                                         // Flock/RockMelt/Midori/Epiphany/Silk/Skyfire/Bolt/Iron/Iridium/PhantomJS/Bowser/QupZilla/Falkon
            /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|duckduckgo|klar|helio|(?=comodo_)?dragon)\/([-\w\.]+)/i,
            // Rekonq/Puffin/Brave/Whale/QQBrowserLite/QQ//Vivaldi/DuckDuckGo/Klar/Helio/Dragon
            /(heytap|ovi|115)browser\/([\d\.]+)/i,
            // HeyTap/Ovi/115
            /(weibo)__([\d\.]+)/i
            // Weibo
          ],
          [NAME, VERSION],
          [
            /quark(?:pc)?\/([-\w\.]+)/i
            // Quark
          ],
          [VERSION, [NAME, "Quark"]],
          [
            /\bddg\/([\w\.]+)/i
            // DuckDuckGo
          ],
          [VERSION, [NAME, "DuckDuckGo"]],
          [
            /(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i
            // UCBrowser
          ],
          [VERSION, [NAME, "UC" + BROWSER]],
          [
            /microm.+\bqbcore\/([\w\.]+)/i,
            // WeChat Desktop for Windows Built-in Browser
            /\bqbcore\/([\w\.]+).+microm/i,
            /micromessenger\/([\w\.]+)/i
            // WeChat
          ],
          [VERSION, [NAME, "WeChat"]],
          [
            /konqueror\/([\w\.]+)/i
            // Konqueror
          ],
          [VERSION, [NAME, "Konqueror"]],
          [
            /trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i
            // IE11
          ],
          [VERSION, [NAME, "IE"]],
          [
            /ya(?:search)?browser\/([\w\.]+)/i
            // Yandex
          ],
          [VERSION, [NAME, "Yandex"]],
          [
            /slbrowser\/([\w\.]+)/i
            // Smart Lenovo Browser
          ],
          [VERSION, [NAME, "Smart Lenovo " + BROWSER]],
          [
            /(avast|avg)\/([\w\.]+)/i
            // Avast/AVG Secure Browser
          ],
          [[NAME, /(.+)/, "$1 Secure " + BROWSER], VERSION],
          [
            /\bfocus\/([\w\.]+)/i
            // Firefox Focus
          ],
          [VERSION, [NAME, FIREFOX + " Focus"]],
          [
            /\bopt\/([\w\.]+)/i
            // Opera Touch
          ],
          [VERSION, [NAME, OPERA + " Touch"]],
          [
            /coc_coc\w+\/([\w\.]+)/i
            // Coc Coc Browser
          ],
          [VERSION, [NAME, "Coc Coc"]],
          [
            /dolfin\/([\w\.]+)/i
            // Dolphin
          ],
          [VERSION, [NAME, "Dolphin"]],
          [
            /coast\/([\w\.]+)/i
            // Opera Coast
          ],
          [VERSION, [NAME, OPERA + " Coast"]],
          [
            /miuibrowser\/([\w\.]+)/i
            // MIUI Browser
          ],
          [VERSION, [NAME, "MIUI" + SUFFIX_BROWSER]],
          [
            /fxios\/([\w\.-]+)/i
            // Firefox for iOS
          ],
          [VERSION, [NAME, FIREFOX]],
          [
            /\bqihoobrowser\/?([\w\.]*)/i
            // 360
          ],
          [VERSION, [NAME, "360"]],
          [
            /\b(qq)\/([\w\.]+)/i
            // QQ
          ],
          [[NAME, /(.+)/, "$1Browser"], VERSION],
          [
            /(oculus|sailfish|huawei|vivo|pico)browser\/([\w\.]+)/i
          ],
          [[NAME, /(.+)/, "$1" + SUFFIX_BROWSER], VERSION],
          [
            // Oculus/Sailfish/HuaweiBrowser/VivoBrowser/PicoBrowser
            /samsungbrowser\/([\w\.]+)/i
            // Samsung Internet
          ],
          [VERSION, [NAME, SAMSUNG + " Internet"]],
          [
            /metasr[\/ ]?([\d\.]+)/i
            // Sogou Explorer
          ],
          [VERSION, [NAME, "Sogou Explorer"]],
          [
            /(sogou)mo\w+\/([\d\.]+)/i
            // Sogou Mobile
          ],
          [[NAME, "Sogou Mobile"], VERSION],
          [
            /(electron)\/([\w\.]+) safari/i,
            // Electron-based App
            /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i,
            // Tesla
            /m?(qqbrowser|2345(?=browser|chrome|explorer))\w*[\/ ]?v?([\w\.]+)/i
            // QQ/2345
          ],
          [NAME, VERSION],
          [
            /(lbbrowser|rekonq)/i,
            // LieBao Browser/Rekonq
            /\[(linkedin)app\]/i
            // LinkedIn App for iOS & Android
          ],
          [NAME],
          [
            /ome\/([\w\.]+) \w* ?(iron) saf/i,
            // Iron
            /ome\/([\w\.]+).+qihu (360)[es]e/i
            // 360
          ],
          [VERSION, NAME],
          [
            // WebView
            /((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i
            // Facebook App for iOS & Android
          ],
          [[NAME, FACEBOOK], VERSION],
          [
            /(Klarna)\/([\w\.]+)/i,
            // Klarna Shopping Browser for iOS & Android
            /(kakao(?:talk|story))[\/ ]([\w\.]+)/i,
            // Kakao App
            /(naver)\(.*?(\d+\.[\w\.]+).*\)/i,
            // Naver InApp
            /safari (line)\/([\w\.]+)/i,
            // Line App for iOS
            /\b(line)\/([\w\.]+)\/iab/i,
            // Line App for Android
            /(alipay)client\/([\w\.]+)/i,
            // Alipay
            /(twitter)(?:and| f.+e\/([\w\.]+))/i,
            // Twitter
            /(chromium|instagram|snapchat)[\/ ]([-\w\.]+)/i
            // Chromium/Instagram/Snapchat
          ],
          [NAME, VERSION],
          [
            /\bgsa\/([\w\.]+) .*safari\//i
            // Google Search Appliance on iOS
          ],
          [VERSION, [NAME, "GSA"]],
          [
            /musical_ly(?:.+app_?version\/|_)([\w\.]+)/i
            // TikTok
          ],
          [VERSION, [NAME, "TikTok"]],
          [
            /headlesschrome(?:\/([\w\.]+)| )/i
            // Chrome Headless
          ],
          [VERSION, [NAME, CHROME + " Headless"]],
          [
            / wv\).+(chrome)\/([\w\.]+)/i
            // Chrome WebView
          ],
          [[NAME, CHROME + " WebView"], VERSION],
          [
            /droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i
            // Android Browser
          ],
          [VERSION, [NAME, "Android " + BROWSER]],
          [
            /(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i
            // Chrome/OmniWeb/Arora/Tizen/Nokia
          ],
          [NAME, VERSION],
          [
            /version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i
            // Mobile Safari
          ],
          [VERSION, [NAME, "Mobile Safari"]],
          [
            /version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i
            // Safari & Safari Mobile
          ],
          [VERSION, NAME],
          [
            /webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i
            // Safari < 3.0
          ],
          [NAME, [VERSION, strMapper, oldSafariMap]],
          [
            /(webkit|khtml)\/([\w\.]+)/i
          ],
          [NAME, VERSION],
          [
            // Gecko based
            /(navigator|netscape\d?)\/([-\w\.]+)/i
            // Netscape
          ],
          [[NAME, "Netscape"], VERSION],
          [
            /(wolvic|librewolf)\/([\w\.]+)/i
            // Wolvic/LibreWolf
          ],
          [NAME, VERSION],
          [
            /mobile vr; rv:([\w\.]+)\).+firefox/i
            // Firefox Reality
          ],
          [VERSION, [NAME, FIREFOX + " Reality"]],
          [
            /ekiohf.+(flow)\/([\w\.]+)/i,
            // Flow
            /(swiftfox)/i,
            // Swiftfox
            /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror)[\/ ]?([\w\.\+]+)/i,
            // IceDragon/Iceweasel/Camino/Chimera/Fennec/Maemo/Minimo/Conkeror
            /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i,
            // Firefox/SeaMonkey/K-Meleon/IceCat/IceApe/Firebird/Phoenix
            /(firefox)\/([\w\.]+)/i,
            // Other Firefox-based
            /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i,
            // Mozilla
            // Other
            /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i,
            // Polaris/Lynx/Dillo/iCab/Doris/Amaya/w3m/NetSurf/Obigo/Mosaic/Go/ICE/UP.Browser
            /(links) \(([\w\.]+)/i
            // Links
          ],
          [NAME, [VERSION, /_/g, "."]],
          [
            /(cobalt)\/([\w\.]+)/i
            // Cobalt
          ],
          [NAME, [VERSION, /master.|lts./, ""]]
        ],
        cpu: [
          [
            /(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i
            // AMD64 (x64)
          ],
          [[ARCHITECTURE, "amd64"]],
          [
            /(ia32(?=;))/i
            // IA32 (quicktime)
          ],
          [[ARCHITECTURE, lowerize]],
          [
            /((?:i[346]|x)86)[;\)]/i
            // IA32 (x86)
          ],
          [[ARCHITECTURE, "ia32"]],
          [
            /\b(aarch64|arm(v?8e?l?|_?64))\b/i
            // ARM64
          ],
          [[ARCHITECTURE, "arm64"]],
          [
            /\b(arm(?:v[67])?ht?n?[fl]p?)\b/i
            // ARMHF
          ],
          [[ARCHITECTURE, "armhf"]],
          [
            // PocketPC mistakenly identified as PowerPC
            /windows (ce|mobile); ppc;/i
          ],
          [[ARCHITECTURE, "arm"]],
          [
            /((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i
            // PowerPC
          ],
          [[ARCHITECTURE, /ower/, EMPTY2, lowerize]],
          [
            /(sun4\w)[;\)]/i
            // SPARC
          ],
          [[ARCHITECTURE, "sparc"]],
          [
            /((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i
            // IA64, 68K, ARM/64, AVR/32, IRIX/64, MIPS/64, SPARC/64, PA-RISC
          ],
          [[ARCHITECTURE, lowerize]]
        ],
        device: [
          [
            //////////////////////////
            // MOBILES & TABLETS
            /////////////////////////
            // Samsung
            /\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i
          ],
          [MODEL, [VENDOR, SAMSUNG], [TYPE, TABLET]],
          [
            /\b((?:s[cgp]h|gt|sm)-(?![lr])\w+|sc[g-]?[\d]+a?|galaxy nexus)/i,
            /samsung[- ]((?!sm-[lr])[-\w]+)/i,
            /sec-(sgh\w+)/i
          ],
          [MODEL, [VENDOR, SAMSUNG], [TYPE, MOBILE]],
          [
            // Apple
            /(?:\/|\()(ip(?:hone|od)[\w, ]*)(?:\/|;)/i
            // iPod/iPhone
          ],
          [MODEL, [VENDOR, APPLE], [TYPE, MOBILE]],
          [
            /\((ipad);[-\w\),; ]+apple/i,
            // iPad
            /applecoremedia\/[\w\.]+ \((ipad)/i,
            /\b(ipad)\d\d?,\d\d?[;\]].+ios/i
          ],
          [MODEL, [VENDOR, APPLE], [TYPE, TABLET]],
          [
            /(macintosh);/i
          ],
          [MODEL, [VENDOR, APPLE]],
          [
            // Sharp
            /\b(sh-?[altvz]?\d\d[a-ekm]?)/i
          ],
          [MODEL, [VENDOR, SHARP], [TYPE, MOBILE]],
          [
            // Honor
            /(?:honor)([-\w ]+)[;\)]/i
          ],
          [MODEL, [VENDOR, "Honor"], [TYPE, MOBILE]],
          [
            // Huawei
            /\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i
          ],
          [MODEL, [VENDOR, HUAWEI], [TYPE, TABLET]],
          [
            /(?:huawei)([-\w ]+)[;\)]/i,
            /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i
          ],
          [MODEL, [VENDOR, HUAWEI], [TYPE, MOBILE]],
          [
            // Xiaomi
            /\b(poco[\w ]+|m2\d{3}j\d\d[a-z]{2})(?: bui|\))/i,
            // Xiaomi POCO
            /\b; (\w+) build\/hm\1/i,
            // Xiaomi Hongmi 'numeric' models
            /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i,
            // Xiaomi Hongmi
            /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i,
            // Xiaomi Redmi
            /oid[^\)]+; (m?[12][0-389][01]\w{3,6}[c-y])( bui|; wv|\))/i,
            // Xiaomi Redmi 'numeric' models
            /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite|pro)?)(?: bui|\))/i
            // Xiaomi Mi
          ],
          [[MODEL, /_/g, " "], [VENDOR, XIAOMI], [TYPE, MOBILE]],
          [
            /oid[^\)]+; (2\d{4}(283|rpbf)[cgl])( bui|\))/i,
            // Redmi Pad
            /\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i
            // Mi Pad tablets
          ],
          [[MODEL, /_/g, " "], [VENDOR, XIAOMI], [TYPE, TABLET]],
          [
            // OPPO
            /; (\w+) bui.+ oppo/i,
            /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i
          ],
          [MODEL, [VENDOR, "OPPO"], [TYPE, MOBILE]],
          [
            /\b(opd2\d{3}a?) bui/i
          ],
          [MODEL, [VENDOR, "OPPO"], [TYPE, TABLET]],
          [
            // Vivo
            /vivo (\w+)(?: bui|\))/i,
            /\b(v[12]\d{3}\w?[at])(?: bui|;)/i
          ],
          [MODEL, [VENDOR, "Vivo"], [TYPE, MOBILE]],
          [
            // Realme
            /\b(rmx[1-3]\d{3})(?: bui|;|\))/i
          ],
          [MODEL, [VENDOR, "Realme"], [TYPE, MOBILE]],
          [
            // Motorola
            /\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i,
            /\bmot(?:orola)?[- ](\w*)/i,
            /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i
          ],
          [MODEL, [VENDOR, MOTOROLA], [TYPE, MOBILE]],
          [
            /\b(mz60\d|xoom[2 ]{0,2}) build\//i
          ],
          [MODEL, [VENDOR, MOTOROLA], [TYPE, TABLET]],
          [
            // LG
            /((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i
          ],
          [MODEL, [VENDOR, LG], [TYPE, TABLET]],
          [
            /(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i,
            /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i,
            /\blg-?([\d\w]+) bui/i
          ],
          [MODEL, [VENDOR, LG], [TYPE, MOBILE]],
          [
            // Lenovo
            /(ideatab[-\w ]+)/i,
            /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i
          ],
          [MODEL, [VENDOR, "Lenovo"], [TYPE, TABLET]],
          [
            // Nokia
            /(?:maemo|nokia).*(n900|lumia \d+)/i,
            /nokia[-_ ]?([-\w\.]*)/i
          ],
          [[MODEL, /_/g, " "], [VENDOR, "Nokia"], [TYPE, MOBILE]],
          [
            // Google
            /(pixel c)\b/i
            // Google Pixel C
          ],
          [MODEL, [VENDOR, GOOGLE], [TYPE, TABLET]],
          [
            /droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i
            // Google Pixel
          ],
          [MODEL, [VENDOR, GOOGLE], [TYPE, MOBILE]],
          [
            // Sony
            /droid.+; (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i
          ],
          [MODEL, [VENDOR, SONY], [TYPE, MOBILE]],
          [
            /sony tablet [ps]/i,
            /\b(?:sony)?sgp\w+(?: bui|\))/i
          ],
          [[MODEL, "Xperia Tablet"], [VENDOR, SONY], [TYPE, TABLET]],
          [
            // OnePlus
            / (kb2005|in20[12]5|be20[12][59])\b/i,
            /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i
          ],
          [MODEL, [VENDOR, "OnePlus"], [TYPE, MOBILE]],
          [
            // Amazon
            /(alexa)webm/i,
            /(kf[a-z]{2}wi|aeo(?!bc)\w\w)( bui|\))/i,
            // Kindle Fire without Silk / Echo Show
            /(kf[a-z]+)( bui|\)).+silk\//i
            // Kindle Fire HD
          ],
          [MODEL, [VENDOR, AMAZON], [TYPE, TABLET]],
          [
            /((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i
            // Fire Phone
          ],
          [[MODEL, /(.+)/g, "Fire Phone $1"], [VENDOR, AMAZON], [TYPE, MOBILE]],
          [
            // BlackBerry
            /(playbook);[-\w\),; ]+(rim)/i
            // BlackBerry PlayBook
          ],
          [MODEL, VENDOR, [TYPE, TABLET]],
          [
            /\b((?:bb[a-f]|st[hv])100-\d)/i,
            /\(bb10; (\w+)/i
            // BlackBerry 10
          ],
          [MODEL, [VENDOR, BLACKBERRY], [TYPE, MOBILE]],
          [
            // Asus
            /(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i
          ],
          [MODEL, [VENDOR, ASUS], [TYPE, TABLET]],
          [
            / (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i
          ],
          [MODEL, [VENDOR, ASUS], [TYPE, MOBILE]],
          [
            // HTC
            /(nexus 9)/i
            // HTC Nexus 9
          ],
          [MODEL, [VENDOR, "HTC"], [TYPE, TABLET]],
          [
            /(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i,
            // HTC
            // ZTE
            /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i,
            /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i
            // Alcatel/GeeksPhone/Nexian/Panasonic/Sony
          ],
          [VENDOR, [MODEL, /_/g, " "], [TYPE, MOBILE]],
          [
            // TCL
            /droid [\w\.]+; ((?:8[14]9[16]|9(?:0(?:48|60|8[01])|1(?:3[27]|66)|2(?:6[69]|9[56])|466))[gqswx])\w*(\)| bui)/i
          ],
          [MODEL, [VENDOR, "TCL"], [TYPE, TABLET]],
          [
            // itel
            /(itel) ((\w+))/i
          ],
          [[VENDOR, lowerize], MODEL, [TYPE, strMapper, { "tablet": ["p10001l", "w7001"], "*": "mobile" }]],
          [
            // Acer
            /droid.+; ([ab][1-7]-?[0178a]\d\d?)/i
          ],
          [MODEL, [VENDOR, "Acer"], [TYPE, TABLET]],
          [
            // Meizu
            /droid.+; (m[1-5] note) bui/i,
            /\bmz-([-\w]{2,})/i
          ],
          [MODEL, [VENDOR, "Meizu"], [TYPE, MOBILE]],
          [
            // Ulefone
            /; ((?:power )?armor(?:[\w ]{0,8}))(?: bui|\))/i
          ],
          [MODEL, [VENDOR, "Ulefone"], [TYPE, MOBILE]],
          [
            // Energizer
            /; (energy ?\w+)(?: bui|\))/i,
            /; energizer ([\w ]+)(?: bui|\))/i
          ],
          [MODEL, [VENDOR, "Energizer"], [TYPE, MOBILE]],
          [
            // Cat
            /; cat (b35);/i,
            /; (b15q?|s22 flip|s48c|s62 pro)(?: bui|\))/i
          ],
          [MODEL, [VENDOR, "Cat"], [TYPE, MOBILE]],
          [
            // Smartfren
            /((?:new )?andromax[\w- ]+)(?: bui|\))/i
          ],
          [MODEL, [VENDOR, "Smartfren"], [TYPE, MOBILE]],
          [
            // Nothing
            /droid.+; (a(?:015|06[35]|142p?))/i
          ],
          [MODEL, [VENDOR, "Nothing"], [TYPE, MOBILE]],
          [
            // MIXED
            /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron|infinix|tecno|micromax|advan)[-_ ]?([-\w]*)/i,
            // BlackBerry/BenQ/Palm/Sony-Ericsson/Acer/Asus/Dell/Meizu/Motorola/Polytron/Infinix/Tecno/Micromax/Advan
            /; (imo) ((?!tab)[\w ]+?)(?: bui|\))/i,
            // IMO
            /(hp) ([\w ]+\w)/i,
            // HP iPAQ
            /(asus)-?(\w+)/i,
            // Asus
            /(microsoft); (lumia[\w ]+)/i,
            // Microsoft Lumia
            /(lenovo)[-_ ]?([-\w]+)/i,
            // Lenovo
            /(jolla)/i,
            // Jolla
            /(oppo) ?([\w ]+) bui/i
            // OPPO
          ],
          [VENDOR, MODEL, [TYPE, MOBILE]],
          [
            /(imo) (tab \w+)/i,
            // IMO
            /(kobo)\s(ereader|touch)/i,
            // Kobo
            /(archos) (gamepad2?)/i,
            // Archos
            /(hp).+(touchpad(?!.+tablet)|tablet)/i,
            // HP TouchPad
            /(kindle)\/([\w\.]+)/i,
            // Kindle
            /(nook)[\w ]+build\/(\w+)/i,
            // Nook
            /(dell) (strea[kpr\d ]*[\dko])/i,
            // Dell Streak
            /(le[- ]+pan)[- ]+(\w{1,9}) bui/i,
            // Le Pan Tablets
            /(trinity)[- ]*(t\d{3}) bui/i,
            // Trinity Tablets
            /(gigaset)[- ]+(q\w{1,9}) bui/i,
            // Gigaset Tablets
            /(vodafone) ([\w ]+)(?:\)| bui)/i
            // Vodafone
          ],
          [VENDOR, MODEL, [TYPE, TABLET]],
          [
            /(surface duo)/i
            // Surface Duo
          ],
          [MODEL, [VENDOR, MICROSOFT], [TYPE, TABLET]],
          [
            /droid [\d\.]+; (fp\du?)(?: b|\))/i
            // Fairphone
          ],
          [MODEL, [VENDOR, "Fairphone"], [TYPE, MOBILE]],
          [
            /(u304aa)/i
            // AT&T
          ],
          [MODEL, [VENDOR, "AT&T"], [TYPE, MOBILE]],
          [
            /\bsie-(\w*)/i
            // Siemens
          ],
          [MODEL, [VENDOR, "Siemens"], [TYPE, MOBILE]],
          [
            /\b(rct\w+) b/i
            // RCA Tablets
          ],
          [MODEL, [VENDOR, "RCA"], [TYPE, TABLET]],
          [
            /\b(venue[\d ]{2,7}) b/i
            // Dell Venue Tablets
          ],
          [MODEL, [VENDOR, "Dell"], [TYPE, TABLET]],
          [
            /\b(q(?:mv|ta)\w+) b/i
            // Verizon Tablet
          ],
          [MODEL, [VENDOR, "Verizon"], [TYPE, TABLET]],
          [
            /\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i
            // Barnes & Noble Tablet
          ],
          [MODEL, [VENDOR, "Barnes & Noble"], [TYPE, TABLET]],
          [
            /\b(tm\d{3}\w+) b/i
          ],
          [MODEL, [VENDOR, "NuVision"], [TYPE, TABLET]],
          [
            /\b(k88) b/i
            // ZTE K Series Tablet
          ],
          [MODEL, [VENDOR, "ZTE"], [TYPE, TABLET]],
          [
            /\b(nx\d{3}j) b/i
            // ZTE Nubia
          ],
          [MODEL, [VENDOR, "ZTE"], [TYPE, MOBILE]],
          [
            /\b(gen\d{3}) b.+49h/i
            // Swiss GEN Mobile
          ],
          [MODEL, [VENDOR, "Swiss"], [TYPE, MOBILE]],
          [
            /\b(zur\d{3}) b/i
            // Swiss ZUR Tablet
          ],
          [MODEL, [VENDOR, "Swiss"], [TYPE, TABLET]],
          [
            /\b((zeki)?tb.*\b) b/i
            // Zeki Tablets
          ],
          [MODEL, [VENDOR, "Zeki"], [TYPE, TABLET]],
          [
            /\b([yr]\d{2}) b/i,
            /\b(dragon[- ]+touch |dt)(\w{5}) b/i
            // Dragon Touch Tablet
          ],
          [[VENDOR, "Dragon Touch"], MODEL, [TYPE, TABLET]],
          [
            /\b(ns-?\w{0,9}) b/i
            // Insignia Tablets
          ],
          [MODEL, [VENDOR, "Insignia"], [TYPE, TABLET]],
          [
            /\b((nxa|next)-?\w{0,9}) b/i
            // NextBook Tablets
          ],
          [MODEL, [VENDOR, "NextBook"], [TYPE, TABLET]],
          [
            /\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i
            // Voice Xtreme Phones
          ],
          [[VENDOR, "Voice"], MODEL, [TYPE, MOBILE]],
          [
            /\b(lvtel\-)?(v1[12]) b/i
            // LvTel Phones
          ],
          [[VENDOR, "LvTel"], MODEL, [TYPE, MOBILE]],
          [
            /\b(ph-1) /i
            // Essential PH-1
          ],
          [MODEL, [VENDOR, "Essential"], [TYPE, MOBILE]],
          [
            /\b(v(100md|700na|7011|917g).*\b) b/i
            // Envizen Tablets
          ],
          [MODEL, [VENDOR, "Envizen"], [TYPE, TABLET]],
          [
            /\b(trio[-\w\. ]+) b/i
            // MachSpeed Tablets
          ],
          [MODEL, [VENDOR, "MachSpeed"], [TYPE, TABLET]],
          [
            /\btu_(1491) b/i
            // Rotor Tablets
          ],
          [MODEL, [VENDOR, "Rotor"], [TYPE, TABLET]],
          [
            /(shield[\w ]+) b/i
            // Nvidia Shield Tablets
          ],
          [MODEL, [VENDOR, "Nvidia"], [TYPE, TABLET]],
          [
            /(sprint) (\w+)/i
            // Sprint Phones
          ],
          [VENDOR, MODEL, [TYPE, MOBILE]],
          [
            /(kin\.[onetw]{3})/i
            // Microsoft Kin
          ],
          [[MODEL, /\./g, " "], [VENDOR, MICROSOFT], [TYPE, MOBILE]],
          [
            /droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i
            // Zebra
          ],
          [MODEL, [VENDOR, ZEBRA], [TYPE, TABLET]],
          [
            /droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i
          ],
          [MODEL, [VENDOR, ZEBRA], [TYPE, MOBILE]],
          [
            ///////////////////
            // SMARTTVS
            ///////////////////
            /smart-tv.+(samsung)/i
            // Samsung
          ],
          [VENDOR, [TYPE, SMARTTV]],
          [
            /hbbtv.+maple;(\d+)/i
          ],
          [[MODEL, /^/, "SmartTV"], [VENDOR, SAMSUNG], [TYPE, SMARTTV]],
          [
            /(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i
            // LG SmartTV
          ],
          [[VENDOR, LG], [TYPE, SMARTTV]],
          [
            /(apple) ?tv/i
            // Apple TV
          ],
          [VENDOR, [MODEL, APPLE + " TV"], [TYPE, SMARTTV]],
          [
            /crkey/i
            // Google Chromecast
          ],
          [[MODEL, CHROME + "cast"], [VENDOR, GOOGLE], [TYPE, SMARTTV]],
          [
            /droid.+aft(\w+)( bui|\))/i
            // Fire TV
          ],
          [MODEL, [VENDOR, AMAZON], [TYPE, SMARTTV]],
          [
            /\(dtv[\);].+(aquos)/i,
            /(aquos-tv[\w ]+)\)/i
            // Sharp
          ],
          [MODEL, [VENDOR, SHARP], [TYPE, SMARTTV]],
          [
            /(bravia[\w ]+)( bui|\))/i
            // Sony
          ],
          [MODEL, [VENDOR, SONY], [TYPE, SMARTTV]],
          [
            /(mitv-\w{5}) bui/i
            // Xiaomi
          ],
          [MODEL, [VENDOR, XIAOMI], [TYPE, SMARTTV]],
          [
            /Hbbtv.*(technisat) (.*);/i
            // TechniSAT
          ],
          [VENDOR, MODEL, [TYPE, SMARTTV]],
          [
            /\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i,
            // Roku
            /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i
            // HbbTV devices
          ],
          [[VENDOR, trim], [MODEL, trim], [TYPE, SMARTTV]],
          [
            /\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i
            // SmartTV from Unidentified Vendors
          ],
          [[TYPE, SMARTTV]],
          [
            ///////////////////
            // CONSOLES
            ///////////////////
            /(ouya)/i,
            // Ouya
            /(nintendo) ([wids3utch]+)/i
            // Nintendo
          ],
          [VENDOR, MODEL, [TYPE, CONSOLE]],
          [
            /droid.+; (shield) bui/i
            // Nvidia
          ],
          [MODEL, [VENDOR, "Nvidia"], [TYPE, CONSOLE]],
          [
            /(playstation [345portablevi]+)/i
            // Playstation
          ],
          [MODEL, [VENDOR, SONY], [TYPE, CONSOLE]],
          [
            /\b(xbox(?: one)?(?!; xbox))[\); ]/i
            // Microsoft Xbox
          ],
          [MODEL, [VENDOR, MICROSOFT], [TYPE, CONSOLE]],
          [
            ///////////////////
            // WEARABLES
            ///////////////////
            /\b(sm-[lr]\d\d[05][fnuw]?s?)\b/i
            // Samsung Galaxy Watch
          ],
          [MODEL, [VENDOR, SAMSUNG], [TYPE, WEARABLE]],
          [
            /((pebble))app/i
            // Pebble
          ],
          [VENDOR, MODEL, [TYPE, WEARABLE]],
          [
            /(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i
            // Apple Watch
          ],
          [MODEL, [VENDOR, APPLE], [TYPE, WEARABLE]],
          [
            /droid.+; (glass) \d/i
            // Google Glass
          ],
          [MODEL, [VENDOR, GOOGLE], [TYPE, WEARABLE]],
          [
            /droid.+; (wt63?0{2,3})\)/i
          ],
          [MODEL, [VENDOR, ZEBRA], [TYPE, WEARABLE]],
          [
            ///////////////////
            // XR
            ///////////////////
            /droid.+; (glass) \d/i
            // Google Glass
          ],
          [MODEL, [VENDOR, GOOGLE], [TYPE, WEARABLE]],
          [
            /(pico) (4|neo3(?: link|pro)?)/i
            // Pico
          ],
          [VENDOR, MODEL, [TYPE, WEARABLE]],
          [
            /; (quest( \d| pro)?)/i
            // Oculus Quest
          ],
          [MODEL, [VENDOR, FACEBOOK], [TYPE, WEARABLE]],
          [
            ///////////////////
            // EMBEDDED
            ///////////////////
            /(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i
            // Tesla
          ],
          [VENDOR, [TYPE, EMBEDDED]],
          [
            /(aeobc)\b/i
            // Echo Dot
          ],
          [MODEL, [VENDOR, AMAZON], [TYPE, EMBEDDED]],
          [
            ////////////////////
            // MIXED (GENERIC)
            ///////////////////
            /droid .+?; ([^;]+?)(?: bui|; wv\)|\) applew).+? mobile safari/i
            // Android Phones from Unidentified Vendors
          ],
          [MODEL, [TYPE, MOBILE]],
          [
            /droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i
            // Android Tablets from Unidentified Vendors
          ],
          [MODEL, [TYPE, TABLET]],
          [
            /\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i
            // Unidentifiable Tablet
          ],
          [[TYPE, TABLET]],
          [
            /(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i
            // Unidentifiable Mobile
          ],
          [[TYPE, MOBILE]],
          [
            /(android[-\w\. ]{0,9});.+buil/i
            // Generic Android Device
          ],
          [MODEL, [VENDOR, "Generic"]]
        ],
        engine: [
          [
            /windows.+ edge\/([\w\.]+)/i
            // EdgeHTML
          ],
          [VERSION, [NAME, EDGE + "HTML"]],
          [
            /(arkweb)\/([\w\.]+)/i
            // ArkWeb
          ],
          [NAME, VERSION],
          [
            /webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i
            // Blink
          ],
          [VERSION, [NAME, "Blink"]],
          [
            /(presto)\/([\w\.]+)/i,
            // Presto
            /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna|servo)\/([\w\.]+)/i,
            // WebKit/Trident/NetFront/NetSurf/Amaya/Lynx/w3m/Goanna/Servo
            /ekioh(flow)\/([\w\.]+)/i,
            // Flow
            /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i,
            // KHTML/Tasman/Links
            /(icab)[\/ ]([23]\.[\d\.]+)/i,
            // iCab
            /\b(libweb)/i
          ],
          [NAME, VERSION],
          [
            /rv\:([\w\.]{1,9})\b.+(gecko)/i
            // Gecko
          ],
          [VERSION, NAME]
        ],
        os: [
          [
            // Windows
            /microsoft (windows) (vista|xp)/i
            // Windows (iTunes)
          ],
          [NAME, VERSION],
          [
            /(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i
            // Windows Phone
          ],
          [NAME, [VERSION, strMapper, windowsVersionMap]],
          [
            /windows nt 6\.2; (arm)/i,
            // Windows RT
            /windows[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i,
            /(?:win(?=3|9|n)|win 9x )([nt\d\.]+)/i
          ],
          [[VERSION, strMapper, windowsVersionMap], [NAME, "Windows"]],
          [
            // iOS/macOS
            /ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i,
            // iOS
            /(?:ios;fbsv\/|iphone.+ios[\/ ])([\d\.]+)/i,
            /cfnetwork\/.+darwin/i
          ],
          [[VERSION, /_/g, "."], [NAME, "iOS"]],
          [
            /(mac os x) ?([\w\. ]*)/i,
            /(macintosh|mac_powerpc\b)(?!.+haiku)/i
            // Mac OS
          ],
          [[NAME, MAC_OS], [VERSION, /_/g, "."]],
          [
            // Mobile OSes
            /droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i
            // Android-x86/HarmonyOS
          ],
          [VERSION, NAME],
          [
            // Android/WebOS/QNX/Bada/RIM/Maemo/MeeGo/Sailfish OS/OpenHarmony
            /(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish|openharmony)[-\/ ]?([\w\.]*)/i,
            /(blackberry)\w*\/([\w\.]*)/i,
            // Blackberry
            /(tizen|kaios)[\/ ]([\w\.]+)/i,
            // Tizen/KaiOS
            /\((series40);/i
            // Series 40
          ],
          [NAME, VERSION],
          [
            /\(bb(10);/i
            // BlackBerry 10
          ],
          [VERSION, [NAME, BLACKBERRY]],
          [
            /(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i
            // Symbian
          ],
          [VERSION, [NAME, "Symbian"]],
          [
            /mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i
            // Firefox OS
          ],
          [VERSION, [NAME, FIREFOX + " OS"]],
          [
            /web0s;.+rt(tv)/i,
            /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i
            // WebOS
          ],
          [VERSION, [NAME, "webOS"]],
          [
            /watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i
            // watchOS
          ],
          [VERSION, [NAME, "watchOS"]],
          [
            // Google Chromecast
            /crkey\/([\d\.]+)/i
            // Google Chromecast
          ],
          [VERSION, [NAME, CHROME + "cast"]],
          [
            /(cros) [\w]+(?:\)| ([\w\.]+)\b)/i
            // Chromium OS
          ],
          [[NAME, CHROMIUM_OS], VERSION],
          [
            // Smart TVs
            /panasonic;(viera)/i,
            // Panasonic Viera
            /(netrange)mmh/i,
            // Netrange
            /(nettv)\/(\d+\.[\w\.]+)/i,
            // NetTV
            // Console
            /(nintendo|playstation) ([wids345portablevuch]+)/i,
            // Nintendo/Playstation
            /(xbox); +xbox ([^\);]+)/i,
            // Microsoft Xbox (360, One, X, S, Series X, Series S)
            // Other
            /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i,
            // Joli/Palm
            /(mint)[\/\(\) ]?(\w*)/i,
            // Mint
            /(mageia|vectorlinux)[; ]/i,
            // Mageia/VectorLinux
            /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i,
            // Ubuntu/Debian/SUSE/Gentoo/Arch/Slackware/Fedora/Mandriva/CentOS/PCLinuxOS/RedHat/Zenwalk/Linpus/Raspbian/Plan9/Minix/RISCOS/Contiki/Deepin/Manjaro/elementary/Sabayon/Linspire
            /(hurd|linux) ?([\w\.]*)/i,
            // Hurd/Linux
            /(gnu) ?([\w\.]*)/i,
            // GNU
            /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i,
            // FreeBSD/NetBSD/OpenBSD/PC-BSD/GhostBSD/DragonFly
            /(haiku) (\w+)/i
            // Haiku
          ],
          [NAME, VERSION],
          [
            /(sunos) ?([\w\.\d]*)/i
            // Solaris
          ],
          [[NAME, "Solaris"], VERSION],
          [
            /((?:open)?solaris)[-\/ ]?([\w\.]*)/i,
            // Solaris
            /(aix) ((\d)(?=\.|\)| )[\w\.])*/i,
            // AIX
            /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux|serenityos)/i,
            // BeOS/OS2/AmigaOS/MorphOS/OpenVMS/Fuchsia/HP-UX/SerenityOS
            /(unix) ?([\w\.]*)/i
            // UNIX
          ],
          [NAME, VERSION]
        ]
      };
      var UAParser2 = function(ua, extensions) {
        if (typeof ua === OBJ_TYPE) {
          extensions = ua;
          ua = undefined2;
        }
        if (!(this instanceof UAParser2)) {
          return new UAParser2(ua, extensions).getResult();
        }
        var _navigator = typeof window3 !== UNDEF_TYPE && window3.navigator ? window3.navigator : undefined2;
        var _ua = ua || (_navigator && _navigator.userAgent ? _navigator.userAgent : EMPTY2);
        var _uach = _navigator && _navigator.userAgentData ? _navigator.userAgentData : undefined2;
        var _rgxmap = extensions ? extend(regexes, extensions) : regexes;
        var _isSelfNav = _navigator && _navigator.userAgent == _ua;
        this.getBrowser = function() {
          var _browser = {};
          _browser[NAME] = undefined2;
          _browser[VERSION] = undefined2;
          rgxMapper.call(_browser, _ua, _rgxmap.browser);
          _browser[MAJOR] = majorize(_browser[VERSION]);
          if (_isSelfNav && _navigator && _navigator.brave && typeof _navigator.brave.isBrave == FUNC_TYPE) {
            _browser[NAME] = "Brave";
          }
          return _browser;
        };
        this.getCPU = function() {
          var _cpu = {};
          _cpu[ARCHITECTURE] = undefined2;
          rgxMapper.call(_cpu, _ua, _rgxmap.cpu);
          return _cpu;
        };
        this.getDevice = function() {
          var _device = {};
          _device[VENDOR] = undefined2;
          _device[MODEL] = undefined2;
          _device[TYPE] = undefined2;
          rgxMapper.call(_device, _ua, _rgxmap.device);
          if (_isSelfNav && !_device[TYPE] && _uach && _uach.mobile) {
            _device[TYPE] = MOBILE;
          }
          if (_isSelfNav && _device[MODEL] == "Macintosh" && _navigator && typeof _navigator.standalone !== UNDEF_TYPE && _navigator.maxTouchPoints && _navigator.maxTouchPoints > 2) {
            _device[MODEL] = "iPad";
            _device[TYPE] = TABLET;
          }
          return _device;
        };
        this.getEngine = function() {
          var _engine = {};
          _engine[NAME] = undefined2;
          _engine[VERSION] = undefined2;
          rgxMapper.call(_engine, _ua, _rgxmap.engine);
          return _engine;
        };
        this.getOS = function() {
          var _os = {};
          _os[NAME] = undefined2;
          _os[VERSION] = undefined2;
          rgxMapper.call(_os, _ua, _rgxmap.os);
          if (_isSelfNav && !_os[NAME] && _uach && _uach.platform && _uach.platform != "Unknown") {
            _os[NAME] = _uach.platform.replace(/chrome os/i, CHROMIUM_OS).replace(/macos/i, MAC_OS);
          }
          return _os;
        };
        this.getResult = function() {
          return {
            ua: this.getUA(),
            browser: this.getBrowser(),
            engine: this.getEngine(),
            os: this.getOS(),
            device: this.getDevice(),
            cpu: this.getCPU()
          };
        };
        this.getUA = function() {
          return _ua;
        };
        this.setUA = function(ua2) {
          _ua = typeof ua2 === STR_TYPE && ua2.length > UA_MAX_LENGTH ? trim(ua2, UA_MAX_LENGTH) : ua2;
          return this;
        };
        this.setUA(_ua);
        return this;
      };
      UAParser2.VERSION = LIBVERSION;
      UAParser2.BROWSER = enumerize([NAME, VERSION, MAJOR]);
      UAParser2.CPU = enumerize([ARCHITECTURE]);
      UAParser2.DEVICE = enumerize([MODEL, VENDOR, TYPE, CONSOLE, MOBILE, SMARTTV, TABLET, WEARABLE, EMBEDDED]);
      UAParser2.ENGINE = UAParser2.OS = enumerize([NAME, VERSION]);
      if (typeof exports !== UNDEF_TYPE) {
        if (typeof module !== UNDEF_TYPE && module.exports) {
          exports = module.exports = UAParser2;
        }
        exports.UAParser = UAParser2;
      } else {
        if (typeof define === FUNC_TYPE && define.amd) {
          define(function() {
            return UAParser2;
          });
        } else if (typeof window3 !== UNDEF_TYPE) {
          window3.UAParser = UAParser2;
        }
      }
      var $ = typeof window3 !== UNDEF_TYPE && (window3.jQuery || window3.Zepto);
      if ($ && !$.ua) {
        var parser = new UAParser2();
        $.ua = parser.getResult();
        $.ua.get = function() {
          return parser.getUA();
        };
        $.ua.set = function(ua) {
          parser.setUA(ua);
          var result = parser.getResult();
          for (var prop in result) {
            $.ua[prop] = result[prop];
          }
        };
      }
    })(typeof window === "object" ? window : exports);
  }
});

// node_modules/sdp-transform/lib/grammar.js
var require_grammar = __commonJS({
  "node_modules/sdp-transform/lib/grammar.js"(exports, module) {
    var grammar = module.exports = {
      v: [{
        name: "version",
        reg: /^(\d*)$/
      }],
      o: [{
        // o=- 20518 0 IN IP4 203.0.113.1
        // NB: sessionId will be a String in most cases because it is huge
        name: "origin",
        reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
        names: ["username", "sessionId", "sessionVersion", "netType", "ipVer", "address"],
        format: "%s %s %d %s IP%d %s"
      }],
      // default parsing of these only (though some of these feel outdated)
      s: [{ name: "name" }],
      i: [{ name: "description" }],
      u: [{ name: "uri" }],
      e: [{ name: "email" }],
      p: [{ name: "phone" }],
      z: [{ name: "timezones" }],
      // TODO: this one can actually be parsed properly...
      r: [{ name: "repeats" }],
      // TODO: this one can also be parsed properly
      // k: [{}], // outdated thing ignored
      t: [{
        // t=0 0
        name: "timing",
        reg: /^(\d*) (\d*)/,
        names: ["start", "stop"],
        format: "%d %d"
      }],
      c: [{
        // c=IN IP4 10.47.197.26
        name: "connection",
        reg: /^IN IP(\d) (\S*)/,
        names: ["version", "ip"],
        format: "IN IP%d %s"
      }],
      b: [{
        // b=AS:4000
        push: "bandwidth",
        reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
        names: ["type", "limit"],
        format: "%s:%s"
      }],
      m: [{
        // m=video 51744 RTP/AVP 126 97 98 34 31
        // NB: special - pushes to session
        // TODO: rtp/fmtp should be filtered by the payloads found here?
        reg: /^(\w*) (\d*) ([\w/]*)(?: (.*))?/,
        names: ["type", "port", "protocol", "payloads"],
        format: "%s %d %s %s"
      }],
      a: [
        {
          // a=rtpmap:110 opus/48000/2
          push: "rtp",
          reg: /^rtpmap:(\d*) ([\w\-.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
          names: ["payload", "codec", "rate", "encoding"],
          format: function(o) {
            return o.encoding ? "rtpmap:%d %s/%s/%s" : o.rate ? "rtpmap:%d %s/%s" : "rtpmap:%d %s";
          }
        },
        {
          // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000
          // a=fmtp:111 minptime=10; useinbandfec=1
          push: "fmtp",
          reg: /^fmtp:(\d*) ([\S| ]*)/,
          names: ["payload", "config"],
          format: "fmtp:%d %s"
        },
        {
          // a=control:streamid=0
          name: "control",
          reg: /^control:(.*)/,
          format: "control:%s"
        },
        {
          // a=rtcp:65179 IN IP4 193.84.77.194
          name: "rtcp",
          reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
          names: ["port", "netType", "ipVer", "address"],
          format: function(o) {
            return o.address != null ? "rtcp:%d %s IP%d %s" : "rtcp:%d";
          }
        },
        {
          // a=rtcp-fb:98 trr-int 100
          push: "rtcpFbTrrInt",
          reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
          names: ["payload", "value"],
          format: "rtcp-fb:%s trr-int %d"
        },
        {
          // a=rtcp-fb:98 nack rpsi
          push: "rtcpFb",
          reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
          names: ["payload", "type", "subtype"],
          format: function(o) {
            return o.subtype != null ? "rtcp-fb:%s %s %s" : "rtcp-fb:%s %s";
          }
        },
        {
          // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
          // a=extmap:1/recvonly URI-gps-string
          // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24
          push: "ext",
          reg: /^extmap:(\d+)(?:\/(\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\S*)(?: (\S*))?/,
          names: ["value", "direction", "encrypt-uri", "uri", "config"],
          format: function(o) {
            return "extmap:%d" + (o.direction ? "/%s" : "%v") + (o["encrypt-uri"] ? " %s" : "%v") + " %s" + (o.config ? " %s" : "");
          }
        },
        {
          // a=extmap-allow-mixed
          name: "extmapAllowMixed",
          reg: /^(extmap-allow-mixed)/
        },
        {
          // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32
          push: "crypto",
          reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
          names: ["id", "suite", "config", "sessionConfig"],
          format: function(o) {
            return o.sessionConfig != null ? "crypto:%d %s %s %s" : "crypto:%d %s %s";
          }
        },
        {
          // a=setup:actpass
          name: "setup",
          reg: /^setup:(\w*)/,
          format: "setup:%s"
        },
        {
          // a=connection:new
          name: "connectionType",
          reg: /^connection:(new|existing)/,
          format: "connection:%s"
        },
        {
          // a=mid:1
          name: "mid",
          reg: /^mid:([^\s]*)/,
          format: "mid:%s"
        },
        {
          // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a
          name: "msid",
          reg: /^msid:(.*)/,
          format: "msid:%s"
        },
        {
          // a=ptime:20
          name: "ptime",
          reg: /^ptime:(\d*(?:\.\d*)*)/,
          format: "ptime:%d"
        },
        {
          // a=maxptime:60
          name: "maxptime",
          reg: /^maxptime:(\d*(?:\.\d*)*)/,
          format: "maxptime:%d"
        },
        {
          // a=sendrecv
          name: "direction",
          reg: /^(sendrecv|recvonly|sendonly|inactive)/
        },
        {
          // a=ice-lite
          name: "icelite",
          reg: /^(ice-lite)/
        },
        {
          // a=ice-ufrag:F7gI
          name: "iceUfrag",
          reg: /^ice-ufrag:(\S*)/,
          format: "ice-ufrag:%s"
        },
        {
          // a=ice-pwd:x9cml/YzichV2+XlhiMu8g
          name: "icePwd",
          reg: /^ice-pwd:(\S*)/,
          format: "ice-pwd:%s"
        },
        {
          // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33
          name: "fingerprint",
          reg: /^fingerprint:(\S*) (\S*)/,
          names: ["type", "hash"],
          format: "fingerprint:%s %s"
        },
        {
          // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host
          // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10
          // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10
          // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10
          // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10
          push: "candidates",
          reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,
          names: ["foundation", "component", "transport", "priority", "ip", "port", "type", "raddr", "rport", "tcptype", "generation", "network-id", "network-cost"],
          format: function(o) {
            var str = "candidate:%s %d %s %d %s %d typ %s";
            str += o.raddr != null ? " raddr %s rport %d" : "%v%v";
            str += o.tcptype != null ? " tcptype %s" : "%v";
            if (o.generation != null) {
              str += " generation %d";
            }
            str += o["network-id"] != null ? " network-id %d" : "%v";
            str += o["network-cost"] != null ? " network-cost %d" : "%v";
            return str;
          }
        },
        {
          // a=end-of-candidates (keep after the candidates line for readability)
          name: "endOfCandidates",
          reg: /^(end-of-candidates)/
        },
        {
          // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...
          name: "remoteCandidates",
          reg: /^remote-candidates:(.*)/,
          format: "remote-candidates:%s"
        },
        {
          // a=ice-options:google-ice
          name: "iceOptions",
          reg: /^ice-options:(\S*)/,
          format: "ice-options:%s"
        },
        {
          // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1
          push: "ssrcs",
          reg: /^ssrc:(\d*) ([\w_-]*)(?::(.*))?/,
          names: ["id", "attribute", "value"],
          format: function(o) {
            var str = "ssrc:%d";
            if (o.attribute != null) {
              str += " %s";
              if (o.value != null) {
                str += ":%s";
              }
            }
            return str;
          }
        },
        {
          // a=ssrc-group:FEC 1 2
          // a=ssrc-group:FEC-FR 3004364195 1080772241
          push: "ssrcGroups",
          // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E
          reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,
          names: ["semantics", "ssrcs"],
          format: "ssrc-group:%s %s"
        },
        {
          // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV
          name: "msidSemantic",
          reg: /^msid-semantic:\s?(\w*) (\S*)/,
          names: ["semantic", "token"],
          format: "msid-semantic: %s %s"
          // space after ':' is not accidental
        },
        {
          // a=group:BUNDLE audio video
          push: "groups",
          reg: /^group:(\w*) (.*)/,
          names: ["type", "mids"],
          format: "group:%s %s"
        },
        {
          // a=rtcp-mux
          name: "rtcpMux",
          reg: /^(rtcp-mux)/
        },
        {
          // a=rtcp-rsize
          name: "rtcpRsize",
          reg: /^(rtcp-rsize)/
        },
        {
          // a=sctpmap:5000 webrtc-datachannel 1024
          name: "sctpmap",
          reg: /^sctpmap:([\w_/]*) (\S*)(?: (\S*))?/,
          names: ["sctpmapNumber", "app", "maxMessageSize"],
          format: function(o) {
            return o.maxMessageSize != null ? "sctpmap:%s %s %s" : "sctpmap:%s %s";
          }
        },
        {
          // a=x-google-flag:conference
          name: "xGoogleFlag",
          reg: /^x-google-flag:([^\s]*)/,
          format: "x-google-flag:%s"
        },
        {
          // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0
          push: "rids",
          reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,
          names: ["id", "direction", "params"],
          format: function(o) {
            return o.params ? "rid:%s %s %s" : "rid:%s %s";
          }
        },
        {
          // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]
          // a=imageattr:* send [x=800,y=640] recv *
          // a=imageattr:100 recv [x=320,y=240]
          push: "imageattrs",
          reg: new RegExp(
            // a=imageattr:97
            "^imageattr:(\\d+|\\*)[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?"
          ),
          names: ["pt", "dir1", "attrs1", "dir2", "attrs2"],
          format: function(o) {
            return "imageattr:%s %s %s" + (o.dir2 ? " %s %s" : "");
          }
        },
        {
          // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8
          // a=simulcast:recv 1;4,5 send 6;7
          name: "simulcast",
          reg: new RegExp(
            // a=simulcast:
            "^simulcast:(send|recv) ([a-zA-Z0-9\\-_~;,]+)(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?$"
          ),
          names: ["dir1", "list1", "dir2", "list2"],
          format: function(o) {
            return "simulcast:%s %s" + (o.dir2 ? " %s %s" : "");
          }
        },
        {
          // old simulcast draft 03 (implemented by Firefox)
          //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03
          // a=simulcast: recv pt=97;98 send pt=97
          // a=simulcast: send rid=5;6;7 paused=6,7
          name: "simulcast_03",
          reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/,
          names: ["value"],
          format: "simulcast: %s"
        },
        {
          // a=framerate:25
          // a=framerate:29.97
          name: "framerate",
          reg: /^framerate:(\d+(?:$|\.\d+))/,
          format: "framerate:%s"
        },
        {
          // RFC4570
          // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5
          name: "sourceFilter",
          reg: /^source-filter: *(excl|incl) (\S*) (IP4|IP6|\*) (\S*) (.*)/,
          names: ["filterMode", "netType", "addressTypes", "destAddress", "srcList"],
          format: "source-filter: %s %s %s %s %s"
        },
        {
          // a=bundle-only
          name: "bundleOnly",
          reg: /^(bundle-only)/
        },
        {
          // a=label:1
          name: "label",
          reg: /^label:(.+)/,
          format: "label:%s"
        },
        {
          // RFC version 26 for SCTP over DTLS
          // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5
          name: "sctpPort",
          reg: /^sctp-port:(\d+)$/,
          format: "sctp-port:%s"
        },
        {
          // RFC version 26 for SCTP over DTLS
          // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6
          name: "maxMessageSize",
          reg: /^max-message-size:(\d+)$/,
          format: "max-message-size:%s"
        },
        {
          // RFC7273
          // a=ts-refclk:ptp=IEEE1588-2008:39-A7-94-FF-FE-07-CB-D0:37
          push: "tsRefClocks",
          reg: /^ts-refclk:([^\s=]*)(?:=(\S*))?/,
          names: ["clksrc", "clksrcExt"],
          format: function(o) {
            return "ts-refclk:%s" + (o.clksrcExt != null ? "=%s" : "");
          }
        },
        {
          // RFC7273
          // a=mediaclk:direct=963214424
          name: "mediaClk",
          reg: /^mediaclk:(?:id=(\S*))? *([^\s=]*)(?:=(\S*))?(?: *rate=(\d+)\/(\d+))?/,
          names: ["id", "mediaClockName", "mediaClockValue", "rateNumerator", "rateDenominator"],
          format: function(o) {
            var str = "mediaclk:";
            str += o.id != null ? "id=%s %s" : "%v%s";
            str += o.mediaClockValue != null ? "=%s" : "";
            str += o.rateNumerator != null ? " rate=%s" : "";
            str += o.rateDenominator != null ? "/%s" : "";
            return str;
          }
        },
        {
          // a=keywds:keywords
          name: "keywords",
          reg: /^keywds:(.+)$/,
          format: "keywds:%s"
        },
        {
          // a=content:main
          name: "content",
          reg: /^content:(.+)/,
          format: "content:%s"
        },
        // BFCP https://tools.ietf.org/html/rfc4583
        {
          // a=floorctrl:c-s
          name: "bfcpFloorCtrl",
          reg: /^floorctrl:(c-only|s-only|c-s)/,
          format: "floorctrl:%s"
        },
        {
          // a=confid:1
          name: "bfcpConfId",
          reg: /^confid:(\d+)/,
          format: "confid:%s"
        },
        {
          // a=userid:1
          name: "bfcpUserId",
          reg: /^userid:(\d+)/,
          format: "userid:%s"
        },
        {
          // a=floorid:1
          name: "bfcpFloorId",
          reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,
          names: ["id", "mStream"],
          format: "floorid:%s mstrm:%s"
        },
        {
          // any a= that we don't understand is kept verbatim on media.invalid
          push: "invalid",
          names: ["value"]
        }
      ]
    };
    Object.keys(grammar).forEach(function(key) {
      var objs = grammar[key];
      objs.forEach(function(obj) {
        if (!obj.reg) {
          obj.reg = /(.*)/;
        }
        if (!obj.format) {
          obj.format = "%s";
        }
      });
    });
  }
});

// node_modules/sdp-transform/lib/parser.js
var require_parser = __commonJS({
  "node_modules/sdp-transform/lib/parser.js"(exports) {
    var toIntIfInt = function(v) {
      return String(Number(v)) === v ? Number(v) : v;
    };
    var attachProperties = function(match, location, names, rawName) {
      if (rawName && !names) {
        location[rawName] = toIntIfInt(match[1]);
      } else {
        for (var i = 0; i < names.length; i += 1) {
          if (match[i + 1] != null) {
            location[names[i]] = toIntIfInt(match[i + 1]);
          }
        }
      }
    };
    var parseReg = function(obj, location, content) {
      var needsBlank = obj.name && obj.names;
      if (obj.push && !location[obj.push]) {
        location[obj.push] = [];
      } else if (needsBlank && !location[obj.name]) {
        location[obj.name] = {};
      }
      var keyLocation = obj.push ? {} : (
        // blank object that will be pushed
        needsBlank ? location[obj.name] : location
      );
      attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);
      if (obj.push) {
        location[obj.push].push(keyLocation);
      }
    };
    var grammar = require_grammar();
    var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);
    exports.parse = function(sdp2) {
      var session = {}, media = [], location = session;
      sdp2.split(/(\r\n|\r|\n)/).filter(validLine).forEach(function(l) {
        var type = l[0];
        var content = l.slice(2);
        if (type === "m") {
          media.push({ rtp: [], fmtp: [] });
          location = media[media.length - 1];
        }
        for (var j = 0; j < (grammar[type] || []).length; j += 1) {
          var obj = grammar[type][j];
          if (obj.reg.test(content)) {
            return parseReg(obj, location, content);
          }
        }
      });
      session.media = media;
      return session;
    };
    var paramReducer = function(acc, expr) {
      var s = expr.split(/=(.+)/, 2);
      if (s.length === 2) {
        acc[s[0]] = toIntIfInt(s[1]);
      } else if (s.length === 1 && expr.length > 1) {
        acc[s[0]] = void 0;
      }
      return acc;
    };
    exports.parseParams = function(str) {
      return str.split(/;\s?/).reduce(paramReducer, {});
    };
    exports.parseFmtpConfig = exports.parseParams;
    exports.parsePayloads = function(str) {
      return str.toString().split(" ").map(Number);
    };
    exports.parseRemoteCandidates = function(str) {
      var candidates = [];
      var parts = str.split(" ").map(toIntIfInt);
      for (var i = 0; i < parts.length; i += 3) {
        candidates.push({
          component: parts[i],
          ip: parts[i + 1],
          port: parts[i + 2]
        });
      }
      return candidates;
    };
    exports.parseImageAttributes = function(str) {
      return str.split(" ").map(function(item) {
        return item.substring(1, item.length - 1).split(",").reduce(paramReducer, {});
      });
    };
    exports.parseSimulcastStreamList = function(str) {
      return str.split(";").map(function(stream) {
        return stream.split(",").map(function(format) {
          var scid, paused = false;
          if (format[0] !== "~") {
            scid = toIntIfInt(format);
          } else {
            scid = toIntIfInt(format.substring(1, format.length));
            paused = true;
          }
          return {
            scid,
            paused
          };
        });
      });
    };
  }
});

// node_modules/sdp-transform/lib/writer.js
var require_writer = __commonJS({
  "node_modules/sdp-transform/lib/writer.js"(exports, module) {
    var grammar = require_grammar();
    var formatRegExp = /%[sdv%]/g;
    var format = function(formatStr) {
      var i = 1;
      var args = arguments;
      var len = args.length;
      return formatStr.replace(formatRegExp, function(x) {
        if (i >= len) {
          return x;
        }
        var arg = args[i];
        i += 1;
        switch (x) {
          case "%%":
            return "%";
          case "%s":
            return String(arg);
          case "%d":
            return Number(arg);
          case "%v":
            return "";
        }
      });
    };
    var makeLine = function(type, obj, location) {
      var str = obj.format instanceof Function ? obj.format(obj.push ? location : location[obj.name]) : obj.format;
      var args = [type + "=" + str];
      if (obj.names) {
        for (var i = 0; i < obj.names.length; i += 1) {
          var n = obj.names[i];
          if (obj.name) {
            args.push(location[obj.name][n]);
          } else {
            args.push(location[obj.names[i]]);
          }
        }
      } else {
        args.push(location[obj.name]);
      }
      return format.apply(null, args);
    };
    var defaultOuterOrder = [
      "v",
      "o",
      "s",
      "i",
      "u",
      "e",
      "p",
      "c",
      "b",
      "t",
      "r",
      "z",
      "a"
    ];
    var defaultInnerOrder = ["i", "c", "b", "a"];
    module.exports = function(session, opts) {
      opts = opts || {};
      if (session.version == null) {
        session.version = 0;
      }
      if (session.name == null) {
        session.name = " ";
      }
      session.media.forEach(function(mLine) {
        if (mLine.payloads == null) {
          mLine.payloads = "";
        }
      });
      var outerOrder = opts.outerOrder || defaultOuterOrder;
      var innerOrder = opts.innerOrder || defaultInnerOrder;
      var sdp2 = [];
      outerOrder.forEach(function(type) {
        grammar[type].forEach(function(obj) {
          if (obj.name in session && session[obj.name] != null) {
            sdp2.push(makeLine(type, obj, session));
          } else if (obj.push in session && session[obj.push] != null) {
            session[obj.push].forEach(function(el) {
              sdp2.push(makeLine(type, obj, el));
            });
          }
        });
      });
      session.media.forEach(function(mLine) {
        sdp2.push(makeLine("m", grammar.m[0], mLine));
        innerOrder.forEach(function(type) {
          grammar[type].forEach(function(obj) {
            if (obj.name in mLine && mLine[obj.name] != null) {
              sdp2.push(makeLine(type, obj, mLine));
            } else if (obj.push in mLine && mLine[obj.push] != null) {
              mLine[obj.push].forEach(function(el) {
                sdp2.push(makeLine(type, obj, el));
              });
            }
          });
        });
      });
      return sdp2.join("\r\n") + "\r\n";
    };
  }
});

// node_modules/sdp-transform/lib/index.js
var require_lib = __commonJS({
  "node_modules/sdp-transform/lib/index.js"(exports) {
    var parser = require_parser();
    var writer = require_writer();
    var grammar = require_grammar();
    exports.grammar = grammar;
    exports.write = writer;
    exports.parse = parser.parse;
    exports.parseParams = parser.parseParams;
    exports.parseFmtpConfig = parser.parseFmtpConfig;
    exports.parsePayloads = parser.parsePayloads;
    exports.parseRemoteCandidates = parser.parseRemoteCandidates;
    exports.parseImageAttributes = parser.parseImageAttributes;
    exports.parseSimulcastStreamList = parser.parseSimulcastStreamList;
  }
});

// node_modules/webrtc-adapter/src/js/utils.js
var logDisabled_ = true;
var deprecationWarnings_ = true;
function extractVersion(uastring, expr, pos) {
  const match = uastring.match(expr);
  return match && match.length >= pos && parseFloat(match[pos], 10);
}
function wrapPeerConnectionEvent(window3, eventNameToWrap, wrapper) {
  if (!window3.RTCPeerConnection) {
    return;
  }
  const proto = window3.RTCPeerConnection.prototype;
  const nativeAddEventListener = proto.addEventListener;
  proto.addEventListener = function(nativeEventName, cb) {
    if (nativeEventName !== eventNameToWrap) {
      return nativeAddEventListener.apply(this, arguments);
    }
    const wrappedCallback = (e) => {
      const modifiedEvent = wrapper(e);
      if (modifiedEvent) {
        if (cb.handleEvent) {
          cb.handleEvent(modifiedEvent);
        } else {
          cb(modifiedEvent);
        }
      }
    };
    this._eventMap = this._eventMap || {};
    if (!this._eventMap[eventNameToWrap]) {
      this._eventMap[eventNameToWrap] = /* @__PURE__ */ new Map();
    }
    this._eventMap[eventNameToWrap].set(cb, wrappedCallback);
    return nativeAddEventListener.apply(this, [
      nativeEventName,
      wrappedCallback
    ]);
  };
  const nativeRemoveEventListener = proto.removeEventListener;
  proto.removeEventListener = function(nativeEventName, cb) {
    if (nativeEventName !== eventNameToWrap || !this._eventMap || !this._eventMap[eventNameToWrap]) {
      return nativeRemoveEventListener.apply(this, arguments);
    }
    if (!this._eventMap[eventNameToWrap].has(cb)) {
      return nativeRemoveEventListener.apply(this, arguments);
    }
    const unwrappedCb = this._eventMap[eventNameToWrap].get(cb);
    this._eventMap[eventNameToWrap].delete(cb);
    if (this._eventMap[eventNameToWrap].size === 0) {
      delete this._eventMap[eventNameToWrap];
    }
    if (Object.keys(this._eventMap).length === 0) {
      delete this._eventMap;
    }
    return nativeRemoveEventListener.apply(this, [
      nativeEventName,
      unwrappedCb
    ]);
  };
  Object.defineProperty(proto, "on" + eventNameToWrap, {
    get() {
      return this["_on" + eventNameToWrap];
    },
    set(cb) {
      if (this["_on" + eventNameToWrap]) {
        this.removeEventListener(
          eventNameToWrap,
          this["_on" + eventNameToWrap]
        );
        delete this["_on" + eventNameToWrap];
      }
      if (cb) {
        this.addEventListener(
          eventNameToWrap,
          this["_on" + eventNameToWrap] = cb
        );
      }
    },
    enumerable: true,
    configurable: true
  });
}
function disableLog(bool) {
  if (typeof bool !== "boolean") {
    return new Error("Argument type: " + typeof bool + ". Please use a boolean.");
  }
  logDisabled_ = bool;
  return bool ? "adapter.js logging disabled" : "adapter.js logging enabled";
}
function disableWarnings(bool) {
  if (typeof bool !== "boolean") {
    return new Error("Argument type: " + typeof bool + ". Please use a boolean.");
  }
  deprecationWarnings_ = !bool;
  return "adapter.js deprecation warnings " + (bool ? "disabled" : "enabled");
}
function log() {
  if (typeof window === "object") {
    if (logDisabled_) {
      return;
    }
    if (typeof console !== "undefined" && typeof console.log === "function") {
      console.log.apply(console, arguments);
    }
  }
}
function deprecated(oldMethod, newMethod) {
  if (!deprecationWarnings_) {
    return;
  }
  console.warn(oldMethod + " is deprecated, please use " + newMethod + " instead.");
}
function detectBrowser(window3) {
  const result = { browser: null, version: null };
  if (typeof window3 === "undefined" || !window3.navigator || !window3.navigator.userAgent) {
    result.browser = "Not a browser.";
    return result;
  }
  const { navigator: navigator2 } = window3;
  if (navigator2.mozGetUserMedia) {
    result.browser = "firefox";
    result.version = parseInt(extractVersion(
      navigator2.userAgent,
      /Firefox\/(\d+)\./,
      1
    ));
  } else if (navigator2.webkitGetUserMedia || window3.isSecureContext === false && window3.webkitRTCPeerConnection) {
    result.browser = "chrome";
    result.version = parseInt(extractVersion(
      navigator2.userAgent,
      /Chrom(e|ium)\/(\d+)\./,
      2
    ));
  } else if (window3.RTCPeerConnection && navigator2.userAgent.match(/AppleWebKit\/(\d+)\./)) {
    result.browser = "safari";
    result.version = parseInt(extractVersion(
      navigator2.userAgent,
      /AppleWebKit\/(\d+)\./,
      1
    ));
    result.supportsUnifiedPlan = window3.RTCRtpTransceiver && "currentDirection" in window3.RTCRtpTransceiver.prototype;
    result._safariVersion = extractVersion(
      navigator2.userAgent,
      /Version\/(\d+(\.?\d+))/,
      1
    );
  } else {
    result.browser = "Not a supported browser.";
    return result;
  }
  return result;
}
function isObject(val) {
  return Object.prototype.toString.call(val) === "[object Object]";
}
function compactObject(data) {
  if (!isObject(data)) {
    return data;
  }
  return Object.keys(data).reduce(function(accumulator, key) {
    const isObj = isObject(data[key]);
    const value = isObj ? compactObject(data[key]) : data[key];
    const isEmptyObject = isObj && !Object.keys(value).length;
    if (value === void 0 || isEmptyObject) {
      return accumulator;
    }
    return Object.assign(accumulator, { [key]: value });
  }, {});
}
function walkStats(stats, base, resultSet) {
  if (!base || resultSet.has(base.id)) {
    return;
  }
  resultSet.set(base.id, base);
  Object.keys(base).forEach((name2) => {
    if (name2.endsWith("Id")) {
      walkStats(stats, stats.get(base[name2]), resultSet);
    } else if (name2.endsWith("Ids")) {
      base[name2].forEach((id) => {
        walkStats(stats, stats.get(id), resultSet);
      });
    }
  });
}
function filterStats(result, track, outbound) {
  const streamStatsType = outbound ? "outbound-rtp" : "inbound-rtp";
  const filteredResult = /* @__PURE__ */ new Map();
  if (track === null) {
    return filteredResult;
  }
  const trackStats = [];
  result.forEach((value) => {
    if (value.type === "track" && value.trackIdentifier === track.id) {
      trackStats.push(value);
    }
  });
  trackStats.forEach((trackStat) => {
    result.forEach((stats) => {
      if (stats.type === streamStatsType && stats.trackId === trackStat.id) {
        walkStats(result, stats, filteredResult);
      }
    });
  });
  return filteredResult;
}

// node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js
var chrome_shim_exports = {};
__export(chrome_shim_exports, {
  fixNegotiationNeeded: () => fixNegotiationNeeded,
  shimAddTrackRemoveTrack: () => shimAddTrackRemoveTrack,
  shimAddTrackRemoveTrackWithNative: () => shimAddTrackRemoveTrackWithNative,
  shimGetDisplayMedia: () => shimGetDisplayMedia,
  shimGetSendersWithDtmf: () => shimGetSendersWithDtmf,
  shimGetStats: () => shimGetStats,
  shimGetUserMedia: () => shimGetUserMedia,
  shimMediaStream: () => shimMediaStream,
  shimOnTrack: () => shimOnTrack,
  shimPeerConnection: () => shimPeerConnection,
  shimSenderReceiverGetStats: () => shimSenderReceiverGetStats
});

// node_modules/webrtc-adapter/src/js/chrome/getusermedia.js
var logging = log;
function shimGetUserMedia(window3, browserDetails) {
  const navigator2 = window3 && window3.navigator;
  if (!navigator2.mediaDevices) {
    return;
  }
  const constraintsToChrome_ = function(c) {
    if (typeof c !== "object" || c.mandatory || c.optional) {
      return c;
    }
    const cc = {};
    Object.keys(c).forEach((key) => {
      if (key === "require" || key === "advanced" || key === "mediaSource") {
        return;
      }
      const r = typeof c[key] === "object" ? c[key] : { ideal: c[key] };
      if (r.exact !== void 0 && typeof r.exact === "number") {
        r.min = r.max = r.exact;
      }
      const oldname_ = function(prefix, name2) {
        if (prefix) {
          return prefix + name2.charAt(0).toUpperCase() + name2.slice(1);
        }
        return name2 === "deviceId" ? "sourceId" : name2;
      };
      if (r.ideal !== void 0) {
        cc.optional = cc.optional || [];
        let oc = {};
        if (typeof r.ideal === "number") {
          oc[oldname_("min", key)] = r.ideal;
          cc.optional.push(oc);
          oc = {};
          oc[oldname_("max", key)] = r.ideal;
          cc.optional.push(oc);
        } else {
          oc[oldname_("", key)] = r.ideal;
          cc.optional.push(oc);
        }
      }
      if (r.exact !== void 0 && typeof r.exact !== "number") {
        cc.mandatory = cc.mandatory || {};
        cc.mandatory[oldname_("", key)] = r.exact;
      } else {
        ["min", "max"].forEach((mix) => {
          if (r[mix] !== void 0) {
            cc.mandatory = cc.mandatory || {};
            cc.mandatory[oldname_(mix, key)] = r[mix];
          }
        });
      }
    });
    if (c.advanced) {
      cc.optional = (cc.optional || []).concat(c.advanced);
    }
    return cc;
  };
  const shimConstraints_ = function(constraints, func) {
    if (browserDetails.version >= 61) {
      return func(constraints);
    }
    constraints = JSON.parse(JSON.stringify(constraints));
    if (constraints && typeof constraints.audio === "object") {
      const remap = function(obj, a, b) {
        if (a in obj && !(b in obj)) {
          obj[b] = obj[a];
          delete obj[a];
        }
      };
      constraints = JSON.parse(JSON.stringify(constraints));
      remap(constraints.audio, "autoGainControl", "googAutoGainControl");
      remap(constraints.audio, "noiseSuppression", "googNoiseSuppression");
      constraints.audio = constraintsToChrome_(constraints.audio);
    }
    if (constraints && typeof constraints.video === "object") {
      let face = constraints.video.facingMode;
      face = face && (typeof face === "object" ? face : { ideal: face });
      const getSupportedFacingModeLies = browserDetails.version < 66;
      if (face && (face.exact === "user" || face.exact === "environment" || face.ideal === "user" || face.ideal === "environment") && !(navigator2.mediaDevices.getSupportedConstraints && navigator2.mediaDevices.getSupportedConstraints().facingMode && !getSupportedFacingModeLies)) {
        delete constraints.video.facingMode;
        let matches2;
        if (face.exact === "environment" || face.ideal === "environment") {
          matches2 = ["back", "rear"];
        } else if (face.exact === "user" || face.ideal === "user") {
          matches2 = ["front"];
        }
        if (matches2) {
          return navigator2.mediaDevices.enumerateDevices().then((devices) => {
            devices = devices.filter((d) => d.kind === "videoinput");
            let dev = devices.find((d) => matches2.some((match) => d.label.toLowerCase().includes(match)));
            if (!dev && devices.length && matches2.includes("back")) {
              dev = devices[devices.length - 1];
            }
            if (dev) {
              constraints.video.deviceId = face.exact ? { exact: dev.deviceId } : { ideal: dev.deviceId };
            }
            constraints.video = constraintsToChrome_(constraints.video);
            logging("chrome: " + JSON.stringify(constraints));
            return func(constraints);
          });
        }
      }
      constraints.video = constraintsToChrome_(constraints.video);
    }
    logging("chrome: " + JSON.stringify(constraints));
    return func(constraints);
  };
  const shimError_ = function(e) {
    if (browserDetails.version >= 64) {
      return e;
    }
    return {
      name: {
        PermissionDeniedError: "NotAllowedError",
        PermissionDismissedError: "NotAllowedError",
        InvalidStateError: "NotAllowedError",
        DevicesNotFoundError: "NotFoundError",
        ConstraintNotSatisfiedError: "OverconstrainedError",
        TrackStartError: "NotReadableError",
        MediaDeviceFailedDueToShutdown: "NotAllowedError",
        MediaDeviceKillSwitchOn: "NotAllowedError",
        TabCaptureError: "AbortError",
        ScreenCaptureError: "AbortError",
        DeviceCaptureError: "AbortError"
      }[e.name] || e.name,
      message: e.message,
      constraint: e.constraint || e.constraintName,
      toString() {
        return this.name + (this.message && ": ") + this.message;
      }
    };
  };
  const getUserMedia_ = function(constraints, onSuccess, onError) {
    shimConstraints_(constraints, (c) => {
      navigator2.webkitGetUserMedia(c, onSuccess, (e) => {
        if (onError) {
          onError(shimError_(e));
        }
      });
    });
  };
  navigator2.getUserMedia = getUserMedia_.bind(navigator2);
  if (navigator2.mediaDevices.getUserMedia) {
    const origGetUserMedia = navigator2.mediaDevices.getUserMedia.bind(navigator2.mediaDevices);
    navigator2.mediaDevices.getUserMedia = function(cs) {
      return shimConstraints_(cs, (c) => origGetUserMedia(c).then((stream) => {
        if (c.audio && !stream.getAudioTracks().length || c.video && !stream.getVideoTracks().length) {
          stream.getTracks().forEach((track) => {
            track.stop();
          });
          throw new DOMException("", "NotFoundError");
        }
        return stream;
      }, (e) => Promise.reject(shimError_(e))));
    };
  }
}

// node_modules/webrtc-adapter/src/js/chrome/getdisplaymedia.js
function shimGetDisplayMedia(window3, getSourceId) {
  if (window3.navigator.mediaDevices && "getDisplayMedia" in window3.navigator.mediaDevices) {
    return;
  }
  if (!window3.navigator.mediaDevices) {
    return;
  }
  if (typeof getSourceId !== "function") {
    console.error("shimGetDisplayMedia: getSourceId argument is not a function");
    return;
  }
  window3.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {
    return getSourceId(constraints).then((sourceId) => {
      const widthSpecified = constraints.video && constraints.video.width;
      const heightSpecified = constraints.video && constraints.video.height;
      const frameRateSpecified = constraints.video && constraints.video.frameRate;
      constraints.video = {
        mandatory: {
          chromeMediaSource: "desktop",
          chromeMediaSourceId: sourceId,
          maxFrameRate: frameRateSpecified || 3
        }
      };
      if (widthSpecified) {
        constraints.video.mandatory.maxWidth = widthSpecified;
      }
      if (heightSpecified) {
        constraints.video.mandatory.maxHeight = heightSpecified;
      }
      return window3.navigator.mediaDevices.getUserMedia(constraints);
    });
  };
}

// node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js
function shimMediaStream(window3) {
  window3.MediaStream = window3.MediaStream || window3.webkitMediaStream;
}
function shimOnTrack(window3) {
  if (typeof window3 === "object" && window3.RTCPeerConnection && !("ontrack" in window3.RTCPeerConnection.prototype)) {
    Object.defineProperty(window3.RTCPeerConnection.prototype, "ontrack", {
      get() {
        return this._ontrack;
      },
      set(f) {
        if (this._ontrack) {
          this.removeEventListener("track", this._ontrack);
        }
        this.addEventListener("track", this._ontrack = f);
      },
      enumerable: true,
      configurable: true
    });
    const origSetRemoteDescription = window3.RTCPeerConnection.prototype.setRemoteDescription;
    window3.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
      if (!this._ontrackpoly) {
        this._ontrackpoly = (e) => {
          e.stream.addEventListener("addtrack", (te) => {
            let receiver;
            if (window3.RTCPeerConnection.prototype.getReceivers) {
              receiver = this.getReceivers().find((r) => r.track && r.track.id === te.track.id);
            } else {
              receiver = { track: te.track };
            }
            const event = new Event("track");
            event.track = te.track;
            event.receiver = receiver;
            event.transceiver = { receiver };
            event.streams = [e.stream];
            this.dispatchEvent(event);
          });
          e.stream.getTracks().forEach((track) => {
            let receiver;
            if (window3.RTCPeerConnection.prototype.getReceivers) {
              receiver = this.getReceivers().find((r) => r.track && r.track.id === track.id);
            } else {
              receiver = { track };
            }
            const event = new Event("track");
            event.track = track;
            event.receiver = receiver;
            event.transceiver = { receiver };
            event.streams = [e.stream];
            this.dispatchEvent(event);
          });
        };
        this.addEventListener("addstream", this._ontrackpoly);
      }
      return origSetRemoteDescription.apply(this, arguments);
    };
  } else {
    wrapPeerConnectionEvent(window3, "track", (e) => {
      if (!e.transceiver) {
        Object.defineProperty(
          e,
          "transceiver",
          { value: { receiver: e.receiver } }
        );
      }
      return e;
    });
  }
}
function shimGetSendersWithDtmf(window3) {
  if (typeof window3 === "object" && window3.RTCPeerConnection && !("getSenders" in window3.RTCPeerConnection.prototype) && "createDTMFSender" in window3.RTCPeerConnection.prototype) {
    const shimSenderWithDtmf = function(pc, track) {
      return {
        track,
        get dtmf() {
          if (this._dtmf === void 0) {
            if (track.kind === "audio") {
              this._dtmf = pc.createDTMFSender(track);
            } else {
              this._dtmf = null;
            }
          }
          return this._dtmf;
        },
        _pc: pc
      };
    };
    if (!window3.RTCPeerConnection.prototype.getSenders) {
      window3.RTCPeerConnection.prototype.getSenders = function getSenders() {
        this._senders = this._senders || [];
        return this._senders.slice();
      };
      const origAddTrack = window3.RTCPeerConnection.prototype.addTrack;
      window3.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
        let sender = origAddTrack.apply(this, arguments);
        if (!sender) {
          sender = shimSenderWithDtmf(this, track);
          this._senders.push(sender);
        }
        return sender;
      };
      const origRemoveTrack = window3.RTCPeerConnection.prototype.removeTrack;
      window3.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
        origRemoveTrack.apply(this, arguments);
        const idx = this._senders.indexOf(sender);
        if (idx !== -1) {
          this._senders.splice(idx, 1);
        }
      };
    }
    const origAddStream = window3.RTCPeerConnection.prototype.addStream;
    window3.RTCPeerConnection.prototype.addStream = function addStream(stream) {
      this._senders = this._senders || [];
      origAddStream.apply(this, [stream]);
      stream.getTracks().forEach((track) => {
        this._senders.push(shimSenderWithDtmf(this, track));
      });
    };
    const origRemoveStream = window3.RTCPeerConnection.prototype.removeStream;
    window3.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
      this._senders = this._senders || [];
      origRemoveStream.apply(this, [stream]);
      stream.getTracks().forEach((track) => {
        const sender = this._senders.find((s) => s.track === track);
        if (sender) {
          this._senders.splice(this._senders.indexOf(sender), 1);
        }
      });
    };
  } else if (typeof window3 === "object" && window3.RTCPeerConnection && "getSenders" in window3.RTCPeerConnection.prototype && "createDTMFSender" in window3.RTCPeerConnection.prototype && window3.RTCRtpSender && !("dtmf" in window3.RTCRtpSender.prototype)) {
    const origGetSenders = window3.RTCPeerConnection.prototype.getSenders;
    window3.RTCPeerConnection.prototype.getSenders = function getSenders() {
      const senders = origGetSenders.apply(this, []);
      senders.forEach((sender) => sender._pc = this);
      return senders;
    };
    Object.defineProperty(window3.RTCRtpSender.prototype, "dtmf", {
      get() {
        if (this._dtmf === void 0) {
          if (this.track.kind === "audio") {
            this._dtmf = this._pc.createDTMFSender(this.track);
          } else {
            this._dtmf = null;
          }
        }
        return this._dtmf;
      }
    });
  }
}
function shimGetStats(window3) {
  if (!window3.RTCPeerConnection) {
    return;
  }
  const origGetStats = window3.RTCPeerConnection.prototype.getStats;
  window3.RTCPeerConnection.prototype.getStats = function getStats() {
    const [selector, onSucc, onErr] = arguments;
    if (arguments.length > 0 && typeof selector === "function") {
      return origGetStats.apply(this, arguments);
    }
    if (origGetStats.length === 0 && (arguments.length === 0 || typeof selector !== "function")) {
      return origGetStats.apply(this, []);
    }
    const fixChromeStats_ = function(response) {
      const standardReport = {};
      const reports = response.result();
      reports.forEach((report) => {
        const standardStats = {
          id: report.id,
          timestamp: report.timestamp,
          type: {
            localcandidate: "local-candidate",
            remotecandidate: "remote-candidate"
          }[report.type] || report.type
        };
        report.names().forEach((name2) => {
          standardStats[name2] = report.stat(name2);
        });
        standardReport[standardStats.id] = standardStats;
      });
      return standardReport;
    };
    const makeMapStats = function(stats) {
      return new Map(Object.keys(stats).map((key) => [key, stats[key]]));
    };
    if (arguments.length >= 2) {
      const successCallbackWrapper_ = function(response) {
        onSucc(makeMapStats(fixChromeStats_(response)));
      };
      return origGetStats.apply(this, [
        successCallbackWrapper_,
        selector
      ]);
    }
    return new Promise((resolve, reject) => {
      origGetStats.apply(this, [
        function(response) {
          resolve(makeMapStats(fixChromeStats_(response)));
        },
        reject
      ]);
    }).then(onSucc, onErr);
  };
}
function shimSenderReceiverGetStats(window3) {
  if (!(typeof window3 === "object" && window3.RTCPeerConnection && window3.RTCRtpSender && window3.RTCRtpReceiver)) {
    return;
  }
  if (!("getStats" in window3.RTCRtpSender.prototype)) {
    const origGetSenders = window3.RTCPeerConnection.prototype.getSenders;
    if (origGetSenders) {
      window3.RTCPeerConnection.prototype.getSenders = function getSenders() {
        const senders = origGetSenders.apply(this, []);
        senders.forEach((sender) => sender._pc = this);
        return senders;
      };
    }
    const origAddTrack = window3.RTCPeerConnection.prototype.addTrack;
    if (origAddTrack) {
      window3.RTCPeerConnection.prototype.addTrack = function addTrack() {
        const sender = origAddTrack.apply(this, arguments);
        sender._pc = this;
        return sender;
      };
    }
    window3.RTCRtpSender.prototype.getStats = function getStats() {
      const sender = this;
      return this._pc.getStats().then((result) => (
        /* Note: this will include stats of all senders that
         *   send a track with the same id as sender.track as
         *   it is not possible to identify the RTCRtpSender.
         */
        filterStats(result, sender.track, true)
      ));
    };
  }
  if (!("getStats" in window3.RTCRtpReceiver.prototype)) {
    const origGetReceivers = window3.RTCPeerConnection.prototype.getReceivers;
    if (origGetReceivers) {
      window3.RTCPeerConnection.prototype.getReceivers = function getReceivers() {
        const receivers = origGetReceivers.apply(this, []);
        receivers.forEach((receiver) => receiver._pc = this);
        return receivers;
      };
    }
    wrapPeerConnectionEvent(window3, "track", (e) => {
      e.receiver._pc = e.srcElement;
      return e;
    });
    window3.RTCRtpReceiver.prototype.getStats = function getStats() {
      const receiver = this;
      return this._pc.getStats().then((result) => filterStats(result, receiver.track, false));
    };
  }
  if (!("getStats" in window3.RTCRtpSender.prototype && "getStats" in window3.RTCRtpReceiver.prototype)) {
    return;
  }
  const origGetStats = window3.RTCPeerConnection.prototype.getStats;
  window3.RTCPeerConnection.prototype.getStats = function getStats() {
    if (arguments.length > 0 && arguments[0] instanceof window3.MediaStreamTrack) {
      const track = arguments[0];
      let sender;
      let receiver;
      let err;
      this.getSenders().forEach((s) => {
        if (s.track === track) {
          if (sender) {
            err = true;
          } else {
            sender = s;
          }
        }
      });
      this.getReceivers().forEach((r) => {
        if (r.track === track) {
          if (receiver) {
            err = true;
          } else {
            receiver = r;
          }
        }
        return r.track === track;
      });
      if (err || sender && receiver) {
        return Promise.reject(new DOMException(
          "There are more than one sender or receiver for the track.",
          "InvalidAccessError"
        ));
      } else if (sender) {
        return sender.getStats();
      } else if (receiver) {
        return receiver.getStats();
      }
      return Promise.reject(new DOMException(
        "There is no sender or receiver for the track.",
        "InvalidAccessError"
      ));
    }
    return origGetStats.apply(this, arguments);
  };
}
function shimAddTrackRemoveTrackWithNative(window3) {
  window3.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    return Object.keys(this._shimmedLocalStreams).map((streamId) => this._shimmedLocalStreams[streamId][0]);
  };
  const origAddTrack = window3.RTCPeerConnection.prototype.addTrack;
  window3.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
    if (!stream) {
      return origAddTrack.apply(this, arguments);
    }
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    const sender = origAddTrack.apply(this, arguments);
    if (!this._shimmedLocalStreams[stream.id]) {
      this._shimmedLocalStreams[stream.id] = [stream, sender];
    } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {
      this._shimmedLocalStreams[stream.id].push(sender);
    }
    return sender;
  };
  const origAddStream = window3.RTCPeerConnection.prototype.addStream;
  window3.RTCPeerConnection.prototype.addStream = function addStream(stream) {
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    stream.getTracks().forEach((track) => {
      const alreadyExists = this.getSenders().find((s) => s.track === track);
      if (alreadyExists) {
        throw new DOMException(
          "Track already exists.",
          "InvalidAccessError"
        );
      }
    });
    const existingSenders = this.getSenders();
    origAddStream.apply(this, arguments);
    const newSenders = this.getSenders().filter((newSender) => existingSenders.indexOf(newSender) === -1);
    this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);
  };
  const origRemoveStream = window3.RTCPeerConnection.prototype.removeStream;
  window3.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    delete this._shimmedLocalStreams[stream.id];
    return origRemoveStream.apply(this, arguments);
  };
  const origRemoveTrack = window3.RTCPeerConnection.prototype.removeTrack;
  window3.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    if (sender) {
      Object.keys(this._shimmedLocalStreams).forEach((streamId) => {
        const idx = this._shimmedLocalStreams[streamId].indexOf(sender);
        if (idx !== -1) {
          this._shimmedLocalStreams[streamId].splice(idx, 1);
        }
        if (this._shimmedLocalStreams[streamId].length === 1) {
          delete this._shimmedLocalStreams[streamId];
        }
      });
    }
    return origRemoveTrack.apply(this, arguments);
  };
}
function shimAddTrackRemoveTrack(window3, browserDetails) {
  if (!window3.RTCPeerConnection) {
    return;
  }
  if (window3.RTCPeerConnection.prototype.addTrack && browserDetails.version >= 65) {
    return shimAddTrackRemoveTrackWithNative(window3);
  }
  const origGetLocalStreams = window3.RTCPeerConnection.prototype.getLocalStreams;
  window3.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
    const nativeStreams = origGetLocalStreams.apply(this);
    this._reverseStreams = this._reverseStreams || {};
    return nativeStreams.map((stream) => this._reverseStreams[stream.id]);
  };
  const origAddStream = window3.RTCPeerConnection.prototype.addStream;
  window3.RTCPeerConnection.prototype.addStream = function addStream(stream) {
    this._streams = this._streams || {};
    this._reverseStreams = this._reverseStreams || {};
    stream.getTracks().forEach((track) => {
      const alreadyExists = this.getSenders().find((s) => s.track === track);
      if (alreadyExists) {
        throw new DOMException(
          "Track already exists.",
          "InvalidAccessError"
        );
      }
    });
    if (!this._reverseStreams[stream.id]) {
      const newStream = new window3.MediaStream(stream.getTracks());
      this._streams[stream.id] = newStream;
      this._reverseStreams[newStream.id] = stream;
      stream = newStream;
    }
    origAddStream.apply(this, [stream]);
  };
  const origRemoveStream = window3.RTCPeerConnection.prototype.removeStream;
  window3.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
    this._streams = this._streams || {};
    this._reverseStreams = this._reverseStreams || {};
    origRemoveStream.apply(this, [this._streams[stream.id] || stream]);
    delete this._reverseStreams[this._streams[stream.id] ? this._streams[stream.id].id : stream.id];
    delete this._streams[stream.id];
  };
  window3.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
    if (this.signalingState === "closed") {
      throw new DOMException(
        "The RTCPeerConnection's signalingState is 'closed'.",
        "InvalidStateError"
      );
    }
    const streams = [].slice.call(arguments, 1);
    if (streams.length !== 1 || !streams[0].getTracks().find((t2) => t2 === track)) {
      throw new DOMException(
        "The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.",
        "NotSupportedError"
      );
    }
    const alreadyExists = this.getSenders().find((s) => s.track === track);
    if (alreadyExists) {
      throw new DOMException(
        "Track already exists.",
        "InvalidAccessError"
      );
    }
    this._streams = this._streams || {};
    this._reverseStreams = this._reverseStreams || {};
    const oldStream = this._streams[stream.id];
    if (oldStream) {
      oldStream.addTrack(track);
      Promise.resolve().then(() => {
        this.dispatchEvent(new Event("negotiationneeded"));
      });
    } else {
      const newStream = new window3.MediaStream([track]);
      this._streams[stream.id] = newStream;
      this._reverseStreams[newStream.id] = stream;
      this.addStream(newStream);
    }
    return this.getSenders().find((s) => s.track === track);
  };
  function replaceInternalStreamId(pc, description) {
    let sdp2 = description.sdp;
    Object.keys(pc._reverseStreams || []).forEach((internalId) => {
      const externalStream = pc._reverseStreams[internalId];
      const internalStream = pc._streams[externalStream.id];
      sdp2 = sdp2.replace(
        new RegExp(internalStream.id, "g"),
        externalStream.id
      );
    });
    return new RTCSessionDescription({
      type: description.type,
      sdp: sdp2
    });
  }
  function replaceExternalStreamId(pc, description) {
    let sdp2 = description.sdp;
    Object.keys(pc._reverseStreams || []).forEach((internalId) => {
      const externalStream = pc._reverseStreams[internalId];
      const internalStream = pc._streams[externalStream.id];
      sdp2 = sdp2.replace(
        new RegExp(externalStream.id, "g"),
        internalStream.id
      );
    });
    return new RTCSessionDescription({
      type: description.type,
      sdp: sdp2
    });
  }
  ["createOffer", "createAnswer"].forEach(function(method) {
    const nativeMethod = window3.RTCPeerConnection.prototype[method];
    const methodObj = { [method]() {
      const args = arguments;
      const isLegacyCall = arguments.length && typeof arguments[0] === "function";
      if (isLegacyCall) {
        return nativeMethod.apply(this, [
          (description) => {
            const desc = replaceInternalStreamId(this, description);
            args[0].apply(null, [desc]);
          },
          (err) => {
            if (args[1]) {
              args[1].apply(null, err);
            }
          },
          arguments[2]
        ]);
      }
      return nativeMethod.apply(this, arguments).then((description) => replaceInternalStreamId(this, description));
    } };
    window3.RTCPeerConnection.prototype[method] = methodObj[method];
  });
  const origSetLocalDescription = window3.RTCPeerConnection.prototype.setLocalDescription;
  window3.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {
    if (!arguments.length || !arguments[0].type) {
      return origSetLocalDescription.apply(this, arguments);
    }
    arguments[0] = replaceExternalStreamId(this, arguments[0]);
    return origSetLocalDescription.apply(this, arguments);
  };
  const origLocalDescription = Object.getOwnPropertyDescriptor(
    window3.RTCPeerConnection.prototype,
    "localDescription"
  );
  Object.defineProperty(
    window3.RTCPeerConnection.prototype,
    "localDescription",
    {
      get() {
        const description = origLocalDescription.get.apply(this);
        if (description.type === "") {
          return description;
        }
        return replaceInternalStreamId(this, description);
      }
    }
  );
  window3.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
    if (this.signalingState === "closed") {
      throw new DOMException(
        "The RTCPeerConnection's signalingState is 'closed'.",
        "InvalidStateError"
      );
    }
    if (!sender._pc) {
      throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.", "TypeError");
    }
    const isLocal = sender._pc === this;
    if (!isLocal) {
      throw new DOMException(
        "Sender was not created by this connection.",
        "InvalidAccessError"
      );
    }
    this._streams = this._streams || {};
    let stream;
    Object.keys(this._streams).forEach((streamid) => {
      const hasTrack = this._streams[streamid].getTracks().find((track) => sender.track === track);
      if (hasTrack) {
        stream = this._streams[streamid];
      }
    });
    if (stream) {
      if (stream.getTracks().length === 1) {
        this.removeStream(this._reverseStreams[stream.id]);
      } else {
        stream.removeTrack(sender.track);
      }
      this.dispatchEvent(new Event("negotiationneeded"));
    }
  };
}
function shimPeerConnection(window3, browserDetails) {
  if (!window3.RTCPeerConnection && window3.webkitRTCPeerConnection) {
    window3.RTCPeerConnection = window3.webkitRTCPeerConnection;
  }
  if (!window3.RTCPeerConnection) {
    return;
  }
  if (browserDetails.version < 53) {
    ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(method) {
      const nativeMethod = window3.RTCPeerConnection.prototype[method];
      const methodObj = { [method]() {
        arguments[0] = new (method === "addIceCandidate" ? window3.RTCIceCandidate : window3.RTCSessionDescription)(arguments[0]);
        return nativeMethod.apply(this, arguments);
      } };
      window3.RTCPeerConnection.prototype[method] = methodObj[method];
    });
  }
}
function fixNegotiationNeeded(window3, browserDetails) {
  wrapPeerConnectionEvent(window3, "negotiationneeded", (e) => {
    const pc = e.target;
    if (browserDetails.version < 72 || pc.getConfiguration && pc.getConfiguration().sdpSemantics === "plan-b") {
      if (pc.signalingState !== "stable") {
        return;
      }
    }
    return e;
  });
}

// node_modules/webrtc-adapter/src/js/firefox/firefox_shim.js
var firefox_shim_exports = {};
__export(firefox_shim_exports, {
  shimAddTransceiver: () => shimAddTransceiver,
  shimCreateAnswer: () => shimCreateAnswer,
  shimCreateOffer: () => shimCreateOffer,
  shimGetDisplayMedia: () => shimGetDisplayMedia2,
  shimGetParameters: () => shimGetParameters,
  shimGetUserMedia: () => shimGetUserMedia2,
  shimOnTrack: () => shimOnTrack2,
  shimPeerConnection: () => shimPeerConnection2,
  shimRTCDataChannel: () => shimRTCDataChannel,
  shimReceiverGetStats: () => shimReceiverGetStats,
  shimRemoveStream: () => shimRemoveStream,
  shimSenderGetStats: () => shimSenderGetStats
});

// node_modules/webrtc-adapter/src/js/firefox/getusermedia.js
function shimGetUserMedia2(window3, browserDetails) {
  const navigator2 = window3 && window3.navigator;
  const MediaStreamTrack = window3 && window3.MediaStreamTrack;
  navigator2.getUserMedia = function(constraints, onSuccess, onError) {
    deprecated(
      "navigator.getUserMedia",
      "navigator.mediaDevices.getUserMedia"
    );
    navigator2.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);
  };
  if (!(browserDetails.version > 55 && "autoGainControl" in navigator2.mediaDevices.getSupportedConstraints())) {
    const remap = function(obj, a, b) {
      if (a in obj && !(b in obj)) {
        obj[b] = obj[a];
        delete obj[a];
      }
    };
    const nativeGetUserMedia = navigator2.mediaDevices.getUserMedia.bind(navigator2.mediaDevices);
    navigator2.mediaDevices.getUserMedia = function(c) {
      if (typeof c === "object" && typeof c.audio === "object") {
        c = JSON.parse(JSON.stringify(c));
        remap(c.audio, "autoGainControl", "mozAutoGainControl");
        remap(c.audio, "noiseSuppression", "mozNoiseSuppression");
      }
      return nativeGetUserMedia(c);
    };
    if (MediaStreamTrack && MediaStreamTrack.prototype.getSettings) {
      const nativeGetSettings = MediaStreamTrack.prototype.getSettings;
      MediaStreamTrack.prototype.getSettings = function() {
        const obj = nativeGetSettings.apply(this, arguments);
        remap(obj, "mozAutoGainControl", "autoGainControl");
        remap(obj, "mozNoiseSuppression", "noiseSuppression");
        return obj;
      };
    }
    if (MediaStreamTrack && MediaStreamTrack.prototype.applyConstraints) {
      const nativeApplyConstraints = MediaStreamTrack.prototype.applyConstraints;
      MediaStreamTrack.prototype.applyConstraints = function(c) {
        if (this.kind === "audio" && typeof c === "object") {
          c = JSON.parse(JSON.stringify(c));
          remap(c, "autoGainControl", "mozAutoGainControl");
          remap(c, "noiseSuppression", "mozNoiseSuppression");
        }
        return nativeApplyConstraints.apply(this, [c]);
      };
    }
  }
}

// node_modules/webrtc-adapter/src/js/firefox/getdisplaymedia.js
function shimGetDisplayMedia2(window3, preferredMediaSource) {
  if (window3.navigator.mediaDevices && "getDisplayMedia" in window3.navigator.mediaDevices) {
    return;
  }
  if (!window3.navigator.mediaDevices) {
    return;
  }
  window3.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {
    if (!(constraints && constraints.video)) {
      const err = new DOMException("getDisplayMedia without video constraints is undefined");
      err.name = "NotFoundError";
      err.code = 8;
      return Promise.reject(err);
    }
    if (constraints.video === true) {
      constraints.video = { mediaSource: preferredMediaSource };
    } else {
      constraints.video.mediaSource = preferredMediaSource;
    }
    return window3.navigator.mediaDevices.getUserMedia(constraints);
  };
}

// node_modules/webrtc-adapter/src/js/firefox/firefox_shim.js
function shimOnTrack2(window3) {
  if (typeof window3 === "object" && window3.RTCTrackEvent && "receiver" in window3.RTCTrackEvent.prototype && !("transceiver" in window3.RTCTrackEvent.prototype)) {
    Object.defineProperty(window3.RTCTrackEvent.prototype, "transceiver", {
      get() {
        return { receiver: this.receiver };
      }
    });
  }
}
function shimPeerConnection2(window3, browserDetails) {
  if (typeof window3 !== "object" || !(window3.RTCPeerConnection || window3.mozRTCPeerConnection)) {
    return;
  }
  if (!window3.RTCPeerConnection && window3.mozRTCPeerConnection) {
    window3.RTCPeerConnection = window3.mozRTCPeerConnection;
  }
  if (browserDetails.version < 53) {
    ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(method) {
      const nativeMethod = window3.RTCPeerConnection.prototype[method];
      const methodObj = { [method]() {
        arguments[0] = new (method === "addIceCandidate" ? window3.RTCIceCandidate : window3.RTCSessionDescription)(arguments[0]);
        return nativeMethod.apply(this, arguments);
      } };
      window3.RTCPeerConnection.prototype[method] = methodObj[method];
    });
  }
  const modernStatsTypes = {
    inboundrtp: "inbound-rtp",
    outboundrtp: "outbound-rtp",
    candidatepair: "candidate-pair",
    localcandidate: "local-candidate",
    remotecandidate: "remote-candidate"
  };
  const nativeGetStats = window3.RTCPeerConnection.prototype.getStats;
  window3.RTCPeerConnection.prototype.getStats = function getStats() {
    const [selector, onSucc, onErr] = arguments;
    return nativeGetStats.apply(this, [selector || null]).then((stats) => {
      if (browserDetails.version < 53 && !onSucc) {
        try {
          stats.forEach((stat) => {
            stat.type = modernStatsTypes[stat.type] || stat.type;
          });
        } catch (e) {
          if (e.name !== "TypeError") {
            throw e;
          }
          stats.forEach((stat, i) => {
            stats.set(i, Object.assign({}, stat, {
              type: modernStatsTypes[stat.type] || stat.type
            }));
          });
        }
      }
      return stats;
    }).then(onSucc, onErr);
  };
}
function shimSenderGetStats(window3) {
  if (!(typeof window3 === "object" && window3.RTCPeerConnection && window3.RTCRtpSender)) {
    return;
  }
  if (window3.RTCRtpSender && "getStats" in window3.RTCRtpSender.prototype) {
    return;
  }
  const origGetSenders = window3.RTCPeerConnection.prototype.getSenders;
  if (origGetSenders) {
    window3.RTCPeerConnection.prototype.getSenders = function getSenders() {
      const senders = origGetSenders.apply(this, []);
      senders.forEach((sender) => sender._pc = this);
      return senders;
    };
  }
  const origAddTrack = window3.RTCPeerConnection.prototype.addTrack;
  if (origAddTrack) {
    window3.RTCPeerConnection.prototype.addTrack = function addTrack() {
      const sender = origAddTrack.apply(this, arguments);
      sender._pc = this;
      return sender;
    };
  }
  window3.RTCRtpSender.prototype.getStats = function getStats() {
    return this.track ? this._pc.getStats(this.track) : Promise.resolve(/* @__PURE__ */ new Map());
  };
}
function shimReceiverGetStats(window3) {
  if (!(typeof window3 === "object" && window3.RTCPeerConnection && window3.RTCRtpSender)) {
    return;
  }
  if (window3.RTCRtpSender && "getStats" in window3.RTCRtpReceiver.prototype) {
    return;
  }
  const origGetReceivers = window3.RTCPeerConnection.prototype.getReceivers;
  if (origGetReceivers) {
    window3.RTCPeerConnection.prototype.getReceivers = function getReceivers() {
      const receivers = origGetReceivers.apply(this, []);
      receivers.forEach((receiver) => receiver._pc = this);
      return receivers;
    };
  }
  wrapPeerConnectionEvent(window3, "track", (e) => {
    e.receiver._pc = e.srcElement;
    return e;
  });
  window3.RTCRtpReceiver.prototype.getStats = function getStats() {
    return this._pc.getStats(this.track);
  };
}
function shimRemoveStream(window3) {
  if (!window3.RTCPeerConnection || "removeStream" in window3.RTCPeerConnection.prototype) {
    return;
  }
  window3.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
    deprecated("removeStream", "removeTrack");
    this.getSenders().forEach((sender) => {
      if (sender.track && stream.getTracks().includes(sender.track)) {
        this.removeTrack(sender);
      }
    });
  };
}
function shimRTCDataChannel(window3) {
  if (window3.DataChannel && !window3.RTCDataChannel) {
    window3.RTCDataChannel = window3.DataChannel;
  }
}
function shimAddTransceiver(window3) {
  if (!(typeof window3 === "object" && window3.RTCPeerConnection)) {
    return;
  }
  const origAddTransceiver = window3.RTCPeerConnection.prototype.addTransceiver;
  if (origAddTransceiver) {
    window3.RTCPeerConnection.prototype.addTransceiver = function addTransceiver() {
      this.setParametersPromises = [];
      let sendEncodings = arguments[1] && arguments[1].sendEncodings;
      if (sendEncodings === void 0) {
        sendEncodings = [];
      }
      sendEncodings = [...sendEncodings];
      const shouldPerformCheck = sendEncodings.length > 0;
      if (shouldPerformCheck) {
        sendEncodings.forEach((encodingParam) => {
          if ("rid" in encodingParam) {
            const ridRegex = /^[a-z0-9]{0,16}$/i;
            if (!ridRegex.test(encodingParam.rid)) {
              throw new TypeError("Invalid RID value provided.");
            }
          }
          if ("scaleResolutionDownBy" in encodingParam) {
            if (!(parseFloat(encodingParam.scaleResolutionDownBy) >= 1)) {
              throw new RangeError("scale_resolution_down_by must be >= 1.0");
            }
          }
          if ("maxFramerate" in encodingParam) {
            if (!(parseFloat(encodingParam.maxFramerate) >= 0)) {
              throw new RangeError("max_framerate must be >= 0.0");
            }
          }
        });
      }
      const transceiver = origAddTransceiver.apply(this, arguments);
      if (shouldPerformCheck) {
        const { sender } = transceiver;
        const params = sender.getParameters();
        if (!("encodings" in params) || // Avoid being fooled by patched getParameters() below.
        params.encodings.length === 1 && Object.keys(params.encodings[0]).length === 0) {
          params.encodings = sendEncodings;
          sender.sendEncodings = sendEncodings;
          this.setParametersPromises.push(
            sender.setParameters(params).then(() => {
              delete sender.sendEncodings;
            }).catch(() => {
              delete sender.sendEncodings;
            })
          );
        }
      }
      return transceiver;
    };
  }
}
function shimGetParameters(window3) {
  if (!(typeof window3 === "object" && window3.RTCRtpSender)) {
    return;
  }
  const origGetParameters = window3.RTCRtpSender.prototype.getParameters;
  if (origGetParameters) {
    window3.RTCRtpSender.prototype.getParameters = function getParameters() {
      const params = origGetParameters.apply(this, arguments);
      if (!("encodings" in params)) {
        params.encodings = [].concat(this.sendEncodings || [{}]);
      }
      return params;
    };
  }
}
function shimCreateOffer(window3) {
  if (!(typeof window3 === "object" && window3.RTCPeerConnection)) {
    return;
  }
  const origCreateOffer = window3.RTCPeerConnection.prototype.createOffer;
  window3.RTCPeerConnection.prototype.createOffer = function createOffer() {
    if (this.setParametersPromises && this.setParametersPromises.length) {
      return Promise.all(this.setParametersPromises).then(() => {
        return origCreateOffer.apply(this, arguments);
      }).finally(() => {
        this.setParametersPromises = [];
      });
    }
    return origCreateOffer.apply(this, arguments);
  };
}
function shimCreateAnswer(window3) {
  if (!(typeof window3 === "object" && window3.RTCPeerConnection)) {
    return;
  }
  const origCreateAnswer = window3.RTCPeerConnection.prototype.createAnswer;
  window3.RTCPeerConnection.prototype.createAnswer = function createAnswer() {
    if (this.setParametersPromises && this.setParametersPromises.length) {
      return Promise.all(this.setParametersPromises).then(() => {
        return origCreateAnswer.apply(this, arguments);
      }).finally(() => {
        this.setParametersPromises = [];
      });
    }
    return origCreateAnswer.apply(this, arguments);
  };
}

// node_modules/webrtc-adapter/src/js/safari/safari_shim.js
var safari_shim_exports = {};
__export(safari_shim_exports, {
  shimAudioContext: () => shimAudioContext,
  shimCallbacksAPI: () => shimCallbacksAPI,
  shimConstraints: () => shimConstraints,
  shimCreateOfferLegacy: () => shimCreateOfferLegacy,
  shimGetUserMedia: () => shimGetUserMedia3,
  shimLocalStreamsAPI: () => shimLocalStreamsAPI,
  shimRTCIceServerUrls: () => shimRTCIceServerUrls,
  shimRemoteStreamsAPI: () => shimRemoteStreamsAPI,
  shimTrackEventTransceiver: () => shimTrackEventTransceiver
});
function shimLocalStreamsAPI(window3) {
  if (typeof window3 !== "object" || !window3.RTCPeerConnection) {
    return;
  }
  if (!("getLocalStreams" in window3.RTCPeerConnection.prototype)) {
    window3.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
      if (!this._localStreams) {
        this._localStreams = [];
      }
      return this._localStreams;
    };
  }
  if (!("addStream" in window3.RTCPeerConnection.prototype)) {
    const _addTrack = window3.RTCPeerConnection.prototype.addTrack;
    window3.RTCPeerConnection.prototype.addStream = function addStream(stream) {
      if (!this._localStreams) {
        this._localStreams = [];
      }
      if (!this._localStreams.includes(stream)) {
        this._localStreams.push(stream);
      }
      stream.getAudioTracks().forEach((track) => _addTrack.call(
        this,
        track,
        stream
      ));
      stream.getVideoTracks().forEach((track) => _addTrack.call(
        this,
        track,
        stream
      ));
    };
    window3.RTCPeerConnection.prototype.addTrack = function addTrack(track, ...streams) {
      if (streams) {
        streams.forEach((stream) => {
          if (!this._localStreams) {
            this._localStreams = [stream];
          } else if (!this._localStreams.includes(stream)) {
            this._localStreams.push(stream);
          }
        });
      }
      return _addTrack.apply(this, arguments);
    };
  }
  if (!("removeStream" in window3.RTCPeerConnection.prototype)) {
    window3.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
      if (!this._localStreams) {
        this._localStreams = [];
      }
      const index3 = this._localStreams.indexOf(stream);
      if (index3 === -1) {
        return;
      }
      this._localStreams.splice(index3, 1);
      const tracks = stream.getTracks();
      this.getSenders().forEach((sender) => {
        if (tracks.includes(sender.track)) {
          this.removeTrack(sender);
        }
      });
    };
  }
}
function shimRemoteStreamsAPI(window3) {
  if (typeof window3 !== "object" || !window3.RTCPeerConnection) {
    return;
  }
  if (!("getRemoteStreams" in window3.RTCPeerConnection.prototype)) {
    window3.RTCPeerConnection.prototype.getRemoteStreams = function getRemoteStreams() {
      return this._remoteStreams ? this._remoteStreams : [];
    };
  }
  if (!("onaddstream" in window3.RTCPeerConnection.prototype)) {
    Object.defineProperty(window3.RTCPeerConnection.prototype, "onaddstream", {
      get() {
        return this._onaddstream;
      },
      set(f) {
        if (this._onaddstream) {
          this.removeEventListener("addstream", this._onaddstream);
          this.removeEventListener("track", this._onaddstreampoly);
        }
        this.addEventListener("addstream", this._onaddstream = f);
        this.addEventListener("track", this._onaddstreampoly = (e) => {
          e.streams.forEach((stream) => {
            if (!this._remoteStreams) {
              this._remoteStreams = [];
            }
            if (this._remoteStreams.includes(stream)) {
              return;
            }
            this._remoteStreams.push(stream);
            const event = new Event("addstream");
            event.stream = stream;
            this.dispatchEvent(event);
          });
        });
      }
    });
    const origSetRemoteDescription = window3.RTCPeerConnection.prototype.setRemoteDescription;
    window3.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
      const pc = this;
      if (!this._onaddstreampoly) {
        this.addEventListener("track", this._onaddstreampoly = function(e) {
          e.streams.forEach((stream) => {
            if (!pc._remoteStreams) {
              pc._remoteStreams = [];
            }
            if (pc._remoteStreams.indexOf(stream) >= 0) {
              return;
            }
            pc._remoteStreams.push(stream);
            const event = new Event("addstream");
            event.stream = stream;
            pc.dispatchEvent(event);
          });
        });
      }
      return origSetRemoteDescription.apply(pc, arguments);
    };
  }
}
function shimCallbacksAPI(window3) {
  if (typeof window3 !== "object" || !window3.RTCPeerConnection) {
    return;
  }
  const prototype = window3.RTCPeerConnection.prototype;
  const origCreateOffer = prototype.createOffer;
  const origCreateAnswer = prototype.createAnswer;
  const setLocalDescription = prototype.setLocalDescription;
  const setRemoteDescription = prototype.setRemoteDescription;
  const addIceCandidate = prototype.addIceCandidate;
  prototype.createOffer = function createOffer(successCallback, failureCallback) {
    const options = arguments.length >= 2 ? arguments[2] : arguments[0];
    const promise = origCreateOffer.apply(this, [options]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };
  prototype.createAnswer = function createAnswer(successCallback, failureCallback) {
    const options = arguments.length >= 2 ? arguments[2] : arguments[0];
    const promise = origCreateAnswer.apply(this, [options]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };
  let withCallback = function(description, successCallback, failureCallback) {
    const promise = setLocalDescription.apply(this, [description]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };
  prototype.setLocalDescription = withCallback;
  withCallback = function(description, successCallback, failureCallback) {
    const promise = setRemoteDescription.apply(this, [description]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };
  prototype.setRemoteDescription = withCallback;
  withCallback = function(candidate, successCallback, failureCallback) {
    const promise = addIceCandidate.apply(this, [candidate]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };
  prototype.addIceCandidate = withCallback;
}
function shimGetUserMedia3(window3) {
  const navigator2 = window3 && window3.navigator;
  if (navigator2.mediaDevices && navigator2.mediaDevices.getUserMedia) {
    const mediaDevices = navigator2.mediaDevices;
    const _getUserMedia = mediaDevices.getUserMedia.bind(mediaDevices);
    navigator2.mediaDevices.getUserMedia = (constraints) => {
      return _getUserMedia(shimConstraints(constraints));
    };
  }
  if (!navigator2.getUserMedia && navigator2.mediaDevices && navigator2.mediaDevices.getUserMedia) {
    navigator2.getUserMedia = (function getUserMedia(constraints, cb, errcb) {
      navigator2.mediaDevices.getUserMedia(constraints).then(cb, errcb);
    }).bind(navigator2);
  }
}
function shimConstraints(constraints) {
  if (constraints && constraints.video !== void 0) {
    return Object.assign(
      {},
      constraints,
      { video: compactObject(constraints.video) }
    );
  }
  return constraints;
}
function shimRTCIceServerUrls(window3) {
  if (!window3.RTCPeerConnection) {
    return;
  }
  const OrigPeerConnection = window3.RTCPeerConnection;
  window3.RTCPeerConnection = function RTCPeerConnection2(pcConfig, pcConstraints) {
    if (pcConfig && pcConfig.iceServers) {
      const newIceServers = [];
      for (let i = 0; i < pcConfig.iceServers.length; i++) {
        let server = pcConfig.iceServers[i];
        if (server.urls === void 0 && server.url) {
          deprecated("RTCIceServer.url", "RTCIceServer.urls");
          server = JSON.parse(JSON.stringify(server));
          server.urls = server.url;
          delete server.url;
          newIceServers.push(server);
        } else {
          newIceServers.push(pcConfig.iceServers[i]);
        }
      }
      pcConfig.iceServers = newIceServers;
    }
    return new OrigPeerConnection(pcConfig, pcConstraints);
  };
  window3.RTCPeerConnection.prototype = OrigPeerConnection.prototype;
  if ("generateCertificate" in OrigPeerConnection) {
    Object.defineProperty(window3.RTCPeerConnection, "generateCertificate", {
      get() {
        return OrigPeerConnection.generateCertificate;
      }
    });
  }
}
function shimTrackEventTransceiver(window3) {
  if (typeof window3 === "object" && window3.RTCTrackEvent && "receiver" in window3.RTCTrackEvent.prototype && !("transceiver" in window3.RTCTrackEvent.prototype)) {
    Object.defineProperty(window3.RTCTrackEvent.prototype, "transceiver", {
      get() {
        return { receiver: this.receiver };
      }
    });
  }
}
function shimCreateOfferLegacy(window3) {
  const origCreateOffer = window3.RTCPeerConnection.prototype.createOffer;
  window3.RTCPeerConnection.prototype.createOffer = function createOffer(offerOptions) {
    if (offerOptions) {
      if (typeof offerOptions.offerToReceiveAudio !== "undefined") {
        offerOptions.offerToReceiveAudio = !!offerOptions.offerToReceiveAudio;
      }
      const audioTransceiver = this.getTransceivers().find((transceiver) => transceiver.receiver.track.kind === "audio");
      if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {
        if (audioTransceiver.direction === "sendrecv") {
          if (audioTransceiver.setDirection) {
            audioTransceiver.setDirection("sendonly");
          } else {
            audioTransceiver.direction = "sendonly";
          }
        } else if (audioTransceiver.direction === "recvonly") {
          if (audioTransceiver.setDirection) {
            audioTransceiver.setDirection("inactive");
          } else {
            audioTransceiver.direction = "inactive";
          }
        }
      } else if (offerOptions.offerToReceiveAudio === true && !audioTransceiver) {
        this.addTransceiver("audio", { direction: "recvonly" });
      }
      if (typeof offerOptions.offerToReceiveVideo !== "undefined") {
        offerOptions.offerToReceiveVideo = !!offerOptions.offerToReceiveVideo;
      }
      const videoTransceiver = this.getTransceivers().find((transceiver) => transceiver.receiver.track.kind === "video");
      if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {
        if (videoTransceiver.direction === "sendrecv") {
          if (videoTransceiver.setDirection) {
            videoTransceiver.setDirection("sendonly");
          } else {
            videoTransceiver.direction = "sendonly";
          }
        } else if (videoTransceiver.direction === "recvonly") {
          if (videoTransceiver.setDirection) {
            videoTransceiver.setDirection("inactive");
          } else {
            videoTransceiver.direction = "inactive";
          }
        }
      } else if (offerOptions.offerToReceiveVideo === true && !videoTransceiver) {
        this.addTransceiver("video", { direction: "recvonly" });
      }
    }
    return origCreateOffer.apply(this, arguments);
  };
}
function shimAudioContext(window3) {
  if (typeof window3 !== "object" || window3.AudioContext) {
    return;
  }
  window3.AudioContext = window3.webkitAudioContext;
}

// node_modules/webrtc-adapter/src/js/common_shim.js
var common_shim_exports = {};
__export(common_shim_exports, {
  removeExtmapAllowMixed: () => removeExtmapAllowMixed,
  shimAddIceCandidateNullOrEmpty: () => shimAddIceCandidateNullOrEmpty,
  shimConnectionState: () => shimConnectionState,
  shimMaxMessageSize: () => shimMaxMessageSize,
  shimParameterlessSetLocalDescription: () => shimParameterlessSetLocalDescription,
  shimRTCIceCandidate: () => shimRTCIceCandidate,
  shimRTCIceCandidateRelayProtocol: () => shimRTCIceCandidateRelayProtocol,
  shimSendThrowTypeError: () => shimSendThrowTypeError
});
var import_sdp = __toESM(require_sdp());
function shimRTCIceCandidate(window3) {
  if (!window3.RTCIceCandidate || window3.RTCIceCandidate && "foundation" in window3.RTCIceCandidate.prototype) {
    return;
  }
  const NativeRTCIceCandidate = window3.RTCIceCandidate;
  window3.RTCIceCandidate = function RTCIceCandidate(args) {
    if (typeof args === "object" && args.candidate && args.candidate.indexOf("a=") === 0) {
      args = JSON.parse(JSON.stringify(args));
      args.candidate = args.candidate.substring(2);
    }
    if (args.candidate && args.candidate.length) {
      const nativeCandidate = new NativeRTCIceCandidate(args);
      const parsedCandidate = import_sdp.default.parseCandidate(args.candidate);
      for (const key in parsedCandidate) {
        if (!(key in nativeCandidate)) {
          Object.defineProperty(
            nativeCandidate,
            key,
            { value: parsedCandidate[key] }
          );
        }
      }
      nativeCandidate.toJSON = function toJSON() {
        return {
          candidate: nativeCandidate.candidate,
          sdpMid: nativeCandidate.sdpMid,
          sdpMLineIndex: nativeCandidate.sdpMLineIndex,
          usernameFragment: nativeCandidate.usernameFragment
        };
      };
      return nativeCandidate;
    }
    return new NativeRTCIceCandidate(args);
  };
  window3.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;
  wrapPeerConnectionEvent(window3, "icecandidate", (e) => {
    if (e.candidate) {
      Object.defineProperty(e, "candidate", {
        value: new window3.RTCIceCandidate(e.candidate),
        writable: "false"
      });
    }
    return e;
  });
}
function shimRTCIceCandidateRelayProtocol(window3) {
  if (!window3.RTCIceCandidate || window3.RTCIceCandidate && "relayProtocol" in window3.RTCIceCandidate.prototype) {
    return;
  }
  wrapPeerConnectionEvent(window3, "icecandidate", (e) => {
    if (e.candidate) {
      const parsedCandidate = import_sdp.default.parseCandidate(e.candidate.candidate);
      if (parsedCandidate.type === "relay") {
        e.candidate.relayProtocol = {
          0: "tls",
          1: "tcp",
          2: "udp"
        }[parsedCandidate.priority >> 24];
      }
    }
    return e;
  });
}
function shimMaxMessageSize(window3, browserDetails) {
  if (!window3.RTCPeerConnection) {
    return;
  }
  if (!("sctp" in window3.RTCPeerConnection.prototype)) {
    Object.defineProperty(window3.RTCPeerConnection.prototype, "sctp", {
      get() {
        return typeof this._sctp === "undefined" ? null : this._sctp;
      }
    });
  }
  const sctpInDescription = function(description) {
    if (!description || !description.sdp) {
      return false;
    }
    const sections = import_sdp.default.splitSections(description.sdp);
    sections.shift();
    return sections.some((mediaSection) => {
      const mLine = import_sdp.default.parseMLine(mediaSection);
      return mLine && mLine.kind === "application" && mLine.protocol.indexOf("SCTP") !== -1;
    });
  };
  const getRemoteFirefoxVersion = function(description) {
    const match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
    if (match === null || match.length < 2) {
      return -1;
    }
    const version3 = parseInt(match[1], 10);
    return version3 !== version3 ? -1 : version3;
  };
  const getCanSendMaxMessageSize = function(remoteIsFirefox) {
    let canSendMaxMessageSize = 65536;
    if (browserDetails.browser === "firefox") {
      if (browserDetails.version < 57) {
        if (remoteIsFirefox === -1) {
          canSendMaxMessageSize = 16384;
        } else {
          canSendMaxMessageSize = 2147483637;
        }
      } else if (browserDetails.version < 60) {
        canSendMaxMessageSize = browserDetails.version === 57 ? 65535 : 65536;
      } else {
        canSendMaxMessageSize = 2147483637;
      }
    }
    return canSendMaxMessageSize;
  };
  const getMaxMessageSize = function(description, remoteIsFirefox) {
    let maxMessageSize = 65536;
    if (browserDetails.browser === "firefox" && browserDetails.version === 57) {
      maxMessageSize = 65535;
    }
    const match = import_sdp.default.matchPrefix(
      description.sdp,
      "a=max-message-size:"
    );
    if (match.length > 0) {
      maxMessageSize = parseInt(match[0].substring(19), 10);
    } else if (browserDetails.browser === "firefox" && remoteIsFirefox !== -1) {
      maxMessageSize = 2147483637;
    }
    return maxMessageSize;
  };
  const origSetRemoteDescription = window3.RTCPeerConnection.prototype.setRemoteDescription;
  window3.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
    this._sctp = null;
    if (browserDetails.browser === "chrome" && browserDetails.version >= 76) {
      const { sdpSemantics } = this.getConfiguration();
      if (sdpSemantics === "plan-b") {
        Object.defineProperty(this, "sctp", {
          get() {
            return typeof this._sctp === "undefined" ? null : this._sctp;
          },
          enumerable: true,
          configurable: true
        });
      }
    }
    if (sctpInDescription(arguments[0])) {
      const isFirefox2 = getRemoteFirefoxVersion(arguments[0]);
      const canSendMMS = getCanSendMaxMessageSize(isFirefox2);
      const remoteMMS = getMaxMessageSize(arguments[0], isFirefox2);
      let maxMessageSize;
      if (canSendMMS === 0 && remoteMMS === 0) {
        maxMessageSize = Number.POSITIVE_INFINITY;
      } else if (canSendMMS === 0 || remoteMMS === 0) {
        maxMessageSize = Math.max(canSendMMS, remoteMMS);
      } else {
        maxMessageSize = Math.min(canSendMMS, remoteMMS);
      }
      const sctp = {};
      Object.defineProperty(sctp, "maxMessageSize", {
        get() {
          return maxMessageSize;
        }
      });
      this._sctp = sctp;
    }
    return origSetRemoteDescription.apply(this, arguments);
  };
}
function shimSendThrowTypeError(window3) {
  if (!(window3.RTCPeerConnection && "createDataChannel" in window3.RTCPeerConnection.prototype)) {
    return;
  }
  function wrapDcSend(dc, pc) {
    const origDataChannelSend = dc.send;
    dc.send = function send() {
      const data = arguments[0];
      const length = data.length || data.size || data.byteLength;
      if (dc.readyState === "open" && pc.sctp && length > pc.sctp.maxMessageSize) {
        throw new TypeError("Message too large (can send a maximum of " + pc.sctp.maxMessageSize + " bytes)");
      }
      return origDataChannelSend.apply(dc, arguments);
    };
  }
  const origCreateDataChannel = window3.RTCPeerConnection.prototype.createDataChannel;
  window3.RTCPeerConnection.prototype.createDataChannel = function createDataChannel() {
    const dataChannel = origCreateDataChannel.apply(this, arguments);
    wrapDcSend(dataChannel, this);
    return dataChannel;
  };
  wrapPeerConnectionEvent(window3, "datachannel", (e) => {
    wrapDcSend(e.channel, e.target);
    return e;
  });
}
function shimConnectionState(window3) {
  if (!window3.RTCPeerConnection || "connectionState" in window3.RTCPeerConnection.prototype) {
    return;
  }
  const proto = window3.RTCPeerConnection.prototype;
  Object.defineProperty(proto, "connectionState", {
    get() {
      return {
        completed: "connected",
        checking: "connecting"
      }[this.iceConnectionState] || this.iceConnectionState;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(proto, "onconnectionstatechange", {
    get() {
      return this._onconnectionstatechange || null;
    },
    set(cb) {
      if (this._onconnectionstatechange) {
        this.removeEventListener(
          "connectionstatechange",
          this._onconnectionstatechange
        );
        delete this._onconnectionstatechange;
      }
      if (cb) {
        this.addEventListener(
          "connectionstatechange",
          this._onconnectionstatechange = cb
        );
      }
    },
    enumerable: true,
    configurable: true
  });
  ["setLocalDescription", "setRemoteDescription"].forEach((method) => {
    const origMethod = proto[method];
    proto[method] = function() {
      if (!this._connectionstatechangepoly) {
        this._connectionstatechangepoly = (e) => {
          const pc = e.target;
          if (pc._lastConnectionState !== pc.connectionState) {
            pc._lastConnectionState = pc.connectionState;
            const newEvent = new Event("connectionstatechange", e);
            pc.dispatchEvent(newEvent);
          }
          return e;
        };
        this.addEventListener(
          "iceconnectionstatechange",
          this._connectionstatechangepoly
        );
      }
      return origMethod.apply(this, arguments);
    };
  });
}
function removeExtmapAllowMixed(window3, browserDetails) {
  if (!window3.RTCPeerConnection) {
    return;
  }
  if (browserDetails.browser === "chrome" && browserDetails.version >= 71) {
    return;
  }
  if (browserDetails.browser === "safari" && browserDetails._safariVersion >= 13.1) {
    return;
  }
  const nativeSRD = window3.RTCPeerConnection.prototype.setRemoteDescription;
  window3.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription(desc) {
    if (desc && desc.sdp && desc.sdp.indexOf("\na=extmap-allow-mixed") !== -1) {
      const sdp2 = desc.sdp.split("\n").filter((line) => {
        return line.trim() !== "a=extmap-allow-mixed";
      }).join("\n");
      if (window3.RTCSessionDescription && desc instanceof window3.RTCSessionDescription) {
        arguments[0] = new window3.RTCSessionDescription({
          type: desc.type,
          sdp: sdp2
        });
      } else {
        desc.sdp = sdp2;
      }
    }
    return nativeSRD.apply(this, arguments);
  };
}
function shimAddIceCandidateNullOrEmpty(window3, browserDetails) {
  if (!(window3.RTCPeerConnection && window3.RTCPeerConnection.prototype)) {
    return;
  }
  const nativeAddIceCandidate = window3.RTCPeerConnection.prototype.addIceCandidate;
  if (!nativeAddIceCandidate || nativeAddIceCandidate.length === 0) {
    return;
  }
  window3.RTCPeerConnection.prototype.addIceCandidate = function addIceCandidate() {
    if (!arguments[0]) {
      if (arguments[1]) {
        arguments[1].apply(null);
      }
      return Promise.resolve();
    }
    if ((browserDetails.browser === "chrome" && browserDetails.version < 78 || browserDetails.browser === "firefox" && browserDetails.version < 68 || browserDetails.browser === "safari") && arguments[0] && arguments[0].candidate === "") {
      return Promise.resolve();
    }
    return nativeAddIceCandidate.apply(this, arguments);
  };
}
function shimParameterlessSetLocalDescription(window3, browserDetails) {
  if (!(window3.RTCPeerConnection && window3.RTCPeerConnection.prototype)) {
    return;
  }
  const nativeSetLocalDescription = window3.RTCPeerConnection.prototype.setLocalDescription;
  if (!nativeSetLocalDescription || nativeSetLocalDescription.length === 0) {
    return;
  }
  window3.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {
    let desc = arguments[0] || {};
    if (typeof desc !== "object" || desc.type && desc.sdp) {
      return nativeSetLocalDescription.apply(this, arguments);
    }
    desc = { type: desc.type, sdp: desc.sdp };
    if (!desc.type) {
      switch (this.signalingState) {
        case "stable":
        case "have-local-offer":
        case "have-remote-pranswer":
          desc.type = "offer";
          break;
        default:
          desc.type = "answer";
          break;
      }
    }
    if (desc.sdp || desc.type !== "offer" && desc.type !== "answer") {
      return nativeSetLocalDescription.apply(this, [desc]);
    }
    const func = desc.type === "offer" ? this.createOffer : this.createAnswer;
    return func.apply(this).then((d) => nativeSetLocalDescription.apply(this, [d]));
  };
}

// node_modules/webrtc-adapter/src/js/adapter_factory.js
var sdp = __toESM(require_sdp());
function adapterFactory({ window: window3 } = {}, options = {
  shimChrome: true,
  shimFirefox: true,
  shimSafari: true
}) {
  const logging2 = log;
  const browserDetails = detectBrowser(window3);
  const adapter2 = {
    browserDetails,
    commonShim: common_shim_exports,
    extractVersion,
    disableLog,
    disableWarnings,
    // Expose sdp as a convenience. For production apps include directly.
    sdp
  };
  switch (browserDetails.browser) {
    case "chrome":
      if (!chrome_shim_exports || !shimPeerConnection || !options.shimChrome) {
        logging2("Chrome shim is not included in this adapter release.");
        return adapter2;
      }
      if (browserDetails.version === null) {
        logging2("Chrome shim can not determine version, not shimming.");
        return adapter2;
      }
      logging2("adapter.js shimming chrome.");
      adapter2.browserShim = chrome_shim_exports;
      shimAddIceCandidateNullOrEmpty(window3, browserDetails);
      shimParameterlessSetLocalDescription(window3, browserDetails);
      shimGetUserMedia(window3, browserDetails);
      shimMediaStream(window3, browserDetails);
      shimPeerConnection(window3, browserDetails);
      shimOnTrack(window3, browserDetails);
      shimAddTrackRemoveTrack(window3, browserDetails);
      shimGetSendersWithDtmf(window3, browserDetails);
      shimGetStats(window3, browserDetails);
      shimSenderReceiverGetStats(window3, browserDetails);
      fixNegotiationNeeded(window3, browserDetails);
      shimRTCIceCandidate(window3, browserDetails);
      shimRTCIceCandidateRelayProtocol(window3, browserDetails);
      shimConnectionState(window3, browserDetails);
      shimMaxMessageSize(window3, browserDetails);
      shimSendThrowTypeError(window3, browserDetails);
      removeExtmapAllowMixed(window3, browserDetails);
      break;
    case "firefox":
      if (!firefox_shim_exports || !shimPeerConnection2 || !options.shimFirefox) {
        logging2("Firefox shim is not included in this adapter release.");
        return adapter2;
      }
      logging2("adapter.js shimming firefox.");
      adapter2.browserShim = firefox_shim_exports;
      shimAddIceCandidateNullOrEmpty(window3, browserDetails);
      shimParameterlessSetLocalDescription(window3, browserDetails);
      shimGetUserMedia2(window3, browserDetails);
      shimPeerConnection2(window3, browserDetails);
      shimOnTrack2(window3, browserDetails);
      shimRemoveStream(window3, browserDetails);
      shimSenderGetStats(window3, browserDetails);
      shimReceiverGetStats(window3, browserDetails);
      shimRTCDataChannel(window3, browserDetails);
      shimAddTransceiver(window3, browserDetails);
      shimGetParameters(window3, browserDetails);
      shimCreateOffer(window3, browserDetails);
      shimCreateAnswer(window3, browserDetails);
      shimRTCIceCandidate(window3, browserDetails);
      shimConnectionState(window3, browserDetails);
      shimMaxMessageSize(window3, browserDetails);
      shimSendThrowTypeError(window3, browserDetails);
      break;
    case "safari":
      if (!safari_shim_exports || !options.shimSafari) {
        logging2("Safari shim is not included in this adapter release.");
        return adapter2;
      }
      logging2("adapter.js shimming safari.");
      adapter2.browserShim = safari_shim_exports;
      shimAddIceCandidateNullOrEmpty(window3, browserDetails);
      shimParameterlessSetLocalDescription(window3, browserDetails);
      shimRTCIceServerUrls(window3, browserDetails);
      shimCreateOfferLegacy(window3, browserDetails);
      shimCallbacksAPI(window3, browserDetails);
      shimLocalStreamsAPI(window3, browserDetails);
      shimRemoteStreamsAPI(window3, browserDetails);
      shimTrackEventTransceiver(window3, browserDetails);
      shimGetUserMedia3(window3, browserDetails);
      shimAudioContext(window3, browserDetails);
      shimRTCIceCandidate(window3, browserDetails);
      shimRTCIceCandidateRelayProtocol(window3, browserDetails);
      shimMaxMessageSize(window3, browserDetails);
      shimSendThrowTypeError(window3, browserDetails);
      removeExtmapAllowMixed(window3, browserDetails);
      break;
    default:
      logging2("Unsupported browser!");
      break;
  }
  return adapter2;
}

// node_modules/webrtc-adapter/src/js/adapter_core.js
var adapter = adapterFactory({ window: typeof window === "undefined" ? void 0 : window });

// node_modules/@protobuf-ts/runtime/build/es2015/json-typings.js
function typeofJsonValue(value) {
  let t2 = typeof value;
  if (t2 == "object") {
    if (Array.isArray(value))
      return "array";
    if (value === null)
      return "null";
  }
  return t2;
}
function isJsonObject(value) {
  return value !== null && typeof value == "object" && !Array.isArray(value);
}

// node_modules/@protobuf-ts/runtime/build/es2015/base64.js
var encTable = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
var decTable = [];
for (let i = 0; i < encTable.length; i++)
  decTable[encTable[i].charCodeAt(0)] = i;
decTable["-".charCodeAt(0)] = encTable.indexOf("+");
decTable["_".charCodeAt(0)] = encTable.indexOf("/");
function base64decode(base64Str) {
  let es = base64Str.length * 3 / 4;
  if (base64Str[base64Str.length - 2] == "=")
    es -= 2;
  else if (base64Str[base64Str.length - 1] == "=")
    es -= 1;
  let bytes = new Uint8Array(es), bytePos = 0, groupPos = 0, b, p = 0;
  for (let i = 0; i < base64Str.length; i++) {
    b = decTable[base64Str.charCodeAt(i)];
    if (b === void 0) {
      switch (base64Str[i]) {
        case "=":
          groupPos = 0;
        // reset state when padding found
        case "\n":
        case "\r":
        case "	":
        case " ":
          continue;
        // skip white-space, and padding
        default:
          throw Error(`invalid base64 string.`);
      }
    }
    switch (groupPos) {
      case 0:
        p = b;
        groupPos = 1;
        break;
      case 1:
        bytes[bytePos++] = p << 2 | (b & 48) >> 4;
        p = b;
        groupPos = 2;
        break;
      case 2:
        bytes[bytePos++] = (p & 15) << 4 | (b & 60) >> 2;
        p = b;
        groupPos = 3;
        break;
      case 3:
        bytes[bytePos++] = (p & 3) << 6 | b;
        groupPos = 0;
        break;
    }
  }
  if (groupPos == 1)
    throw Error(`invalid base64 string.`);
  return bytes.subarray(0, bytePos);
}
function base64encode(bytes) {
  let base64 = "", groupPos = 0, b, p = 0;
  for (let i = 0; i < bytes.length; i++) {
    b = bytes[i];
    switch (groupPos) {
      case 0:
        base64 += encTable[b >> 2];
        p = (b & 3) << 4;
        groupPos = 1;
        break;
      case 1:
        base64 += encTable[p | b >> 4];
        p = (b & 15) << 2;
        groupPos = 2;
        break;
      case 2:
        base64 += encTable[p | b >> 6];
        base64 += encTable[b & 63];
        groupPos = 0;
        break;
    }
  }
  if (groupPos) {
    base64 += encTable[p];
    base64 += "=";
    if (groupPos == 1)
      base64 += "=";
  }
  return base64;
}

// node_modules/@protobuf-ts/runtime/build/es2015/binary-format-contract.js
var UnknownFieldHandler;
(function(UnknownFieldHandler2) {
  UnknownFieldHandler2.symbol = Symbol.for("protobuf-ts/unknown");
  UnknownFieldHandler2.onRead = (typeName, message, fieldNo, wireType, data) => {
    let container = is(message) ? message[UnknownFieldHandler2.symbol] : message[UnknownFieldHandler2.symbol] = [];
    container.push({ no: fieldNo, wireType, data });
  };
  UnknownFieldHandler2.onWrite = (typeName, message, writer) => {
    for (let { no, wireType, data } of UnknownFieldHandler2.list(message))
      writer.tag(no, wireType).raw(data);
  };
  UnknownFieldHandler2.list = (message, fieldNo) => {
    if (is(message)) {
      let all = message[UnknownFieldHandler2.symbol];
      return fieldNo ? all.filter((uf) => uf.no == fieldNo) : all;
    }
    return [];
  };
  UnknownFieldHandler2.last = (message, fieldNo) => UnknownFieldHandler2.list(message, fieldNo).slice(-1)[0];
  const is = (message) => message && Array.isArray(message[UnknownFieldHandler2.symbol]);
})(UnknownFieldHandler || (UnknownFieldHandler = {}));
function mergeBinaryOptions(a, b) {
  return Object.assign(Object.assign({}, a), b);
}
var WireType;
(function(WireType2) {
  WireType2[WireType2["Varint"] = 0] = "Varint";
  WireType2[WireType2["Bit64"] = 1] = "Bit64";
  WireType2[WireType2["LengthDelimited"] = 2] = "LengthDelimited";
  WireType2[WireType2["StartGroup"] = 3] = "StartGroup";
  WireType2[WireType2["EndGroup"] = 4] = "EndGroup";
  WireType2[WireType2["Bit32"] = 5] = "Bit32";
})(WireType || (WireType = {}));

// node_modules/@protobuf-ts/runtime/build/es2015/goog-varint.js
function varint64read() {
  let lowBits = 0;
  let highBits = 0;
  for (let shift4 = 0; shift4 < 28; shift4 += 7) {
    let b = this.buf[this.pos++];
    lowBits |= (b & 127) << shift4;
    if ((b & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
  }
  let middleByte = this.buf[this.pos++];
  lowBits |= (middleByte & 15) << 28;
  highBits = (middleByte & 112) >> 4;
  if ((middleByte & 128) == 0) {
    this.assertBounds();
    return [lowBits, highBits];
  }
  for (let shift4 = 3; shift4 <= 31; shift4 += 7) {
    let b = this.buf[this.pos++];
    highBits |= (b & 127) << shift4;
    if ((b & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
  }
  throw new Error("invalid varint");
}
function varint64write(lo, hi, bytes) {
  for (let i = 0; i < 28; i = i + 7) {
    const shift4 = lo >>> i;
    const hasNext = !(shift4 >>> 7 == 0 && hi == 0);
    const byte = (hasNext ? shift4 | 128 : shift4) & 255;
    bytes.push(byte);
    if (!hasNext) {
      return;
    }
  }
  const splitBits = lo >>> 28 & 15 | (hi & 7) << 4;
  const hasMoreBits = !(hi >> 3 == 0);
  bytes.push((hasMoreBits ? splitBits | 128 : splitBits) & 255);
  if (!hasMoreBits) {
    return;
  }
  for (let i = 3; i < 31; i = i + 7) {
    const shift4 = hi >>> i;
    const hasNext = !(shift4 >>> 7 == 0);
    const byte = (hasNext ? shift4 | 128 : shift4) & 255;
    bytes.push(byte);
    if (!hasNext) {
      return;
    }
  }
  bytes.push(hi >>> 31 & 1);
}
var TWO_PWR_32_DBL = (1 << 16) * (1 << 16);
function int64fromString(dec) {
  let minus = dec[0] == "-";
  if (minus)
    dec = dec.slice(1);
  const base = 1e6;
  let lowBits = 0;
  let highBits = 0;
  function add1e6digit(begin, end) {
    const digit1e6 = Number(dec.slice(begin, end));
    highBits *= base;
    lowBits = lowBits * base + digit1e6;
    if (lowBits >= TWO_PWR_32_DBL) {
      highBits = highBits + (lowBits / TWO_PWR_32_DBL | 0);
      lowBits = lowBits % TWO_PWR_32_DBL;
    }
  }
  add1e6digit(-24, -18);
  add1e6digit(-18, -12);
  add1e6digit(-12, -6);
  add1e6digit(-6);
  return [minus, lowBits, highBits];
}
function int64toString(bitsLow, bitsHigh) {
  if (bitsHigh >>> 0 <= 2097151) {
    return "" + (TWO_PWR_32_DBL * bitsHigh + (bitsLow >>> 0));
  }
  let low = bitsLow & 16777215;
  let mid = (bitsLow >>> 24 | bitsHigh << 8) >>> 0 & 16777215;
  let high = bitsHigh >> 16 & 65535;
  let digitA = low + mid * 6777216 + high * 6710656;
  let digitB = mid + high * 8147497;
  let digitC = high * 2;
  let base = 1e7;
  if (digitA >= base) {
    digitB += Math.floor(digitA / base);
    digitA %= base;
  }
  if (digitB >= base) {
    digitC += Math.floor(digitB / base);
    digitB %= base;
  }
  function decimalFrom1e7(digit1e7, needLeadingZeros) {
    let partial = digit1e7 ? String(digit1e7) : "";
    if (needLeadingZeros) {
      return "0000000".slice(partial.length) + partial;
    }
    return partial;
  }
  return decimalFrom1e7(
    digitC,
    /*needLeadingZeros=*/
    0
  ) + decimalFrom1e7(
    digitB,
    /*needLeadingZeros=*/
    digitC
  ) + // If the final 1e7 digit didn't need leading zeros, we would have
  // returned via the trivial code path at the top.
  decimalFrom1e7(
    digitA,
    /*needLeadingZeros=*/
    1
  );
}
function varint32write(value, bytes) {
  if (value >= 0) {
    while (value > 127) {
      bytes.push(value & 127 | 128);
      value = value >>> 7;
    }
    bytes.push(value);
  } else {
    for (let i = 0; i < 9; i++) {
      bytes.push(value & 127 | 128);
      value = value >> 7;
    }
    bytes.push(1);
  }
}
function varint32read() {
  let b = this.buf[this.pos++];
  let result = b & 127;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 127) << 7;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 127) << 14;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 127) << 21;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 15) << 28;
  for (let readBytes = 5; (b & 128) !== 0 && readBytes < 10; readBytes++)
    b = this.buf[this.pos++];
  if ((b & 128) != 0)
    throw new Error("invalid varint");
  this.assertBounds();
  return result >>> 0;
}

// node_modules/@protobuf-ts/runtime/build/es2015/pb-long.js
var BI;
function detectBi() {
  const dv = new DataView(new ArrayBuffer(8));
  const ok = globalThis.BigInt !== void 0 && typeof dv.getBigInt64 === "function" && typeof dv.getBigUint64 === "function" && typeof dv.setBigInt64 === "function" && typeof dv.setBigUint64 === "function";
  BI = ok ? {
    MIN: BigInt("-9223372036854775808"),
    MAX: BigInt("9223372036854775807"),
    UMIN: BigInt("0"),
    UMAX: BigInt("18446744073709551615"),
    C: BigInt,
    V: dv
  } : void 0;
}
detectBi();
function assertBi(bi) {
  if (!bi)
    throw new Error("BigInt unavailable, see https://github.com/timostamm/protobuf-ts/blob/v1.0.8/MANUAL.md#bigint-support");
}
var RE_DECIMAL_STR = /^-?[0-9]+$/;
var TWO_PWR_32_DBL2 = 4294967296;
var HALF_2_PWR_32 = 2147483648;
var SharedPbLong = class {
  /**
   * Create a new instance with the given bits.
   */
  constructor(lo, hi) {
    this.lo = lo | 0;
    this.hi = hi | 0;
  }
  /**
   * Is this instance equal to 0?
   */
  isZero() {
    return this.lo == 0 && this.hi == 0;
  }
  /**
   * Convert to a native number.
   */
  toNumber() {
    let result = this.hi * TWO_PWR_32_DBL2 + (this.lo >>> 0);
    if (!Number.isSafeInteger(result))
      throw new Error("cannot convert to safe number");
    return result;
  }
};
var PbULong = class _PbULong extends SharedPbLong {
  /**
   * Create instance from a `string`, `number` or `bigint`.
   */
  static from(value) {
    if (BI)
      switch (typeof value) {
        case "string":
          if (value == "0")
            return this.ZERO;
          if (value == "")
            throw new Error("string is no integer");
          value = BI.C(value);
        case "number":
          if (value === 0)
            return this.ZERO;
          value = BI.C(value);
        case "bigint":
          if (!value)
            return this.ZERO;
          if (value < BI.UMIN)
            throw new Error("signed value for ulong");
          if (value > BI.UMAX)
            throw new Error("ulong too large");
          BI.V.setBigUint64(0, value, true);
          return new _PbULong(BI.V.getInt32(0, true), BI.V.getInt32(4, true));
      }
    else
      switch (typeof value) {
        case "string":
          if (value == "0")
            return this.ZERO;
          value = value.trim();
          if (!RE_DECIMAL_STR.test(value))
            throw new Error("string is no integer");
          let [minus, lo, hi] = int64fromString(value);
          if (minus)
            throw new Error("signed value for ulong");
          return new _PbULong(lo, hi);
        case "number":
          if (value == 0)
            return this.ZERO;
          if (!Number.isSafeInteger(value))
            throw new Error("number is no integer");
          if (value < 0)
            throw new Error("signed value for ulong");
          return new _PbULong(value, value / TWO_PWR_32_DBL2);
      }
    throw new Error("unknown value " + typeof value);
  }
  /**
   * Convert to decimal string.
   */
  toString() {
    return BI ? this.toBigInt().toString() : int64toString(this.lo, this.hi);
  }
  /**
   * Convert to native bigint.
   */
  toBigInt() {
    assertBi(BI);
    BI.V.setInt32(0, this.lo, true);
    BI.V.setInt32(4, this.hi, true);
    return BI.V.getBigUint64(0, true);
  }
};
PbULong.ZERO = new PbULong(0, 0);
var PbLong = class _PbLong extends SharedPbLong {
  /**
   * Create instance from a `string`, `number` or `bigint`.
   */
  static from(value) {
    if (BI)
      switch (typeof value) {
        case "string":
          if (value == "0")
            return this.ZERO;
          if (value == "")
            throw new Error("string is no integer");
          value = BI.C(value);
        case "number":
          if (value === 0)
            return this.ZERO;
          value = BI.C(value);
        case "bigint":
          if (!value)
            return this.ZERO;
          if (value < BI.MIN)
            throw new Error("signed long too small");
          if (value > BI.MAX)
            throw new Error("signed long too large");
          BI.V.setBigInt64(0, value, true);
          return new _PbLong(BI.V.getInt32(0, true), BI.V.getInt32(4, true));
      }
    else
      switch (typeof value) {
        case "string":
          if (value == "0")
            return this.ZERO;
          value = value.trim();
          if (!RE_DECIMAL_STR.test(value))
            throw new Error("string is no integer");
          let [minus, lo, hi] = int64fromString(value);
          if (minus) {
            if (hi > HALF_2_PWR_32 || hi == HALF_2_PWR_32 && lo != 0)
              throw new Error("signed long too small");
          } else if (hi >= HALF_2_PWR_32)
            throw new Error("signed long too large");
          let pbl = new _PbLong(lo, hi);
          return minus ? pbl.negate() : pbl;
        case "number":
          if (value == 0)
            return this.ZERO;
          if (!Number.isSafeInteger(value))
            throw new Error("number is no integer");
          return value > 0 ? new _PbLong(value, value / TWO_PWR_32_DBL2) : new _PbLong(-value, -value / TWO_PWR_32_DBL2).negate();
      }
    throw new Error("unknown value " + typeof value);
  }
  /**
   * Do we have a minus sign?
   */
  isNegative() {
    return (this.hi & HALF_2_PWR_32) !== 0;
  }
  /**
   * Negate two's complement.
   * Invert all the bits and add one to the result.
   */
  negate() {
    let hi = ~this.hi, lo = this.lo;
    if (lo)
      lo = ~lo + 1;
    else
      hi += 1;
    return new _PbLong(lo, hi);
  }
  /**
   * Convert to decimal string.
   */
  toString() {
    if (BI)
      return this.toBigInt().toString();
    if (this.isNegative()) {
      let n = this.negate();
      return "-" + int64toString(n.lo, n.hi);
    }
    return int64toString(this.lo, this.hi);
  }
  /**
   * Convert to native bigint.
   */
  toBigInt() {
    assertBi(BI);
    BI.V.setInt32(0, this.lo, true);
    BI.V.setInt32(4, this.hi, true);
    return BI.V.getBigInt64(0, true);
  }
};
PbLong.ZERO = new PbLong(0, 0);

// node_modules/@protobuf-ts/runtime/build/es2015/binary-reader.js
var defaultsRead = {
  readUnknownField: true,
  readerFactory: (bytes) => new BinaryReader(bytes)
};
function binaryReadOptions(options) {
  return options ? Object.assign(Object.assign({}, defaultsRead), options) : defaultsRead;
}
var BinaryReader = class {
  constructor(buf, textDecoder) {
    this.varint64 = varint64read;
    this.uint32 = varint32read;
    this.buf = buf;
    this.len = buf.length;
    this.pos = 0;
    this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    this.textDecoder = textDecoder !== null && textDecoder !== void 0 ? textDecoder : new TextDecoder("utf-8", {
      fatal: true,
      ignoreBOM: true
    });
  }
  /**
   * Reads a tag - field number and wire type.
   */
  tag() {
    let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;
    if (fieldNo <= 0 || wireType < 0 || wireType > 5)
      throw new Error("illegal tag: field no " + fieldNo + " wire type " + wireType);
    return [fieldNo, wireType];
  }
  /**
   * Skip one element on the wire and return the skipped data.
   * Supports WireType.StartGroup since v2.0.0-alpha.23.
   */
  skip(wireType) {
    let start = this.pos;
    switch (wireType) {
      case WireType.Varint:
        while (this.buf[this.pos++] & 128) {
        }
        break;
      case WireType.Bit64:
        this.pos += 4;
      case WireType.Bit32:
        this.pos += 4;
        break;
      case WireType.LengthDelimited:
        let len = this.uint32();
        this.pos += len;
        break;
      case WireType.StartGroup:
        let t2;
        while ((t2 = this.tag()[1]) !== WireType.EndGroup) {
          this.skip(t2);
        }
        break;
      default:
        throw new Error("cant skip wire type " + wireType);
    }
    this.assertBounds();
    return this.buf.subarray(start, this.pos);
  }
  /**
   * Throws error if position in byte array is out of range.
   */
  assertBounds() {
    if (this.pos > this.len)
      throw new RangeError("premature EOF");
  }
  /**
   * Read a `int32` field, a signed 32 bit varint.
   */
  int32() {
    return this.uint32() | 0;
  }
  /**
   * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
   */
  sint32() {
    let zze = this.uint32();
    return zze >>> 1 ^ -(zze & 1);
  }
  /**
   * Read a `int64` field, a signed 64-bit varint.
   */
  int64() {
    return new PbLong(...this.varint64());
  }
  /**
   * Read a `uint64` field, an unsigned 64-bit varint.
   */
  uint64() {
    return new PbULong(...this.varint64());
  }
  /**
   * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64() {
    let [lo, hi] = this.varint64();
    let s = -(lo & 1);
    lo = (lo >>> 1 | (hi & 1) << 31) ^ s;
    hi = hi >>> 1 ^ s;
    return new PbLong(lo, hi);
  }
  /**
   * Read a `bool` field, a variant.
   */
  bool() {
    let [lo, hi] = this.varint64();
    return lo !== 0 || hi !== 0;
  }
  /**
   * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
   */
  fixed32() {
    return this.view.getUint32((this.pos += 4) - 4, true);
  }
  /**
   * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
   */
  sfixed32() {
    return this.view.getInt32((this.pos += 4) - 4, true);
  }
  /**
   * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
   */
  fixed64() {
    return new PbULong(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
   */
  sfixed64() {
    return new PbLong(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `float` field, 32-bit floating point number.
   */
  float() {
    return this.view.getFloat32((this.pos += 4) - 4, true);
  }
  /**
   * Read a `double` field, a 64-bit floating point number.
   */
  double() {
    return this.view.getFloat64((this.pos += 8) - 8, true);
  }
  /**
   * Read a `bytes` field, length-delimited arbitrary data.
   */
  bytes() {
    let len = this.uint32();
    let start = this.pos;
    this.pos += len;
    this.assertBounds();
    return this.buf.subarray(start, start + len);
  }
  /**
   * Read a `string` field, length-delimited data converted to UTF-8 text.
   */
  string() {
    return this.textDecoder.decode(this.bytes());
  }
};

// node_modules/@protobuf-ts/runtime/build/es2015/assert.js
function assert(condition, msg) {
  if (!condition) {
    throw new Error(msg);
  }
}
function assertNever(value, msg) {
  throw new Error(msg !== null && msg !== void 0 ? msg : "Unexpected object: " + value);
}
var FLOAT32_MAX = 34028234663852886e22;
var FLOAT32_MIN = -34028234663852886e22;
var UINT32_MAX = 4294967295;
var INT32_MAX = 2147483647;
var INT32_MIN = -2147483648;
function assertInt32(arg) {
  if (typeof arg !== "number")
    throw new Error("invalid int 32: " + typeof arg);
  if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN)
    throw new Error("invalid int 32: " + arg);
}
function assertUInt32(arg) {
  if (typeof arg !== "number")
    throw new Error("invalid uint 32: " + typeof arg);
  if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0)
    throw new Error("invalid uint 32: " + arg);
}
function assertFloat32(arg) {
  if (typeof arg !== "number")
    throw new Error("invalid float 32: " + typeof arg);
  if (!Number.isFinite(arg))
    return;
  if (arg > FLOAT32_MAX || arg < FLOAT32_MIN)
    throw new Error("invalid float 32: " + arg);
}

// node_modules/@protobuf-ts/runtime/build/es2015/binary-writer.js
var defaultsWrite = {
  writeUnknownFields: true,
  writerFactory: () => new BinaryWriter()
};
function binaryWriteOptions(options) {
  return options ? Object.assign(Object.assign({}, defaultsWrite), options) : defaultsWrite;
}
var BinaryWriter = class {
  constructor(textEncoder) {
    this.stack = [];
    this.textEncoder = textEncoder !== null && textEncoder !== void 0 ? textEncoder : new TextEncoder();
    this.chunks = [];
    this.buf = [];
  }
  /**
   * Return all bytes written and reset this writer.
   */
  finish() {
    this.chunks.push(new Uint8Array(this.buf));
    let len = 0;
    for (let i = 0; i < this.chunks.length; i++)
      len += this.chunks[i].length;
    let bytes = new Uint8Array(len);
    let offset4 = 0;
    for (let i = 0; i < this.chunks.length; i++) {
      bytes.set(this.chunks[i], offset4);
      offset4 += this.chunks[i].length;
    }
    this.chunks = [];
    return bytes;
  }
  /**
   * Start a new fork for length-delimited data like a message
   * or a packed repeated field.
   *
   * Must be joined later with `join()`.
   */
  fork() {
    this.stack.push({ chunks: this.chunks, buf: this.buf });
    this.chunks = [];
    this.buf = [];
    return this;
  }
  /**
   * Join the last fork. Write its length and bytes, then
   * return to the previous state.
   */
  join() {
    let chunk2 = this.finish();
    let prev = this.stack.pop();
    if (!prev)
      throw new Error("invalid state, fork stack empty");
    this.chunks = prev.chunks;
    this.buf = prev.buf;
    this.uint32(chunk2.byteLength);
    return this.raw(chunk2);
  }
  /**
   * Writes a tag (field number and wire type).
   *
   * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
   *
   * Generated code should compute the tag ahead of time and call `uint32()`.
   */
  tag(fieldNo, type) {
    return this.uint32((fieldNo << 3 | type) >>> 0);
  }
  /**
   * Write a chunk of raw bytes.
   */
  raw(chunk2) {
    if (this.buf.length) {
      this.chunks.push(new Uint8Array(this.buf));
      this.buf = [];
    }
    this.chunks.push(chunk2);
    return this;
  }
  /**
   * Write a `uint32` value, an unsigned 32 bit varint.
   */
  uint32(value) {
    assertUInt32(value);
    while (value > 127) {
      this.buf.push(value & 127 | 128);
      value = value >>> 7;
    }
    this.buf.push(value);
    return this;
  }
  /**
   * Write a `int32` value, a signed 32 bit varint.
   */
  int32(value) {
    assertInt32(value);
    varint32write(value, this.buf);
    return this;
  }
  /**
   * Write a `bool` value, a variant.
   */
  bool(value) {
    this.buf.push(value ? 1 : 0);
    return this;
  }
  /**
   * Write a `bytes` value, length-delimited arbitrary data.
   */
  bytes(value) {
    this.uint32(value.byteLength);
    return this.raw(value);
  }
  /**
   * Write a `string` value, length-delimited data converted to UTF-8 text.
   */
  string(value) {
    let chunk2 = this.textEncoder.encode(value);
    this.uint32(chunk2.byteLength);
    return this.raw(chunk2);
  }
  /**
   * Write a `float` value, 32-bit floating point number.
   */
  float(value) {
    assertFloat32(value);
    let chunk2 = new Uint8Array(4);
    new DataView(chunk2.buffer).setFloat32(0, value, true);
    return this.raw(chunk2);
  }
  /**
   * Write a `double` value, a 64-bit floating point number.
   */
  double(value) {
    let chunk2 = new Uint8Array(8);
    new DataView(chunk2.buffer).setFloat64(0, value, true);
    return this.raw(chunk2);
  }
  /**
   * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
   */
  fixed32(value) {
    assertUInt32(value);
    let chunk2 = new Uint8Array(4);
    new DataView(chunk2.buffer).setUint32(0, value, true);
    return this.raw(chunk2);
  }
  /**
   * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
   */
  sfixed32(value) {
    assertInt32(value);
    let chunk2 = new Uint8Array(4);
    new DataView(chunk2.buffer).setInt32(0, value, true);
    return this.raw(chunk2);
  }
  /**
   * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
   */
  sint32(value) {
    assertInt32(value);
    value = (value << 1 ^ value >> 31) >>> 0;
    varint32write(value, this.buf);
    return this;
  }
  /**
   * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
   */
  sfixed64(value) {
    let chunk2 = new Uint8Array(8);
    let view = new DataView(chunk2.buffer);
    let long = PbLong.from(value);
    view.setInt32(0, long.lo, true);
    view.setInt32(4, long.hi, true);
    return this.raw(chunk2);
  }
  /**
   * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
   */
  fixed64(value) {
    let chunk2 = new Uint8Array(8);
    let view = new DataView(chunk2.buffer);
    let long = PbULong.from(value);
    view.setInt32(0, long.lo, true);
    view.setInt32(4, long.hi, true);
    return this.raw(chunk2);
  }
  /**
   * Write a `int64` value, a signed 64-bit varint.
   */
  int64(value) {
    let long = PbLong.from(value);
    varint64write(long.lo, long.hi, this.buf);
    return this;
  }
  /**
   * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64(value) {
    let long = PbLong.from(value), sign = long.hi >> 31, lo = long.lo << 1 ^ sign, hi = (long.hi << 1 | long.lo >>> 31) ^ sign;
    varint64write(lo, hi, this.buf);
    return this;
  }
  /**
   * Write a `uint64` value, an unsigned 64-bit varint.
   */
  uint64(value) {
    let long = PbULong.from(value);
    varint64write(long.lo, long.hi, this.buf);
    return this;
  }
};

// node_modules/@protobuf-ts/runtime/build/es2015/json-format-contract.js
var defaultsWrite2 = {
  emitDefaultValues: false,
  enumAsInteger: false,
  useProtoFieldName: false,
  prettySpaces: 0
};
var defaultsRead2 = {
  ignoreUnknownFields: false
};
function jsonReadOptions(options) {
  return options ? Object.assign(Object.assign({}, defaultsRead2), options) : defaultsRead2;
}
function jsonWriteOptions(options) {
  return options ? Object.assign(Object.assign({}, defaultsWrite2), options) : defaultsWrite2;
}
function mergeJsonOptions(a, b) {
  var _a, _b;
  let c = Object.assign(Object.assign({}, a), b);
  c.typeRegistry = [...(_a = a === null || a === void 0 ? void 0 : a.typeRegistry) !== null && _a !== void 0 ? _a : [], ...(_b = b === null || b === void 0 ? void 0 : b.typeRegistry) !== null && _b !== void 0 ? _b : []];
  return c;
}

// node_modules/@protobuf-ts/runtime/build/es2015/message-type-contract.js
var MESSAGE_TYPE = Symbol.for("protobuf-ts/message-type");

// node_modules/@protobuf-ts/runtime/build/es2015/lower-camel-case.js
function lowerCamelCase(snakeCase) {
  let capNext = false;
  const sb = [];
  for (let i = 0; i < snakeCase.length; i++) {
    let next = snakeCase.charAt(i);
    if (next == "_") {
      capNext = true;
    } else if (/\d/.test(next)) {
      sb.push(next);
      capNext = true;
    } else if (capNext) {
      sb.push(next.toUpperCase());
      capNext = false;
    } else if (i == 0) {
      sb.push(next.toLowerCase());
    } else {
      sb.push(next);
    }
  }
  return sb.join("");
}

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-info.js
var ScalarType;
(function(ScalarType2) {
  ScalarType2[ScalarType2["DOUBLE"] = 1] = "DOUBLE";
  ScalarType2[ScalarType2["FLOAT"] = 2] = "FLOAT";
  ScalarType2[ScalarType2["INT64"] = 3] = "INT64";
  ScalarType2[ScalarType2["UINT64"] = 4] = "UINT64";
  ScalarType2[ScalarType2["INT32"] = 5] = "INT32";
  ScalarType2[ScalarType2["FIXED64"] = 6] = "FIXED64";
  ScalarType2[ScalarType2["FIXED32"] = 7] = "FIXED32";
  ScalarType2[ScalarType2["BOOL"] = 8] = "BOOL";
  ScalarType2[ScalarType2["STRING"] = 9] = "STRING";
  ScalarType2[ScalarType2["BYTES"] = 12] = "BYTES";
  ScalarType2[ScalarType2["UINT32"] = 13] = "UINT32";
  ScalarType2[ScalarType2["SFIXED32"] = 15] = "SFIXED32";
  ScalarType2[ScalarType2["SFIXED64"] = 16] = "SFIXED64";
  ScalarType2[ScalarType2["SINT32"] = 17] = "SINT32";
  ScalarType2[ScalarType2["SINT64"] = 18] = "SINT64";
})(ScalarType || (ScalarType = {}));
var LongType;
(function(LongType2) {
  LongType2[LongType2["BIGINT"] = 0] = "BIGINT";
  LongType2[LongType2["STRING"] = 1] = "STRING";
  LongType2[LongType2["NUMBER"] = 2] = "NUMBER";
})(LongType || (LongType = {}));
var RepeatType;
(function(RepeatType2) {
  RepeatType2[RepeatType2["NO"] = 0] = "NO";
  RepeatType2[RepeatType2["PACKED"] = 1] = "PACKED";
  RepeatType2[RepeatType2["UNPACKED"] = 2] = "UNPACKED";
})(RepeatType || (RepeatType = {}));
function normalizeFieldInfo(field) {
  var _a, _b, _c, _d;
  field.localName = (_a = field.localName) !== null && _a !== void 0 ? _a : lowerCamelCase(field.name);
  field.jsonName = (_b = field.jsonName) !== null && _b !== void 0 ? _b : lowerCamelCase(field.name);
  field.repeat = (_c = field.repeat) !== null && _c !== void 0 ? _c : RepeatType.NO;
  field.opt = (_d = field.opt) !== null && _d !== void 0 ? _d : field.repeat ? false : field.oneof ? false : field.kind == "message";
  return field;
}

// node_modules/@protobuf-ts/runtime/build/es2015/oneof.js
function isOneofGroup(any) {
  if (typeof any != "object" || any === null || !any.hasOwnProperty("oneofKind")) {
    return false;
  }
  switch (typeof any.oneofKind) {
    case "string":
      if (any[any.oneofKind] === void 0)
        return false;
      return Object.keys(any).length == 2;
    case "undefined":
      return Object.keys(any).length == 1;
    default:
      return false;
  }
}

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-type-check.js
var ReflectionTypeCheck = class {
  constructor(info) {
    var _a;
    this.fields = (_a = info.fields) !== null && _a !== void 0 ? _a : [];
  }
  prepare() {
    if (this.data)
      return;
    const req = [], known = [], oneofs = [];
    for (let field of this.fields) {
      if (field.oneof) {
        if (!oneofs.includes(field.oneof)) {
          oneofs.push(field.oneof);
          req.push(field.oneof);
          known.push(field.oneof);
        }
      } else {
        known.push(field.localName);
        switch (field.kind) {
          case "scalar":
          case "enum":
            if (!field.opt || field.repeat)
              req.push(field.localName);
            break;
          case "message":
            if (field.repeat)
              req.push(field.localName);
            break;
          case "map":
            req.push(field.localName);
            break;
        }
      }
    }
    this.data = { req, known, oneofs: Object.values(oneofs) };
  }
  /**
   * Is the argument a valid message as specified by the
   * reflection information?
   *
   * Checks all field types recursively. The `depth`
   * specifies how deep into the structure the check will be.
   *
   * With a depth of 0, only the presence of fields
   * is checked.
   *
   * With a depth of 1 or more, the field types are checked.
   *
   * With a depth of 2 or more, the members of map, repeated
   * and message fields are checked.
   *
   * Message fields will be checked recursively with depth - 1.
   *
   * The number of map entries / repeated values being checked
   * is < depth.
   */
  is(message, depth, allowExcessProperties = false) {
    if (depth < 0)
      return true;
    if (message === null || message === void 0 || typeof message != "object")
      return false;
    this.prepare();
    let keys = Object.keys(message), data = this.data;
    if (keys.length < data.req.length || data.req.some((n) => !keys.includes(n)))
      return false;
    if (!allowExcessProperties) {
      if (keys.some((k) => !data.known.includes(k)))
        return false;
    }
    if (depth < 1) {
      return true;
    }
    for (const name2 of data.oneofs) {
      const group = message[name2];
      if (!isOneofGroup(group))
        return false;
      if (group.oneofKind === void 0)
        continue;
      const field = this.fields.find((f) => f.localName === group.oneofKind);
      if (!field)
        return false;
      if (!this.field(group[group.oneofKind], field, allowExcessProperties, depth))
        return false;
    }
    for (const field of this.fields) {
      if (field.oneof !== void 0)
        continue;
      if (!this.field(message[field.localName], field, allowExcessProperties, depth))
        return false;
    }
    return true;
  }
  field(arg, field, allowExcessProperties, depth) {
    let repeated = field.repeat;
    switch (field.kind) {
      case "scalar":
        if (arg === void 0)
          return field.opt;
        if (repeated)
          return this.scalars(arg, field.T, depth, field.L);
        return this.scalar(arg, field.T, field.L);
      case "enum":
        if (arg === void 0)
          return field.opt;
        if (repeated)
          return this.scalars(arg, ScalarType.INT32, depth);
        return this.scalar(arg, ScalarType.INT32);
      case "message":
        if (arg === void 0)
          return true;
        if (repeated)
          return this.messages(arg, field.T(), allowExcessProperties, depth);
        return this.message(arg, field.T(), allowExcessProperties, depth);
      case "map":
        if (typeof arg != "object" || arg === null)
          return false;
        if (depth < 2)
          return true;
        if (!this.mapKeys(arg, field.K, depth))
          return false;
        switch (field.V.kind) {
          case "scalar":
            return this.scalars(Object.values(arg), field.V.T, depth, field.V.L);
          case "enum":
            return this.scalars(Object.values(arg), ScalarType.INT32, depth);
          case "message":
            return this.messages(Object.values(arg), field.V.T(), allowExcessProperties, depth);
        }
        break;
    }
    return true;
  }
  message(arg, type, allowExcessProperties, depth) {
    if (allowExcessProperties) {
      return type.isAssignable(arg, depth);
    }
    return type.is(arg, depth);
  }
  messages(arg, type, allowExcessProperties, depth) {
    if (!Array.isArray(arg))
      return false;
    if (depth < 2)
      return true;
    if (allowExcessProperties) {
      for (let i = 0; i < arg.length && i < depth; i++)
        if (!type.isAssignable(arg[i], depth - 1))
          return false;
    } else {
      for (let i = 0; i < arg.length && i < depth; i++)
        if (!type.is(arg[i], depth - 1))
          return false;
    }
    return true;
  }
  scalar(arg, type, longType) {
    let argType = typeof arg;
    switch (type) {
      case ScalarType.UINT64:
      case ScalarType.FIXED64:
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        switch (longType) {
          case LongType.BIGINT:
            return argType == "bigint";
          case LongType.NUMBER:
            return argType == "number" && !isNaN(arg);
          default:
            return argType == "string";
        }
      case ScalarType.BOOL:
        return argType == "boolean";
      case ScalarType.STRING:
        return argType == "string";
      case ScalarType.BYTES:
        return arg instanceof Uint8Array;
      case ScalarType.DOUBLE:
      case ScalarType.FLOAT:
        return argType == "number" && !isNaN(arg);
      default:
        return argType == "number" && Number.isInteger(arg);
    }
  }
  scalars(arg, type, depth, longType) {
    if (!Array.isArray(arg))
      return false;
    if (depth < 2)
      return true;
    if (Array.isArray(arg)) {
      for (let i = 0; i < arg.length && i < depth; i++)
        if (!this.scalar(arg[i], type, longType))
          return false;
    }
    return true;
  }
  mapKeys(map2, type, depth) {
    let keys = Object.keys(map2);
    switch (type) {
      case ScalarType.INT32:
      case ScalarType.FIXED32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
      case ScalarType.UINT32:
        return this.scalars(keys.slice(0, depth).map((k) => parseInt(k)), type, depth);
      case ScalarType.BOOL:
        return this.scalars(keys.slice(0, depth).map((k) => k == "true" ? true : k == "false" ? false : k), type, depth);
      default:
        return this.scalars(keys, type, depth, LongType.STRING);
    }
  }
};

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-long-convert.js
function reflectionLongConvert(long, type) {
  switch (type) {
    case LongType.BIGINT:
      return long.toBigInt();
    case LongType.NUMBER:
      return long.toNumber();
    default:
      return long.toString();
  }
}

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-json-reader.js
var ReflectionJsonReader = class {
  constructor(info) {
    this.info = info;
  }
  prepare() {
    var _a;
    if (this.fMap === void 0) {
      this.fMap = {};
      const fieldsInput = (_a = this.info.fields) !== null && _a !== void 0 ? _a : [];
      for (const field of fieldsInput) {
        this.fMap[field.name] = field;
        this.fMap[field.jsonName] = field;
        this.fMap[field.localName] = field;
      }
    }
  }
  // Cannot parse JSON <type of jsonValue> for <type name>#<fieldName>.
  assert(condition, fieldName, jsonValue) {
    if (!condition) {
      let what = typeofJsonValue(jsonValue);
      if (what == "number" || what == "boolean")
        what = jsonValue.toString();
      throw new Error(`Cannot parse JSON ${what} for ${this.info.typeName}#${fieldName}`);
    }
  }
  /**
   * Reads a message from canonical JSON format into the target message.
   *
   * Repeated fields are appended. Map entries are added, overwriting
   * existing keys.
   *
   * If a message field is already present, it will be merged with the
   * new data.
   */
  read(input, message, options) {
    this.prepare();
    const oneofsHandled = [];
    for (const [jsonKey, jsonValue] of Object.entries(input)) {
      const field = this.fMap[jsonKey];
      if (!field) {
        if (!options.ignoreUnknownFields)
          throw new Error(`Found unknown field while reading ${this.info.typeName} from JSON format. JSON key: ${jsonKey}`);
        continue;
      }
      const localName = field.localName;
      let target;
      if (field.oneof) {
        if (jsonValue === null && (field.kind !== "enum" || field.T()[0] !== "google.protobuf.NullValue")) {
          continue;
        }
        if (oneofsHandled.includes(field.oneof))
          throw new Error(`Multiple members of the oneof group "${field.oneof}" of ${this.info.typeName} are present in JSON.`);
        oneofsHandled.push(field.oneof);
        target = message[field.oneof] = {
          oneofKind: localName
        };
      } else {
        target = message;
      }
      if (field.kind == "map") {
        if (jsonValue === null) {
          continue;
        }
        this.assert(isJsonObject(jsonValue), field.name, jsonValue);
        const fieldObj = target[localName];
        for (const [jsonObjKey, jsonObjValue] of Object.entries(jsonValue)) {
          this.assert(jsonObjValue !== null, field.name + " map value", null);
          let val;
          switch (field.V.kind) {
            case "message":
              val = field.V.T().internalJsonRead(jsonObjValue, options);
              break;
            case "enum":
              val = this.enum(field.V.T(), jsonObjValue, field.name, options.ignoreUnknownFields);
              if (val === false)
                continue;
              break;
            case "scalar":
              val = this.scalar(jsonObjValue, field.V.T, field.V.L, field.name);
              break;
          }
          this.assert(val !== void 0, field.name + " map value", jsonObjValue);
          let key = jsonObjKey;
          if (field.K == ScalarType.BOOL)
            key = key == "true" ? true : key == "false" ? false : key;
          key = this.scalar(key, field.K, LongType.STRING, field.name).toString();
          fieldObj[key] = val;
        }
      } else if (field.repeat) {
        if (jsonValue === null)
          continue;
        this.assert(Array.isArray(jsonValue), field.name, jsonValue);
        const fieldArr = target[localName];
        for (const jsonItem of jsonValue) {
          this.assert(jsonItem !== null, field.name, null);
          let val;
          switch (field.kind) {
            case "message":
              val = field.T().internalJsonRead(jsonItem, options);
              break;
            case "enum":
              val = this.enum(field.T(), jsonItem, field.name, options.ignoreUnknownFields);
              if (val === false)
                continue;
              break;
            case "scalar":
              val = this.scalar(jsonItem, field.T, field.L, field.name);
              break;
          }
          this.assert(val !== void 0, field.name, jsonValue);
          fieldArr.push(val);
        }
      } else {
        switch (field.kind) {
          case "message":
            if (jsonValue === null && field.T().typeName != "google.protobuf.Value") {
              this.assert(field.oneof === void 0, field.name + " (oneof member)", null);
              continue;
            }
            target[localName] = field.T().internalJsonRead(jsonValue, options, target[localName]);
            break;
          case "enum":
            if (jsonValue === null)
              continue;
            let val = this.enum(field.T(), jsonValue, field.name, options.ignoreUnknownFields);
            if (val === false)
              continue;
            target[localName] = val;
            break;
          case "scalar":
            if (jsonValue === null)
              continue;
            target[localName] = this.scalar(jsonValue, field.T, field.L, field.name);
            break;
        }
      }
    }
  }
  /**
   * Returns `false` for unrecognized string representations.
   *
   * google.protobuf.NullValue accepts only JSON `null` (or the old `"NULL_VALUE"`).
   */
  enum(type, json, fieldName, ignoreUnknownFields) {
    if (type[0] == "google.protobuf.NullValue")
      assert(json === null || json === "NULL_VALUE", `Unable to parse field ${this.info.typeName}#${fieldName}, enum ${type[0]} only accepts null.`);
    if (json === null)
      return 0;
    switch (typeof json) {
      case "number":
        assert(Number.isInteger(json), `Unable to parse field ${this.info.typeName}#${fieldName}, enum can only be integral number, got ${json}.`);
        return json;
      case "string":
        let localEnumName = json;
        if (type[2] && json.substring(0, type[2].length) === type[2])
          localEnumName = json.substring(type[2].length);
        let enumNumber = type[1][localEnumName];
        if (typeof enumNumber === "undefined" && ignoreUnknownFields) {
          return false;
        }
        assert(typeof enumNumber == "number", `Unable to parse field ${this.info.typeName}#${fieldName}, enum ${type[0]} has no value for "${json}".`);
        return enumNumber;
    }
    assert(false, `Unable to parse field ${this.info.typeName}#${fieldName}, cannot parse enum value from ${typeof json}".`);
  }
  scalar(json, type, longType, fieldName) {
    let e;
    try {
      switch (type) {
        // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
        // Either numbers or strings are accepted. Exponent notation is also accepted.
        case ScalarType.DOUBLE:
        case ScalarType.FLOAT:
          if (json === null)
            return 0;
          if (json === "NaN")
            return Number.NaN;
          if (json === "Infinity")
            return Number.POSITIVE_INFINITY;
          if (json === "-Infinity")
            return Number.NEGATIVE_INFINITY;
          if (json === "") {
            e = "empty string";
            break;
          }
          if (typeof json == "string" && json.trim().length !== json.length) {
            e = "extra whitespace";
            break;
          }
          if (typeof json != "string" && typeof json != "number") {
            break;
          }
          let float = Number(json);
          if (Number.isNaN(float)) {
            e = "not a number";
            break;
          }
          if (!Number.isFinite(float)) {
            e = "too large or small";
            break;
          }
          if (type == ScalarType.FLOAT)
            assertFloat32(float);
          return float;
        // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
        case ScalarType.INT32:
        case ScalarType.FIXED32:
        case ScalarType.SFIXED32:
        case ScalarType.SINT32:
        case ScalarType.UINT32:
          if (json === null)
            return 0;
          let int32;
          if (typeof json == "number")
            int32 = json;
          else if (json === "")
            e = "empty string";
          else if (typeof json == "string") {
            if (json.trim().length !== json.length)
              e = "extra whitespace";
            else
              int32 = Number(json);
          }
          if (int32 === void 0)
            break;
          if (type == ScalarType.UINT32)
            assertUInt32(int32);
          else
            assertInt32(int32);
          return int32;
        // int64, fixed64, uint64: JSON value will be a decimal string. Either numbers or strings are accepted.
        case ScalarType.INT64:
        case ScalarType.SFIXED64:
        case ScalarType.SINT64:
          if (json === null)
            return reflectionLongConvert(PbLong.ZERO, longType);
          if (typeof json != "number" && typeof json != "string")
            break;
          return reflectionLongConvert(PbLong.from(json), longType);
        case ScalarType.FIXED64:
        case ScalarType.UINT64:
          if (json === null)
            return reflectionLongConvert(PbULong.ZERO, longType);
          if (typeof json != "number" && typeof json != "string")
            break;
          return reflectionLongConvert(PbULong.from(json), longType);
        // bool:
        case ScalarType.BOOL:
          if (json === null)
            return false;
          if (typeof json !== "boolean")
            break;
          return json;
        // string:
        case ScalarType.STRING:
          if (json === null)
            return "";
          if (typeof json !== "string") {
            e = "extra whitespace";
            break;
          }
          try {
            encodeURIComponent(json);
          } catch (e2) {
            e2 = "invalid UTF8";
            break;
          }
          return json;
        // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
        // Either standard or URL-safe base64 encoding with/without paddings are accepted.
        case ScalarType.BYTES:
          if (json === null || json === "")
            return new Uint8Array(0);
          if (typeof json !== "string")
            break;
          return base64decode(json);
      }
    } catch (error2) {
      e = error2.message;
    }
    this.assert(false, fieldName + (e ? " - " + e : ""), json);
  }
};

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-json-writer.js
var ReflectionJsonWriter = class {
  constructor(info) {
    var _a;
    this.fields = (_a = info.fields) !== null && _a !== void 0 ? _a : [];
  }
  /**
   * Converts the message to a JSON object, based on the field descriptors.
   */
  write(message, options) {
    const json = {}, source = message;
    for (const field of this.fields) {
      if (!field.oneof) {
        let jsonValue2 = this.field(field, source[field.localName], options);
        if (jsonValue2 !== void 0)
          json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue2;
        continue;
      }
      const group = source[field.oneof];
      if (group.oneofKind !== field.localName)
        continue;
      const opt = field.kind == "scalar" || field.kind == "enum" ? Object.assign(Object.assign({}, options), { emitDefaultValues: true }) : options;
      let jsonValue = this.field(field, group[field.localName], opt);
      assert(jsonValue !== void 0);
      json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;
    }
    return json;
  }
  field(field, value, options) {
    let jsonValue = void 0;
    if (field.kind == "map") {
      assert(typeof value == "object" && value !== null);
      const jsonObj = {};
      switch (field.V.kind) {
        case "scalar":
          for (const [entryKey, entryValue] of Object.entries(value)) {
            const val = this.scalar(field.V.T, entryValue, field.name, false, true);
            assert(val !== void 0);
            jsonObj[entryKey.toString()] = val;
          }
          break;
        case "message":
          const messageType = field.V.T();
          for (const [entryKey, entryValue] of Object.entries(value)) {
            const val = this.message(messageType, entryValue, field.name, options);
            assert(val !== void 0);
            jsonObj[entryKey.toString()] = val;
          }
          break;
        case "enum":
          const enumInfo = field.V.T();
          for (const [entryKey, entryValue] of Object.entries(value)) {
            assert(entryValue === void 0 || typeof entryValue == "number");
            const val = this.enum(enumInfo, entryValue, field.name, false, true, options.enumAsInteger);
            assert(val !== void 0);
            jsonObj[entryKey.toString()] = val;
          }
          break;
      }
      if (options.emitDefaultValues || Object.keys(jsonObj).length > 0)
        jsonValue = jsonObj;
    } else if (field.repeat) {
      assert(Array.isArray(value));
      const jsonArr = [];
      switch (field.kind) {
        case "scalar":
          for (let i = 0; i < value.length; i++) {
            const val = this.scalar(field.T, value[i], field.name, field.opt, true);
            assert(val !== void 0);
            jsonArr.push(val);
          }
          break;
        case "enum":
          const enumInfo = field.T();
          for (let i = 0; i < value.length; i++) {
            assert(value[i] === void 0 || typeof value[i] == "number");
            const val = this.enum(enumInfo, value[i], field.name, field.opt, true, options.enumAsInteger);
            assert(val !== void 0);
            jsonArr.push(val);
          }
          break;
        case "message":
          const messageType = field.T();
          for (let i = 0; i < value.length; i++) {
            const val = this.message(messageType, value[i], field.name, options);
            assert(val !== void 0);
            jsonArr.push(val);
          }
          break;
      }
      if (options.emitDefaultValues || jsonArr.length > 0 || options.emitDefaultValues)
        jsonValue = jsonArr;
    } else {
      switch (field.kind) {
        case "scalar":
          jsonValue = this.scalar(field.T, value, field.name, field.opt, options.emitDefaultValues);
          break;
        case "enum":
          jsonValue = this.enum(field.T(), value, field.name, field.opt, options.emitDefaultValues, options.enumAsInteger);
          break;
        case "message":
          jsonValue = this.message(field.T(), value, field.name, options);
          break;
      }
    }
    return jsonValue;
  }
  /**
   * Returns `null` as the default for google.protobuf.NullValue.
   */
  enum(type, value, fieldName, optional, emitDefaultValues, enumAsInteger) {
    if (type[0] == "google.protobuf.NullValue")
      return !emitDefaultValues && !optional ? void 0 : null;
    if (value === void 0) {
      assert(optional);
      return void 0;
    }
    if (value === 0 && !emitDefaultValues && !optional)
      return void 0;
    assert(typeof value == "number");
    assert(Number.isInteger(value));
    if (enumAsInteger || !type[1].hasOwnProperty(value))
      return value;
    if (type[2])
      return type[2] + type[1][value];
    return type[1][value];
  }
  message(type, value, fieldName, options) {
    if (value === void 0)
      return options.emitDefaultValues ? null : void 0;
    return type.internalJsonWrite(value, options);
  }
  scalar(type, value, fieldName, optional, emitDefaultValues) {
    if (value === void 0) {
      assert(optional);
      return void 0;
    }
    const ed = emitDefaultValues || optional;
    switch (type) {
      // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
      case ScalarType.INT32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
        if (value === 0)
          return ed ? 0 : void 0;
        assertInt32(value);
        return value;
      case ScalarType.FIXED32:
      case ScalarType.UINT32:
        if (value === 0)
          return ed ? 0 : void 0;
        assertUInt32(value);
        return value;
      // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
      // Either numbers or strings are accepted. Exponent notation is also accepted.
      case ScalarType.FLOAT:
        assertFloat32(value);
      case ScalarType.DOUBLE:
        if (value === 0)
          return ed ? 0 : void 0;
        assert(typeof value == "number");
        if (Number.isNaN(value))
          return "NaN";
        if (value === Number.POSITIVE_INFINITY)
          return "Infinity";
        if (value === Number.NEGATIVE_INFINITY)
          return "-Infinity";
        return value;
      // string:
      case ScalarType.STRING:
        if (value === "")
          return ed ? "" : void 0;
        assert(typeof value == "string");
        return value;
      // bool:
      case ScalarType.BOOL:
        if (value === false)
          return ed ? false : void 0;
        assert(typeof value == "boolean");
        return value;
      // JSON value will be a decimal string. Either numbers or strings are accepted.
      case ScalarType.UINT64:
      case ScalarType.FIXED64:
        assert(typeof value == "number" || typeof value == "string" || typeof value == "bigint");
        let ulong = PbULong.from(value);
        if (ulong.isZero() && !ed)
          return void 0;
        return ulong.toString();
      // JSON value will be a decimal string. Either numbers or strings are accepted.
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        assert(typeof value == "number" || typeof value == "string" || typeof value == "bigint");
        let long = PbLong.from(value);
        if (long.isZero() && !ed)
          return void 0;
        return long.toString();
      // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
      // Either standard or URL-safe base64 encoding with/without paddings are accepted.
      case ScalarType.BYTES:
        assert(value instanceof Uint8Array);
        if (!value.byteLength)
          return ed ? "" : void 0;
        return base64encode(value);
    }
  }
};

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-scalar-default.js
function reflectionScalarDefault(type, longType = LongType.STRING) {
  switch (type) {
    case ScalarType.BOOL:
      return false;
    case ScalarType.UINT64:
    case ScalarType.FIXED64:
      return reflectionLongConvert(PbULong.ZERO, longType);
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      return reflectionLongConvert(PbLong.ZERO, longType);
    case ScalarType.DOUBLE:
    case ScalarType.FLOAT:
      return 0;
    case ScalarType.BYTES:
      return new Uint8Array(0);
    case ScalarType.STRING:
      return "";
    default:
      return 0;
  }
}

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-binary-reader.js
var ReflectionBinaryReader = class {
  constructor(info) {
    this.info = info;
  }
  prepare() {
    var _a;
    if (!this.fieldNoToField) {
      const fieldsInput = (_a = this.info.fields) !== null && _a !== void 0 ? _a : [];
      this.fieldNoToField = new Map(fieldsInput.map((field) => [field.no, field]));
    }
  }
  /**
   * Reads a message from binary format into the target message.
   *
   * Repeated fields are appended. Map entries are added, overwriting
   * existing keys.
   *
   * If a message field is already present, it will be merged with the
   * new data.
   */
  read(reader, message, options, length) {
    this.prepare();
    const end = length === void 0 ? reader.len : reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag(), field = this.fieldNoToField.get(fieldNo);
      if (!field) {
        let u = options.readUnknownField;
        if (u == "throw")
          throw new Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.info.typeName}`);
        let d = reader.skip(wireType);
        if (u !== false)
          (u === true ? UnknownFieldHandler.onRead : u)(this.info.typeName, message, fieldNo, wireType, d);
        continue;
      }
      let target = message, repeated = field.repeat, localName = field.localName;
      if (field.oneof) {
        target = target[field.oneof];
        if (target.oneofKind !== localName)
          target = message[field.oneof] = {
            oneofKind: localName
          };
      }
      switch (field.kind) {
        case "scalar":
        case "enum":
          let T = field.kind == "enum" ? ScalarType.INT32 : field.T;
          let L = field.kind == "scalar" ? field.L : void 0;
          if (repeated) {
            let arr = target[localName];
            if (wireType == WireType.LengthDelimited && T != ScalarType.STRING && T != ScalarType.BYTES) {
              let e = reader.uint32() + reader.pos;
              while (reader.pos < e)
                arr.push(this.scalar(reader, T, L));
            } else
              arr.push(this.scalar(reader, T, L));
          } else
            target[localName] = this.scalar(reader, T, L);
          break;
        case "message":
          if (repeated) {
            let arr = target[localName];
            let msg = field.T().internalBinaryRead(reader, reader.uint32(), options);
            arr.push(msg);
          } else
            target[localName] = field.T().internalBinaryRead(reader, reader.uint32(), options, target[localName]);
          break;
        case "map":
          let [mapKey, mapVal] = this.mapEntry(field, reader, options);
          target[localName][mapKey] = mapVal;
          break;
      }
    }
  }
  /**
   * Read a map field, expecting key field = 1, value field = 2
   */
  mapEntry(field, reader, options) {
    let length = reader.uint32();
    let end = reader.pos + length;
    let key = void 0;
    let val = void 0;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case 1:
          if (field.K == ScalarType.BOOL)
            key = reader.bool().toString();
          else
            key = this.scalar(reader, field.K, LongType.STRING);
          break;
        case 2:
          switch (field.V.kind) {
            case "scalar":
              val = this.scalar(reader, field.V.T, field.V.L);
              break;
            case "enum":
              val = reader.int32();
              break;
            case "message":
              val = field.V.T().internalBinaryRead(reader, reader.uint32(), options);
              break;
          }
          break;
        default:
          throw new Error(`Unknown field ${fieldNo} (wire type ${wireType}) in map entry for ${this.info.typeName}#${field.name}`);
      }
    }
    if (key === void 0) {
      let keyRaw = reflectionScalarDefault(field.K);
      key = field.K == ScalarType.BOOL ? keyRaw.toString() : keyRaw;
    }
    if (val === void 0)
      switch (field.V.kind) {
        case "scalar":
          val = reflectionScalarDefault(field.V.T, field.V.L);
          break;
        case "enum":
          val = 0;
          break;
        case "message":
          val = field.V.T().create();
          break;
      }
    return [key, val];
  }
  scalar(reader, type, longType) {
    switch (type) {
      case ScalarType.INT32:
        return reader.int32();
      case ScalarType.STRING:
        return reader.string();
      case ScalarType.BOOL:
        return reader.bool();
      case ScalarType.DOUBLE:
        return reader.double();
      case ScalarType.FLOAT:
        return reader.float();
      case ScalarType.INT64:
        return reflectionLongConvert(reader.int64(), longType);
      case ScalarType.UINT64:
        return reflectionLongConvert(reader.uint64(), longType);
      case ScalarType.FIXED64:
        return reflectionLongConvert(reader.fixed64(), longType);
      case ScalarType.FIXED32:
        return reader.fixed32();
      case ScalarType.BYTES:
        return reader.bytes();
      case ScalarType.UINT32:
        return reader.uint32();
      case ScalarType.SFIXED32:
        return reader.sfixed32();
      case ScalarType.SFIXED64:
        return reflectionLongConvert(reader.sfixed64(), longType);
      case ScalarType.SINT32:
        return reader.sint32();
      case ScalarType.SINT64:
        return reflectionLongConvert(reader.sint64(), longType);
    }
  }
};

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-binary-writer.js
var ReflectionBinaryWriter = class {
  constructor(info) {
    this.info = info;
  }
  prepare() {
    if (!this.fields) {
      const fieldsInput = this.info.fields ? this.info.fields.concat() : [];
      this.fields = fieldsInput.sort((a, b) => a.no - b.no);
    }
  }
  /**
   * Writes the message to binary format.
   */
  write(message, writer, options) {
    this.prepare();
    for (const field of this.fields) {
      let value, emitDefault, repeated = field.repeat, localName = field.localName;
      if (field.oneof) {
        const group = message[field.oneof];
        if (group.oneofKind !== localName)
          continue;
        value = group[localName];
        emitDefault = true;
      } else {
        value = message[localName];
        emitDefault = false;
      }
      switch (field.kind) {
        case "scalar":
        case "enum":
          let T = field.kind == "enum" ? ScalarType.INT32 : field.T;
          if (repeated) {
            assert(Array.isArray(value));
            if (repeated == RepeatType.PACKED)
              this.packed(writer, T, field.no, value);
            else
              for (const item of value)
                this.scalar(writer, T, field.no, item, true);
          } else if (value === void 0)
            assert(field.opt);
          else
            this.scalar(writer, T, field.no, value, emitDefault || field.opt);
          break;
        case "message":
          if (repeated) {
            assert(Array.isArray(value));
            for (const item of value)
              this.message(writer, options, field.T(), field.no, item);
          } else {
            this.message(writer, options, field.T(), field.no, value);
          }
          break;
        case "map":
          assert(typeof value == "object" && value !== null);
          for (const [key, val] of Object.entries(value))
            this.mapEntry(writer, options, field, key, val);
          break;
      }
    }
    let u = options.writeUnknownFields;
    if (u !== false)
      (u === true ? UnknownFieldHandler.onWrite : u)(this.info.typeName, message, writer);
  }
  mapEntry(writer, options, field, key, value) {
    writer.tag(field.no, WireType.LengthDelimited);
    writer.fork();
    let keyValue = key;
    switch (field.K) {
      case ScalarType.INT32:
      case ScalarType.FIXED32:
      case ScalarType.UINT32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
        keyValue = Number.parseInt(key);
        break;
      case ScalarType.BOOL:
        assert(key == "true" || key == "false");
        keyValue = key == "true";
        break;
    }
    this.scalar(writer, field.K, 1, keyValue, true);
    switch (field.V.kind) {
      case "scalar":
        this.scalar(writer, field.V.T, 2, value, true);
        break;
      case "enum":
        this.scalar(writer, ScalarType.INT32, 2, value, true);
        break;
      case "message":
        this.message(writer, options, field.V.T(), 2, value);
        break;
    }
    writer.join();
  }
  message(writer, options, handler, fieldNo, value) {
    if (value === void 0)
      return;
    handler.internalBinaryWrite(value, writer.tag(fieldNo, WireType.LengthDelimited).fork(), options);
    writer.join();
  }
  /**
   * Write a single scalar value.
   */
  scalar(writer, type, fieldNo, value, emitDefault) {
    let [wireType, method, isDefault] = this.scalarInfo(type, value);
    if (!isDefault || emitDefault) {
      writer.tag(fieldNo, wireType);
      writer[method](value);
    }
  }
  /**
   * Write an array of scalar values in packed format.
   */
  packed(writer, type, fieldNo, value) {
    if (!value.length)
      return;
    assert(type !== ScalarType.BYTES && type !== ScalarType.STRING);
    writer.tag(fieldNo, WireType.LengthDelimited);
    writer.fork();
    let [, method] = this.scalarInfo(type);
    for (let i = 0; i < value.length; i++)
      writer[method](value[i]);
    writer.join();
  }
  /**
   * Get information for writing a scalar value.
   *
   * Returns tuple:
   * [0]: appropriate WireType
   * [1]: name of the appropriate method of IBinaryWriter
   * [2]: whether the given value is a default value
   *
   * If argument `value` is omitted, [2] is always false.
   */
  scalarInfo(type, value) {
    let t2 = WireType.Varint;
    let m;
    let i = value === void 0;
    let d = value === 0;
    switch (type) {
      case ScalarType.INT32:
        m = "int32";
        break;
      case ScalarType.STRING:
        d = i || !value.length;
        t2 = WireType.LengthDelimited;
        m = "string";
        break;
      case ScalarType.BOOL:
        d = value === false;
        m = "bool";
        break;
      case ScalarType.UINT32:
        m = "uint32";
        break;
      case ScalarType.DOUBLE:
        t2 = WireType.Bit64;
        m = "double";
        break;
      case ScalarType.FLOAT:
        t2 = WireType.Bit32;
        m = "float";
        break;
      case ScalarType.INT64:
        d = i || PbLong.from(value).isZero();
        m = "int64";
        break;
      case ScalarType.UINT64:
        d = i || PbULong.from(value).isZero();
        m = "uint64";
        break;
      case ScalarType.FIXED64:
        d = i || PbULong.from(value).isZero();
        t2 = WireType.Bit64;
        m = "fixed64";
        break;
      case ScalarType.BYTES:
        d = i || !value.byteLength;
        t2 = WireType.LengthDelimited;
        m = "bytes";
        break;
      case ScalarType.FIXED32:
        t2 = WireType.Bit32;
        m = "fixed32";
        break;
      case ScalarType.SFIXED32:
        t2 = WireType.Bit32;
        m = "sfixed32";
        break;
      case ScalarType.SFIXED64:
        d = i || PbLong.from(value).isZero();
        t2 = WireType.Bit64;
        m = "sfixed64";
        break;
      case ScalarType.SINT32:
        m = "sint32";
        break;
      case ScalarType.SINT64:
        d = i || PbLong.from(value).isZero();
        m = "sint64";
        break;
    }
    return [t2, m, i || d];
  }
};

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-create.js
function reflectionCreate(type) {
  const msg = type.messagePrototype ? Object.create(type.messagePrototype) : Object.defineProperty({}, MESSAGE_TYPE, { value: type });
  for (let field of type.fields) {
    let name2 = field.localName;
    if (field.opt)
      continue;
    if (field.oneof)
      msg[field.oneof] = { oneofKind: void 0 };
    else if (field.repeat)
      msg[name2] = [];
    else
      switch (field.kind) {
        case "scalar":
          msg[name2] = reflectionScalarDefault(field.T, field.L);
          break;
        case "enum":
          msg[name2] = 0;
          break;
        case "map":
          msg[name2] = {};
          break;
      }
  }
  return msg;
}

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-merge-partial.js
function reflectionMergePartial(info, target, source) {
  let fieldValue, input = source, output;
  for (let field of info.fields) {
    let name2 = field.localName;
    if (field.oneof) {
      const group = input[field.oneof];
      if ((group === null || group === void 0 ? void 0 : group.oneofKind) == void 0) {
        continue;
      }
      fieldValue = group[name2];
      output = target[field.oneof];
      output.oneofKind = group.oneofKind;
      if (fieldValue == void 0) {
        delete output[name2];
        continue;
      }
    } else {
      fieldValue = input[name2];
      output = target;
      if (fieldValue == void 0) {
        continue;
      }
    }
    if (field.repeat)
      output[name2].length = fieldValue.length;
    switch (field.kind) {
      case "scalar":
      case "enum":
        if (field.repeat)
          for (let i = 0; i < fieldValue.length; i++)
            output[name2][i] = fieldValue[i];
        else
          output[name2] = fieldValue;
        break;
      case "message":
        let T = field.T();
        if (field.repeat)
          for (let i = 0; i < fieldValue.length; i++)
            output[name2][i] = T.create(fieldValue[i]);
        else if (output[name2] === void 0)
          output[name2] = T.create(fieldValue);
        else
          T.mergePartial(output[name2], fieldValue);
        break;
      case "map":
        switch (field.V.kind) {
          case "scalar":
          case "enum":
            Object.assign(output[name2], fieldValue);
            break;
          case "message":
            let T2 = field.V.T();
            for (let k of Object.keys(fieldValue))
              output[name2][k] = T2.create(fieldValue[k]);
            break;
        }
        break;
    }
  }
}

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-equals.js
function reflectionEquals(info, a, b) {
  if (a === b)
    return true;
  if (!a || !b)
    return false;
  for (let field of info.fields) {
    let localName = field.localName;
    let val_a = field.oneof ? a[field.oneof][localName] : a[localName];
    let val_b = field.oneof ? b[field.oneof][localName] : b[localName];
    switch (field.kind) {
      case "enum":
      case "scalar":
        let t2 = field.kind == "enum" ? ScalarType.INT32 : field.T;
        if (!(field.repeat ? repeatedPrimitiveEq(t2, val_a, val_b) : primitiveEq(t2, val_a, val_b)))
          return false;
        break;
      case "map":
        if (!(field.V.kind == "message" ? repeatedMsgEq(field.V.T(), objectValues(val_a), objectValues(val_b)) : repeatedPrimitiveEq(field.V.kind == "enum" ? ScalarType.INT32 : field.V.T, objectValues(val_a), objectValues(val_b))))
          return false;
        break;
      case "message":
        let T = field.T();
        if (!(field.repeat ? repeatedMsgEq(T, val_a, val_b) : T.equals(val_a, val_b)))
          return false;
        break;
    }
  }
  return true;
}
var objectValues = Object.values;
function primitiveEq(type, a, b) {
  if (a === b)
    return true;
  if (type !== ScalarType.BYTES)
    return false;
  let ba = a;
  let bb = b;
  if (ba.length !== bb.length)
    return false;
  for (let i = 0; i < ba.length; i++)
    if (ba[i] != bb[i])
      return false;
  return true;
}
function repeatedPrimitiveEq(type, a, b) {
  if (a.length !== b.length)
    return false;
  for (let i = 0; i < a.length; i++)
    if (!primitiveEq(type, a[i], b[i]))
      return false;
  return true;
}
function repeatedMsgEq(type, a, b) {
  if (a.length !== b.length)
    return false;
  for (let i = 0; i < a.length; i++)
    if (!type.equals(a[i], b[i]))
      return false;
  return true;
}

// node_modules/@protobuf-ts/runtime/build/es2015/message-type.js
var baseDescriptors = Object.getOwnPropertyDescriptors(Object.getPrototypeOf({}));
var MessageType = class {
  constructor(name2, fields, options) {
    this.defaultCheckDepth = 16;
    this.typeName = name2;
    this.fields = fields.map(normalizeFieldInfo);
    this.options = options !== null && options !== void 0 ? options : {};
    this.messagePrototype = Object.create(null, Object.assign(Object.assign({}, baseDescriptors), { [MESSAGE_TYPE]: { value: this } }));
    this.refTypeCheck = new ReflectionTypeCheck(this);
    this.refJsonReader = new ReflectionJsonReader(this);
    this.refJsonWriter = new ReflectionJsonWriter(this);
    this.refBinReader = new ReflectionBinaryReader(this);
    this.refBinWriter = new ReflectionBinaryWriter(this);
  }
  create(value) {
    let message = reflectionCreate(this);
    if (value !== void 0) {
      reflectionMergePartial(this, message, value);
    }
    return message;
  }
  /**
   * Clone the message.
   *
   * Unknown fields are discarded.
   */
  clone(message) {
    let copy3 = this.create();
    reflectionMergePartial(this, copy3, message);
    return copy3;
  }
  /**
   * Determines whether two message of the same type have the same field values.
   * Checks for deep equality, traversing repeated fields, oneof groups, maps
   * and messages recursively.
   * Will also return true if both messages are `undefined`.
   */
  equals(a, b) {
    return reflectionEquals(this, a, b);
  }
  /**
   * Is the given value assignable to our message type
   * and contains no [excess properties](https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks)?
   */
  is(arg, depth = this.defaultCheckDepth) {
    return this.refTypeCheck.is(arg, depth, false);
  }
  /**
   * Is the given value assignable to our message type,
   * regardless of [excess properties](https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks)?
   */
  isAssignable(arg, depth = this.defaultCheckDepth) {
    return this.refTypeCheck.is(arg, depth, true);
  }
  /**
   * Copy partial data into the target message.
   */
  mergePartial(target, source) {
    reflectionMergePartial(this, target, source);
  }
  /**
   * Create a new message from binary format.
   */
  fromBinary(data, options) {
    let opt = binaryReadOptions(options);
    return this.internalBinaryRead(opt.readerFactory(data), data.byteLength, opt);
  }
  /**
   * Read a new message from a JSON value.
   */
  fromJson(json, options) {
    return this.internalJsonRead(json, jsonReadOptions(options));
  }
  /**
   * Read a new message from a JSON string.
   * This is equivalent to `T.fromJson(JSON.parse(json))`.
   */
  fromJsonString(json, options) {
    let value = JSON.parse(json);
    return this.fromJson(value, options);
  }
  /**
   * Write the message to canonical JSON value.
   */
  toJson(message, options) {
    return this.internalJsonWrite(message, jsonWriteOptions(options));
  }
  /**
   * Convert the message to canonical JSON string.
   * This is equivalent to `JSON.stringify(T.toJson(t))`
   */
  toJsonString(message, options) {
    var _a;
    let value = this.toJson(message, options);
    return JSON.stringify(value, null, (_a = options === null || options === void 0 ? void 0 : options.prettySpaces) !== null && _a !== void 0 ? _a : 0);
  }
  /**
   * Write the message to binary format.
   */
  toBinary(message, options) {
    let opt = binaryWriteOptions(options);
    return this.internalBinaryWrite(message, opt.writerFactory(), opt).finish();
  }
  /**
   * This is an internal method. If you just want to read a message from
   * JSON, use `fromJson()` or `fromJsonString()`.
   *
   * Reads JSON value and merges the fields into the target
   * according to protobuf rules. If the target is omitted,
   * a new instance is created first.
   */
  internalJsonRead(json, options, target) {
    if (json !== null && typeof json == "object" && !Array.isArray(json)) {
      let message = target !== null && target !== void 0 ? target : this.create();
      this.refJsonReader.read(json, message, options);
      return message;
    }
    throw new Error(`Unable to parse message ${this.typeName} from JSON ${typeofJsonValue(json)}.`);
  }
  /**
   * This is an internal method. If you just want to write a message
   * to JSON, use `toJson()` or `toJsonString().
   *
   * Writes JSON value and returns it.
   */
  internalJsonWrite(message, options) {
    return this.refJsonWriter.write(message, options);
  }
  /**
   * This is an internal method. If you just want to write a message
   * in binary format, use `toBinary()`.
   *
   * Serializes the message in binary format and appends it to the given
   * writer. Returns passed writer.
   */
  internalBinaryWrite(message, writer, options) {
    this.refBinWriter.write(message, writer, options);
    return writer;
  }
  /**
   * This is an internal method. If you just want to read a message from
   * binary data, use `fromBinary()`.
   *
   * Reads data from binary format and merges the fields into
   * the target according to protobuf rules. If the target is
   * omitted, a new instance is created first.
   */
  internalBinaryRead(reader, length, options, target) {
    let message = target !== null && target !== void 0 ? target : this.create();
    this.refBinReader.read(reader, message, options, length);
    return message;
  }
};

// node_modules/@protobuf-ts/runtime-rpc/build/es2015/reflection-info.js
function normalizeMethodInfo(method, service) {
  var _a, _b, _c;
  let m = method;
  m.service = service;
  m.localName = (_a = m.localName) !== null && _a !== void 0 ? _a : lowerCamelCase(m.name);
  m.serverStreaming = !!m.serverStreaming;
  m.clientStreaming = !!m.clientStreaming;
  m.options = (_b = m.options) !== null && _b !== void 0 ? _b : {};
  m.idempotency = (_c = m.idempotency) !== null && _c !== void 0 ? _c : void 0;
  return m;
}

// node_modules/@protobuf-ts/runtime-rpc/build/es2015/service-type.js
var ServiceType = class {
  constructor(typeName, methods, options) {
    this.typeName = typeName;
    this.methods = methods.map((i) => normalizeMethodInfo(i, this));
    this.options = options !== null && options !== void 0 ? options : {};
  }
};

// node_modules/@protobuf-ts/runtime-rpc/build/es2015/rpc-error.js
var RpcError = class extends Error {
  constructor(message, code = "UNKNOWN", meta) {
    super(message);
    this.name = "RpcError";
    Object.setPrototypeOf(this, new.target.prototype);
    this.code = code;
    this.meta = meta !== null && meta !== void 0 ? meta : {};
  }
  toString() {
    const l = [this.name + ": " + this.message];
    if (this.code) {
      l.push("");
      l.push("Code: " + this.code);
    }
    if (this.serviceName && this.methodName) {
      l.push("Method: " + this.serviceName + "/" + this.methodName);
    }
    let m = Object.entries(this.meta);
    if (m.length) {
      l.push("");
      l.push("Meta:");
      for (let [k, v] of m) {
        l.push(`  ${k}: ${v}`);
      }
    }
    return l.join("\n");
  }
};

// node_modules/@protobuf-ts/runtime-rpc/build/es2015/rpc-options.js
function mergeRpcOptions(defaults, options) {
  if (!options)
    return defaults;
  let o = {};
  copy(defaults, o);
  copy(options, o);
  for (let key of Object.keys(options)) {
    let val = options[key];
    switch (key) {
      case "jsonOptions":
        o.jsonOptions = mergeJsonOptions(defaults.jsonOptions, o.jsonOptions);
        break;
      case "binaryOptions":
        o.binaryOptions = mergeBinaryOptions(defaults.binaryOptions, o.binaryOptions);
        break;
      case "meta":
        o.meta = {};
        copy(defaults.meta, o.meta);
        copy(options.meta, o.meta);
        break;
      case "interceptors":
        o.interceptors = defaults.interceptors ? defaults.interceptors.concat(val) : val.concat();
        break;
    }
  }
  return o;
}
function copy(a, into) {
  if (!a)
    return;
  let c = into;
  for (let [k, v] of Object.entries(a)) {
    if (v instanceof Date)
      c[k] = new Date(v.getTime());
    else if (Array.isArray(v))
      c[k] = v.concat();
    else
      c[k] = v;
  }
}

// node_modules/@protobuf-ts/runtime-rpc/build/es2015/deferred.js
var DeferredState;
(function(DeferredState2) {
  DeferredState2[DeferredState2["PENDING"] = 0] = "PENDING";
  DeferredState2[DeferredState2["REJECTED"] = 1] = "REJECTED";
  DeferredState2[DeferredState2["RESOLVED"] = 2] = "RESOLVED";
})(DeferredState || (DeferredState = {}));
var Deferred = class {
  /**
   * @param preventUnhandledRejectionWarning - prevents the warning
   * "Unhandled Promise rejection" by adding a noop rejection handler.
   * Working with calls returned from the runtime-rpc package in an
   * async function usually means awaiting one call property after
   * the other. This means that the "status" is not being awaited when
   * an earlier await for the "headers" is rejected. This causes the
   * "unhandled promise reject" warning. A more correct behaviour for
   * calls might be to become aware whether at least one of the
   * promises is handled and swallow the rejection warning for the
   * others.
   */
  constructor(preventUnhandledRejectionWarning = true) {
    this._state = DeferredState.PENDING;
    this._promise = new Promise((resolve, reject) => {
      this._resolve = resolve;
      this._reject = reject;
    });
    if (preventUnhandledRejectionWarning) {
      this._promise.catch((_) => {
      });
    }
  }
  /**
   * Get the current state of the promise.
   */
  get state() {
    return this._state;
  }
  /**
   * Get the deferred promise.
   */
  get promise() {
    return this._promise;
  }
  /**
   * Resolve the promise. Throws if the promise is already resolved or rejected.
   */
  resolve(value) {
    if (this.state !== DeferredState.PENDING)
      throw new Error(`cannot resolve ${DeferredState[this.state].toLowerCase()}`);
    this._resolve(value);
    this._state = DeferredState.RESOLVED;
  }
  /**
   * Reject the promise. Throws if the promise is already resolved or rejected.
   */
  reject(reason) {
    if (this.state !== DeferredState.PENDING)
      throw new Error(`cannot reject ${DeferredState[this.state].toLowerCase()}`);
    this._reject(reason);
    this._state = DeferredState.REJECTED;
  }
  /**
   * Resolve the promise. Ignore if not pending.
   */
  resolvePending(val) {
    if (this._state === DeferredState.PENDING)
      this.resolve(val);
  }
  /**
   * Reject the promise. Ignore if not pending.
   */
  rejectPending(reason) {
    if (this._state === DeferredState.PENDING)
      this.reject(reason);
  }
};

// node_modules/@protobuf-ts/runtime-rpc/build/es2015/rpc-output-stream.js
var RpcOutputStreamController = class {
  constructor() {
    this._lis = {
      nxt: [],
      msg: [],
      err: [],
      cmp: []
    };
    this._closed = false;
  }
  // --- RpcOutputStream callback API
  onNext(callback) {
    return this.addLis(callback, this._lis.nxt);
  }
  onMessage(callback) {
    return this.addLis(callback, this._lis.msg);
  }
  onError(callback) {
    return this.addLis(callback, this._lis.err);
  }
  onComplete(callback) {
    return this.addLis(callback, this._lis.cmp);
  }
  addLis(callback, list) {
    list.push(callback);
    return () => {
      let i = list.indexOf(callback);
      if (i >= 0)
        list.splice(i, 1);
    };
  }
  // remove all listeners
  clearLis() {
    for (let l of Object.values(this._lis))
      l.splice(0, l.length);
  }
  // --- Controller API
  /**
   * Is this stream already closed by a completion or error?
   */
  get closed() {
    return this._closed !== false;
  }
  /**
   * Emit message, close with error, or close successfully, but only one
   * at a time.
   * Can be used to wrap a stream by using the other stream's `onNext`.
   */
  notifyNext(message, error2, complete) {
    assert((message ? 1 : 0) + (error2 ? 1 : 0) + (complete ? 1 : 0) <= 1, "only one emission at a time");
    if (message)
      this.notifyMessage(message);
    if (error2)
      this.notifyError(error2);
    if (complete)
      this.notifyComplete();
  }
  /**
   * Emits a new message. Throws if stream is closed.
   *
   * Triggers onNext and onMessage callbacks.
   */
  notifyMessage(message) {
    assert(!this.closed, "stream is closed");
    this.pushIt({ value: message, done: false });
    this._lis.msg.forEach((l) => l(message));
    this._lis.nxt.forEach((l) => l(message, void 0, false));
  }
  /**
   * Closes the stream with an error. Throws if stream is closed.
   *
   * Triggers onNext and onError callbacks.
   */
  notifyError(error2) {
    assert(!this.closed, "stream is closed");
    this._closed = error2;
    this.pushIt(error2);
    this._lis.err.forEach((l) => l(error2));
    this._lis.nxt.forEach((l) => l(void 0, error2, false));
    this.clearLis();
  }
  /**
   * Closes the stream successfully. Throws if stream is closed.
   *
   * Triggers onNext and onComplete callbacks.
   */
  notifyComplete() {
    assert(!this.closed, "stream is closed");
    this._closed = true;
    this.pushIt({ value: null, done: true });
    this._lis.cmp.forEach((l) => l());
    this._lis.nxt.forEach((l) => l(void 0, void 0, true));
    this.clearLis();
  }
  /**
   * Creates an async iterator (that can be used with `for await {...}`)
   * to consume the stream.
   *
   * Some things to note:
   * - If an error occurs, the `for await` will throw it.
   * - If an error occurred before the `for await` was started, `for await`
   *   will re-throw it.
   * - If the stream is already complete, the `for await` will be empty.
   * - If your `for await` consumes slower than the stream produces,
   *   for example because you are relaying messages in a slow operation,
   *   messages are queued.
   */
  [Symbol.asyncIterator]() {
    if (!this._itState) {
      this._itState = { q: [] };
    }
    if (this._closed === true)
      this.pushIt({ value: null, done: true });
    else if (this._closed !== false)
      this.pushIt(this._closed);
    return {
      next: () => {
        let state = this._itState;
        assert(state, "bad state");
        assert(!state.p, "iterator contract broken");
        let first2 = state.q.shift();
        if (first2)
          return "value" in first2 ? Promise.resolve(first2) : Promise.reject(first2);
        state.p = new Deferred();
        return state.p.promise;
      }
    };
  }
  // "push" a new iterator result.
  // this either resolves a pending promise, or enqueues the result.
  pushIt(result) {
    let state = this._itState;
    if (!state)
      return;
    if (state.p) {
      const p = state.p;
      assert(p.state == DeferredState.PENDING, "iterator contract broken");
      "value" in result ? p.resolve(result) : p.reject(result);
      delete state.p;
    } else {
      state.q.push(result);
    }
  }
};

// node_modules/@protobuf-ts/runtime-rpc/build/es2015/unary-call.js
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var UnaryCall = class {
  constructor(method, requestHeaders, request, headers, response, status, trailers) {
    this.method = method;
    this.requestHeaders = requestHeaders;
    this.request = request;
    this.headers = headers;
    this.response = response;
    this.status = status;
    this.trailers = trailers;
  }
  /**
   * If you are only interested in the final outcome of this call,
   * you can await it to receive a `FinishedUnaryCall`.
   */
  then(onfulfilled, onrejected) {
    return this.promiseFinished().then((value) => onfulfilled ? Promise.resolve(onfulfilled(value)) : value, (reason) => onrejected ? Promise.resolve(onrejected(reason)) : Promise.reject(reason));
  }
  promiseFinished() {
    return __awaiter2(this, void 0, void 0, function* () {
      let [headers, response, status, trailers] = yield Promise.all([this.headers, this.response, this.status, this.trailers]);
      return {
        method: this.method,
        requestHeaders: this.requestHeaders,
        request: this.request,
        headers,
        response,
        status,
        trailers
      };
    });
  }
};

// node_modules/@protobuf-ts/runtime-rpc/build/es2015/server-streaming-call.js
var __awaiter3 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ServerStreamingCall = class {
  constructor(method, requestHeaders, request, headers, response, status, trailers) {
    this.method = method;
    this.requestHeaders = requestHeaders;
    this.request = request;
    this.headers = headers;
    this.responses = response;
    this.status = status;
    this.trailers = trailers;
  }
  /**
   * Instead of awaiting the response status and trailers, you can
   * just as well await this call itself to receive the server outcome.
   * You should first setup some listeners to the `request` to
   * see the actual messages the server replied with.
   */
  then(onfulfilled, onrejected) {
    return this.promiseFinished().then((value) => onfulfilled ? Promise.resolve(onfulfilled(value)) : value, (reason) => onrejected ? Promise.resolve(onrejected(reason)) : Promise.reject(reason));
  }
  promiseFinished() {
    return __awaiter3(this, void 0, void 0, function* () {
      let [headers, status, trailers] = yield Promise.all([this.headers, this.status, this.trailers]);
      return {
        method: this.method,
        requestHeaders: this.requestHeaders,
        request: this.request,
        headers,
        status,
        trailers
      };
    });
  }
};

// node_modules/@protobuf-ts/runtime-rpc/build/es2015/client-streaming-call.js
var __awaiter4 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ClientStreamingCall = class {
  constructor(method, requestHeaders, request, headers, response, status, trailers) {
    this.method = method;
    this.requestHeaders = requestHeaders;
    this.requests = request;
    this.headers = headers;
    this.response = response;
    this.status = status;
    this.trailers = trailers;
  }
  /**
   * Instead of awaiting the response status and trailers, you can
   * just as well await this call itself to receive the server outcome.
   * Note that it may still be valid to send more request messages.
   */
  then(onfulfilled, onrejected) {
    return this.promiseFinished().then((value) => onfulfilled ? Promise.resolve(onfulfilled(value)) : value, (reason) => onrejected ? Promise.resolve(onrejected(reason)) : Promise.reject(reason));
  }
  promiseFinished() {
    return __awaiter4(this, void 0, void 0, function* () {
      let [headers, response, status, trailers] = yield Promise.all([this.headers, this.response, this.status, this.trailers]);
      return {
        method: this.method,
        requestHeaders: this.requestHeaders,
        headers,
        response,
        status,
        trailers
      };
    });
  }
};

// node_modules/@protobuf-ts/runtime-rpc/build/es2015/duplex-streaming-call.js
var __awaiter5 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DuplexStreamingCall = class {
  constructor(method, requestHeaders, request, headers, response, status, trailers) {
    this.method = method;
    this.requestHeaders = requestHeaders;
    this.requests = request;
    this.headers = headers;
    this.responses = response;
    this.status = status;
    this.trailers = trailers;
  }
  /**
   * Instead of awaiting the response status and trailers, you can
   * just as well await this call itself to receive the server outcome.
   * Note that it may still be valid to send more request messages.
   */
  then(onfulfilled, onrejected) {
    return this.promiseFinished().then((value) => onfulfilled ? Promise.resolve(onfulfilled(value)) : value, (reason) => onrejected ? Promise.resolve(onrejected(reason)) : Promise.reject(reason));
  }
  promiseFinished() {
    return __awaiter5(this, void 0, void 0, function* () {
      let [headers, status, trailers] = yield Promise.all([this.headers, this.status, this.trailers]);
      return {
        method: this.method,
        requestHeaders: this.requestHeaders,
        headers,
        status,
        trailers
      };
    });
  }
};

// node_modules/@protobuf-ts/runtime-rpc/build/es2015/test-transport.js
var __awaiter6 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var TestTransport = class _TestTransport {
  /**
   * Initialize with mock data. Omitted fields have default value.
   */
  constructor(data) {
    this.suppressUncaughtRejections = true;
    this.headerDelay = 10;
    this.responseDelay = 50;
    this.betweenResponseDelay = 10;
    this.afterResponseDelay = 10;
    this.data = data !== null && data !== void 0 ? data : {};
  }
  /**
   * Sent message(s) during the last operation.
   */
  get sentMessages() {
    if (this.lastInput instanceof TestInputStream) {
      return this.lastInput.sent;
    } else if (typeof this.lastInput == "object") {
      return [this.lastInput.single];
    }
    return [];
  }
  /**
   * Sending message(s) completed?
   */
  get sendComplete() {
    if (this.lastInput instanceof TestInputStream) {
      return this.lastInput.completed;
    } else if (typeof this.lastInput == "object") {
      return true;
    }
    return false;
  }
  // Creates a promise for response headers from the mock data.
  promiseHeaders() {
    var _a;
    const headers = (_a = this.data.headers) !== null && _a !== void 0 ? _a : _TestTransport.defaultHeaders;
    return headers instanceof RpcError ? Promise.reject(headers) : Promise.resolve(headers);
  }
  // Creates a promise for a single, valid, message from the mock data.
  promiseSingleResponse(method) {
    if (this.data.response instanceof RpcError) {
      return Promise.reject(this.data.response);
    }
    let r;
    if (Array.isArray(this.data.response)) {
      assert(this.data.response.length > 0);
      r = this.data.response[0];
    } else if (this.data.response !== void 0) {
      r = this.data.response;
    } else {
      r = method.O.create();
    }
    assert(method.O.is(r));
    return Promise.resolve(r);
  }
  /**
   * Pushes response messages from the mock data to the output stream.
   * If an error response, status or trailers are mocked, the stream is
   * closed with the respective error.
   * Otherwise, stream is completed successfully.
   *
   * The returned promise resolves when the stream is closed. It should
   * not reject. If it does, code is broken.
   */
  streamResponses(method, stream, abort) {
    return __awaiter6(this, void 0, void 0, function* () {
      const messages = [];
      if (this.data.response === void 0) {
        messages.push(method.O.create());
      } else if (Array.isArray(this.data.response)) {
        for (let msg of this.data.response) {
          assert(method.O.is(msg));
          messages.push(msg);
        }
      } else if (!(this.data.response instanceof RpcError)) {
        assert(method.O.is(this.data.response));
        messages.push(this.data.response);
      }
      try {
        yield delay(this.responseDelay, abort)(void 0);
      } catch (error2) {
        stream.notifyError(error2);
        return;
      }
      if (this.data.response instanceof RpcError) {
        stream.notifyError(this.data.response);
        return;
      }
      for (let msg of messages) {
        stream.notifyMessage(msg);
        try {
          yield delay(this.betweenResponseDelay, abort)(void 0);
        } catch (error2) {
          stream.notifyError(error2);
          return;
        }
      }
      if (this.data.status instanceof RpcError) {
        stream.notifyError(this.data.status);
        return;
      }
      if (this.data.trailers instanceof RpcError) {
        stream.notifyError(this.data.trailers);
        return;
      }
      stream.notifyComplete();
    });
  }
  // Creates a promise for response status from the mock data.
  promiseStatus() {
    var _a;
    const status = (_a = this.data.status) !== null && _a !== void 0 ? _a : _TestTransport.defaultStatus;
    return status instanceof RpcError ? Promise.reject(status) : Promise.resolve(status);
  }
  // Creates a promise for response trailers from the mock data.
  promiseTrailers() {
    var _a;
    const trailers = (_a = this.data.trailers) !== null && _a !== void 0 ? _a : _TestTransport.defaultTrailers;
    return trailers instanceof RpcError ? Promise.reject(trailers) : Promise.resolve(trailers);
  }
  maybeSuppressUncaught(...promise) {
    if (this.suppressUncaughtRejections) {
      for (let p of promise) {
        p.catch(() => {
        });
      }
    }
  }
  mergeOptions(options) {
    return mergeRpcOptions({}, options);
  }
  unary(method, input, options) {
    var _a;
    const requestHeaders = (_a = options.meta) !== null && _a !== void 0 ? _a : {}, headersPromise = this.promiseHeaders().then(delay(this.headerDelay, options.abort)), responsePromise = headersPromise.catch((_) => {
    }).then(delay(this.responseDelay, options.abort)).then((_) => this.promiseSingleResponse(method)), statusPromise = responsePromise.catch((_) => {
    }).then(delay(this.afterResponseDelay, options.abort)).then((_) => this.promiseStatus()), trailersPromise = responsePromise.catch((_) => {
    }).then(delay(this.afterResponseDelay, options.abort)).then((_) => this.promiseTrailers());
    this.maybeSuppressUncaught(statusPromise, trailersPromise);
    this.lastInput = { single: input };
    return new UnaryCall(method, requestHeaders, input, headersPromise, responsePromise, statusPromise, trailersPromise);
  }
  serverStreaming(method, input, options) {
    var _a;
    const requestHeaders = (_a = options.meta) !== null && _a !== void 0 ? _a : {}, headersPromise = this.promiseHeaders().then(delay(this.headerDelay, options.abort)), outputStream = new RpcOutputStreamController(), responseStreamClosedPromise = headersPromise.then(delay(this.responseDelay, options.abort)).catch(() => {
    }).then(() => this.streamResponses(method, outputStream, options.abort)).then(delay(this.afterResponseDelay, options.abort)), statusPromise = responseStreamClosedPromise.then(() => this.promiseStatus()), trailersPromise = responseStreamClosedPromise.then(() => this.promiseTrailers());
    this.maybeSuppressUncaught(statusPromise, trailersPromise);
    this.lastInput = { single: input };
    return new ServerStreamingCall(method, requestHeaders, input, headersPromise, outputStream, statusPromise, trailersPromise);
  }
  clientStreaming(method, options) {
    var _a;
    const requestHeaders = (_a = options.meta) !== null && _a !== void 0 ? _a : {}, headersPromise = this.promiseHeaders().then(delay(this.headerDelay, options.abort)), responsePromise = headersPromise.catch((_) => {
    }).then(delay(this.responseDelay, options.abort)).then((_) => this.promiseSingleResponse(method)), statusPromise = responsePromise.catch((_) => {
    }).then(delay(this.afterResponseDelay, options.abort)).then((_) => this.promiseStatus()), trailersPromise = responsePromise.catch((_) => {
    }).then(delay(this.afterResponseDelay, options.abort)).then((_) => this.promiseTrailers());
    this.maybeSuppressUncaught(statusPromise, trailersPromise);
    this.lastInput = new TestInputStream(this.data, options.abort);
    return new ClientStreamingCall(method, requestHeaders, this.lastInput, headersPromise, responsePromise, statusPromise, trailersPromise);
  }
  duplex(method, options) {
    var _a;
    const requestHeaders = (_a = options.meta) !== null && _a !== void 0 ? _a : {}, headersPromise = this.promiseHeaders().then(delay(this.headerDelay, options.abort)), outputStream = new RpcOutputStreamController(), responseStreamClosedPromise = headersPromise.then(delay(this.responseDelay, options.abort)).catch(() => {
    }).then(() => this.streamResponses(method, outputStream, options.abort)).then(delay(this.afterResponseDelay, options.abort)), statusPromise = responseStreamClosedPromise.then(() => this.promiseStatus()), trailersPromise = responseStreamClosedPromise.then(() => this.promiseTrailers());
    this.maybeSuppressUncaught(statusPromise, trailersPromise);
    this.lastInput = new TestInputStream(this.data, options.abort);
    return new DuplexStreamingCall(method, requestHeaders, this.lastInput, headersPromise, outputStream, statusPromise, trailersPromise);
  }
};
TestTransport.defaultHeaders = {
  responseHeader: "test"
};
TestTransport.defaultStatus = {
  code: "OK",
  detail: "all good"
};
TestTransport.defaultTrailers = {
  responseTrailer: "test"
};
function delay(ms, abort) {
  return (v) => new Promise((resolve, reject) => {
    if (abort === null || abort === void 0 ? void 0 : abort.aborted) {
      reject(new RpcError("user cancel", "CANCELLED"));
    } else {
      const id = setTimeout(() => resolve(v), ms);
      if (abort) {
        abort.addEventListener("abort", (ev) => {
          clearTimeout(id);
          reject(new RpcError("user cancel", "CANCELLED"));
        });
      }
    }
  });
}
var TestInputStream = class {
  constructor(data, abort) {
    this._completed = false;
    this._sent = [];
    this.data = data;
    this.abort = abort;
  }
  get sent() {
    return this._sent;
  }
  get completed() {
    return this._completed;
  }
  send(message) {
    if (this.data.inputMessage instanceof RpcError) {
      return Promise.reject(this.data.inputMessage);
    }
    const delayMs = this.data.inputMessage === void 0 ? 10 : this.data.inputMessage;
    return Promise.resolve(void 0).then(() => {
      this._sent.push(message);
    }).then(delay(delayMs, this.abort));
  }
  complete() {
    if (this.data.inputComplete instanceof RpcError) {
      return Promise.reject(this.data.inputComplete);
    }
    const delayMs = this.data.inputComplete === void 0 ? 10 : this.data.inputComplete;
    return Promise.resolve(void 0).then(() => {
      this._completed = true;
    }).then(delay(delayMs, this.abort));
  }
};

// node_modules/@protobuf-ts/runtime-rpc/build/es2015/rpc-interceptor.js
function stackIntercept(kind, transport, method, options, input) {
  var _a, _b, _c, _d;
  if (kind == "unary") {
    let tail = (mtd, inp, opt) => transport.unary(mtd, inp, opt);
    for (const curr of ((_a = options.interceptors) !== null && _a !== void 0 ? _a : []).filter((i) => i.interceptUnary).reverse()) {
      const next = tail;
      tail = (mtd, inp, opt) => curr.interceptUnary(next, mtd, inp, opt);
    }
    return tail(method, input, options);
  }
  if (kind == "serverStreaming") {
    let tail = (mtd, inp, opt) => transport.serverStreaming(mtd, inp, opt);
    for (const curr of ((_b = options.interceptors) !== null && _b !== void 0 ? _b : []).filter((i) => i.interceptServerStreaming).reverse()) {
      const next = tail;
      tail = (mtd, inp, opt) => curr.interceptServerStreaming(next, mtd, inp, opt);
    }
    return tail(method, input, options);
  }
  if (kind == "clientStreaming") {
    let tail = (mtd, opt) => transport.clientStreaming(mtd, opt);
    for (const curr of ((_c = options.interceptors) !== null && _c !== void 0 ? _c : []).filter((i) => i.interceptClientStreaming).reverse()) {
      const next = tail;
      tail = (mtd, opt) => curr.interceptClientStreaming(next, mtd, opt);
    }
    return tail(method, options);
  }
  if (kind == "duplex") {
    let tail = (mtd, opt) => transport.duplex(mtd, opt);
    for (const curr of ((_d = options.interceptors) !== null && _d !== void 0 ? _d : []).filter((i) => i.interceptDuplex).reverse()) {
      const next = tail;
      tail = (mtd, opt) => curr.interceptDuplex(next, mtd, opt);
    }
    return tail(method, options);
  }
  assertNever(kind);
}

// node_modules/@protobuf-ts/twirp-transport/build/es2015/twitch-twirp-error-code.js
var TwirpErrorCode;
(function(TwirpErrorCode2) {
  TwirpErrorCode2[TwirpErrorCode2["cancelled"] = 0] = "cancelled";
  TwirpErrorCode2[TwirpErrorCode2["unknown"] = 1] = "unknown";
  TwirpErrorCode2[TwirpErrorCode2["invalid_argument"] = 2] = "invalid_argument";
  TwirpErrorCode2[TwirpErrorCode2["malformed"] = 3] = "malformed";
  TwirpErrorCode2[TwirpErrorCode2["deadline_exceeded"] = 4] = "deadline_exceeded";
  TwirpErrorCode2[TwirpErrorCode2["not_found"] = 5] = "not_found";
  TwirpErrorCode2[TwirpErrorCode2["bad_route"] = 6] = "bad_route";
  TwirpErrorCode2[TwirpErrorCode2["already_exists"] = 7] = "already_exists";
  TwirpErrorCode2[TwirpErrorCode2["permission_denied"] = 8] = "permission_denied";
  TwirpErrorCode2[TwirpErrorCode2["unauthenticated"] = 9] = "unauthenticated";
  TwirpErrorCode2[TwirpErrorCode2["resource_exhausted"] = 10] = "resource_exhausted";
  TwirpErrorCode2[TwirpErrorCode2["failed_precondition"] = 11] = "failed_precondition";
  TwirpErrorCode2[TwirpErrorCode2["aborted"] = 12] = "aborted";
  TwirpErrorCode2[TwirpErrorCode2["out_of_range"] = 13] = "out_of_range";
  TwirpErrorCode2[TwirpErrorCode2["unimplemented"] = 14] = "unimplemented";
  TwirpErrorCode2[TwirpErrorCode2["internal"] = 15] = "internal";
  TwirpErrorCode2[TwirpErrorCode2["unavailable"] = 16] = "unavailable";
  TwirpErrorCode2[TwirpErrorCode2["dataloss"] = 17] = "dataloss";
})(TwirpErrorCode || (TwirpErrorCode = {}));

// node_modules/@protobuf-ts/twirp-transport/build/es2015/twirp-format.js
function createTwirpRequestHeader(headers, sendJson, meta) {
  if (meta) {
    for (let [k, v] of Object.entries(meta)) {
      if (typeof v == "string")
        headers.append(k, v);
      else
        for (let i of v)
          headers.append(k, i);
    }
  }
  headers.set("Content-Type", sendJson ? "application/json" : "application/protobuf");
  headers.set("Accept", sendJson ? "application/json" : "application/protobuf, application/json");
  return headers;
}
function parseTwirpErrorResponse(json) {
  if (!isJsonObject(json) || typeof json.code !== "string" || typeof json.msg !== "string")
    return new RpcError("cannot read twirp error response", TwirpErrorCode[TwirpErrorCode.internal]);
  let meta = {};
  if (isJsonObject(json.meta)) {
    for (let [k, v] of Object.entries(json.meta)) {
      if (typeof v == "string")
        meta[k] = v;
    }
  }
  return new RpcError(json.msg, json.code, meta);
}
function parseMetadataFromResponseHeaders(headers) {
  let meta = {};
  headers.forEach((value, key) => {
    if (key.toLowerCase() === "content-type")
      return;
    if (key.toLowerCase() === "content-length")
      return;
    if (meta.hasOwnProperty(key))
      meta[key].push(value);
    else
      meta[key] = value;
  });
  return meta;
}

// node_modules/@protobuf-ts/twirp-transport/build/es2015/twirp-transport.js
var TwirpFetchTransport = class {
  constructor(options) {
    this.defaultOptions = options;
  }
  mergeOptions(options) {
    return mergeRpcOptions(this.defaultOptions, options);
  }
  unary(method, input, options) {
    var _a, _b, _c;
    let opt = options, url = this.makeUrl(method, opt), fetchInit = (_a = opt.fetchInit) !== null && _a !== void 0 ? _a : {}, requestBody = opt.sendJson ? method.I.toJsonString(input, opt.jsonOptions) : method.I.toBinary(input, opt.binaryOptions), defHeader = new Deferred(), defMessage = new Deferred(), defStatus = new Deferred(), defTrailer = new Deferred();
    globalThis.fetch(url, Object.assign(Object.assign({}, fetchInit), {
      method: "POST",
      headers: createTwirpRequestHeader(new globalThis.Headers(), !!opt.sendJson, opt.meta),
      body: requestBody,
      signal: (_b = options.abort) !== null && _b !== void 0 ? _b : null
      // node-fetch@3.0.0-beta.9 rejects `undefined`
    })).then((fetchResponse) => {
      defHeader.resolve(parseMetadataFromResponseHeaders(fetchResponse.headers));
      let responseType;
      try {
        responseType = fetchResponse.type;
      } catch (_a2) {
      }
      switch (responseType) {
        case "error":
        case "opaque":
        case "opaqueredirect":
          throw new RpcError(`fetch response type ${fetchResponse.type}`, TwirpErrorCode[TwirpErrorCode.unknown]);
      }
      if (!fetchResponse.ok) {
        return fetchResponse.json().then((value) => {
          throw parseTwirpErrorResponse(value);
        }, () => {
          throw new RpcError("received HTTP " + fetchResponse.status + ", unable to read response body as json", TwirpErrorCode[TwirpErrorCode.internal]);
        });
      }
      if (opt.sendJson) {
        return fetchResponse.json().then((value) => method.O.fromJson(value, opt.jsonOptions), () => {
          throw new RpcError("unable to read response body as json", TwirpErrorCode[TwirpErrorCode.dataloss]);
        });
      }
      return fetchResponse.arrayBuffer().then((value) => method.O.fromBinary(new Uint8Array(value), opt.binaryOptions), () => {
        throw new RpcError("unable to read response body", TwirpErrorCode[TwirpErrorCode.dataloss]);
      });
    }, (reason) => {
      if (reason instanceof Error && reason.name === "AbortError")
        throw new RpcError(reason.message, TwirpErrorCode[TwirpErrorCode.cancelled]);
      throw new RpcError(reason instanceof Error ? reason.message : reason);
    }).then((message) => {
      defMessage.resolve(message);
      defStatus.resolve({ code: "OK", detail: "" });
      defTrailer.resolve({});
    }).catch((reason) => {
      let error2 = reason instanceof RpcError ? reason : new RpcError(reason instanceof Error ? reason.message : reason, TwirpErrorCode[TwirpErrorCode.internal]);
      error2.methodName = method.name;
      error2.serviceName = method.service.typeName;
      defHeader.rejectPending(error2);
      defMessage.rejectPending(error2);
      defStatus.rejectPending(error2);
      defTrailer.rejectPending(error2);
    });
    return new UnaryCall(method, (_c = opt.meta) !== null && _c !== void 0 ? _c : {}, input, defHeader.promise, defMessage.promise, defStatus.promise, defTrailer.promise);
  }
  /**
   * Create an URI for a RPC call.
   *
   * Takes the `baseUrl` option and appends:
   * - slash "/"
   * - package name
   * - dot "."
   * - service name
   * - slash "/"
   * - method name
   *
   * If the service was declared without a package, the package name and dot
   * are omitted.
   *
   * The method name is CamelCased just as it would be in Go, unless the
   * option `useProtoMethodName` is `true`.
   */
  makeUrl(method, options) {
    let base = options.baseUrl;
    if (base.endsWith("/"))
      base = base.substring(0, base.length - 1);
    let methodName = method.name;
    if (options.useProtoMethodName !== true) {
      methodName = lowerCamelCase(methodName);
      methodName = methodName.substring(0, 1).toUpperCase() + methodName.substring(1);
    }
    return `${base}/${method.service.typeName}/${methodName}`;
  }
  clientStreaming(method) {
    const e = new RpcError("Client streaming is not supported by Twirp", TwirpErrorCode[TwirpErrorCode.unimplemented]);
    e.methodName = method.name;
    e.serviceName = method.service.typeName;
    throw e;
  }
  duplex(method) {
    const e = new RpcError("Duplex streaming is not supported by Twirp", TwirpErrorCode[TwirpErrorCode.unimplemented]);
    e.methodName = method.name;
    e.serviceName = method.service.typeName;
    throw e;
  }
  serverStreaming(method) {
    const e = new RpcError("Server streaming is not supported by Twirp", TwirpErrorCode[TwirpErrorCode.unimplemented]);
    e.methodName = method.name;
    e.serviceName = method.service.typeName;
    throw e;
  }
};

// node_modules/rxjs/dist/esm5/internal/util/isFunction.js
function isFunction(value) {
  return typeof value === "function";
}

// node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js
function createErrorClass(createImpl) {
  var _super = function(instance2) {
    Error.call(instance2);
    instance2.stack = new Error().stack;
  };
  var ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}

// node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js
var UnsubscriptionError = createErrorClass(function(_super) {
  return function UnsubscriptionErrorImpl(errors) {
    _super(this);
    this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
      return i + 1 + ") " + err.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors;
  };
});

// node_modules/rxjs/dist/esm5/internal/util/arrRemove.js
function arrRemove(arr, item) {
  if (arr) {
    var index3 = arr.indexOf(item);
    0 <= index3 && arr.splice(index3, 1);
  }
}

// node_modules/rxjs/dist/esm5/internal/Subscription.js
var Subscription = function() {
  function Subscription2(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  Subscription2.prototype.unsubscribe = function() {
    var e_1, _a, e_2, _b;
    var errors;
    if (!this.closed) {
      this.closed = true;
      var _parentage = this._parentage;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          try {
            for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
              var parent_1 = _parentage_1_1.value;
              parent_1.remove(this);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return)) _a.call(_parentage_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        } else {
          _parentage.remove(this);
        }
      }
      var initialFinalizer = this.initialTeardown;
      if (isFunction(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e) {
          errors = e instanceof UnsubscriptionError ? e.errors : [e];
        }
      }
      var _finalizers = this._finalizers;
      if (_finalizers) {
        this._finalizers = null;
        try {
          for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
            var finalizer = _finalizers_1_1.value;
            try {
              execFinalizer(finalizer);
            } catch (err) {
              errors = errors !== null && errors !== void 0 ? errors : [];
              if (err instanceof UnsubscriptionError) {
                errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
              } else {
                errors.push(err);
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return)) _b.call(_finalizers_1);
          } finally {
            if (e_2) throw e_2.error;
          }
        }
      }
      if (errors) {
        throw new UnsubscriptionError(errors);
      }
    }
  };
  Subscription2.prototype.add = function(teardown) {
    var _a;
    if (teardown && teardown !== this) {
      if (this.closed) {
        execFinalizer(teardown);
      } else {
        if (teardown instanceof Subscription2) {
          if (teardown.closed || teardown._hasParent(this)) {
            return;
          }
          teardown._addParent(this);
        }
        (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
      }
    }
  };
  Subscription2.prototype._hasParent = function(parent) {
    var _parentage = this._parentage;
    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
  };
  Subscription2.prototype._addParent = function(parent) {
    var _parentage = this._parentage;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
  };
  Subscription2.prototype._removeParent = function(parent) {
    var _parentage = this._parentage;
    if (_parentage === parent) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      arrRemove(_parentage, parent);
    }
  };
  Subscription2.prototype.remove = function(teardown) {
    var _finalizers = this._finalizers;
    _finalizers && arrRemove(_finalizers, teardown);
    if (teardown instanceof Subscription2) {
      teardown._removeParent(this);
    }
  };
  Subscription2.EMPTY = function() {
    var empty2 = new Subscription2();
    empty2.closed = true;
    return empty2;
  }();
  return Subscription2;
}();
var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value) {
  return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
}
function execFinalizer(finalizer) {
  if (isFunction(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}

// node_modules/rxjs/dist/esm5/internal/config.js
var config = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};

// node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js
var timeoutProvider = {
  setTimeout: function(handler, timeout2) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var delegate = timeoutProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
      return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout2], __read(args)));
    }
    return setTimeout.apply(void 0, __spreadArray([handler, timeout2], __read(args)));
  },
  clearTimeout: function(handle) {
    var delegate = timeoutProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js
function reportUnhandledError(err) {
  timeoutProvider.setTimeout(function() {
    var onUnhandledError = config.onUnhandledError;
    if (onUnhandledError) {
      onUnhandledError(err);
    } else {
      throw err;
    }
  });
}

// node_modules/rxjs/dist/esm5/internal/util/noop.js
function noop() {
}

// node_modules/rxjs/dist/esm5/internal/NotificationFactories.js
var COMPLETE_NOTIFICATION = function() {
  return createNotification("C", void 0, void 0);
}();
function errorNotification(error2) {
  return createNotification("E", void 0, error2);
}
function nextNotification(value) {
  return createNotification("N", value, void 0);
}
function createNotification(kind, value, error2) {
  return {
    kind,
    value,
    error: error2
  };
}

// node_modules/rxjs/dist/esm5/internal/util/errorContext.js
var context = null;
function errorContext(cb) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    var isRoot = !context;
    if (isRoot) {
      context = { errorThrown: false, error: null };
    }
    cb();
    if (isRoot) {
      var _a = context, errorThrown = _a.errorThrown, error2 = _a.error;
      context = null;
      if (errorThrown) {
        throw error2;
      }
    }
  } else {
    cb();
  }
}
function captureError(err) {
  if (config.useDeprecatedSynchronousErrorHandling && context) {
    context.errorThrown = true;
    context.error = err;
  }
}

// node_modules/rxjs/dist/esm5/internal/Subscriber.js
var Subscriber = function(_super) {
  __extends(Subscriber3, _super);
  function Subscriber3(destination) {
    var _this = _super.call(this) || this;
    _this.isStopped = false;
    if (destination) {
      _this.destination = destination;
      if (isSubscription(destination)) {
        destination.add(_this);
      }
    } else {
      _this.destination = EMPTY_OBSERVER;
    }
    return _this;
  }
  Subscriber3.create = function(next, error2, complete) {
    return new SafeSubscriber(next, error2, complete);
  };
  Subscriber3.prototype.next = function(value) {
    if (this.isStopped) {
      handleStoppedNotification(nextNotification(value), this);
    } else {
      this._next(value);
    }
  };
  Subscriber3.prototype.error = function(err) {
    if (this.isStopped) {
      handleStoppedNotification(errorNotification(err), this);
    } else {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber3.prototype.complete = function() {
    if (this.isStopped) {
      handleStoppedNotification(COMPLETE_NOTIFICATION, this);
    } else {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber3.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.isStopped = true;
      _super.prototype.unsubscribe.call(this);
      this.destination = null;
    }
  };
  Subscriber3.prototype._next = function(value) {
    this.destination.next(value);
  };
  Subscriber3.prototype._error = function(err) {
    try {
      this.destination.error(err);
    } finally {
      this.unsubscribe();
    }
  };
  Subscriber3.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  };
  return Subscriber3;
}(Subscription);
var _bind = Function.prototype.bind;
function bind(fn, thisArg) {
  return _bind.call(fn, thisArg);
}
var ConsumerObserver = function() {
  function ConsumerObserver2(partialObserver) {
    this.partialObserver = partialObserver;
  }
  ConsumerObserver2.prototype.next = function(value) {
    var partialObserver = this.partialObserver;
    if (partialObserver.next) {
      try {
        partialObserver.next(value);
      } catch (error2) {
        handleUnhandledError(error2);
      }
    }
  };
  ConsumerObserver2.prototype.error = function(err) {
    var partialObserver = this.partialObserver;
    if (partialObserver.error) {
      try {
        partialObserver.error(err);
      } catch (error2) {
        handleUnhandledError(error2);
      }
    } else {
      handleUnhandledError(err);
    }
  };
  ConsumerObserver2.prototype.complete = function() {
    var partialObserver = this.partialObserver;
    if (partialObserver.complete) {
      try {
        partialObserver.complete();
      } catch (error2) {
        handleUnhandledError(error2);
      }
    }
  };
  return ConsumerObserver2;
}();
var SafeSubscriber = function(_super) {
  __extends(SafeSubscriber2, _super);
  function SafeSubscriber2(observerOrNext, error2, complete) {
    var _this = _super.call(this) || this;
    var partialObserver;
    if (isFunction(observerOrNext) || !observerOrNext) {
      partialObserver = {
        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
        error: error2 !== null && error2 !== void 0 ? error2 : void 0,
        complete: complete !== null && complete !== void 0 ? complete : void 0
      };
    } else {
      var context_1;
      if (_this && config.useDeprecatedNextContext) {
        context_1 = Object.create(observerOrNext);
        context_1.unsubscribe = function() {
          return _this.unsubscribe();
        };
        partialObserver = {
          next: observerOrNext.next && bind(observerOrNext.next, context_1),
          error: observerOrNext.error && bind(observerOrNext.error, context_1),
          complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
        };
      } else {
        partialObserver = observerOrNext;
      }
    }
    _this.destination = new ConsumerObserver(partialObserver);
    return _this;
  }
  return SafeSubscriber2;
}(Subscriber);
function handleUnhandledError(error2) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    captureError(error2);
  } else {
    reportUnhandledError(error2);
  }
}
function defaultErrorHandler(err) {
  throw err;
}
function handleStoppedNotification(notification, subscriber) {
  var onStoppedNotification = config.onStoppedNotification;
  onStoppedNotification && timeoutProvider.setTimeout(function() {
    return onStoppedNotification(notification, subscriber);
  });
}
var EMPTY_OBSERVER = {
  closed: true,
  next: noop,
  error: defaultErrorHandler,
  complete: noop
};

// node_modules/rxjs/dist/esm5/internal/symbol/observable.js
var observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();

// node_modules/rxjs/dist/esm5/internal/util/identity.js
function identity(x) {
  return x;
}

// node_modules/rxjs/dist/esm5/internal/util/pipe.js
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev, fn) {
      return fn(prev);
    }, input);
  };
}

// node_modules/rxjs/dist/esm5/internal/Observable.js
var Observable = function() {
  function Observable2(subscribe) {
    if (subscribe) {
      this._subscribe = subscribe;
    }
  }
  Observable2.prototype.lift = function(operator) {
    var observable2 = new Observable2();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable2.prototype.subscribe = function(observerOrNext, error2, complete) {
    var _this = this;
    var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error2, complete);
    errorContext(function() {
      var _a = _this, operator = _a.operator, source = _a.source;
      subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
    });
    return subscriber;
  };
  Observable2.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      sink.error(err);
    }
  };
  Observable2.prototype.forEach = function(next, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var subscriber = new SafeSubscriber({
        next: function(value) {
          try {
            next(value);
          } catch (err) {
            reject(err);
            subscriber.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
      _this.subscribe(subscriber);
    });
  };
  Observable2.prototype._subscribe = function(subscriber) {
    var _a;
    return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
  };
  Observable2.prototype[observable] = function() {
    return this;
  };
  Observable2.prototype.pipe = function() {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    return pipeFromArray(operations)(this);
  };
  Observable2.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var value;
      _this.subscribe(function(x) {
        return value = x;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve(value);
      });
    });
  };
  Observable2.create = function(subscribe) {
    return new Observable2(subscribe);
  };
  return Observable2;
}();
function getPromiseCtor(promiseCtor) {
  var _a;
  return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;
}
function isObserver(value) {
  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
}
function isSubscriber(value) {
  return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
}

// node_modules/rxjs/dist/esm5/internal/util/lift.js
function hasLift(source) {
  return isFunction(source === null || source === void 0 ? void 0 : source.lift);
}
function operate(init2) {
  return function(source) {
    if (hasLift(source)) {
      return source.lift(function(liftedSource) {
        try {
          return init2(liftedSource, this);
        } catch (err) {
          this.error(err);
        }
      });
    }
    throw new TypeError("Unable to lift unknown Observable type");
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js
function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
var OperatorSubscriber = function(_super) {
  __extends(OperatorSubscriber2, _super);
  function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
    var _this = _super.call(this, destination) || this;
    _this.onFinalize = onFinalize;
    _this.shouldUnsubscribe = shouldUnsubscribe;
    _this._next = onNext ? function(value) {
      try {
        onNext(value);
      } catch (err) {
        destination.error(err);
      }
    } : _super.prototype._next;
    _this._error = onError ? function(err) {
      try {
        onError(err);
      } catch (err2) {
        destination.error(err2);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._error;
    _this._complete = onComplete ? function() {
      try {
        onComplete();
      } catch (err) {
        destination.error(err);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._complete;
    return _this;
  }
  OperatorSubscriber2.prototype.unsubscribe = function() {
    var _a;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var closed_1 = this.closed;
      _super.prototype.unsubscribe.call(this);
      !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
    }
  };
  return OperatorSubscriber2;
}(Subscriber);

// node_modules/rxjs/dist/esm5/internal/operators/refCount.js
function refCount() {
  return operate(function(source, subscriber) {
    var connection = null;
    source._refCount++;
    var refCounter = createOperatorSubscriber(subscriber, void 0, void 0, void 0, function() {
      if (!source || source._refCount <= 0 || 0 < --source._refCount) {
        connection = null;
        return;
      }
      var sharedConnection = source._connection;
      var conn = connection;
      connection = null;
      if (sharedConnection && (!conn || sharedConnection === conn)) {
        sharedConnection.unsubscribe();
      }
      subscriber.unsubscribe();
    });
    source.subscribe(refCounter);
    if (!refCounter.closed) {
      connection = source.connect();
    }
  });
}

// node_modules/rxjs/dist/esm5/internal/observable/ConnectableObservable.js
var ConnectableObservable = function(_super) {
  __extends(ConnectableObservable2, _super);
  function ConnectableObservable2(source, subjectFactory) {
    var _this = _super.call(this) || this;
    _this.source = source;
    _this.subjectFactory = subjectFactory;
    _this._subject = null;
    _this._refCount = 0;
    _this._connection = null;
    if (hasLift(source)) {
      _this.lift = source.lift;
    }
    return _this;
  }
  ConnectableObservable2.prototype._subscribe = function(subscriber) {
    return this.getSubject().subscribe(subscriber);
  };
  ConnectableObservable2.prototype.getSubject = function() {
    var subject = this._subject;
    if (!subject || subject.isStopped) {
      this._subject = this.subjectFactory();
    }
    return this._subject;
  };
  ConnectableObservable2.prototype._teardown = function() {
    this._refCount = 0;
    var _connection = this._connection;
    this._subject = this._connection = null;
    _connection === null || _connection === void 0 ? void 0 : _connection.unsubscribe();
  };
  ConnectableObservable2.prototype.connect = function() {
    var _this = this;
    var connection = this._connection;
    if (!connection) {
      connection = this._connection = new Subscription();
      var subject_1 = this.getSubject();
      connection.add(this.source.subscribe(createOperatorSubscriber(subject_1, void 0, function() {
        _this._teardown();
        subject_1.complete();
      }, function(err) {
        _this._teardown();
        subject_1.error(err);
      }, function() {
        return _this._teardown();
      })));
      if (connection.closed) {
        this._connection = null;
        connection = Subscription.EMPTY;
      }
    }
    return connection;
  };
  ConnectableObservable2.prototype.refCount = function() {
    return refCount()(this);
  };
  return ConnectableObservable2;
}(Observable);

// node_modules/rxjs/dist/esm5/internal/scheduler/performanceTimestampProvider.js
var performanceTimestampProvider = {
  now: function() {
    return (performanceTimestampProvider.delegate || performance).now();
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/scheduler/animationFrameProvider.js
var animationFrameProvider = {
  schedule: function(callback) {
    var request = requestAnimationFrame;
    var cancel = cancelAnimationFrame;
    var delegate = animationFrameProvider.delegate;
    if (delegate) {
      request = delegate.requestAnimationFrame;
      cancel = delegate.cancelAnimationFrame;
    }
    var handle = request(function(timestamp2) {
      cancel = void 0;
      callback(timestamp2);
    });
    return new Subscription(function() {
      return cancel === null || cancel === void 0 ? void 0 : cancel(handle);
    });
  },
  requestAnimationFrame: function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var delegate = animationFrameProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.requestAnimationFrame) || requestAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
  },
  cancelAnimationFrame: function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var delegate = animationFrameProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.cancelAnimationFrame) || cancelAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/observable/dom/animationFrames.js
function animationFramesFactory(timestampProvider) {
  return new Observable(function(subscriber) {
    var provider = timestampProvider || performanceTimestampProvider;
    var start = provider.now();
    var id = 0;
    var run = function() {
      if (!subscriber.closed) {
        id = animationFrameProvider.requestAnimationFrame(function(timestamp2) {
          id = 0;
          var now = provider.now();
          subscriber.next({
            timestamp: timestampProvider ? now : timestamp2,
            elapsed: now - start
          });
          run();
        });
      }
    };
    run();
    return function() {
      if (id) {
        animationFrameProvider.cancelAnimationFrame(id);
      }
    };
  });
}
var DEFAULT_ANIMATION_FRAMES = animationFramesFactory();

// node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js
var ObjectUnsubscribedError = createErrorClass(function(_super) {
  return function ObjectUnsubscribedErrorImpl() {
    _super(this);
    this.name = "ObjectUnsubscribedError";
    this.message = "object unsubscribed";
  };
});

// node_modules/rxjs/dist/esm5/internal/Subject.js
var Subject = function(_super) {
  __extends(Subject2, _super);
  function Subject2() {
    var _this = _super.call(this) || this;
    _this.closed = false;
    _this.currentObservers = null;
    _this.observers = [];
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }
  Subject2.prototype.lift = function(operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  };
  Subject2.prototype._throwIfClosed = function() {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
  };
  Subject2.prototype.next = function(value) {
    var _this = this;
    errorContext(function() {
      var e_1, _a;
      _this._throwIfClosed();
      if (!_this.isStopped) {
        if (!_this.currentObservers) {
          _this.currentObservers = Array.from(_this.observers);
        }
        try {
          for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
            var observer = _c.value;
            observer.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
      }
    });
  };
  Subject2.prototype.error = function(err) {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.hasError = _this.isStopped = true;
        _this.thrownError = err;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().error(err);
        }
      }
    });
  };
  Subject2.prototype.complete = function() {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.isStopped = true;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().complete();
        }
      }
    });
  };
  Subject2.prototype.unsubscribe = function() {
    this.isStopped = this.closed = true;
    this.observers = this.currentObservers = null;
  };
  Object.defineProperty(Subject2.prototype, "observed", {
    get: function() {
      var _a;
      return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
    },
    enumerable: false,
    configurable: true
  });
  Subject2.prototype._trySubscribe = function(subscriber) {
    this._throwIfClosed();
    return _super.prototype._trySubscribe.call(this, subscriber);
  };
  Subject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._checkFinalizedStatuses(subscriber);
    return this._innerSubscribe(subscriber);
  };
  Subject2.prototype._innerSubscribe = function(subscriber) {
    var _this = this;
    var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
    if (hasError || isStopped) {
      return EMPTY_SUBSCRIPTION;
    }
    this.currentObservers = null;
    observers.push(subscriber);
    return new Subscription(function() {
      _this.currentObservers = null;
      arrRemove(observers, subscriber);
    });
  };
  Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped) {
      subscriber.complete();
    }
  };
  Subject2.prototype.asObservable = function() {
    var observable2 = new Observable();
    observable2.source = this;
    return observable2;
  };
  Subject2.create = function(destination, source) {
    return new AnonymousSubject(destination, source);
  };
  return Subject2;
}(Observable);
var AnonymousSubject = function(_super) {
  __extends(AnonymousSubject2, _super);
  function AnonymousSubject2(destination, source) {
    var _this = _super.call(this) || this;
    _this.destination = destination;
    _this.source = source;
    return _this;
  }
  AnonymousSubject2.prototype.next = function(value) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
  };
  AnonymousSubject2.prototype.error = function(err) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
  };
  AnonymousSubject2.prototype.complete = function() {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
  };
  AnonymousSubject2.prototype._subscribe = function(subscriber) {
    var _a, _b;
    return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
  };
  return AnonymousSubject2;
}(Subject);

// node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js
var BehaviorSubject = function(_super) {
  __extends(BehaviorSubject2, _super);
  function BehaviorSubject2(_value) {
    var _this = _super.call(this) || this;
    _this._value = _value;
    return _this;
  }
  Object.defineProperty(BehaviorSubject2.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: false,
    configurable: true
  });
  BehaviorSubject2.prototype._subscribe = function(subscriber) {
    var subscription = _super.prototype._subscribe.call(this, subscriber);
    !subscription.closed && subscriber.next(this._value);
    return subscription;
  };
  BehaviorSubject2.prototype.getValue = function() {
    var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
    if (hasError) {
      throw thrownError;
    }
    this._throwIfClosed();
    return _value;
  };
  BehaviorSubject2.prototype.next = function(value) {
    _super.prototype.next.call(this, this._value = value);
  };
  return BehaviorSubject2;
}(Subject);

// node_modules/rxjs/dist/esm5/internal/scheduler/dateTimestampProvider.js
var dateTimestampProvider = {
  now: function() {
    return (dateTimestampProvider.delegate || Date).now();
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/ReplaySubject.js
var ReplaySubject = function(_super) {
  __extends(ReplaySubject2, _super);
  function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
    if (_bufferSize === void 0) {
      _bufferSize = Infinity;
    }
    if (_windowTime === void 0) {
      _windowTime = Infinity;
    }
    if (_timestampProvider === void 0) {
      _timestampProvider = dateTimestampProvider;
    }
    var _this = _super.call(this) || this;
    _this._bufferSize = _bufferSize;
    _this._windowTime = _windowTime;
    _this._timestampProvider = _timestampProvider;
    _this._buffer = [];
    _this._infiniteTimeWindow = true;
    _this._infiniteTimeWindow = _windowTime === Infinity;
    _this._bufferSize = Math.max(1, _bufferSize);
    _this._windowTime = Math.max(1, _windowTime);
    return _this;
  }
  ReplaySubject2.prototype.next = function(value) {
    var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;
    if (!isStopped) {
      _buffer.push(value);
      !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
    }
    this._trimBuffer();
    _super.prototype.next.call(this, value);
  };
  ReplaySubject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._trimBuffer();
    var subscription = this._innerSubscribe(subscriber);
    var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow, _buffer = _a._buffer;
    var copy3 = _buffer.slice();
    for (var i = 0; i < copy3.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {
      subscriber.next(copy3[i]);
    }
    this._checkFinalizedStatuses(subscriber);
    return subscription;
  };
  ReplaySubject2.prototype._trimBuffer = function() {
    var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;
    var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
    _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
    if (!_infiniteTimeWindow) {
      var now = _timestampProvider.now();
      var last3 = 0;
      for (var i = 1; i < _buffer.length && _buffer[i] <= now; i += 2) {
        last3 = i;
      }
      last3 && _buffer.splice(0, last3 + 1);
    }
  };
  return ReplaySubject2;
}(Subject);

// node_modules/rxjs/dist/esm5/internal/AsyncSubject.js
var AsyncSubject = function(_super) {
  __extends(AsyncSubject2, _super);
  function AsyncSubject2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._value = null;
    _this._hasValue = false;
    _this._isComplete = false;
    return _this;
  }
  AsyncSubject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a = this, hasError = _a.hasError, _hasValue = _a._hasValue, _value = _a._value, thrownError = _a.thrownError, isStopped = _a.isStopped, _isComplete = _a._isComplete;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped || _isComplete) {
      _hasValue && subscriber.next(_value);
      subscriber.complete();
    }
  };
  AsyncSubject2.prototype.next = function(value) {
    if (!this.isStopped) {
      this._value = value;
      this._hasValue = true;
    }
  };
  AsyncSubject2.prototype.complete = function() {
    var _a = this, _hasValue = _a._hasValue, _value = _a._value, _isComplete = _a._isComplete;
    if (!_isComplete) {
      this._isComplete = true;
      _hasValue && _super.prototype.next.call(this, _value);
      _super.prototype.complete.call(this);
    }
  };
  return AsyncSubject2;
}(Subject);

// node_modules/rxjs/dist/esm5/internal/scheduler/Action.js
var Action = function(_super) {
  __extends(Action2, _super);
  function Action2(scheduler, work) {
    return _super.call(this) || this;
  }
  Action2.prototype.schedule = function(state, delay3) {
    if (delay3 === void 0) {
      delay3 = 0;
    }
    return this;
  };
  return Action2;
}(Subscription);

// node_modules/rxjs/dist/esm5/internal/scheduler/intervalProvider.js
var intervalProvider = {
  setInterval: function(handler, timeout2) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var delegate = intervalProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
      return delegate.setInterval.apply(delegate, __spreadArray([handler, timeout2], __read(args)));
    }
    return setInterval.apply(void 0, __spreadArray([handler, timeout2], __read(args)));
  },
  clearInterval: function(handle) {
    var delegate = intervalProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/scheduler/AsyncAction.js
var AsyncAction = function(_super) {
  __extends(AsyncAction2, _super);
  function AsyncAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.pending = false;
    return _this;
  }
  AsyncAction2.prototype.schedule = function(state, delay3) {
    var _a;
    if (delay3 === void 0) {
      delay3 = 0;
    }
    if (this.closed) {
      return this;
    }
    this.state = state;
    var id = this.id;
    var scheduler = this.scheduler;
    if (id != null) {
      this.id = this.recycleAsyncId(scheduler, id, delay3);
    }
    this.pending = true;
    this.delay = delay3;
    this.id = (_a = this.id) !== null && _a !== void 0 ? _a : this.requestAsyncId(scheduler, this.id, delay3);
    return this;
  };
  AsyncAction2.prototype.requestAsyncId = function(scheduler, _id, delay3) {
    if (delay3 === void 0) {
      delay3 = 0;
    }
    return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay3);
  };
  AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id, delay3) {
    if (delay3 === void 0) {
      delay3 = 0;
    }
    if (delay3 != null && this.delay === delay3 && this.pending === false) {
      return id;
    }
    if (id != null) {
      intervalProvider.clearInterval(id);
    }
    return void 0;
  };
  AsyncAction2.prototype.execute = function(state, delay3) {
    if (this.closed) {
      return new Error("executing a cancelled action");
    }
    this.pending = false;
    var error2 = this._execute(state, delay3);
    if (error2) {
      return error2;
    } else if (this.pending === false && this.id != null) {
      this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    }
  };
  AsyncAction2.prototype._execute = function(state, _delay) {
    var errored = false;
    var errorValue;
    try {
      this.work(state);
    } catch (e) {
      errored = true;
      errorValue = e ? e : new Error("Scheduled action threw falsy error");
    }
    if (errored) {
      this.unsubscribe();
      return errorValue;
    }
  };
  AsyncAction2.prototype.unsubscribe = function() {
    if (!this.closed) {
      var _a = this, id = _a.id, scheduler = _a.scheduler;
      var actions = scheduler.actions;
      this.work = this.state = this.scheduler = null;
      this.pending = false;
      arrRemove(actions, this);
      if (id != null) {
        this.id = this.recycleAsyncId(scheduler, id, null);
      }
      this.delay = null;
      _super.prototype.unsubscribe.call(this);
    }
  };
  return AsyncAction2;
}(Action);

// node_modules/rxjs/dist/esm5/internal/util/Immediate.js
var nextHandle = 1;
var resolved;
var activeHandles = {};
function findAndClearHandle(handle) {
  if (handle in activeHandles) {
    delete activeHandles[handle];
    return true;
  }
  return false;
}
var Immediate = {
  setImmediate: function(cb) {
    var handle = nextHandle++;
    activeHandles[handle] = true;
    if (!resolved) {
      resolved = Promise.resolve();
    }
    resolved.then(function() {
      return findAndClearHandle(handle) && cb();
    });
    return handle;
  },
  clearImmediate: function(handle) {
    findAndClearHandle(handle);
  }
};

// node_modules/rxjs/dist/esm5/internal/scheduler/immediateProvider.js
var setImmediate = Immediate.setImmediate;
var clearImmediate = Immediate.clearImmediate;
var immediateProvider = {
  setImmediate: function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var delegate = immediateProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.setImmediate) || setImmediate).apply(void 0, __spreadArray([], __read(args)));
  },
  clearImmediate: function(handle) {
    var delegate = immediateProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearImmediate) || clearImmediate)(handle);
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/scheduler/AsapAction.js
var AsapAction = function(_super) {
  __extends(AsapAction2, _super);
  function AsapAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  AsapAction2.prototype.requestAsyncId = function(scheduler, id, delay3) {
    if (delay3 === void 0) {
      delay3 = 0;
    }
    if (delay3 !== null && delay3 > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay3);
    }
    scheduler.actions.push(this);
    return scheduler._scheduled || (scheduler._scheduled = immediateProvider.setImmediate(scheduler.flush.bind(scheduler, void 0)));
  };
  AsapAction2.prototype.recycleAsyncId = function(scheduler, id, delay3) {
    var _a;
    if (delay3 === void 0) {
      delay3 = 0;
    }
    if (delay3 != null ? delay3 > 0 : this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay3);
    }
    var actions = scheduler.actions;
    if (id != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {
      immediateProvider.clearImmediate(id);
      if (scheduler._scheduled === id) {
        scheduler._scheduled = void 0;
      }
    }
    return void 0;
  };
  return AsapAction2;
}(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/Scheduler.js
var Scheduler = function() {
  function Scheduler2(schedulerActionCtor, now) {
    if (now === void 0) {
      now = Scheduler2.now;
    }
    this.schedulerActionCtor = schedulerActionCtor;
    this.now = now;
  }
  Scheduler2.prototype.schedule = function(work, delay3, state) {
    if (delay3 === void 0) {
      delay3 = 0;
    }
    return new this.schedulerActionCtor(this, work).schedule(state, delay3);
  };
  Scheduler2.now = dateTimestampProvider.now;
  return Scheduler2;
}();

// node_modules/rxjs/dist/esm5/internal/scheduler/AsyncScheduler.js
var AsyncScheduler = function(_super) {
  __extends(AsyncScheduler2, _super);
  function AsyncScheduler2(SchedulerAction, now) {
    if (now === void 0) {
      now = Scheduler.now;
    }
    var _this = _super.call(this, SchedulerAction, now) || this;
    _this.actions = [];
    _this._active = false;
    return _this;
  }
  AsyncScheduler2.prototype.flush = function(action) {
    var actions = this.actions;
    if (this._active) {
      actions.push(action);
      return;
    }
    var error2;
    this._active = true;
    do {
      if (error2 = action.execute(action.state, action.delay)) {
        break;
      }
    } while (action = actions.shift());
    this._active = false;
    if (error2) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error2;
    }
  };
  return AsyncScheduler2;
}(Scheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/AsapScheduler.js
var AsapScheduler = function(_super) {
  __extends(AsapScheduler2, _super);
  function AsapScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AsapScheduler2.prototype.flush = function(action) {
    this._active = true;
    var flushId = this._scheduled;
    this._scheduled = void 0;
    var actions = this.actions;
    var error2;
    action = action || actions.shift();
    do {
      if (error2 = action.execute(action.state, action.delay)) {
        break;
      }
    } while ((action = actions[0]) && action.id === flushId && actions.shift());
    this._active = false;
    if (error2) {
      while ((action = actions[0]) && action.id === flushId && actions.shift()) {
        action.unsubscribe();
      }
      throw error2;
    }
  };
  return AsapScheduler2;
}(AsyncScheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/asap.js
var asapScheduler = new AsapScheduler(AsapAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/async.js
var asyncScheduler = new AsyncScheduler(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/QueueAction.js
var QueueAction = function(_super) {
  __extends(QueueAction2, _super);
  function QueueAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  QueueAction2.prototype.schedule = function(state, delay3) {
    if (delay3 === void 0) {
      delay3 = 0;
    }
    if (delay3 > 0) {
      return _super.prototype.schedule.call(this, state, delay3);
    }
    this.delay = delay3;
    this.state = state;
    this.scheduler.flush(this);
    return this;
  };
  QueueAction2.prototype.execute = function(state, delay3) {
    return delay3 > 0 || this.closed ? _super.prototype.execute.call(this, state, delay3) : this._execute(state, delay3);
  };
  QueueAction2.prototype.requestAsyncId = function(scheduler, id, delay3) {
    if (delay3 === void 0) {
      delay3 = 0;
    }
    if (delay3 != null && delay3 > 0 || delay3 == null && this.delay > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay3);
    }
    scheduler.flush(this);
    return 0;
  };
  return QueueAction2;
}(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/QueueScheduler.js
var QueueScheduler = function(_super) {
  __extends(QueueScheduler2, _super);
  function QueueScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return QueueScheduler2;
}(AsyncScheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/queue.js
var queueScheduler = new QueueScheduler(QueueAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/AnimationFrameAction.js
var AnimationFrameAction = function(_super) {
  __extends(AnimationFrameAction2, _super);
  function AnimationFrameAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  AnimationFrameAction2.prototype.requestAsyncId = function(scheduler, id, delay3) {
    if (delay3 === void 0) {
      delay3 = 0;
    }
    if (delay3 !== null && delay3 > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay3);
    }
    scheduler.actions.push(this);
    return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider.requestAnimationFrame(function() {
      return scheduler.flush(void 0);
    }));
  };
  AnimationFrameAction2.prototype.recycleAsyncId = function(scheduler, id, delay3) {
    var _a;
    if (delay3 === void 0) {
      delay3 = 0;
    }
    if (delay3 != null ? delay3 > 0 : this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay3);
    }
    var actions = scheduler.actions;
    if (id != null && id === scheduler._scheduled && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {
      animationFrameProvider.cancelAnimationFrame(id);
      scheduler._scheduled = void 0;
    }
    return void 0;
  };
  return AnimationFrameAction2;
}(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/AnimationFrameScheduler.js
var AnimationFrameScheduler = function(_super) {
  __extends(AnimationFrameScheduler2, _super);
  function AnimationFrameScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AnimationFrameScheduler2.prototype.flush = function(action) {
    this._active = true;
    var flushId;
    if (action) {
      flushId = action.id;
    } else {
      flushId = this._scheduled;
      this._scheduled = void 0;
    }
    var actions = this.actions;
    var error2;
    action = action || actions.shift();
    do {
      if (error2 = action.execute(action.state, action.delay)) {
        break;
      }
    } while ((action = actions[0]) && action.id === flushId && actions.shift());
    this._active = false;
    if (error2) {
      while ((action = actions[0]) && action.id === flushId && actions.shift()) {
        action.unsubscribe();
      }
      throw error2;
    }
  };
  return AnimationFrameScheduler2;
}(AsyncScheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/animationFrame.js
var animationFrameScheduler = new AnimationFrameScheduler(AnimationFrameAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/VirtualTimeScheduler.js
var VirtualTimeScheduler = function(_super) {
  __extends(VirtualTimeScheduler2, _super);
  function VirtualTimeScheduler2(schedulerActionCtor, maxFrames) {
    if (schedulerActionCtor === void 0) {
      schedulerActionCtor = VirtualAction;
    }
    if (maxFrames === void 0) {
      maxFrames = Infinity;
    }
    var _this = _super.call(this, schedulerActionCtor, function() {
      return _this.frame;
    }) || this;
    _this.maxFrames = maxFrames;
    _this.frame = 0;
    _this.index = -1;
    return _this;
  }
  VirtualTimeScheduler2.prototype.flush = function() {
    var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
    var error2;
    var action;
    while ((action = actions[0]) && action.delay <= maxFrames) {
      actions.shift();
      this.frame = action.delay;
      if (error2 = action.execute(action.state, action.delay)) {
        break;
      }
    }
    if (error2) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error2;
    }
  };
  VirtualTimeScheduler2.frameTimeFactor = 10;
  return VirtualTimeScheduler2;
}(AsyncScheduler);
var VirtualAction = function(_super) {
  __extends(VirtualAction2, _super);
  function VirtualAction2(scheduler, work, index3) {
    if (index3 === void 0) {
      index3 = scheduler.index += 1;
    }
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.index = index3;
    _this.active = true;
    _this.index = scheduler.index = index3;
    return _this;
  }
  VirtualAction2.prototype.schedule = function(state, delay3) {
    if (delay3 === void 0) {
      delay3 = 0;
    }
    if (Number.isFinite(delay3)) {
      if (!this.id) {
        return _super.prototype.schedule.call(this, state, delay3);
      }
      this.active = false;
      var action = new VirtualAction2(this.scheduler, this.work);
      this.add(action);
      return action.schedule(state, delay3);
    } else {
      return Subscription.EMPTY;
    }
  };
  VirtualAction2.prototype.requestAsyncId = function(scheduler, id, delay3) {
    if (delay3 === void 0) {
      delay3 = 0;
    }
    this.delay = scheduler.frame + delay3;
    var actions = scheduler.actions;
    actions.push(this);
    actions.sort(VirtualAction2.sortActions);
    return 1;
  };
  VirtualAction2.prototype.recycleAsyncId = function(scheduler, id, delay3) {
    if (delay3 === void 0) {
      delay3 = 0;
    }
    return void 0;
  };
  VirtualAction2.prototype._execute = function(state, delay3) {
    if (this.active === true) {
      return _super.prototype._execute.call(this, state, delay3);
    }
  };
  VirtualAction2.sortActions = function(a, b) {
    if (a.delay === b.delay) {
      if (a.index === b.index) {
        return 0;
      } else if (a.index > b.index) {
        return 1;
      } else {
        return -1;
      }
    } else if (a.delay > b.delay) {
      return 1;
    } else {
      return -1;
    }
  };
  return VirtualAction2;
}(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/observable/empty.js
var EMPTY = new Observable(function(subscriber) {
  return subscriber.complete();
});

// node_modules/rxjs/dist/esm5/internal/util/isScheduler.js
function isScheduler(value) {
  return value && isFunction(value.schedule);
}

// node_modules/rxjs/dist/esm5/internal/util/args.js
function last(arr) {
  return arr[arr.length - 1];
}
function popResultSelector(args) {
  return isFunction(last(args)) ? args.pop() : void 0;
}
function popScheduler(args) {
  return isScheduler(last(args)) ? args.pop() : void 0;
}
function popNumber(args, defaultValue) {
  return typeof last(args) === "number" ? args.pop() : defaultValue;
}

// node_modules/rxjs/dist/esm5/internal/util/isArrayLike.js
var isArrayLike = function(x) {
  return x && typeof x.length === "number" && typeof x !== "function";
};

// node_modules/rxjs/dist/esm5/internal/util/isPromise.js
function isPromise(value) {
  return isFunction(value === null || value === void 0 ? void 0 : value.then);
}

// node_modules/rxjs/dist/esm5/internal/util/isInteropObservable.js
function isInteropObservable(input) {
  return isFunction(input[observable]);
}

// node_modules/rxjs/dist/esm5/internal/util/isAsyncIterable.js
function isAsyncIterable(obj) {
  return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}

// node_modules/rxjs/dist/esm5/internal/util/throwUnobservableError.js
function createInvalidObservableTypeError(input) {
  return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}

// node_modules/rxjs/dist/esm5/internal/symbol/iterator.js
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
var iterator = getSymbolIterator();

// node_modules/rxjs/dist/esm5/internal/util/isIterable.js
function isIterable(input) {
  return isFunction(input === null || input === void 0 ? void 0 : input[iterator]);
}

// node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js
function readableStreamLikeToAsyncGenerator(readableStream) {
  return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
    var reader, _a, value, done;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          reader = readableStream.getReader();
          _b.label = 1;
        case 1:
          _b.trys.push([1, , 9, 10]);
          _b.label = 2;
        case 2:
          if (false) return [3, 8];
          return [4, __await(reader.read())];
        case 3:
          _a = _b.sent(), value = _a.value, done = _a.done;
          if (!done) return [3, 5];
          return [4, __await(void 0)];
        case 4:
          return [2, _b.sent()];
        case 5:
          return [4, __await(value)];
        case 6:
          return [4, _b.sent()];
        case 7:
          _b.sent();
          return [3, 2];
        case 8:
          return [3, 10];
        case 9:
          reader.releaseLock();
          return [7];
        case 10:
          return [2];
      }
    });
  });
}
function isReadableStreamLike(obj) {
  return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
}

// node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js
function innerFrom(input) {
  if (input instanceof Observable) {
    return input;
  }
  if (input != null) {
    if (isInteropObservable(input)) {
      return fromInteropObservable(input);
    }
    if (isArrayLike(input)) {
      return fromArrayLike(input);
    }
    if (isPromise(input)) {
      return fromPromise(input);
    }
    if (isAsyncIterable(input)) {
      return fromAsyncIterable(input);
    }
    if (isIterable(input)) {
      return fromIterable(input);
    }
    if (isReadableStreamLike(input)) {
      return fromReadableStreamLike(input);
    }
  }
  throw createInvalidObservableTypeError(input);
}
function fromInteropObservable(obj) {
  return new Observable(function(subscriber) {
    var obs = obj[observable]();
    if (isFunction(obs.subscribe)) {
      return obs.subscribe(subscriber);
    }
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function fromArrayLike(array) {
  return new Observable(function(subscriber) {
    for (var i = 0; i < array.length && !subscriber.closed; i++) {
      subscriber.next(array[i]);
    }
    subscriber.complete();
  });
}
function fromPromise(promise) {
  return new Observable(function(subscriber) {
    promise.then(function(value) {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, function(err) {
      return subscriber.error(err);
    }).then(null, reportUnhandledError);
  });
}
function fromIterable(iterable) {
  return new Observable(function(subscriber) {
    var e_1, _a;
    try {
      for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
        var value = iterable_1_1.value;
        subscriber.next(value);
        if (subscriber.closed) {
          return;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) _a.call(iterable_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
    subscriber.complete();
  });
}
function fromAsyncIterable(asyncIterable) {
  return new Observable(function(subscriber) {
    process2(asyncIterable, subscriber).catch(function(err) {
      return subscriber.error(err);
    });
  });
}
function fromReadableStreamLike(readableStream) {
  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
}
function process2(asyncIterable, subscriber) {
  var asyncIterable_1, asyncIterable_1_1;
  var e_2, _a;
  return __awaiter(this, void 0, void 0, function() {
    var value, e_2_1;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          _b.trys.push([0, 5, 6, 11]);
          asyncIterable_1 = __asyncValues(asyncIterable);
          _b.label = 1;
        case 1:
          return [4, asyncIterable_1.next()];
        case 2:
          if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done)) return [3, 4];
          value = asyncIterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return [2];
          }
          _b.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          e_2_1 = _b.sent();
          e_2 = { error: e_2_1 };
          return [3, 11];
        case 6:
          _b.trys.push([6, , 9, 10]);
          if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return))) return [3, 8];
          return [4, _a.call(asyncIterable_1)];
        case 7:
          _b.sent();
          _b.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (e_2) throw e_2.error;
          return [7];
        case 10:
          return [7];
        case 11:
          subscriber.complete();
          return [2];
      }
    });
  });
}

// node_modules/rxjs/dist/esm5/internal/util/executeSchedule.js
function executeSchedule(parentSubscription, scheduler, work, delay3, repeat2) {
  if (delay3 === void 0) {
    delay3 = 0;
  }
  if (repeat2 === void 0) {
    repeat2 = false;
  }
  var scheduleSubscription = scheduler.schedule(function() {
    work();
    if (repeat2) {
      parentSubscription.add(this.schedule(null, delay3));
    } else {
      this.unsubscribe();
    }
  }, delay3);
  parentSubscription.add(scheduleSubscription);
  if (!repeat2) {
    return scheduleSubscription;
  }
}

// node_modules/rxjs/dist/esm5/internal/operators/observeOn.js
function observeOn(scheduler, delay3) {
  if (delay3 === void 0) {
    delay3 = 0;
  }
  return operate(function(source, subscriber) {
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.next(value);
      }, delay3);
    }, function() {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.complete();
      }, delay3);
    }, function(err) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.error(err);
      }, delay3);
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/subscribeOn.js
function subscribeOn(scheduler, delay3) {
  if (delay3 === void 0) {
    delay3 = 0;
  }
  return operate(function(source, subscriber) {
    subscriber.add(scheduler.schedule(function() {
      return source.subscribe(subscriber);
    }, delay3));
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleObservable.js
function scheduleObservable(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}

// node_modules/rxjs/dist/esm5/internal/scheduled/schedulePromise.js
function schedulePromise(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleArray.js
function scheduleArray(input, scheduler) {
  return new Observable(function(subscriber) {
    var i = 0;
    return scheduler.schedule(function() {
      if (i === input.length) {
        subscriber.complete();
      } else {
        subscriber.next(input[i++]);
        if (!subscriber.closed) {
          this.schedule();
        }
      }
    });
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleIterable.js
function scheduleIterable(input, scheduler) {
  return new Observable(function(subscriber) {
    var iterator2;
    executeSchedule(subscriber, scheduler, function() {
      iterator2 = input[iterator]();
      executeSchedule(subscriber, scheduler, function() {
        var _a;
        var value;
        var done;
        try {
          _a = iterator2.next(), value = _a.value, done = _a.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done) {
          subscriber.complete();
        } else {
          subscriber.next(value);
        }
      }, 0, true);
    });
    return function() {
      return isFunction(iterator2 === null || iterator2 === void 0 ? void 0 : iterator2.return) && iterator2.return();
    };
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleAsyncIterable.js
function scheduleAsyncIterable(input, scheduler) {
  if (!input) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable(function(subscriber) {
    executeSchedule(subscriber, scheduler, function() {
      var iterator2 = input[Symbol.asyncIterator]();
      executeSchedule(subscriber, scheduler, function() {
        iterator2.next().then(function(result) {
          if (result.done) {
            subscriber.complete();
          } else {
            subscriber.next(result.value);
          }
        });
      }, 0, true);
    });
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleReadableStreamLike.js
function scheduleReadableStreamLike(input, scheduler) {
  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduled.js
function scheduled(input, scheduler) {
  if (input != null) {
    if (isInteropObservable(input)) {
      return scheduleObservable(input, scheduler);
    }
    if (isArrayLike(input)) {
      return scheduleArray(input, scheduler);
    }
    if (isPromise(input)) {
      return schedulePromise(input, scheduler);
    }
    if (isAsyncIterable(input)) {
      return scheduleAsyncIterable(input, scheduler);
    }
    if (isIterable(input)) {
      return scheduleIterable(input, scheduler);
    }
    if (isReadableStreamLike(input)) {
      return scheduleReadableStreamLike(input, scheduler);
    }
  }
  throw createInvalidObservableTypeError(input);
}

// node_modules/rxjs/dist/esm5/internal/observable/from.js
function from(input, scheduler) {
  return scheduler ? scheduled(input, scheduler) : innerFrom(input);
}

// node_modules/rxjs/dist/esm5/internal/observable/of.js
function of() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  return from(args, scheduler);
}

// node_modules/rxjs/dist/esm5/internal/observable/throwError.js
function throwError(errorOrErrorFactory, scheduler) {
  var errorFactory = isFunction(errorOrErrorFactory) ? errorOrErrorFactory : function() {
    return errorOrErrorFactory;
  };
  var init2 = function(subscriber) {
    return subscriber.error(errorFactory());
  };
  return new Observable(scheduler ? function(subscriber) {
    return scheduler.schedule(init2, 0, subscriber);
  } : init2);
}

// node_modules/rxjs/dist/esm5/internal/Notification.js
var NotificationKind;
(function(NotificationKind2) {
  NotificationKind2["NEXT"] = "N";
  NotificationKind2["ERROR"] = "E";
  NotificationKind2["COMPLETE"] = "C";
})(NotificationKind || (NotificationKind = {}));
var Notification = function() {
  function Notification3(kind, value, error2) {
    this.kind = kind;
    this.value = value;
    this.error = error2;
    this.hasValue = kind === "N";
  }
  Notification3.prototype.observe = function(observer) {
    return observeNotification(this, observer);
  };
  Notification3.prototype.do = function(nextHandler, errorHandler, completeHandler) {
    var _a = this, kind = _a.kind, value = _a.value, error2 = _a.error;
    return kind === "N" ? nextHandler === null || nextHandler === void 0 ? void 0 : nextHandler(value) : kind === "E" ? errorHandler === null || errorHandler === void 0 ? void 0 : errorHandler(error2) : completeHandler === null || completeHandler === void 0 ? void 0 : completeHandler();
  };
  Notification3.prototype.accept = function(nextOrObserver, error2, complete) {
    var _a;
    return isFunction((_a = nextOrObserver) === null || _a === void 0 ? void 0 : _a.next) ? this.observe(nextOrObserver) : this.do(nextOrObserver, error2, complete);
  };
  Notification3.prototype.toObservable = function() {
    var _a = this, kind = _a.kind, value = _a.value, error2 = _a.error;
    var result = kind === "N" ? of(value) : kind === "E" ? throwError(function() {
      return error2;
    }) : kind === "C" ? EMPTY : 0;
    if (!result) {
      throw new TypeError("Unexpected notification kind " + kind);
    }
    return result;
  };
  Notification3.createNext = function(value) {
    return new Notification3("N", value);
  };
  Notification3.createError = function(err) {
    return new Notification3("E", void 0, err);
  };
  Notification3.createComplete = function() {
    return Notification3.completeNotification;
  };
  Notification3.completeNotification = new Notification3("C");
  return Notification3;
}();
function observeNotification(notification, observer) {
  var _a, _b, _c;
  var _d = notification, kind = _d.kind, value = _d.value, error2 = _d.error;
  if (typeof kind !== "string") {
    throw new TypeError('Invalid notification, missing "kind"');
  }
  kind === "N" ? (_a = observer.next) === null || _a === void 0 ? void 0 : _a.call(observer, value) : kind === "E" ? (_b = observer.error) === null || _b === void 0 ? void 0 : _b.call(observer, error2) : (_c = observer.complete) === null || _c === void 0 ? void 0 : _c.call(observer);
}

// node_modules/rxjs/dist/esm5/internal/util/EmptyError.js
var EmptyError = createErrorClass(function(_super) {
  return function EmptyErrorImpl() {
    _super(this);
    this.name = "EmptyError";
    this.message = "no elements in sequence";
  };
});

// node_modules/rxjs/dist/esm5/internal/util/ArgumentOutOfRangeError.js
var ArgumentOutOfRangeError = createErrorClass(function(_super) {
  return function ArgumentOutOfRangeErrorImpl() {
    _super(this);
    this.name = "ArgumentOutOfRangeError";
    this.message = "argument out of range";
  };
});

// node_modules/rxjs/dist/esm5/internal/util/NotFoundError.js
var NotFoundError = createErrorClass(function(_super) {
  return function NotFoundErrorImpl(message) {
    _super(this);
    this.name = "NotFoundError";
    this.message = message;
  };
});

// node_modules/rxjs/dist/esm5/internal/util/SequenceError.js
var SequenceError = createErrorClass(function(_super) {
  return function SequenceErrorImpl(message) {
    _super(this);
    this.name = "SequenceError";
    this.message = message;
  };
});

// node_modules/rxjs/dist/esm5/internal/operators/timeout.js
var TimeoutError = createErrorClass(function(_super) {
  return function TimeoutErrorImpl(info) {
    if (info === void 0) {
      info = null;
    }
    _super(this);
    this.message = "Timeout has occurred";
    this.name = "TimeoutError";
    this.info = info;
  };
});

// node_modules/rxjs/dist/esm5/internal/operators/map.js
function map(project, thisArg) {
  return operate(function(source, subscriber) {
    var index3 = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      subscriber.next(project.call(thisArg, value, index3++));
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/util/mapOneOrManyArgs.js
var isArray = Array.isArray;
function callOrApply(fn, args) {
  return isArray(args) ? fn.apply(void 0, __spreadArray([], __read(args))) : fn(args);
}
function mapOneOrManyArgs(fn) {
  return map(function(args) {
    return callOrApply(fn, args);
  });
}

// node_modules/rxjs/dist/esm5/internal/util/argsArgArrayOrObject.js
var isArray2 = Array.isArray;
var getPrototypeOf = Object.getPrototypeOf;
var objectProto = Object.prototype;
var getKeys = Object.keys;
function argsArgArrayOrObject(args) {
  if (args.length === 1) {
    var first_1 = args[0];
    if (isArray2(first_1)) {
      return { args: first_1, keys: null };
    }
    if (isPOJO(first_1)) {
      var keys = getKeys(first_1);
      return {
        args: keys.map(function(key) {
          return first_1[key];
        }),
        keys
      };
    }
  }
  return { args, keys: null };
}
function isPOJO(obj) {
  return obj && typeof obj === "object" && getPrototypeOf(obj) === objectProto;
}

// node_modules/rxjs/dist/esm5/internal/util/createObject.js
function createObject(keys, values) {
  return keys.reduce(function(result, key, i) {
    return result[key] = values[i], result;
  }, {});
}

// node_modules/rxjs/dist/esm5/internal/observable/combineLatest.js
function combineLatest() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  var resultSelector = popResultSelector(args);
  var _a = argsArgArrayOrObject(args), observables = _a.args, keys = _a.keys;
  if (observables.length === 0) {
    return from([], scheduler);
  }
  var result = new Observable(combineLatestInit(observables, scheduler, keys ? function(values) {
    return createObject(keys, values);
  } : identity));
  return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;
}
function combineLatestInit(observables, scheduler, valueTransform) {
  if (valueTransform === void 0) {
    valueTransform = identity;
  }
  return function(subscriber) {
    maybeSchedule(scheduler, function() {
      var length = observables.length;
      var values = new Array(length);
      var active = length;
      var remainingFirstValues = length;
      var _loop_1 = function(i2) {
        maybeSchedule(scheduler, function() {
          var source = from(observables[i2], scheduler);
          var hasFirstValue = false;
          source.subscribe(createOperatorSubscriber(subscriber, function(value) {
            values[i2] = value;
            if (!hasFirstValue) {
              hasFirstValue = true;
              remainingFirstValues--;
            }
            if (!remainingFirstValues) {
              subscriber.next(valueTransform(values.slice()));
            }
          }, function() {
            if (!--active) {
              subscriber.complete();
            }
          }));
        }, subscriber);
      };
      for (var i = 0; i < length; i++) {
        _loop_1(i);
      }
    }, subscriber);
  };
}
function maybeSchedule(scheduler, execute, subscription) {
  if (scheduler) {
    executeSchedule(subscription, scheduler, execute);
  } else {
    execute();
  }
}

// node_modules/rxjs/dist/esm5/internal/operators/mergeInternals.js
function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand2, innerSubScheduler, additionalFinalizer) {
  var buffer2 = [];
  var active = 0;
  var index3 = 0;
  var isComplete = false;
  var checkComplete = function() {
    if (isComplete && !buffer2.length && !active) {
      subscriber.complete();
    }
  };
  var outerNext = function(value) {
    return active < concurrent ? doInnerSub(value) : buffer2.push(value);
  };
  var doInnerSub = function(value) {
    expand2 && subscriber.next(value);
    active++;
    var innerComplete = false;
    innerFrom(project(value, index3++)).subscribe(createOperatorSubscriber(subscriber, function(innerValue) {
      onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
      if (expand2) {
        outerNext(innerValue);
      } else {
        subscriber.next(innerValue);
      }
    }, function() {
      innerComplete = true;
    }, void 0, function() {
      if (innerComplete) {
        try {
          active--;
          var _loop_1 = function() {
            var bufferedValue = buffer2.shift();
            if (innerSubScheduler) {
              executeSchedule(subscriber, innerSubScheduler, function() {
                return doInnerSub(bufferedValue);
              });
            } else {
              doInnerSub(bufferedValue);
            }
          };
          while (buffer2.length && active < concurrent) {
            _loop_1();
          }
          checkComplete();
        } catch (err) {
          subscriber.error(err);
        }
      }
    }));
  };
  source.subscribe(createOperatorSubscriber(subscriber, outerNext, function() {
    isComplete = true;
    checkComplete();
  }));
  return function() {
    additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js
function mergeMap(project, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  if (isFunction(resultSelector)) {
    return mergeMap(function(a, i) {
      return map(function(b, ii) {
        return resultSelector(a, b, i, ii);
      })(innerFrom(project(a, i)));
    }, concurrent);
  } else if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return operate(function(source, subscriber) {
    return mergeInternals(source, subscriber, project, concurrent);
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/mergeAll.js
function mergeAll(concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  return mergeMap(identity, concurrent);
}

// node_modules/rxjs/dist/esm5/internal/operators/concatAll.js
function concatAll() {
  return mergeAll(1);
}

// node_modules/rxjs/dist/esm5/internal/observable/concat.js
function concat() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return concatAll()(from(args, popScheduler(args)));
}

// node_modules/rxjs/dist/esm5/internal/observable/fromEvent.js
var nodeEventEmitterMethods = ["addListener", "removeListener"];
var eventTargetMethods = ["addEventListener", "removeEventListener"];
var jqueryMethods = ["on", "off"];
function fromEvent(target, eventName, options, resultSelector) {
  if (isFunction(options)) {
    resultSelector = options;
    options = void 0;
  }
  if (resultSelector) {
    return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs(resultSelector));
  }
  var _a = __read(isEventTarget(target) ? eventTargetMethods.map(function(methodName) {
    return function(handler) {
      return target[methodName](eventName, handler, options);
    };
  }) : isNodeStyleEventEmitter(target) ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName)) : isJQueryStyleEventEmitter(target) ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName)) : [], 2), add = _a[0], remove = _a[1];
  if (!add) {
    if (isArrayLike(target)) {
      return mergeMap(function(subTarget) {
        return fromEvent(subTarget, eventName, options);
      })(innerFrom(target));
    }
  }
  if (!add) {
    throw new TypeError("Invalid event target");
  }
  return new Observable(function(subscriber) {
    var handler = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return subscriber.next(1 < args.length ? args : args[0]);
    };
    add(handler);
    return function() {
      return remove(handler);
    };
  });
}
function toCommonHandlerRegistry(target, eventName) {
  return function(methodName) {
    return function(handler) {
      return target[methodName](eventName, handler);
    };
  };
}
function isNodeStyleEventEmitter(target) {
  return isFunction(target.addListener) && isFunction(target.removeListener);
}
function isJQueryStyleEventEmitter(target) {
  return isFunction(target.on) && isFunction(target.off);
}
function isEventTarget(target) {
  return isFunction(target.addEventListener) && isFunction(target.removeEventListener);
}

// node_modules/rxjs/dist/esm5/internal/observable/fromEventPattern.js
function fromEventPattern(addHandler, removeHandler, resultSelector) {
  if (resultSelector) {
    return fromEventPattern(addHandler, removeHandler).pipe(mapOneOrManyArgs(resultSelector));
  }
  return new Observable(function(subscriber) {
    var handler = function() {
      var e = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        e[_i] = arguments[_i];
      }
      return subscriber.next(e.length === 1 ? e[0] : e);
    };
    var retValue = addHandler(handler);
    return isFunction(removeHandler) ? function() {
      return removeHandler(handler, retValue);
    } : void 0;
  });
}

// node_modules/rxjs/dist/esm5/internal/observable/merge.js
function merge() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  var concurrent = popNumber(args, Infinity);
  var sources = args;
  return !sources.length ? EMPTY : sources.length === 1 ? innerFrom(sources[0]) : mergeAll(concurrent)(from(sources, scheduler));
}

// node_modules/rxjs/dist/esm5/internal/observable/never.js
var NEVER = new Observable(noop);

// node_modules/rxjs/dist/esm5/internal/util/argsOrArgArray.js
var isArray3 = Array.isArray;

// node_modules/rxjs/dist/esm5/internal/operators/concatMap.js
function concatMap(project, resultSelector) {
  return isFunction(resultSelector) ? mergeMap(project, resultSelector, 1) : mergeMap(project, 1);
}

// node_modules/rxjs/dist/esm5/internal/operators/debounceTime.js
function debounceTime(dueTime, scheduler) {
  if (scheduler === void 0) {
    scheduler = asyncScheduler;
  }
  return operate(function(source, subscriber) {
    var activeTask = null;
    var lastValue = null;
    var lastTime = null;
    var emit = function() {
      if (activeTask) {
        activeTask.unsubscribe();
        activeTask = null;
        var value = lastValue;
        lastValue = null;
        subscriber.next(value);
      }
    };
    function emitWhenIdle() {
      var targetTime = lastTime + dueTime;
      var now = scheduler.now();
      if (now < targetTime) {
        activeTask = this.schedule(void 0, targetTime - now);
        subscriber.add(activeTask);
        return;
      }
      emit();
    }
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      lastValue = value;
      lastTime = scheduler.now();
      if (!activeTask) {
        activeTask = scheduler.schedule(emitWhenIdle, dueTime);
        subscriber.add(activeTask);
      }
    }, function() {
      emit();
      subscriber.complete();
    }, void 0, function() {
      lastValue = activeTask = null;
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/distinctUntilChanged.js
function distinctUntilChanged(comparator, keySelector) {
  if (keySelector === void 0) {
    keySelector = identity;
  }
  comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;
  return operate(function(source, subscriber) {
    var previousKey;
    var first2 = true;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var currentKey = keySelector(value);
      if (first2 || !comparator(previousKey, currentKey)) {
        first2 = false;
        previousKey = currentKey;
        subscriber.next(value);
      }
    }));
  });
}
function defaultCompare(a, b) {
  return a === b;
}

// node_modules/rxjs/dist/esm5/internal/operators/distinctUntilKeyChanged.js
function distinctUntilKeyChanged(key, compare) {
  return distinctUntilChanged(function(x, y) {
    return compare ? compare(x[key], y[key]) : x[key] === y[key];
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/pairwise.js
function pairwise() {
  return operate(function(source, subscriber) {
    var prev;
    var hasPrev = false;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var p = prev;
      prev = value;
      hasPrev && subscriber.next([p, value]);
      hasPrev = true;
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/share.js
function share(options) {
  if (options === void 0) {
    options = {};
  }
  var _a = options.connector, connector = _a === void 0 ? function() {
    return new Subject();
  } : _a, _b = options.resetOnError, resetOnError = _b === void 0 ? true : _b, _c = options.resetOnComplete, resetOnComplete = _c === void 0 ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === void 0 ? true : _d;
  return function(wrapperSource) {
    var connection;
    var resetConnection;
    var subject;
    var refCount2 = 0;
    var hasCompleted = false;
    var hasErrored = false;
    var cancelReset = function() {
      resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();
      resetConnection = void 0;
    };
    var reset = function() {
      cancelReset();
      connection = subject = void 0;
      hasCompleted = hasErrored = false;
    };
    var resetAndUnsubscribe = function() {
      var conn = connection;
      reset();
      conn === null || conn === void 0 ? void 0 : conn.unsubscribe();
    };
    return operate(function(source, subscriber) {
      refCount2++;
      if (!hasErrored && !hasCompleted) {
        cancelReset();
      }
      var dest = subject = subject !== null && subject !== void 0 ? subject : connector();
      subscriber.add(function() {
        refCount2--;
        if (refCount2 === 0 && !hasErrored && !hasCompleted) {
          resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
        }
      });
      dest.subscribe(subscriber);
      if (!connection && refCount2 > 0) {
        connection = new SafeSubscriber({
          next: function(value) {
            return dest.next(value);
          },
          error: function(err) {
            hasErrored = true;
            cancelReset();
            resetConnection = handleReset(reset, resetOnError, err);
            dest.error(err);
          },
          complete: function() {
            hasCompleted = true;
            cancelReset();
            resetConnection = handleReset(reset, resetOnComplete);
            dest.complete();
          }
        });
        innerFrom(source).subscribe(connection);
      }
    })(wrapperSource);
  };
}
function handleReset(reset, on) {
  var args = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    args[_i - 2] = arguments[_i];
  }
  if (on === true) {
    reset();
    return;
  }
  if (on === false) {
    return;
  }
  var onSubscriber = new SafeSubscriber({
    next: function() {
      onSubscriber.unsubscribe();
      reset();
    }
  });
  return innerFrom(on.apply(void 0, __spreadArray([], __read(args)))).subscribe(onSubscriber);
}

// node_modules/rxjs/dist/esm5/internal/operators/shareReplay.js
function shareReplay(configOrBufferSize, windowTime2, scheduler) {
  var _a, _b, _c;
  var bufferSize;
  var refCount2 = false;
  if (configOrBufferSize && typeof configOrBufferSize === "object") {
    _a = configOrBufferSize.bufferSize, bufferSize = _a === void 0 ? Infinity : _a, _b = configOrBufferSize.windowTime, windowTime2 = _b === void 0 ? Infinity : _b, _c = configOrBufferSize.refCount, refCount2 = _c === void 0 ? false : _c, scheduler = configOrBufferSize.scheduler;
  } else {
    bufferSize = configOrBufferSize !== null && configOrBufferSize !== void 0 ? configOrBufferSize : Infinity;
  }
  return share({
    connector: function() {
      return new ReplaySubject(bufferSize, windowTime2, scheduler);
    },
    resetOnError: true,
    resetOnComplete: false,
    resetOnRefCountZero: refCount2
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/startWith.js
function startWith() {
  var values = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    values[_i] = arguments[_i];
  }
  var scheduler = popScheduler(values);
  return operate(function(source, subscriber) {
    (scheduler ? concat(values, source, scheduler) : concat(values, source)).subscribe(subscriber);
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/takeWhile.js
function takeWhile(predicate, inclusive) {
  if (inclusive === void 0) {
    inclusive = false;
  }
  return operate(function(source, subscriber) {
    var index3 = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var result = predicate(value, index3++);
      (result || inclusive) && subscriber.next(value);
      !result && subscriber.complete();
    }));
  });
}

// node_modules/@stream-io/video-client/dist/index.browser.es.js
var import_ua_parser_js = __toESM(require_ua_parser());
var import_sdp_transform = __toESM(require_lib());
var Tracer = class {
  constructor(id) {
    this.buffer = [];
    this.enabled = true;
    this.setEnabled = (enabled) => {
      if (this.enabled === enabled)
        return;
      this.enabled = enabled;
      this.buffer = [];
    };
    this.trace = (tag, data) => {
      if (!this.enabled)
        return;
      this.buffer.push([tag, this.id, data, Date.now()]);
    };
    this.take = () => {
      const snapshot = this.buffer;
      this.buffer = [];
      return {
        snapshot,
        rollback: () => {
          this.buffer.unshift(...snapshot);
        }
      };
    };
    this.dispose = () => {
      this.buffer = [];
    };
    this.id = id;
  }
};
var tracer = new Tracer(null);
if (typeof navigator !== "undefined" && typeof navigator.mediaDevices !== "undefined") {
  const dumpStream = (stream) => ({
    id: stream.id,
    tracks: stream.getTracks().map((track) => ({
      id: track.id,
      kind: track.kind,
      label: track.label,
      enabled: track.enabled,
      muted: track.muted,
      readyState: track.readyState
    }))
  });
  const trace = tracer.trace;
  const target = navigator.mediaDevices;
  for (const method of ["getUserMedia", "getDisplayMedia"]) {
    const original = target[method];
    if (!original)
      continue;
    target[method] = async function tracedMethod(constraints) {
      const tag = `navigator.mediaDevices.${method}`;
      trace(tag, constraints);
      try {
        const stream = await original.call(target, constraints);
        trace(`${tag}OnSuccess`, dumpStream(stream));
        return stream;
      } catch (err) {
        trace(`${tag}OnFailure`, err.name);
        throw err;
      }
    };
  }
}
var AudioSettingsRequestDefaultDeviceEnum = {
  SPEAKER: "speaker",
  EARPIECE: "earpiece"
};
var AudioSettingsResponseDefaultDeviceEnum = {
  SPEAKER: "speaker",
  EARPIECE: "earpiece"
};
var CreateDeviceRequestPushProviderEnum = {
  FIREBASE: "firebase",
  APN: "apn",
  HUAWEI: "huawei",
  XIAOMI: "xiaomi"
};
var FrameRecordingSettingsRequestModeEnum = {
  AVAILABLE: "available",
  DISABLED: "disabled",
  AUTO_ON: "auto-on"
};
var FrameRecordingSettingsRequestQualityEnum = {
  _360P: "360p",
  _480P: "480p",
  _720P: "720p",
  _1080P: "1080p",
  _1440P: "1440p"
};
var FrameRecordingSettingsResponseModeEnum = {
  AVAILABLE: "available",
  DISABLED: "disabled",
  AUTO_ON: "auto-on"
};
var LayoutSettingsRequestNameEnum = {
  SPOTLIGHT: "spotlight",
  GRID: "grid",
  SINGLE_PARTICIPANT: "single-participant",
  MOBILE: "mobile",
  CUSTOM: "custom"
};
var NoiseCancellationSettingsModeEnum = {
  AVAILABLE: "available",
  DISABLED: "disabled",
  AUTO_ON: "auto-on"
};
var OwnCapability = {
  BLOCK_USERS: "block-users",
  CHANGE_MAX_DURATION: "change-max-duration",
  CREATE_CALL: "create-call",
  CREATE_REACTION: "create-reaction",
  ENABLE_NOISE_CANCELLATION: "enable-noise-cancellation",
  END_CALL: "end-call",
  JOIN_BACKSTAGE: "join-backstage",
  JOIN_CALL: "join-call",
  JOIN_ENDED_CALL: "join-ended-call",
  MUTE_USERS: "mute-users",
  PIN_FOR_EVERYONE: "pin-for-everyone",
  READ_CALL: "read-call",
  REMOVE_CALL_MEMBER: "remove-call-member",
  SCREENSHARE: "screenshare",
  SEND_AUDIO: "send-audio",
  SEND_VIDEO: "send-video",
  START_BROADCAST_CALL: "start-broadcast-call",
  START_CLOSED_CAPTIONS_CALL: "start-closed-captions-call",
  START_FRAME_RECORD_CALL: "start-frame-record-call",
  START_RECORD_CALL: "start-record-call",
  START_TRANSCRIPTION_CALL: "start-transcription-call",
  STOP_BROADCAST_CALL: "stop-broadcast-call",
  STOP_CLOSED_CAPTIONS_CALL: "stop-closed-captions-call",
  STOP_FRAME_RECORD_CALL: "stop-frame-record-call",
  STOP_RECORD_CALL: "stop-record-call",
  STOP_TRANSCRIPTION_CALL: "stop-transcription-call",
  UPDATE_CALL: "update-call",
  UPDATE_CALL_MEMBER: "update-call-member",
  UPDATE_CALL_PERMISSIONS: "update-call-permissions",
  UPDATE_CALL_SETTINGS: "update-call-settings"
};
var RTMPBroadcastRequestQualityEnum = {
  _360P: "360p",
  _480P: "480p",
  _720P: "720p",
  _1080P: "1080p",
  _1440P: "1440p",
  PORTRAIT_360X640: "portrait-360x640",
  PORTRAIT_480X854: "portrait-480x854",
  PORTRAIT_720X1280: "portrait-720x1280",
  PORTRAIT_1080X1920: "portrait-1080x1920",
  PORTRAIT_1440X2560: "portrait-1440x2560"
};
var RTMPSettingsRequestQualityEnum = {
  _360P: "360p",
  _480P: "480p",
  _720P: "720p",
  _1080P: "1080p",
  _1440P: "1440p",
  PORTRAIT_360X640: "portrait-360x640",
  PORTRAIT_480X854: "portrait-480x854",
  PORTRAIT_720X1280: "portrait-720x1280",
  PORTRAIT_1080X1920: "portrait-1080x1920",
  PORTRAIT_1440X2560: "portrait-1440x2560"
};
var RecordSettingsRequestModeEnum = {
  AVAILABLE: "available",
  DISABLED: "disabled",
  AUTO_ON: "auto-on"
};
var RecordSettingsRequestQualityEnum = {
  _360P: "360p",
  _480P: "480p",
  _720P: "720p",
  _1080P: "1080p",
  _1440P: "1440p",
  PORTRAIT_360X640: "portrait-360x640",
  PORTRAIT_480X854: "portrait-480x854",
  PORTRAIT_720X1280: "portrait-720x1280",
  PORTRAIT_1080X1920: "portrait-1080x1920",
  PORTRAIT_1440X2560: "portrait-1440x2560"
};
var TranscriptionSettingsRequestClosedCaptionModeEnum = {
  AVAILABLE: "available",
  DISABLED: "disabled",
  AUTO_ON: "auto-on"
};
var TranscriptionSettingsRequestLanguageEnum = {
  AUTO: "auto",
  EN: "en",
  FR: "fr",
  ES: "es",
  DE: "de",
  IT: "it",
  NL: "nl",
  PT: "pt",
  PL: "pl",
  CA: "ca",
  CS: "cs",
  DA: "da",
  EL: "el",
  FI: "fi",
  ID: "id",
  JA: "ja",
  RU: "ru",
  SV: "sv",
  TA: "ta",
  TH: "th",
  TR: "tr",
  HU: "hu",
  RO: "ro",
  ZH: "zh",
  AR: "ar",
  TL: "tl",
  HE: "he",
  HI: "hi",
  HR: "hr",
  KO: "ko",
  MS: "ms",
  NO: "no",
  UK: "uk"
};
var TranscriptionSettingsRequestModeEnum = {
  AVAILABLE: "available",
  DISABLED: "disabled",
  AUTO_ON: "auto-on"
};
var TranscriptionSettingsResponseClosedCaptionModeEnum = {
  AVAILABLE: "available",
  DISABLED: "disabled",
  AUTO_ON: "auto-on"
};
var TranscriptionSettingsResponseLanguageEnum = {
  AUTO: "auto",
  EN: "en",
  FR: "fr",
  ES: "es",
  DE: "de",
  IT: "it",
  NL: "nl",
  PT: "pt",
  PL: "pl",
  CA: "ca",
  CS: "cs",
  DA: "da",
  EL: "el",
  FI: "fi",
  ID: "id",
  JA: "ja",
  RU: "ru",
  SV: "sv",
  TA: "ta",
  TH: "th",
  TR: "tr",
  HU: "hu",
  RO: "ro",
  ZH: "zh",
  AR: "ar",
  TL: "tl",
  HE: "he",
  HI: "hi",
  HR: "hr",
  KO: "ko",
  MS: "ms",
  NO: "no",
  UK: "uk"
};
var TranscriptionSettingsResponseModeEnum = {
  AVAILABLE: "available",
  DISABLED: "disabled",
  AUTO_ON: "auto-on"
};
var VideoSettingsRequestCameraFacingEnum = {
  FRONT: "front",
  BACK: "back",
  EXTERNAL: "external"
};
var VideoSettingsResponseCameraFacingEnum = {
  FRONT: "front",
  BACK: "back",
  EXTERNAL: "external"
};
var ErrorFromResponse = class extends Error {
};
var NullValue;
(function(NullValue2) {
  NullValue2[NullValue2["NULL_VALUE"] = 0] = "NULL_VALUE";
})(NullValue || (NullValue = {}));
var Struct$Type = class extends MessageType {
  constructor() {
    super("google.protobuf.Struct", [
      {
        no: 1,
        name: "fields",
        kind: "map",
        K: 9,
        V: { kind: "message", T: () => Value }
      }
    ]);
  }
  /**
   * Encode `Struct` to JSON object.
   */
  internalJsonWrite(message, options) {
    let json = {};
    for (let [k, v] of Object.entries(message.fields)) {
      json[k] = Value.toJson(v);
    }
    return json;
  }
  /**
   * Decode `Struct` from JSON object.
   */
  internalJsonRead(json, options, target) {
    if (!isJsonObject(json))
      throw new globalThis.Error("Unable to parse message " + this.typeName + " from JSON " + typeofJsonValue(json) + ".");
    if (!target)
      target = this.create();
    for (let [k, v] of globalThis.Object.entries(json)) {
      target.fields[k] = Value.fromJson(v);
    }
    return target;
  }
};
var Struct = new Struct$Type();
var Value$Type = class extends MessageType {
  constructor() {
    super("google.protobuf.Value", [
      {
        no: 1,
        name: "null_value",
        kind: "enum",
        oneof: "kind",
        T: () => ["google.protobuf.NullValue", NullValue]
      },
      {
        no: 2,
        name: "number_value",
        kind: "scalar",
        oneof: "kind",
        T: 1
      },
      {
        no: 3,
        name: "string_value",
        kind: "scalar",
        oneof: "kind",
        T: 9
      },
      {
        no: 4,
        name: "bool_value",
        kind: "scalar",
        oneof: "kind",
        T: 8
      },
      {
        no: 5,
        name: "struct_value",
        kind: "message",
        oneof: "kind",
        T: () => Struct
      },
      {
        no: 6,
        name: "list_value",
        kind: "message",
        oneof: "kind",
        T: () => ListValue
      }
    ]);
  }
  /**
   * Encode `Value` to JSON value.
   */
  internalJsonWrite(message, options) {
    if (message.kind.oneofKind === void 0)
      throw new globalThis.Error();
    switch (message.kind.oneofKind) {
      case void 0:
        throw new globalThis.Error();
      case "boolValue":
        return message.kind.boolValue;
      case "nullValue":
        return null;
      case "numberValue":
        let numberValue = message.kind.numberValue;
        if (typeof numberValue == "number" && !Number.isFinite(numberValue))
          throw new globalThis.Error();
        return numberValue;
      case "stringValue":
        return message.kind.stringValue;
      case "listValue":
        let listValueField = this.fields.find((f) => f.no === 6);
        if ((listValueField == null ? void 0 : listValueField.kind) !== "message")
          throw new globalThis.Error();
        return listValueField.T().toJson(message.kind.listValue);
      case "structValue":
        let structValueField = this.fields.find((f) => f.no === 5);
        if ((structValueField == null ? void 0 : structValueField.kind) !== "message")
          throw new globalThis.Error();
        return structValueField.T().toJson(message.kind.structValue);
    }
  }
  /**
   * Decode `Value` from JSON value.
   */
  internalJsonRead(json, options, target) {
    if (!target)
      target = this.create();
    switch (typeof json) {
      case "number":
        target.kind = { oneofKind: "numberValue", numberValue: json };
        break;
      case "string":
        target.kind = { oneofKind: "stringValue", stringValue: json };
        break;
      case "boolean":
        target.kind = { oneofKind: "boolValue", boolValue: json };
        break;
      case "object":
        if (json === null) {
          target.kind = {
            oneofKind: "nullValue",
            nullValue: NullValue.NULL_VALUE
          };
        } else if (globalThis.Array.isArray(json)) {
          target.kind = {
            oneofKind: "listValue",
            listValue: ListValue.fromJson(json)
          };
        } else {
          target.kind = {
            oneofKind: "structValue",
            structValue: Struct.fromJson(json)
          };
        }
        break;
      default:
        throw new globalThis.Error("Unable to parse " + this.typeName + " from JSON " + typeofJsonValue(json));
    }
    return target;
  }
};
var Value = new Value$Type();
var ListValue$Type = class extends MessageType {
  constructor() {
    super("google.protobuf.ListValue", [
      {
        no: 1,
        name: "values",
        kind: "message",
        repeat: 1,
        T: () => Value
      }
    ]);
  }
  /**
   * Encode `ListValue` to JSON array.
   */
  internalJsonWrite(message, options) {
    return message.values.map((v) => Value.toJson(v));
  }
  /**
   * Decode `ListValue` from JSON array.
   */
  internalJsonRead(json, options, target) {
    if (!globalThis.Array.isArray(json))
      throw new globalThis.Error("Unable to parse " + this.typeName + " from JSON " + typeofJsonValue(json));
    if (!target)
      target = this.create();
    let values = json.map((v) => Value.fromJson(v));
    target.values.push(...values);
    return target;
  }
};
var ListValue = new ListValue$Type();
var Timestamp$Type = class extends MessageType {
  constructor() {
    super("google.protobuf.Timestamp", [
      {
        no: 1,
        name: "seconds",
        kind: "scalar",
        T: 3
        /*ScalarType.INT64*/
      },
      {
        no: 2,
        name: "nanos",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      }
    ]);
  }
  /**
   * Creates a new `Timestamp` for the current time.
   */
  now() {
    const msg = this.create();
    const ms = Date.now();
    msg.seconds = PbLong.from(Math.floor(ms / 1e3)).toString();
    msg.nanos = ms % 1e3 * 1e6;
    return msg;
  }
  /**
   * Converts a `Timestamp` to a JavaScript Date.
   */
  toDate(message) {
    return new Date(PbLong.from(message.seconds).toNumber() * 1e3 + Math.ceil(message.nanos / 1e6));
  }
  /**
   * Converts a JavaScript Date to a `Timestamp`.
   */
  fromDate(date) {
    const msg = this.create();
    const ms = date.getTime();
    msg.seconds = PbLong.from(Math.floor(ms / 1e3)).toString();
    msg.nanos = (ms % 1e3 + (ms < 0 && ms % 1e3 !== 0 ? 1e3 : 0)) * 1e6;
    return msg;
  }
  /**
   * In JSON format, the `Timestamp` type is encoded as a string
   * in the RFC 3339 format.
   */
  internalJsonWrite(message, options) {
    let ms = PbLong.from(message.seconds).toNumber() * 1e3;
    if (ms < Date.parse("0001-01-01T00:00:00Z") || ms > Date.parse("9999-12-31T23:59:59Z"))
      throw new Error("Unable to encode Timestamp to JSON. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.");
    if (message.nanos < 0)
      throw new Error("Unable to encode invalid Timestamp to JSON. Nanos must not be negative.");
    let z = "Z";
    if (message.nanos > 0) {
      let nanosStr = (message.nanos + 1e9).toString().substring(1);
      if (nanosStr.substring(3) === "000000")
        z = "." + nanosStr.substring(0, 3) + "Z";
      else if (nanosStr.substring(6) === "000")
        z = "." + nanosStr.substring(0, 6) + "Z";
      else
        z = "." + nanosStr + "Z";
    }
    return new Date(ms).toISOString().replace(".000Z", z);
  }
  /**
   * In JSON format, the `Timestamp` type is encoded as a string
   * in the RFC 3339 format.
   */
  internalJsonRead(json, options, target) {
    if (typeof json !== "string")
      throw new Error("Unable to parse Timestamp from JSON " + typeofJsonValue(json) + ".");
    let matches2 = json.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:Z|\.([0-9]{3,9})Z|([+-][0-9][0-9]:[0-9][0-9]))$/);
    if (!matches2)
      throw new Error("Unable to parse Timestamp from JSON. Invalid format.");
    let ms = Date.parse(matches2[1] + "-" + matches2[2] + "-" + matches2[3] + "T" + matches2[4] + ":" + matches2[5] + ":" + matches2[6] + (matches2[8] ? matches2[8] : "Z"));
    if (Number.isNaN(ms))
      throw new Error("Unable to parse Timestamp from JSON. Invalid value.");
    if (ms < Date.parse("0001-01-01T00:00:00Z") || ms > Date.parse("9999-12-31T23:59:59Z"))
      throw new globalThis.Error("Unable to parse Timestamp from JSON. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.");
    if (!target)
      target = this.create();
    target.seconds = PbLong.from(ms / 1e3).toString();
    target.nanos = 0;
    if (matches2[7])
      target.nanos = parseInt("1" + matches2[7] + "0".repeat(9 - matches2[7].length)) - 1e9;
    return target;
  }
};
var Timestamp = new Timestamp$Type();
var PeerType;
(function(PeerType2) {
  PeerType2[PeerType2["PUBLISHER_UNSPECIFIED"] = 0] = "PUBLISHER_UNSPECIFIED";
  PeerType2[PeerType2["SUBSCRIBER"] = 1] = "SUBSCRIBER";
})(PeerType || (PeerType = {}));
var ConnectionQuality;
(function(ConnectionQuality2) {
  ConnectionQuality2[ConnectionQuality2["UNSPECIFIED"] = 0] = "UNSPECIFIED";
  ConnectionQuality2[ConnectionQuality2["POOR"] = 1] = "POOR";
  ConnectionQuality2[ConnectionQuality2["GOOD"] = 2] = "GOOD";
  ConnectionQuality2[ConnectionQuality2["EXCELLENT"] = 3] = "EXCELLENT";
})(ConnectionQuality || (ConnectionQuality = {}));
var VideoQuality;
(function(VideoQuality2) {
  VideoQuality2[VideoQuality2["LOW_UNSPECIFIED"] = 0] = "LOW_UNSPECIFIED";
  VideoQuality2[VideoQuality2["MID"] = 1] = "MID";
  VideoQuality2[VideoQuality2["HIGH"] = 2] = "HIGH";
  VideoQuality2[VideoQuality2["OFF"] = 3] = "OFF";
})(VideoQuality || (VideoQuality = {}));
var TrackType;
(function(TrackType2) {
  TrackType2[TrackType2["UNSPECIFIED"] = 0] = "UNSPECIFIED";
  TrackType2[TrackType2["AUDIO"] = 1] = "AUDIO";
  TrackType2[TrackType2["VIDEO"] = 2] = "VIDEO";
  TrackType2[TrackType2["SCREEN_SHARE"] = 3] = "SCREEN_SHARE";
  TrackType2[TrackType2["SCREEN_SHARE_AUDIO"] = 4] = "SCREEN_SHARE_AUDIO";
})(TrackType || (TrackType = {}));
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2[ErrorCode2["UNSPECIFIED"] = 0] = "UNSPECIFIED";
  ErrorCode2[ErrorCode2["PUBLISH_TRACK_NOT_FOUND"] = 100] = "PUBLISH_TRACK_NOT_FOUND";
  ErrorCode2[ErrorCode2["PUBLISH_TRACKS_MISMATCH"] = 101] = "PUBLISH_TRACKS_MISMATCH";
  ErrorCode2[ErrorCode2["PUBLISH_TRACK_OUT_OF_ORDER"] = 102] = "PUBLISH_TRACK_OUT_OF_ORDER";
  ErrorCode2[ErrorCode2["PUBLISH_TRACK_VIDEO_LAYER_NOT_FOUND"] = 103] = "PUBLISH_TRACK_VIDEO_LAYER_NOT_FOUND";
  ErrorCode2[ErrorCode2["LIVE_ENDED"] = 104] = "LIVE_ENDED";
  ErrorCode2[ErrorCode2["PARTICIPANT_NOT_FOUND"] = 200] = "PARTICIPANT_NOT_FOUND";
  ErrorCode2[ErrorCode2["PARTICIPANT_MIGRATING_OUT"] = 201] = "PARTICIPANT_MIGRATING_OUT";
  ErrorCode2[ErrorCode2["PARTICIPANT_MIGRATION_FAILED"] = 202] = "PARTICIPANT_MIGRATION_FAILED";
  ErrorCode2[ErrorCode2["PARTICIPANT_MIGRATING"] = 203] = "PARTICIPANT_MIGRATING";
  ErrorCode2[ErrorCode2["PARTICIPANT_RECONNECT_FAILED"] = 204] = "PARTICIPANT_RECONNECT_FAILED";
  ErrorCode2[ErrorCode2["PARTICIPANT_MEDIA_TRANSPORT_FAILURE"] = 205] = "PARTICIPANT_MEDIA_TRANSPORT_FAILURE";
  ErrorCode2[ErrorCode2["CALL_NOT_FOUND"] = 300] = "CALL_NOT_FOUND";
  ErrorCode2[ErrorCode2["REQUEST_VALIDATION_FAILED"] = 400] = "REQUEST_VALIDATION_FAILED";
  ErrorCode2[ErrorCode2["UNAUTHENTICATED"] = 401] = "UNAUTHENTICATED";
  ErrorCode2[ErrorCode2["PERMISSION_DENIED"] = 403] = "PERMISSION_DENIED";
  ErrorCode2[ErrorCode2["TOO_MANY_REQUESTS"] = 429] = "TOO_MANY_REQUESTS";
  ErrorCode2[ErrorCode2["INTERNAL_SERVER_ERROR"] = 500] = "INTERNAL_SERVER_ERROR";
  ErrorCode2[ErrorCode2["SFU_SHUTTING_DOWN"] = 600] = "SFU_SHUTTING_DOWN";
  ErrorCode2[ErrorCode2["SFU_FULL"] = 700] = "SFU_FULL";
})(ErrorCode || (ErrorCode = {}));
var SdkType;
(function(SdkType2) {
  SdkType2[SdkType2["UNSPECIFIED"] = 0] = "UNSPECIFIED";
  SdkType2[SdkType2["REACT"] = 1] = "REACT";
  SdkType2[SdkType2["ANGULAR"] = 2] = "ANGULAR";
  SdkType2[SdkType2["ANDROID"] = 3] = "ANDROID";
  SdkType2[SdkType2["IOS"] = 4] = "IOS";
  SdkType2[SdkType2["FLUTTER"] = 5] = "FLUTTER";
  SdkType2[SdkType2["REACT_NATIVE"] = 6] = "REACT_NATIVE";
  SdkType2[SdkType2["UNITY"] = 7] = "UNITY";
  SdkType2[SdkType2["GO"] = 8] = "GO";
  SdkType2[SdkType2["PLAIN_JAVASCRIPT"] = 9] = "PLAIN_JAVASCRIPT";
})(SdkType || (SdkType = {}));
var TrackUnpublishReason;
(function(TrackUnpublishReason2) {
  TrackUnpublishReason2[TrackUnpublishReason2["UNSPECIFIED"] = 0] = "UNSPECIFIED";
  TrackUnpublishReason2[TrackUnpublishReason2["USER_MUTED"] = 1] = "USER_MUTED";
  TrackUnpublishReason2[TrackUnpublishReason2["PERMISSION_REVOKED"] = 2] = "PERMISSION_REVOKED";
  TrackUnpublishReason2[TrackUnpublishReason2["MODERATION"] = 3] = "MODERATION";
})(TrackUnpublishReason || (TrackUnpublishReason = {}));
var GoAwayReason;
(function(GoAwayReason2) {
  GoAwayReason2[GoAwayReason2["UNSPECIFIED"] = 0] = "UNSPECIFIED";
  GoAwayReason2[GoAwayReason2["SHUTTING_DOWN"] = 1] = "SHUTTING_DOWN";
  GoAwayReason2[GoAwayReason2["REBALANCE"] = 2] = "REBALANCE";
})(GoAwayReason || (GoAwayReason = {}));
var CallEndedReason;
(function(CallEndedReason2) {
  CallEndedReason2[CallEndedReason2["UNSPECIFIED"] = 0] = "UNSPECIFIED";
  CallEndedReason2[CallEndedReason2["ENDED"] = 1] = "ENDED";
  CallEndedReason2[CallEndedReason2["LIVE_ENDED"] = 2] = "LIVE_ENDED";
  CallEndedReason2[CallEndedReason2["KICKED"] = 3] = "KICKED";
  CallEndedReason2[CallEndedReason2["SESSION_ENDED"] = 4] = "SESSION_ENDED";
})(CallEndedReason || (CallEndedReason = {}));
var WebsocketReconnectStrategy;
(function(WebsocketReconnectStrategy2) {
  WebsocketReconnectStrategy2[WebsocketReconnectStrategy2["UNSPECIFIED"] = 0] = "UNSPECIFIED";
  WebsocketReconnectStrategy2[WebsocketReconnectStrategy2["DISCONNECT"] = 1] = "DISCONNECT";
  WebsocketReconnectStrategy2[WebsocketReconnectStrategy2["FAST"] = 2] = "FAST";
  WebsocketReconnectStrategy2[WebsocketReconnectStrategy2["REJOIN"] = 3] = "REJOIN";
  WebsocketReconnectStrategy2[WebsocketReconnectStrategy2["MIGRATE"] = 4] = "MIGRATE";
})(WebsocketReconnectStrategy || (WebsocketReconnectStrategy = {}));
var AndroidThermalState;
(function(AndroidThermalState2) {
  AndroidThermalState2[AndroidThermalState2["UNSPECIFIED"] = 0] = "UNSPECIFIED";
  AndroidThermalState2[AndroidThermalState2["NONE"] = 1] = "NONE";
  AndroidThermalState2[AndroidThermalState2["LIGHT"] = 2] = "LIGHT";
  AndroidThermalState2[AndroidThermalState2["MODERATE"] = 3] = "MODERATE";
  AndroidThermalState2[AndroidThermalState2["SEVERE"] = 4] = "SEVERE";
  AndroidThermalState2[AndroidThermalState2["CRITICAL"] = 5] = "CRITICAL";
  AndroidThermalState2[AndroidThermalState2["EMERGENCY"] = 6] = "EMERGENCY";
  AndroidThermalState2[AndroidThermalState2["SHUTDOWN"] = 7] = "SHUTDOWN";
})(AndroidThermalState || (AndroidThermalState = {}));
var AppleThermalState;
(function(AppleThermalState2) {
  AppleThermalState2[AppleThermalState2["UNSPECIFIED"] = 0] = "UNSPECIFIED";
  AppleThermalState2[AppleThermalState2["NOMINAL"] = 1] = "NOMINAL";
  AppleThermalState2[AppleThermalState2["FAIR"] = 2] = "FAIR";
  AppleThermalState2[AppleThermalState2["SERIOUS"] = 3] = "SERIOUS";
  AppleThermalState2[AppleThermalState2["CRITICAL"] = 4] = "CRITICAL";
})(AppleThermalState || (AppleThermalState = {}));
var CallState$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.models.CallState", [
      {
        no: 1,
        name: "participants",
        kind: "message",
        repeat: 1,
        T: () => Participant
      },
      { no: 2, name: "started_at", kind: "message", T: () => Timestamp },
      {
        no: 3,
        name: "participant_count",
        kind: "message",
        T: () => ParticipantCount
      },
      {
        no: 4,
        name: "pins",
        kind: "message",
        repeat: 1,
        T: () => Pin
      }
    ]);
  }
};
var CallState$1 = new CallState$Type();
var ParticipantCount$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.models.ParticipantCount", [
      {
        no: 1,
        name: "total",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 2,
        name: "anonymous",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      }
    ]);
  }
};
var ParticipantCount = new ParticipantCount$Type();
var Pin$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.models.Pin", [
      {
        no: 1,
        name: "user_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "session_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var Pin = new Pin$Type();
var Participant$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.models.Participant", [
      {
        no: 1,
        name: "user_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "session_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "published_tracks",
        kind: "enum",
        repeat: 1,
        T: () => [
          "stream.video.sfu.models.TrackType",
          TrackType,
          "TRACK_TYPE_"
        ]
      },
      { no: 4, name: "joined_at", kind: "message", T: () => Timestamp },
      {
        no: 5,
        name: "track_lookup_prefix",
        kind: "scalar",
        T: 9
      },
      {
        no: 6,
        name: "connection_quality",
        kind: "enum",
        T: () => [
          "stream.video.sfu.models.ConnectionQuality",
          ConnectionQuality,
          "CONNECTION_QUALITY_"
        ]
      },
      {
        no: 7,
        name: "is_speaking",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 8,
        name: "is_dominant_speaker",
        kind: "scalar",
        T: 8
      },
      {
        no: 9,
        name: "audio_level",
        kind: "scalar",
        T: 2
        /*ScalarType.FLOAT*/
      },
      {
        no: 10,
        name: "name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 11,
        name: "image",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 12, name: "custom", kind: "message", T: () => Struct },
      {
        no: 13,
        name: "roles",
        kind: "scalar",
        repeat: 2,
        T: 9
      }
    ]);
  }
};
var Participant = new Participant$Type();
var StreamQuality$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.models.StreamQuality", [
      {
        no: 1,
        name: "video_quality",
        kind: "enum",
        T: () => [
          "stream.video.sfu.models.VideoQuality",
          VideoQuality,
          "VIDEO_QUALITY_"
        ]
      },
      {
        no: 2,
        name: "user_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var StreamQuality = new StreamQuality$Type();
var VideoDimension$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.models.VideoDimension", [
      {
        no: 1,
        name: "width",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 2,
        name: "height",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      }
    ]);
  }
};
var VideoDimension = new VideoDimension$Type();
var VideoLayer$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.models.VideoLayer", [
      {
        no: 1,
        name: "rid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "video_dimension",
        kind: "message",
        T: () => VideoDimension
      },
      {
        no: 4,
        name: "bitrate",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 5,
        name: "fps",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 6,
        name: "quality",
        kind: "enum",
        T: () => [
          "stream.video.sfu.models.VideoQuality",
          VideoQuality,
          "VIDEO_QUALITY_"
        ]
      }
    ]);
  }
};
var VideoLayer = new VideoLayer$Type();
var SubscribeOption$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.models.SubscribeOption", [
      {
        no: 1,
        name: "track_type",
        kind: "enum",
        T: () => [
          "stream.video.sfu.models.TrackType",
          TrackType,
          "TRACK_TYPE_"
        ]
      },
      {
        no: 2,
        name: "codecs",
        kind: "message",
        repeat: 1,
        T: () => Codec
      }
    ]);
  }
};
var SubscribeOption = new SubscribeOption$Type();
var PublishOption$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.models.PublishOption", [
      {
        no: 1,
        name: "track_type",
        kind: "enum",
        T: () => [
          "stream.video.sfu.models.TrackType",
          TrackType,
          "TRACK_TYPE_"
        ]
      },
      { no: 2, name: "codec", kind: "message", T: () => Codec },
      {
        no: 3,
        name: "bitrate",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 4,
        name: "fps",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 5,
        name: "max_spatial_layers",
        kind: "scalar",
        T: 5
      },
      {
        no: 6,
        name: "max_temporal_layers",
        kind: "scalar",
        T: 5
      },
      {
        no: 7,
        name: "video_dimension",
        kind: "message",
        T: () => VideoDimension
      },
      {
        no: 8,
        name: "id",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      }
    ]);
  }
};
var PublishOption = new PublishOption$Type();
var Codec$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.models.Codec", [
      {
        no: 16,
        name: "payload_type",
        kind: "scalar",
        T: 13
      },
      {
        no: 10,
        name: "name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 14,
        name: "clock_rate",
        kind: "scalar",
        T: 13
      },
      {
        no: 15,
        name: "encoding_parameters",
        kind: "scalar",
        T: 9
      },
      {
        no: 12,
        name: "fmtp",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var Codec = new Codec$Type();
var ICETrickle$Type$1 = class ICETrickle$Type extends MessageType {
  constructor() {
    super("stream.video.sfu.models.ICETrickle", [
      {
        no: 1,
        name: "peer_type",
        kind: "enum",
        T: () => ["stream.video.sfu.models.PeerType", PeerType, "PEER_TYPE_"]
      },
      {
        no: 2,
        name: "ice_candidate",
        kind: "scalar",
        T: 9
      },
      {
        no: 3,
        name: "session_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var ICETrickle$1 = new ICETrickle$Type$1();
var TrackInfo$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.models.TrackInfo", [
      {
        no: 1,
        name: "track_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "track_type",
        kind: "enum",
        T: () => [
          "stream.video.sfu.models.TrackType",
          TrackType,
          "TRACK_TYPE_"
        ]
      },
      {
        no: 5,
        name: "layers",
        kind: "message",
        repeat: 1,
        T: () => VideoLayer
      },
      {
        no: 6,
        name: "mid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "dtx",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 8,
        name: "stereo",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 9,
        name: "red",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 10,
        name: "muted",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      { no: 11, name: "codec", kind: "message", T: () => Codec },
      {
        no: 12,
        name: "publish_option_id",
        kind: "scalar",
        T: 5
      }
    ]);
  }
};
var TrackInfo = new TrackInfo$Type();
var Error$Type$1 = class Error$Type extends MessageType {
  constructor() {
    super("stream.video.sfu.models.Error", [
      {
        no: 1,
        name: "code",
        kind: "enum",
        T: () => [
          "stream.video.sfu.models.ErrorCode",
          ErrorCode,
          "ERROR_CODE_"
        ]
      },
      {
        no: 2,
        name: "message",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "should_retry",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
};
var Error$2 = new Error$Type$1();
var ClientDetails$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.models.ClientDetails", [
      { no: 1, name: "sdk", kind: "message", T: () => Sdk },
      { no: 2, name: "os", kind: "message", T: () => OS },
      { no: 3, name: "browser", kind: "message", T: () => Browser },
      { no: 4, name: "device", kind: "message", T: () => Device }
    ]);
  }
};
var ClientDetails = new ClientDetails$Type();
var Sdk$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.models.Sdk", [
      {
        no: 1,
        name: "type",
        kind: "enum",
        T: () => ["stream.video.sfu.models.SdkType", SdkType, "SDK_TYPE_"]
      },
      {
        no: 2,
        name: "major",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "minor",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "patch",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var Sdk = new Sdk$Type();
var OS$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.models.OS", [
      {
        no: 1,
        name: "name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "version",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "architecture",
        kind: "scalar",
        T: 9
      }
    ]);
  }
};
var OS = new OS$Type();
var Browser$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.models.Browser", [
      {
        no: 1,
        name: "name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "version",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var Browser = new Browser$Type();
var RTMPIngress$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.models.RTMPIngress", [
      {
        no: 1,
        name: "width",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 2,
        name: "height",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 3,
        name: "frame_rate",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 4,
        name: "software",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "version",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "encoder",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "remote_addr",
        kind: "scalar",
        T: 9
      }
    ]);
  }
};
var RTMPIngress = new RTMPIngress$Type();
var Device$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.models.Device", [
      {
        no: 1,
        name: "name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "version",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var Device = new Device$Type();
var Call$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.models.Call", [
      {
        no: 1,
        name: "type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "created_by_user_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 4,
        name: "host_user_id",
        kind: "scalar",
        T: 9
      },
      { no: 5, name: "custom", kind: "message", T: () => Struct },
      { no: 6, name: "created_at", kind: "message", T: () => Timestamp },
      { no: 7, name: "updated_at", kind: "message", T: () => Timestamp }
    ]);
  }
};
var Call$1 = new Call$Type();
var CallGrants$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.models.CallGrants", [
      {
        no: 1,
        name: "can_publish_audio",
        kind: "scalar",
        T: 8
      },
      {
        no: 2,
        name: "can_publish_video",
        kind: "scalar",
        T: 8
      },
      {
        no: 3,
        name: "can_screenshare",
        kind: "scalar",
        T: 8
      }
    ]);
  }
};
var CallGrants = new CallGrants$Type();
var InputDevices$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.models.InputDevices", [
      {
        no: 1,
        name: "available_devices",
        kind: "scalar",
        repeat: 2,
        T: 9
      },
      {
        no: 2,
        name: "current_device",
        kind: "scalar",
        T: 9
      },
      {
        no: 3,
        name: "is_permitted",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
};
var InputDevices = new InputDevices$Type();
var AndroidState$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.models.AndroidState", [
      {
        no: 1,
        name: "thermal_state",
        kind: "enum",
        T: () => [
          "stream.video.sfu.models.AndroidThermalState",
          AndroidThermalState,
          "ANDROID_THERMAL_STATE_"
        ]
      },
      {
        no: 2,
        name: "is_power_saver_mode",
        kind: "scalar",
        T: 8
      }
    ]);
  }
};
var AndroidState = new AndroidState$Type();
var AppleState$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.models.AppleState", [
      {
        no: 1,
        name: "thermal_state",
        kind: "enum",
        T: () => [
          "stream.video.sfu.models.AppleThermalState",
          AppleThermalState,
          "APPLE_THERMAL_STATE_"
        ]
      },
      {
        no: 2,
        name: "is_low_power_mode_enabled",
        kind: "scalar",
        T: 8
      }
    ]);
  }
};
var AppleState = new AppleState$Type();
var models = Object.freeze({
  __proto__: null,
  AndroidState,
  get AndroidThermalState() {
    return AndroidThermalState;
  },
  AppleState,
  get AppleThermalState() {
    return AppleThermalState;
  },
  Browser,
  Call: Call$1,
  get CallEndedReason() {
    return CallEndedReason;
  },
  CallGrants,
  CallState: CallState$1,
  ClientDetails,
  Codec,
  get ConnectionQuality() {
    return ConnectionQuality;
  },
  Device,
  Error: Error$2,
  get ErrorCode() {
    return ErrorCode;
  },
  get GoAwayReason() {
    return GoAwayReason;
  },
  ICETrickle: ICETrickle$1,
  InputDevices,
  OS,
  Participant,
  ParticipantCount,
  get PeerType() {
    return PeerType;
  },
  Pin,
  PublishOption,
  RTMPIngress,
  Sdk,
  get SdkType() {
    return SdkType;
  },
  StreamQuality,
  SubscribeOption,
  TrackInfo,
  get TrackType() {
    return TrackType;
  },
  get TrackUnpublishReason() {
    return TrackUnpublishReason;
  },
  VideoDimension,
  VideoLayer,
  get VideoQuality() {
    return VideoQuality;
  },
  get WebsocketReconnectStrategy() {
    return WebsocketReconnectStrategy;
  }
});
var StartNoiseCancellationRequest$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.signal.StartNoiseCancellationRequest", [
      {
        no: 1,
        name: "session_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var StartNoiseCancellationRequest = new StartNoiseCancellationRequest$Type();
var StartNoiseCancellationResponse$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.signal.StartNoiseCancellationResponse", [
      { no: 1, name: "error", kind: "message", T: () => Error$2 }
    ]);
  }
};
var StartNoiseCancellationResponse = new StartNoiseCancellationResponse$Type();
var StopNoiseCancellationRequest$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.signal.StopNoiseCancellationRequest", [
      {
        no: 1,
        name: "session_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var StopNoiseCancellationRequest = new StopNoiseCancellationRequest$Type();
var StopNoiseCancellationResponse$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.signal.StopNoiseCancellationResponse", [
      { no: 1, name: "error", kind: "message", T: () => Error$2 }
    ]);
  }
};
var StopNoiseCancellationResponse = new StopNoiseCancellationResponse$Type();
var Reconnection$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.signal.Reconnection", [
      {
        no: 1,
        name: "time_seconds",
        kind: "scalar",
        T: 2
      },
      {
        no: 2,
        name: "strategy",
        kind: "enum",
        T: () => [
          "stream.video.sfu.models.WebsocketReconnectStrategy",
          WebsocketReconnectStrategy,
          "WEBSOCKET_RECONNECT_STRATEGY_"
        ]
      }
    ]);
  }
};
var Reconnection = new Reconnection$Type();
var Telemetry$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.signal.Telemetry", [
      {
        no: 1,
        name: "connection_time_seconds",
        kind: "scalar",
        oneof: "data",
        T: 2
      },
      {
        no: 2,
        name: "reconnection",
        kind: "message",
        oneof: "data",
        T: () => Reconnection
      }
    ]);
  }
};
var Telemetry = new Telemetry$Type();
var SendStatsRequest$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.signal.SendStatsRequest", [
      {
        no: 1,
        name: "session_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "subscriber_stats",
        kind: "scalar",
        T: 9
      },
      {
        no: 3,
        name: "publisher_stats",
        kind: "scalar",
        T: 9
      },
      {
        no: 4,
        name: "webrtc_version",
        kind: "scalar",
        T: 9
      },
      {
        no: 5,
        name: "sdk",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "sdk_version",
        kind: "scalar",
        T: 9
      },
      { no: 7, name: "audio_devices", kind: "message", T: () => InputDevices },
      { no: 8, name: "video_devices", kind: "message", T: () => InputDevices },
      {
        no: 9,
        name: "android",
        kind: "message",
        oneof: "deviceState",
        T: () => AndroidState
      },
      {
        no: 10,
        name: "apple",
        kind: "message",
        oneof: "deviceState",
        T: () => AppleState
      },
      { no: 11, name: "telemetry", kind: "message", T: () => Telemetry },
      { no: 12, name: "rtmp", kind: "message", T: () => RTMPIngress },
      {
        no: 13,
        name: "subscriber_rtc_stats",
        kind: "scalar",
        T: 9
      },
      {
        no: 14,
        name: "publisher_rtc_stats",
        kind: "scalar",
        T: 9
      }
    ]);
  }
};
var SendStatsRequest = new SendStatsRequest$Type();
var SendStatsResponse$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.signal.SendStatsResponse", [
      { no: 1, name: "error", kind: "message", T: () => Error$2 }
    ]);
  }
};
var SendStatsResponse = new SendStatsResponse$Type();
var ICERestartRequest$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.signal.ICERestartRequest", [
      {
        no: 1,
        name: "session_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "peer_type",
        kind: "enum",
        T: () => ["stream.video.sfu.models.PeerType", PeerType, "PEER_TYPE_"]
      }
    ]);
  }
};
var ICERestartRequest = new ICERestartRequest$Type();
var ICERestartResponse$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.signal.ICERestartResponse", [
      { no: 1, name: "error", kind: "message", T: () => Error$2 }
    ]);
  }
};
var ICERestartResponse = new ICERestartResponse$Type();
var UpdateMuteStatesRequest$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.signal.UpdateMuteStatesRequest", [
      {
        no: 1,
        name: "session_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "mute_states",
        kind: "message",
        repeat: 1,
        T: () => TrackMuteState
      }
    ]);
  }
};
var UpdateMuteStatesRequest = new UpdateMuteStatesRequest$Type();
var UpdateMuteStatesResponse$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.signal.UpdateMuteStatesResponse", [
      { no: 4, name: "error", kind: "message", T: () => Error$2 }
    ]);
  }
};
var UpdateMuteStatesResponse = new UpdateMuteStatesResponse$Type();
var TrackMuteState$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.signal.TrackMuteState", [
      {
        no: 1,
        name: "track_type",
        kind: "enum",
        T: () => [
          "stream.video.sfu.models.TrackType",
          TrackType,
          "TRACK_TYPE_"
        ]
      },
      {
        no: 2,
        name: "muted",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
};
var TrackMuteState = new TrackMuteState$Type();
var AudioMuteChanged$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.signal.AudioMuteChanged", [
      {
        no: 1,
        name: "muted",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
};
new AudioMuteChanged$Type();
var VideoMuteChanged$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.signal.VideoMuteChanged", [
      {
        no: 2,
        name: "muted",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
};
new VideoMuteChanged$Type();
var UpdateSubscriptionsRequest$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.signal.UpdateSubscriptionsRequest", [
      {
        no: 2,
        name: "session_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "tracks",
        kind: "message",
        repeat: 1,
        T: () => TrackSubscriptionDetails
      }
    ]);
  }
};
var UpdateSubscriptionsRequest = new UpdateSubscriptionsRequest$Type();
var UpdateSubscriptionsResponse$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.signal.UpdateSubscriptionsResponse", [
      { no: 4, name: "error", kind: "message", T: () => Error$2 }
    ]);
  }
};
var UpdateSubscriptionsResponse = new UpdateSubscriptionsResponse$Type();
var TrackSubscriptionDetails$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.signal.TrackSubscriptionDetails", [
      {
        no: 1,
        name: "user_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "session_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "track_type",
        kind: "enum",
        T: () => [
          "stream.video.sfu.models.TrackType",
          TrackType,
          "TRACK_TYPE_"
        ]
      },
      { no: 4, name: "dimension", kind: "message", T: () => VideoDimension }
    ]);
  }
};
var TrackSubscriptionDetails = new TrackSubscriptionDetails$Type();
var SendAnswerRequest$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.signal.SendAnswerRequest", [
      {
        no: 1,
        name: "peer_type",
        kind: "enum",
        T: () => ["stream.video.sfu.models.PeerType", PeerType, "PEER_TYPE_"]
      },
      {
        no: 2,
        name: "sdp",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "session_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var SendAnswerRequest = new SendAnswerRequest$Type();
var SendAnswerResponse$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.signal.SendAnswerResponse", [
      { no: 4, name: "error", kind: "message", T: () => Error$2 }
    ]);
  }
};
var SendAnswerResponse = new SendAnswerResponse$Type();
var ICETrickleResponse$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.signal.ICETrickleResponse", [
      { no: 4, name: "error", kind: "message", T: () => Error$2 }
    ]);
  }
};
var ICETrickleResponse = new ICETrickleResponse$Type();
var SetPublisherRequest$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.signal.SetPublisherRequest", [
      {
        no: 1,
        name: "sdp",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "session_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "tracks",
        kind: "message",
        repeat: 1,
        T: () => TrackInfo
      }
    ]);
  }
};
var SetPublisherRequest = new SetPublisherRequest$Type();
var SetPublisherResponse$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.signal.SetPublisherResponse", [
      {
        no: 1,
        name: "sdp",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "session_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "ice_restart",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      { no: 4, name: "error", kind: "message", T: () => Error$2 }
    ]);
  }
};
var SetPublisherResponse = new SetPublisherResponse$Type();
var SignalServer = new ServiceType("stream.video.sfu.signal.SignalServer", [
  {
    name: "SetPublisher",
    options: {},
    I: SetPublisherRequest,
    O: SetPublisherResponse
  },
  {
    name: "SendAnswer",
    options: {},
    I: SendAnswerRequest,
    O: SendAnswerResponse
  },
  { name: "IceTrickle", options: {}, I: ICETrickle$1, O: ICETrickleResponse },
  {
    name: "UpdateSubscriptions",
    options: {},
    I: UpdateSubscriptionsRequest,
    O: UpdateSubscriptionsResponse
  },
  {
    name: "UpdateMuteStates",
    options: {},
    I: UpdateMuteStatesRequest,
    O: UpdateMuteStatesResponse
  },
  {
    name: "IceRestart",
    options: {},
    I: ICERestartRequest,
    O: ICERestartResponse
  },
  {
    name: "SendStats",
    options: {},
    I: SendStatsRequest,
    O: SendStatsResponse
  },
  {
    name: "StartNoiseCancellation",
    options: {},
    I: StartNoiseCancellationRequest,
    O: StartNoiseCancellationResponse
  },
  {
    name: "StopNoiseCancellation",
    options: {},
    I: StopNoiseCancellationRequest,
    O: StopNoiseCancellationResponse
  }
]);
var SfuEvent$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.SfuEvent", [
      {
        no: 1,
        name: "subscriber_offer",
        kind: "message",
        oneof: "eventPayload",
        T: () => SubscriberOffer
      },
      {
        no: 2,
        name: "publisher_answer",
        kind: "message",
        oneof: "eventPayload",
        T: () => PublisherAnswer
      },
      {
        no: 3,
        name: "connection_quality_changed",
        kind: "message",
        oneof: "eventPayload",
        T: () => ConnectionQualityChanged
      },
      {
        no: 4,
        name: "audio_level_changed",
        kind: "message",
        oneof: "eventPayload",
        T: () => AudioLevelChanged
      },
      {
        no: 5,
        name: "ice_trickle",
        kind: "message",
        oneof: "eventPayload",
        T: () => ICETrickle$1
      },
      {
        no: 6,
        name: "change_publish_quality",
        kind: "message",
        oneof: "eventPayload",
        T: () => ChangePublishQuality
      },
      {
        no: 10,
        name: "participant_joined",
        kind: "message",
        oneof: "eventPayload",
        T: () => ParticipantJoined
      },
      {
        no: 11,
        name: "participant_left",
        kind: "message",
        oneof: "eventPayload",
        T: () => ParticipantLeft
      },
      {
        no: 12,
        name: "dominant_speaker_changed",
        kind: "message",
        oneof: "eventPayload",
        T: () => DominantSpeakerChanged
      },
      {
        no: 13,
        name: "join_response",
        kind: "message",
        oneof: "eventPayload",
        T: () => JoinResponse
      },
      {
        no: 14,
        name: "health_check_response",
        kind: "message",
        oneof: "eventPayload",
        T: () => HealthCheckResponse
      },
      {
        no: 16,
        name: "track_published",
        kind: "message",
        oneof: "eventPayload",
        T: () => TrackPublished
      },
      {
        no: 17,
        name: "track_unpublished",
        kind: "message",
        oneof: "eventPayload",
        T: () => TrackUnpublished
      },
      {
        no: 18,
        name: "error",
        kind: "message",
        oneof: "eventPayload",
        T: () => Error$1
      },
      {
        no: 19,
        name: "call_grants_updated",
        kind: "message",
        oneof: "eventPayload",
        T: () => CallGrantsUpdated
      },
      {
        no: 20,
        name: "go_away",
        kind: "message",
        oneof: "eventPayload",
        T: () => GoAway
      },
      {
        no: 21,
        name: "ice_restart",
        kind: "message",
        oneof: "eventPayload",
        T: () => ICERestart
      },
      {
        no: 22,
        name: "pins_updated",
        kind: "message",
        oneof: "eventPayload",
        T: () => PinsChanged
      },
      {
        no: 23,
        name: "call_ended",
        kind: "message",
        oneof: "eventPayload",
        T: () => CallEnded
      },
      {
        no: 24,
        name: "participant_updated",
        kind: "message",
        oneof: "eventPayload",
        T: () => ParticipantUpdated
      },
      {
        no: 25,
        name: "participant_migration_complete",
        kind: "message",
        oneof: "eventPayload",
        T: () => ParticipantMigrationComplete
      },
      {
        no: 27,
        name: "change_publish_options",
        kind: "message",
        oneof: "eventPayload",
        T: () => ChangePublishOptions
      }
    ]);
  }
};
var SfuEvent = new SfuEvent$Type();
var ChangePublishOptions$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.ChangePublishOptions", [
      {
        no: 1,
        name: "publish_options",
        kind: "message",
        repeat: 1,
        T: () => PublishOption
      },
      {
        no: 2,
        name: "reason",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var ChangePublishOptions = new ChangePublishOptions$Type();
var ChangePublishOptionsComplete$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.ChangePublishOptionsComplete", []);
  }
};
var ChangePublishOptionsComplete = new ChangePublishOptionsComplete$Type();
var ParticipantMigrationComplete$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.ParticipantMigrationComplete", []);
  }
};
var ParticipantMigrationComplete = new ParticipantMigrationComplete$Type();
var PinsChanged$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.PinsChanged", [
      {
        no: 1,
        name: "pins",
        kind: "message",
        repeat: 1,
        T: () => Pin
      }
    ]);
  }
};
var PinsChanged = new PinsChanged$Type();
var Error$Type2 = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.Error", [
      { no: 4, name: "error", kind: "message", T: () => Error$2 },
      {
        no: 5,
        name: "reconnect_strategy",
        kind: "enum",
        T: () => [
          "stream.video.sfu.models.WebsocketReconnectStrategy",
          WebsocketReconnectStrategy,
          "WEBSOCKET_RECONNECT_STRATEGY_"
        ]
      }
    ]);
  }
};
var Error$1 = new Error$Type2();
var ICETrickle$Type2 = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.ICETrickle", [
      {
        no: 1,
        name: "peer_type",
        kind: "enum",
        T: () => ["stream.video.sfu.models.PeerType", PeerType, "PEER_TYPE_"]
      },
      {
        no: 2,
        name: "ice_candidate",
        kind: "scalar",
        T: 9
      }
    ]);
  }
};
var ICETrickle = new ICETrickle$Type2();
var ICERestart$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.ICERestart", [
      {
        no: 1,
        name: "peer_type",
        kind: "enum",
        T: () => ["stream.video.sfu.models.PeerType", PeerType, "PEER_TYPE_"]
      }
    ]);
  }
};
var ICERestart = new ICERestart$Type();
var SfuRequest$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.SfuRequest", [
      {
        no: 1,
        name: "join_request",
        kind: "message",
        oneof: "requestPayload",
        T: () => JoinRequest
      },
      {
        no: 2,
        name: "health_check_request",
        kind: "message",
        oneof: "requestPayload",
        T: () => HealthCheckRequest
      },
      {
        no: 3,
        name: "leave_call_request",
        kind: "message",
        oneof: "requestPayload",
        T: () => LeaveCallRequest
      }
    ]);
  }
};
var SfuRequest = new SfuRequest$Type();
var LeaveCallRequest$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.LeaveCallRequest", [
      {
        no: 1,
        name: "session_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "reason",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var LeaveCallRequest = new LeaveCallRequest$Type();
var HealthCheckRequest$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.HealthCheckRequest", []);
  }
};
var HealthCheckRequest = new HealthCheckRequest$Type();
var HealthCheckResponse$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.HealthCheckResponse", [
      {
        no: 1,
        name: "participant_count",
        kind: "message",
        T: () => ParticipantCount
      }
    ]);
  }
};
var HealthCheckResponse = new HealthCheckResponse$Type();
var TrackPublished$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.TrackPublished", [
      {
        no: 1,
        name: "user_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "session_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "type",
        kind: "enum",
        T: () => [
          "stream.video.sfu.models.TrackType",
          TrackType,
          "TRACK_TYPE_"
        ]
      },
      { no: 4, name: "participant", kind: "message", T: () => Participant }
    ]);
  }
};
var TrackPublished = new TrackPublished$Type();
var TrackUnpublished$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.TrackUnpublished", [
      {
        no: 1,
        name: "user_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "session_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "type",
        kind: "enum",
        T: () => [
          "stream.video.sfu.models.TrackType",
          TrackType,
          "TRACK_TYPE_"
        ]
      },
      {
        no: 4,
        name: "cause",
        kind: "enum",
        T: () => [
          "stream.video.sfu.models.TrackUnpublishReason",
          TrackUnpublishReason,
          "TRACK_UNPUBLISH_REASON_"
        ]
      },
      { no: 5, name: "participant", kind: "message", T: () => Participant }
    ]);
  }
};
var TrackUnpublished = new TrackUnpublished$Type();
var JoinRequest$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.JoinRequest", [
      {
        no: 1,
        name: "token",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "session_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "subscriber_sdp",
        kind: "scalar",
        T: 9
      },
      {
        no: 8,
        name: "publisher_sdp",
        kind: "scalar",
        T: 9
      },
      {
        no: 4,
        name: "client_details",
        kind: "message",
        T: () => ClientDetails
      },
      { no: 5, name: "migration", kind: "message", T: () => Migration },
      {
        no: 6,
        name: "fast_reconnect",
        kind: "scalar",
        T: 8
      },
      {
        no: 7,
        name: "reconnect_details",
        kind: "message",
        T: () => ReconnectDetails
      },
      {
        no: 9,
        name: "preferred_publish_options",
        kind: "message",
        repeat: 1,
        T: () => PublishOption
      },
      {
        no: 10,
        name: "preferred_subscribe_options",
        kind: "message",
        repeat: 1,
        T: () => SubscribeOption
      }
    ]);
  }
};
var JoinRequest = new JoinRequest$Type();
var ReconnectDetails$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.ReconnectDetails", [
      {
        no: 1,
        name: "strategy",
        kind: "enum",
        T: () => [
          "stream.video.sfu.models.WebsocketReconnectStrategy",
          WebsocketReconnectStrategy,
          "WEBSOCKET_RECONNECT_STRATEGY_"
        ]
      },
      {
        no: 3,
        name: "announced_tracks",
        kind: "message",
        repeat: 1,
        T: () => TrackInfo
      },
      {
        no: 4,
        name: "subscriptions",
        kind: "message",
        repeat: 1,
        T: () => TrackSubscriptionDetails
      },
      {
        no: 5,
        name: "reconnect_attempt",
        kind: "scalar",
        T: 13
      },
      {
        no: 6,
        name: "from_sfu_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 7,
        name: "previous_session_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 8,
        name: "reason",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var ReconnectDetails = new ReconnectDetails$Type();
var Migration$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.Migration", [
      {
        no: 1,
        name: "from_sfu_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "announced_tracks",
        kind: "message",
        repeat: 1,
        T: () => TrackInfo
      },
      {
        no: 3,
        name: "subscriptions",
        kind: "message",
        repeat: 1,
        T: () => TrackSubscriptionDetails
      }
    ]);
  }
};
var Migration = new Migration$Type();
var JoinResponse$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.JoinResponse", [
      { no: 1, name: "call_state", kind: "message", T: () => CallState$1 },
      {
        no: 2,
        name: "reconnected",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 3,
        name: "fast_reconnect_deadline_seconds",
        kind: "scalar",
        T: 5
      },
      {
        no: 4,
        name: "publish_options",
        kind: "message",
        repeat: 1,
        T: () => PublishOption
      }
    ]);
  }
};
var JoinResponse = new JoinResponse$Type();
var ParticipantJoined$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.ParticipantJoined", [
      {
        no: 1,
        name: "call_cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "participant", kind: "message", T: () => Participant }
    ]);
  }
};
var ParticipantJoined = new ParticipantJoined$Type();
var ParticipantLeft$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.ParticipantLeft", [
      {
        no: 1,
        name: "call_cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "participant", kind: "message", T: () => Participant }
    ]);
  }
};
var ParticipantLeft = new ParticipantLeft$Type();
var ParticipantUpdated$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.ParticipantUpdated", [
      {
        no: 1,
        name: "call_cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "participant", kind: "message", T: () => Participant }
    ]);
  }
};
var ParticipantUpdated = new ParticipantUpdated$Type();
var SubscriberOffer$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.SubscriberOffer", [
      {
        no: 1,
        name: "ice_restart",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 2,
        name: "sdp",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var SubscriberOffer = new SubscriberOffer$Type();
var PublisherAnswer$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.PublisherAnswer", [
      {
        no: 1,
        name: "sdp",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var PublisherAnswer = new PublisherAnswer$Type();
var ConnectionQualityChanged$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.ConnectionQualityChanged", [
      {
        no: 1,
        name: "connection_quality_updates",
        kind: "message",
        repeat: 1,
        T: () => ConnectionQualityInfo
      }
    ]);
  }
};
var ConnectionQualityChanged = new ConnectionQualityChanged$Type();
var ConnectionQualityInfo$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.ConnectionQualityInfo", [
      {
        no: 1,
        name: "user_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "session_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "connection_quality",
        kind: "enum",
        T: () => [
          "stream.video.sfu.models.ConnectionQuality",
          ConnectionQuality,
          "CONNECTION_QUALITY_"
        ]
      }
    ]);
  }
};
var ConnectionQualityInfo = new ConnectionQualityInfo$Type();
var DominantSpeakerChanged$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.DominantSpeakerChanged", [
      {
        no: 1,
        name: "user_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "session_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var DominantSpeakerChanged = new DominantSpeakerChanged$Type();
var AudioLevel$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.AudioLevel", [
      {
        no: 1,
        name: "user_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "session_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "level",
        kind: "scalar",
        T: 2
        /*ScalarType.FLOAT*/
      },
      {
        no: 4,
        name: "is_speaking",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
};
var AudioLevel = new AudioLevel$Type();
var AudioLevelChanged$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.AudioLevelChanged", [
      {
        no: 1,
        name: "audio_levels",
        kind: "message",
        repeat: 1,
        T: () => AudioLevel
      }
    ]);
  }
};
var AudioLevelChanged = new AudioLevelChanged$Type();
var AudioSender$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.AudioSender", [
      { no: 2, name: "codec", kind: "message", T: () => Codec },
      {
        no: 3,
        name: "track_type",
        kind: "enum",
        T: () => [
          "stream.video.sfu.models.TrackType",
          TrackType,
          "TRACK_TYPE_"
        ]
      },
      {
        no: 4,
        name: "publish_option_id",
        kind: "scalar",
        T: 5
      }
    ]);
  }
};
var AudioSender = new AudioSender$Type();
var VideoLayerSetting$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.VideoLayerSetting", [
      {
        no: 1,
        name: "name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "active",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 3,
        name: "max_bitrate",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 4,
        name: "scale_resolution_down_by",
        kind: "scalar",
        T: 2
      },
      { no: 6, name: "codec", kind: "message", T: () => Codec },
      {
        no: 7,
        name: "max_framerate",
        kind: "scalar",
        T: 13
      },
      {
        no: 8,
        name: "scalability_mode",
        kind: "scalar",
        T: 9
      }
    ]);
  }
};
var VideoLayerSetting = new VideoLayerSetting$Type();
var VideoSender$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.VideoSender", [
      { no: 2, name: "codec", kind: "message", T: () => Codec },
      {
        no: 3,
        name: "layers",
        kind: "message",
        repeat: 1,
        T: () => VideoLayerSetting
      },
      {
        no: 4,
        name: "track_type",
        kind: "enum",
        T: () => [
          "stream.video.sfu.models.TrackType",
          TrackType,
          "TRACK_TYPE_"
        ]
      },
      {
        no: 5,
        name: "publish_option_id",
        kind: "scalar",
        T: 5
      }
    ]);
  }
};
var VideoSender = new VideoSender$Type();
var ChangePublishQuality$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.ChangePublishQuality", [
      {
        no: 1,
        name: "audio_senders",
        kind: "message",
        repeat: 1,
        T: () => AudioSender
      },
      {
        no: 2,
        name: "video_senders",
        kind: "message",
        repeat: 1,
        T: () => VideoSender
      }
    ]);
  }
};
var ChangePublishQuality = new ChangePublishQuality$Type();
var CallGrantsUpdated$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.CallGrantsUpdated", [
      { no: 1, name: "current_grants", kind: "message", T: () => CallGrants },
      {
        no: 2,
        name: "message",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var CallGrantsUpdated = new CallGrantsUpdated$Type();
var GoAway$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.GoAway", [
      {
        no: 1,
        name: "reason",
        kind: "enum",
        T: () => [
          "stream.video.sfu.models.GoAwayReason",
          GoAwayReason,
          "GO_AWAY_REASON_"
        ]
      }
    ]);
  }
};
var GoAway = new GoAway$Type();
var CallEnded$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.CallEnded", [
      {
        no: 1,
        name: "reason",
        kind: "enum",
        T: () => [
          "stream.video.sfu.models.CallEndedReason",
          CallEndedReason,
          "CALL_ENDED_REASON_"
        ]
      }
    ]);
  }
};
var CallEnded = new CallEnded$Type();
var events = Object.freeze({
  __proto__: null,
  AudioLevel,
  AudioLevelChanged,
  AudioSender,
  CallEnded,
  CallGrantsUpdated,
  ChangePublishOptions,
  ChangePublishOptionsComplete,
  ChangePublishQuality,
  ConnectionQualityChanged,
  ConnectionQualityInfo,
  DominantSpeakerChanged,
  Error: Error$1,
  GoAway,
  HealthCheckRequest,
  HealthCheckResponse,
  ICERestart,
  ICETrickle,
  JoinRequest,
  JoinResponse,
  LeaveCallRequest,
  Migration,
  ParticipantJoined,
  ParticipantLeft,
  ParticipantMigrationComplete,
  ParticipantUpdated,
  PinsChanged,
  PublisherAnswer,
  ReconnectDetails,
  SfuEvent,
  SfuRequest,
  SubscriberOffer,
  TrackPublished,
  TrackUnpublished,
  VideoLayerSetting,
  VideoSender
});
var VisibilityState;
(function(VisibilityState2) {
  VisibilityState2["UNKNOWN"] = "UNKNOWN";
  VisibilityState2["VISIBLE"] = "VISIBLE";
  VisibilityState2["INVISIBLE"] = "INVISIBLE";
})(VisibilityState || (VisibilityState = {}));
var DebounceType;
(function(DebounceType2) {
  DebounceType2[DebounceType2["IMMEDIATE"] = 20] = "IMMEDIATE";
  DebounceType2[DebounceType2["FAST"] = 100] = "FAST";
  DebounceType2[DebounceType2["MEDIUM"] = 600] = "MEDIUM";
  DebounceType2[DebounceType2["SLOW"] = 1200] = "SLOW";
})(DebounceType || (DebounceType = {}));
var SignalServerClient = class {
  constructor(_transport) {
    this._transport = _transport;
    this.typeName = SignalServer.typeName;
    this.methods = SignalServer.methods;
    this.options = SignalServer.options;
  }
  /**
   * SetPublisher sends the WebRTC offer for the peer connection used to publish A/V
   *
   * @generated from protobuf rpc: SetPublisher(stream.video.sfu.signal.SetPublisherRequest) returns (stream.video.sfu.signal.SetPublisherResponse);
   */
  setPublisher(input, options) {
    const method = this.methods[0], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * answer is sent by the client to the SFU after receiving a subscriber_offer.
   *
   * @generated from protobuf rpc: SendAnswer(stream.video.sfu.signal.SendAnswerRequest) returns (stream.video.sfu.signal.SendAnswerResponse);
   */
  sendAnswer(input, options) {
    const method = this.methods[1], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * SendICECandidate sends an ICE candidate to the client
   *
   * @generated from protobuf rpc: IceTrickle(stream.video.sfu.models.ICETrickle) returns (stream.video.sfu.signal.ICETrickleResponse);
   */
  iceTrickle(input, options) {
    const method = this.methods[2], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * UpdateSubscribers is used to notify the SFU about the list of video subscriptions
   * TODO: sync subscriptions based on this + update tracks using the dimension info sent by the user
   *
   * @generated from protobuf rpc: UpdateSubscriptions(stream.video.sfu.signal.UpdateSubscriptionsRequest) returns (stream.video.sfu.signal.UpdateSubscriptionsResponse);
   */
  updateSubscriptions(input, options) {
    const method = this.methods[3], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * @generated from protobuf rpc: UpdateMuteStates(stream.video.sfu.signal.UpdateMuteStatesRequest) returns (stream.video.sfu.signal.UpdateMuteStatesResponse);
   */
  updateMuteStates(input, options) {
    const method = this.methods[4], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * @generated from protobuf rpc: IceRestart(stream.video.sfu.signal.ICERestartRequest) returns (stream.video.sfu.signal.ICERestartResponse);
   */
  iceRestart(input, options) {
    const method = this.methods[5], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * @generated from protobuf rpc: SendStats(stream.video.sfu.signal.SendStatsRequest) returns (stream.video.sfu.signal.SendStatsResponse);
   */
  sendStats(input, options) {
    const method = this.methods[6], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * @generated from protobuf rpc: StartNoiseCancellation(stream.video.sfu.signal.StartNoiseCancellationRequest) returns (stream.video.sfu.signal.StartNoiseCancellationResponse);
   */
  startNoiseCancellation(input, options) {
    const method = this.methods[7], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * @generated from protobuf rpc: StopNoiseCancellation(stream.video.sfu.signal.StopNoiseCancellationRequest) returns (stream.video.sfu.signal.StopNoiseCancellationResponse);
   */
  stopNoiseCancellation(input, options) {
    const method = this.methods[8], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
};
var defaultOptions = {
  baseUrl: "",
  sendJson: true,
  timeout: 5 * 1e3,
  // ms.
  jsonOptions: {
    ignoreUnknownFields: true
  }
};
var withHeaders = (headers) => {
  return {
    interceptUnary(next, method, input, options) {
      options.meta = { ...options.meta, ...headers };
      return next(method, input, options);
    }
  };
};
var withRequestLogger = (logger2, level2) => {
  return {
    interceptUnary: (next, method, input, options) => {
      let invocation;
      try {
        invocation = next(method, input, options);
      } finally {
        logger2(level2, `Invoked SFU RPC method ${method.name}`, {
          request: invocation == null ? void 0 : invocation.request,
          headers: invocation == null ? void 0 : invocation.requestHeaders,
          response: invocation == null ? void 0 : invocation.response
        });
      }
      return invocation;
    }
  };
};
var withRequestTracer = (trace) => {
  const exclusions = {
    SendStats: true
  };
  return {
    interceptUnary(next, method, input, options) {
      if (exclusions[method.name]) {
        return next(method, input, options);
      }
      try {
        trace(method.name, input);
        return next(method, input, options);
      } catch (err) {
        trace(`${method.name}OnFailure`, [input, err]);
        throw err;
      }
    }
  };
};
var createSignalClient = (options) => {
  const transport = new TwirpFetchTransport({
    ...defaultOptions,
    ...options
  });
  return new SignalServerClient(transport);
};
var sleep = (m) => new Promise((r) => setTimeout(r, m));
function isFunction2(value) {
  return value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);
}
var KnownCodes = {
  TOKEN_EXPIRED: 40,
  WS_CLOSED_SUCCESS: 1e3
};
function retryInterval(numberOfFailures) {
  const max3 = Math.min(500 + numberOfFailures * 2e3, 5e3);
  const min3 = Math.min(Math.max(250, (numberOfFailures - 1) * 2e3), 5e3);
  return Math.floor(Math.random() * (max3 - min3) + min3);
}
function hex(bytes) {
  let s = "";
  for (let i = 0; i < bytes.length; i++) {
    s += bytes[i].toString(16).padStart(2, "0");
  }
  return s;
}
function generateUUIDv4() {
  const bytes = getRandomBytes(16);
  bytes[6] = bytes[6] & 15 | 64;
  bytes[8] = bytes[8] & 191 | 128;
  return [
    hex(bytes.subarray(0, 4)),
    hex(bytes.subarray(4, 6)),
    hex(bytes.subarray(6, 8)),
    hex(bytes.subarray(8, 10)),
    hex(bytes.subarray(10, 16))
  ].join("-");
}
var getRandomValues = (() => {
  if (typeof crypto !== "undefined" && crypto.getRandomValues) {
    return crypto.getRandomValues.bind(crypto);
  }
  return function getRandomValuesWithMathRandom(bytes) {
    const max3 = Math.pow(2, 8 * bytes.byteLength / bytes.length);
    for (let i = 0; i < bytes.length; i++) {
      bytes[i] = Math.random() * max3;
    }
  };
})();
function getRandomBytes(length) {
  const bytes = new Uint8Array(length);
  getRandomValues(bytes);
  return bytes;
}
function addConnectionEventListeners(cb) {
  if (typeof window !== "undefined" && window.addEventListener) {
    window.addEventListener("offline", cb);
    window.addEventListener("online", cb);
  }
}
function removeConnectionEventListeners(cb) {
  if (typeof window !== "undefined" && window.removeEventListener) {
    window.removeEventListener("offline", cb);
    window.removeEventListener("online", cb);
  }
}
function isErrorResponse(res) {
  return !res.status || res.status < 200 || 300 <= res.status;
}
function isCloseEvent(res) {
  return res.code !== void 0;
}
var isReactNative = () => {
  var _a;
  if (typeof navigator === "undefined")
    return false;
  return ((_a = navigator.product) == null ? void 0 : _a.toLowerCase()) === "reactnative";
};
var logLevels = Object.freeze({
  trace: 0,
  debug: 1,
  info: 2,
  warn: 3,
  error: 4
});
var logger;
var level = "info";
var logToConsole = (logLevel, message, ...args) => {
  let logMethod;
  switch (logLevel) {
    case "error":
      if (isReactNative()) {
        message = `ERROR: ${message}`;
        logMethod = console.info;
        break;
      }
      logMethod = console.error;
      break;
    case "warn":
      if (isReactNative()) {
        message = `WARN: ${message}`;
        logMethod = console.info;
        break;
      }
      logMethod = console.warn;
      break;
    case "info":
      logMethod = console.info;
      break;
    case "trace":
      logMethod = console.trace;
      break;
    default:
      logMethod = console.log;
      break;
  }
  logMethod(message, ...args);
};
var setLogger = (l, lvl) => {
  logger = l;
  if (lvl) {
    setLogLevel(lvl);
  }
};
var setLogLevel = (l) => {
  level = l;
};
var getLogLevel = () => level;
var getLogger = (withTags) => {
  const loggerMethod = logger || logToConsole;
  const tags = (withTags || []).filter(Boolean).join(":");
  const result = (logLevel, message, ...args) => {
    if (logLevels[logLevel] >= logLevels[level]) {
      loggerMethod(logLevel, `[${tags}]: ${message}`, ...args);
    }
  };
  return result;
};
var retryable = async (rpc, signal) => {
  var _a;
  let attempt = 0;
  let result = void 0;
  do {
    if (attempt > 0)
      await sleep(retryInterval(attempt));
    try {
      result = await rpc();
    } catch (err) {
      const isRequestCancelled = err instanceof RpcError && err.code === TwirpErrorCode[TwirpErrorCode.cancelled];
      const isAborted = (signal == null ? void 0 : signal.aborted) ?? false;
      if (isRequestCancelled || isAborted)
        throw err;
      getLogger(["sfu-client", "rpc"])("debug", `rpc failed (${attempt})`, err);
      attempt++;
    }
  } while (!result || ((_a = result.response.error) == null ? void 0 : _a.shouldRetry));
  return result;
};
var getGenericSdp = async (direction) => {
  const tempPc = new RTCPeerConnection();
  tempPc.addTransceiver("video", { direction });
  tempPc.addTransceiver("audio", { direction });
  const offer = await tempPc.createOffer();
  const sdp2 = offer.sdp ?? "";
  tempPc.getTransceivers().forEach((t2) => {
    var _a;
    (_a = t2.stop) == null ? void 0 : _a.call(t2);
  });
  tempPc.close();
  return sdp2;
};
var isSvcCodec = (codecOrMimeType) => {
  if (!codecOrMimeType)
    return false;
  codecOrMimeType = codecOrMimeType.toLowerCase();
  return codecOrMimeType === "vp9" || codecOrMimeType === "av1" || codecOrMimeType === "video/vp9" || codecOrMimeType === "video/av1";
};
var sfuEventKinds = {
  subscriberOffer: void 0,
  publisherAnswer: void 0,
  connectionQualityChanged: void 0,
  audioLevelChanged: void 0,
  iceTrickle: void 0,
  changePublishQuality: void 0,
  participantJoined: void 0,
  participantLeft: void 0,
  dominantSpeakerChanged: void 0,
  joinResponse: void 0,
  healthCheckResponse: void 0,
  trackPublished: void 0,
  trackUnpublished: void 0,
  error: void 0,
  callGrantsUpdated: void 0,
  goAway: void 0,
  iceRestart: void 0,
  pinsUpdated: void 0,
  callEnded: void 0,
  participantUpdated: void 0,
  participantMigrationComplete: void 0,
  changePublishOptions: void 0
};
var isSfuEvent = (eventName) => {
  return Object.prototype.hasOwnProperty.call(sfuEventKinds, eventName);
};
var Dispatcher = class {
  constructor() {
    this.logger = getLogger(["Dispatcher"]);
    this.subscribers = {};
    this.dispatch = (message, logTag = "0") => {
      const eventKind = message.eventPayload.oneofKind;
      if (!eventKind)
        return;
      const payload = message.eventPayload[eventKind];
      this.logger("debug", `Dispatching ${eventKind}, tag=${logTag}`, payload);
      const listeners = this.subscribers[eventKind];
      if (!listeners)
        return;
      for (const fn of listeners) {
        try {
          fn(payload);
        } catch (e) {
          this.logger("warn", "Listener failed with error", e);
        }
      }
    };
    this.on = (eventName, fn) => {
      var _a;
      ((_a = this.subscribers)[eventName] ?? (_a[eventName] = [])).push(fn);
      return () => {
        this.off(eventName, fn);
      };
    };
    this.off = (eventName, fn) => {
      this.subscribers[eventName] = (this.subscribers[eventName] || []).filter((f) => f !== fn);
    };
  }
};
var IceTrickleBuffer = class {
  constructor() {
    this.subscriberCandidates = new ReplaySubject();
    this.publisherCandidates = new ReplaySubject();
    this.push = (iceTrickle) => {
      const iceCandidate = toIceCandidate(iceTrickle);
      if (!iceCandidate)
        return;
      if (iceTrickle.peerType === PeerType.SUBSCRIBER) {
        this.subscriberCandidates.next(iceCandidate);
      } else if (iceTrickle.peerType === PeerType.PUBLISHER_UNSPECIFIED) {
        this.publisherCandidates.next(iceCandidate);
      } else {
        const logger2 = getLogger(["sfu-client"]);
        logger2("warn", `ICETrickle, Unknown peer type`, iceTrickle);
      }
    };
    this.dispose = () => {
      this.subscriberCandidates.complete();
      this.publisherCandidates.complete();
    };
  }
};
var toIceCandidate = (iceTrickle) => {
  try {
    return JSON.parse(iceTrickle.iceCandidate);
  } catch (e) {
    const logger2 = getLogger(["sfu-client"]);
    logger2("error", `Failed to parse ICE Trickle`, e, iceTrickle);
    return void 0;
  }
};
var withoutConcurrency = createRunner(wrapWithContinuationTracking);
var withCancellation = createRunner(wrapWithCancellation);
var pendingPromises = /* @__PURE__ */ new Map();
function hasPending(tag) {
  return pendingPromises.has(tag);
}
async function settled(tag) {
  let pending;
  while (pending = pendingPromises.get(tag)) {
    await pending.promise;
  }
}
function createRunner(wrapper) {
  return function run(tag, cb) {
    const { cb: wrapped, onContinued } = wrapper(tag, cb);
    const pending = pendingPromises.get(tag);
    pending == null ? void 0 : pending.onContinued();
    const promise = pending ? pending.promise.then(wrapped, wrapped) : wrapped();
    pendingPromises.set(tag, { promise, onContinued });
    return promise;
  };
}
function wrapWithContinuationTracking(tag, cb) {
  let hasContinuation = false;
  const wrapped = () => cb().finally(() => {
    if (!hasContinuation) {
      pendingPromises.delete(tag);
    }
  });
  const onContinued = () => hasContinuation = true;
  return { cb: wrapped, onContinued };
}
function wrapWithCancellation(tag, cb) {
  const ac = new AbortController();
  const wrapped = () => {
    if (ac.signal.aborted) {
      return Promise.resolve("canceled");
    }
    return cb(ac.signal).finally(() => {
      if (!ac.signal.aborted) {
        pendingPromises.delete(tag);
      }
    });
  };
  const onContinued = () => ac.abort();
  return { cb: wrapped, onContinued };
}
var isFunctionPatch = (update) => typeof update === "function";
var getCurrentValue = (observable$) => {
  let value;
  let err = void 0;
  combineLatest([observable$]).subscribe({
    next: ([v]) => {
      value = v;
    },
    error: (e) => {
      err = e;
    }
  }).unsubscribe();
  if (err)
    throw err;
  return value;
};
var setCurrentValue = (subject, update) => {
  const next = isFunctionPatch(update) ? update(getCurrentValue(subject)) : update;
  subject.next(next);
  return next;
};
var updateValue = (subject, update) => {
  const lastValue = subject.getValue();
  const value = setCurrentValue(subject, update);
  return {
    lastValue,
    value,
    rollback: () => setCurrentValue(subject, lastValue)
  };
};
var createSubscription = (observable2, handler, onError = (error2) => getLogger(["RxUtils"])("warn", "An observable emitted an error", error2)) => {
  const subscription = observable2.subscribe({ next: handler, error: onError });
  return () => {
    subscription.unsubscribe();
  };
};
var createSafeAsyncSubscription = (observable2, handler) => {
  const tag = Symbol();
  return createSubscription(observable2, (value) => {
    withoutConcurrency(tag, () => handler(value));
  });
};
var rxUtils = Object.freeze({
  __proto__: null,
  createSafeAsyncSubscription,
  createSubscription,
  getCurrentValue,
  setCurrentValue,
  updateValue
});
var CallingState;
(function(CallingState2) {
  CallingState2["UNKNOWN"] = "unknown";
  CallingState2["IDLE"] = "idle";
  CallingState2["RINGING"] = "ringing";
  CallingState2["JOINING"] = "joining";
  CallingState2["JOINED"] = "joined";
  CallingState2["LEFT"] = "left";
  CallingState2["RECONNECTING"] = "reconnecting";
  CallingState2["MIGRATING"] = "migrating";
  CallingState2["RECONNECTING_FAILED"] = "reconnecting-failed";
  CallingState2["OFFLINE"] = "offline";
})(CallingState || (CallingState = {}));
var StreamVideoWriteableStateStore = class {
  constructor() {
    this.connectedUserSubject = new BehaviorSubject(void 0);
    this.callsSubject = new BehaviorSubject([]);
    this.setConnectedUser = (user) => {
      return setCurrentValue(this.connectedUserSubject, user);
    };
    this.setCalls = (calls) => {
      return setCurrentValue(this.callsSubject, calls);
    };
    this.registerCall = (call) => {
      if (!this.calls.find((c) => c.cid === call.cid)) {
        this.setCalls((calls) => [...calls, call]);
      }
    };
    this.unregisterCall = (call) => {
      const logger2 = getLogger(["client-state"]);
      logger2("trace", `Unregistering call: ${call.cid}`);
      return this.setCalls((calls) => calls.filter((c) => c !== call));
    };
    this.findCall = (type, id) => {
      return this.calls.find((c) => c.type === type && c.id === id);
    };
    this.connectedUserSubject.subscribe(async (user) => {
      if (!user) {
        const logger2 = getLogger(["client-state"]);
        for (const call of this.calls) {
          if (call.state.callingState === CallingState.LEFT)
            continue;
          logger2("info", `User disconnected, leaving call: ${call.cid}`);
          await call.leave({ reason: "client.disconnectUser() called" }).catch((err) => {
            logger2("error", `Error leaving call: ${call.cid}`, err);
          });
        }
      }
    });
  }
  /**
   * The currently connected user.
   */
  get connectedUser() {
    return getCurrentValue(this.connectedUserSubject);
  }
  /**
   * A list of {@link Call} objects created/tracked by this client.
   */
  get calls() {
    return getCurrentValue(this.callsSubject);
  }
};
var StreamVideoReadOnlyStateStore = class {
  constructor(store) {
    this.getCurrentValue = getCurrentValue;
    this.connectedUser$ = store.connectedUserSubject.asObservable();
    this.calls$ = store.callsSubject.asObservable();
  }
  /**
   * The current user connected over WS to the backend.
   */
  get connectedUser() {
    return getCurrentValue(this.connectedUser$);
  }
  /**
   * A list of {@link Call} objects created/tracked by this client.
   */
  get calls() {
    return getCurrentValue(this.calls$);
  }
};
var combineComparators = (...comparators) => {
  return (a, b) => {
    for (const comparator of comparators) {
      const result = comparator(a, b);
      if (result !== 0)
        return result;
    }
    return 0;
  };
};
var descending = (comparator) => {
  return (a, b) => comparator(b, a);
};
var conditional = (predicate) => {
  return (comparator) => {
    return (a, b) => {
      if (!predicate(a, b))
        return 0;
      return comparator(a, b);
    };
  };
};
var noopComparator = () => {
  return () => 0;
};
var hasVideo = (p) => p.publishedTracks.includes(TrackType.VIDEO);
var hasAudio = (p) => p.publishedTracks.includes(TrackType.AUDIO);
var hasScreenShare = (p) => p.publishedTracks.includes(TrackType.SCREEN_SHARE);
var hasScreenShareAudio = (p) => p.publishedTracks.includes(TrackType.SCREEN_SHARE_AUDIO);
var isPinned = (p) => !!p.pin && (p.pin.isLocalPin || p.pin.pinnedAt > 0);
var dominantSpeaker = (a, b) => {
  if (a.isDominantSpeaker && !b.isDominantSpeaker)
    return -1;
  if (!a.isDominantSpeaker && b.isDominantSpeaker)
    return 1;
  return 0;
};
var speaking = (a, b) => {
  if (a.isSpeaking && !b.isSpeaking)
    return -1;
  if (!a.isSpeaking && b.isSpeaking)
    return 1;
  return 0;
};
var screenSharing = (a, b) => {
  if (hasScreenShare(a) && !hasScreenShare(b))
    return -1;
  if (!hasScreenShare(a) && hasScreenShare(b))
    return 1;
  return 0;
};
var publishingVideo = (a, b) => {
  if (hasVideo(a) && !hasVideo(b))
    return -1;
  if (!hasVideo(a) && hasVideo(b))
    return 1;
  return 0;
};
var publishingAudio = (a, b) => {
  if (hasAudio(a) && !hasAudio(b))
    return -1;
  if (!hasAudio(a) && hasAudio(b))
    return 1;
  return 0;
};
var pinned = (a, b) => {
  if (a.pin && b.pin) {
    if (!a.pin.isLocalPin && b.pin.isLocalPin)
      return -1;
    if (a.pin.isLocalPin && !b.pin.isLocalPin)
      return 1;
    if (a.pin.pinnedAt > b.pin.pinnedAt)
      return -1;
    if (a.pin.pinnedAt < b.pin.pinnedAt)
      return 1;
  }
  if (a.pin && !b.pin)
    return -1;
  if (!a.pin && b.pin)
    return 1;
  return 0;
};
var reactionType = (type) => {
  return (a, b) => {
    var _a, _b, _c, _d;
    if (((_a = a.reaction) == null ? void 0 : _a.type) === type && ((_b = b.reaction) == null ? void 0 : _b.type) !== type)
      return -1;
    if (((_c = a.reaction) == null ? void 0 : _c.type) !== type && ((_d = b.reaction) == null ? void 0 : _d.type) === type)
      return 1;
    return 0;
  };
};
var role = (...roles) => (a, b) => {
  if (hasAnyRole(a, roles) && !hasAnyRole(b, roles))
    return -1;
  if (!hasAnyRole(a, roles) && hasAnyRole(b, roles))
    return 1;
  return 0;
};
var name = (a, b) => {
  if (a.name < b.name)
    return -1;
  if (a.name > b.name)
    return 1;
  return 0;
};
var hasAnyRole = (p, roles) => (p.roles || []).some((r) => roles.includes(r));
var ifInvisibleBy = conditional((a, b) => {
  var _a, _b;
  return ((_a = a.viewportVisibilityState) == null ? void 0 : _a.videoTrack) === VisibilityState.INVISIBLE || ((_b = b.viewportVisibilityState) == null ? void 0 : _b.videoTrack) === VisibilityState.INVISIBLE;
});
var ifInvisibleOrUnknownBy = conditional((a, b) => {
  var _a, _b, _c, _d;
  return ((_a = a.viewportVisibilityState) == null ? void 0 : _a.videoTrack) === VisibilityState.INVISIBLE || ((_b = a.viewportVisibilityState) == null ? void 0 : _b.videoTrack) === VisibilityState.UNKNOWN || ((_c = b.viewportVisibilityState) == null ? void 0 : _c.videoTrack) === VisibilityState.INVISIBLE || ((_d = b.viewportVisibilityState) == null ? void 0 : _d.videoTrack) === VisibilityState.UNKNOWN;
});
var defaultSortPreset = combineComparators(pinned, screenSharing, ifInvisibleBy(combineComparators(dominantSpeaker, speaking, reactionType("raised-hand"), publishingVideo, publishingAudio)));
var speakerLayoutSortPreset = combineComparators(pinned, screenSharing, dominantSpeaker, ifInvisibleBy(combineComparators(speaking, reactionType("raised-hand"), publishingVideo, publishingAudio)));
var paginatedLayoutSortPreset = combineComparators(pinned, ifInvisibleOrUnknownBy(combineComparators(dominantSpeaker, speaking, reactionType("raised-hand"), publishingVideo, publishingAudio)));
var livestreamOrAudioRoomSortPreset = combineComparators(ifInvisibleBy(combineComparators(dominantSpeaker, speaking, reactionType("raised-hand"), publishingVideo, publishingAudio)), role("admin", "host", "speaker"));
var defaultEgress = {
  broadcasting: false,
  hls: { playlist_url: "", status: "" },
  rtmps: []
};
var CallState = class {
  /**
   * Creates a new instance of the CallState class.
   *
   */
  constructor() {
    this.backstageSubject = new BehaviorSubject(true);
    this.blockedUserIdsSubject = new BehaviorSubject([]);
    this.createdAtSubject = new BehaviorSubject(/* @__PURE__ */ new Date());
    this.endedAtSubject = new BehaviorSubject(void 0);
    this.startsAtSubject = new BehaviorSubject(void 0);
    this.updatedAtSubject = new BehaviorSubject(/* @__PURE__ */ new Date());
    this.createdBySubject = new BehaviorSubject(void 0);
    this.customSubject = new BehaviorSubject({});
    this.egressSubject = new BehaviorSubject(void 0);
    this.ingressSubject = new BehaviorSubject(void 0);
    this.recordingSubject = new BehaviorSubject(false);
    this.sessionSubject = new BehaviorSubject(void 0);
    this.settingsSubject = new BehaviorSubject(void 0);
    this.transcribingSubject = new BehaviorSubject(false);
    this.captioningSubject = new BehaviorSubject(false);
    this.endedBySubject = new BehaviorSubject(void 0);
    this.thumbnailsSubject = new BehaviorSubject(void 0);
    this.membersSubject = new BehaviorSubject([]);
    this.ownCapabilitiesSubject = new BehaviorSubject([]);
    this.callingStateSubject = new BehaviorSubject(CallingState.UNKNOWN);
    this.startedAtSubject = new BehaviorSubject(void 0);
    this.participantCountSubject = new BehaviorSubject(0);
    this.anonymousParticipantCountSubject = new BehaviorSubject(0);
    this.participantsSubject = new BehaviorSubject([]);
    this.callStatsReportSubject = new BehaviorSubject(void 0);
    this.closedCaptionsSubject = new BehaviorSubject([]);
    this.orphanedTracks = [];
    this.logger = getLogger(["CallState"]);
    this.sortParticipantsBy = defaultSortPreset;
    this.closedCaptionsTasks = /* @__PURE__ */ new Map();
    this.dispose = () => {
      for (const [ccKey, taskId] of this.closedCaptionsTasks.entries()) {
        clearTimeout(taskId);
        this.closedCaptionsTasks.delete(ccKey);
      }
    };
    this.setSortParticipantsBy = (comparator) => {
      this.sortParticipantsBy = comparator;
      this.setCurrentValue(this.participantsSubject, (ps) => ps);
    };
    this.getCurrentValue = getCurrentValue;
    this.setCurrentValue = setCurrentValue;
    this.setParticipantCount = (count3) => {
      return this.setCurrentValue(this.participantCountSubject, count3);
    };
    this.setStartedAt = (startedAt) => {
      return this.setCurrentValue(this.startedAtSubject, startedAt);
    };
    this.setCaptioning = (captioning) => {
      return updateValue(this.captioningSubject, captioning);
    };
    this.setAnonymousParticipantCount = (count3) => {
      return this.setCurrentValue(this.anonymousParticipantCountSubject, count3);
    };
    this.setParticipants = (participants) => {
      return this.setCurrentValue(this.participantsSubject, participants);
    };
    this.setCallingState = (state) => {
      return this.setCurrentValue(this.callingStateSubject, state);
    };
    this.setCallStatsReport = (report) => {
      return this.setCurrentValue(this.callStatsReportSubject, report);
    };
    this.setMembers = (members) => {
      this.setCurrentValue(this.membersSubject, members);
    };
    this.setOwnCapabilities = (capabilities) => {
      return this.setCurrentValue(this.ownCapabilitiesSubject, capabilities);
    };
    this.setBackstage = (backstage) => {
      return this.setCurrentValue(this.backstageSubject, backstage);
    };
    this.setEndedAt = (endedAt) => {
      return this.setCurrentValue(this.endedAtSubject, endedAt);
    };
    this.findParticipantBySessionId = (sessionId) => {
      return this.participants.find((p) => p.sessionId === sessionId);
    };
    this.getParticipantLookupBySessionId = () => {
      return this.participants.reduce((lookupTable, participant) => {
        lookupTable[participant.sessionId] = participant;
        return lookupTable;
      }, {});
    };
    this.updateParticipant = (sessionId, patch3) => {
      const participant = this.findParticipantBySessionId(sessionId);
      if (!participant) {
        this.logger("warn", `Participant with sessionId ${sessionId} not found`);
        return;
      }
      const thePatch = typeof patch3 === "function" ? patch3(participant) : patch3;
      const updatedParticipant = {
        ...participant,
        ...thePatch
      };
      return this.setParticipants((participants) => participants.map((p) => p.sessionId === sessionId ? updatedParticipant : p));
    };
    this.updateOrAddParticipant = (sessionId, participant) => {
      return this.setParticipants((participants) => {
        let add = true;
        const nextParticipants = participants.map((p) => {
          if (p.sessionId === sessionId) {
            add = false;
            return {
              ...p,
              ...participant
            };
          }
          return p;
        });
        if (add)
          nextParticipants.push(participant);
        return nextParticipants;
      });
    };
    this.updateParticipants = (patch3) => {
      if (Object.keys(patch3).length === 0)
        return this.participants;
      return this.setParticipants((participants) => participants.map((p) => {
        const thePatch = patch3[p.sessionId];
        if (thePatch) {
          return {
            ...p,
            ...thePatch
          };
        }
        return p;
      }));
    };
    this.updateParticipantTracks = (trackType, changes) => {
      return this.updateParticipants(Object.entries(changes).reduce((acc, [sessionId, change]) => {
        if (change.dimension) {
          change.dimension.height = Math.ceil(change.dimension.height);
          change.dimension.width = Math.ceil(change.dimension.width);
        }
        const prop = trackType === "videoTrack" ? "videoDimension" : trackType === "screenShareTrack" ? "screenShareDimension" : void 0;
        if (prop) {
          acc[sessionId] = {
            [prop]: change.dimension
          };
        }
        return acc;
      }, {}));
    };
    this.updateFromEvent = (event) => {
      const update = this.eventHandlers[event.type];
      if (update) {
        update(event);
      }
    };
    this.setServerSidePins = (pins) => {
      const pinsLookup = pins.reduce((lookup, pin) => {
        lookup[pin.sessionId] = Date.now();
        return lookup;
      }, {});
      return this.setParticipants((participants) => participants.map((participant) => {
        const serverSidePinnedAt = pinsLookup[participant.sessionId];
        if (serverSidePinnedAt) {
          return {
            ...participant,
            pin: {
              isLocalPin: false,
              pinnedAt: serverSidePinnedAt
            }
          };
        }
        if (participant.pin && !participant.pin.isLocalPin) {
          return {
            ...participant,
            pin: void 0
          };
        }
        return participant;
      }));
    };
    this.registerOrphanedTrack = (orphanedTrack) => {
      this.orphanedTracks.push(orphanedTrack);
    };
    this.removeOrphanedTrack = (id) => {
      this.orphanedTracks = this.orphanedTracks.filter((o) => o.id !== id);
    };
    this.takeOrphanedTracks = (trackLookupPrefix) => {
      const orphans = this.orphanedTracks.filter((orphan) => orphan.trackLookupPrefix === trackLookupPrefix);
      if (orphans.length > 0) {
        this.orphanedTracks = this.orphanedTracks.filter((orphan) => orphan.trackLookupPrefix !== trackLookupPrefix);
      }
      return orphans;
    };
    this.updateClosedCaptionSettings = (config2) => {
      this.closedCaptionsSettings = { ...this.closedCaptionsSettings, ...config2 };
    };
    this.updateFromCallResponse = (call) => {
      this.setBackstage(call.backstage);
      this.setCurrentValue(this.blockedUserIdsSubject, call.blocked_user_ids);
      this.setCurrentValue(this.createdAtSubject, new Date(call.created_at));
      this.setCurrentValue(this.updatedAtSubject, new Date(call.updated_at));
      this.setCurrentValue(this.startsAtSubject, call.starts_at ? new Date(call.starts_at) : void 0);
      this.setEndedAt(call.ended_at ? new Date(call.ended_at) : void 0);
      this.setCurrentValue(this.createdBySubject, call.created_by);
      this.setCurrentValue(this.customSubject, call.custom);
      this.setCurrentValue(this.egressSubject, call.egress);
      this.setCurrentValue(this.ingressSubject, call.ingress);
      this.setCurrentValue(this.recordingSubject, call.recording);
      const s = this.setCurrentValue(this.sessionSubject, call.session);
      this.updateParticipantCountFromSession(s);
      this.setCurrentValue(this.settingsSubject, call.settings);
      this.setCurrentValue(this.transcribingSubject, call.transcribing);
      this.setCurrentValue(this.captioningSubject, call.captioning);
      this.setCurrentValue(this.thumbnailsSubject, call.thumbnails);
    };
    this.updateFromSfuCallState = (callState, currentSessionId, reconnectDetails) => {
      const { participants, participantCount, startedAt, pins } = callState;
      const localPublishedTracks = (reconnectDetails == null ? void 0 : reconnectDetails.announcedTracks.map((t2) => t2.trackType)) ?? [];
      this.setParticipants(() => {
        const participantLookup = this.getParticipantLookupBySessionId();
        return participants.map((p) => {
          const existingParticipant = participantLookup[p.sessionId];
          const isLocalParticipant = p.sessionId === currentSessionId;
          return Object.assign({}, existingParticipant, p, {
            isLocalParticipant,
            publishedTracks: isLocalParticipant ? localPublishedTracks : p.publishedTracks,
            viewportVisibilityState: (existingParticipant == null ? void 0 : existingParticipant.viewportVisibilityState) ?? {
              videoTrack: VisibilityState.UNKNOWN,
              screenShareTrack: VisibilityState.UNKNOWN
            }
          });
        });
      });
      this.setParticipantCount((participantCount == null ? void 0 : participantCount.total) || 0);
      this.setAnonymousParticipantCount((participantCount == null ? void 0 : participantCount.anonymous) || 0);
      this.setStartedAt(startedAt ? Timestamp.toDate(startedAt) : /* @__PURE__ */ new Date());
      this.setServerSidePins(pins);
    };
    this.updateFromMemberRemoved = (event) => {
      this.updateFromCallResponse(event.call);
      this.setCurrentValue(this.membersSubject, (members) => members.filter((m) => event.members.indexOf(m.user_id) === -1));
    };
    this.updateFromMemberAdded = (event) => {
      this.updateFromCallResponse(event.call);
      this.setCurrentValue(this.membersSubject, (members) => [
        ...members,
        ...event.members
      ]);
    };
    this.updateFromHLSBroadcastStopped = () => {
      this.setCurrentValue(this.egressSubject, (egress = defaultEgress) => ({
        ...egress,
        broadcasting: false,
        hls: {
          ...egress.hls,
          status: ""
        }
      }));
    };
    this.updateFromHLSBroadcastingFailed = () => {
      this.setCurrentValue(this.egressSubject, (egress = defaultEgress) => ({
        ...egress,
        broadcasting: false,
        hls: {
          ...egress.hls,
          status: ""
        }
      }));
    };
    this.updateParticipantCountFromSession = (session) => {
      if (!session || this.callingState === CallingState.JOINED)
        return;
      const byRoleCount = Object.values(session.participants_count_by_role).reduce((total, countByRole) => total + countByRole, 0);
      const participantCount = Math.max(byRoleCount, session.participants.length);
      this.setParticipantCount(participantCount);
      this.setAnonymousParticipantCount(session.anonymous_participant_count || 0);
    };
    this.updateFromSessionParticipantCountUpdate = (event) => {
      const s = this.setCurrentValue(this.sessionSubject, (session) => {
        if (!session)
          return session;
        return {
          ...session,
          anonymous_participant_count: event.anonymous_participant_count,
          participants_count_by_role: event.participants_count_by_role
        };
      });
      this.updateParticipantCountFromSession(s);
    };
    this.updateFromSessionParticipantLeft = (event) => {
      const s = this.setCurrentValue(this.sessionSubject, (session) => {
        if (!session)
          return session;
        const { participants, participants_count_by_role } = session;
        const { user, user_session_id } = event.participant;
        return {
          ...session,
          participants: participants.filter((p) => p.user_session_id !== user_session_id),
          participants_count_by_role: {
            ...participants_count_by_role,
            [user.role]: Math.max(0, (participants_count_by_role[user.role] || 0) - 1)
          }
        };
      });
      this.updateParticipantCountFromSession(s);
    };
    this.updateFromSessionParticipantJoined = (event) => {
      const s = this.setCurrentValue(this.sessionSubject, (session) => {
        if (!session)
          return session;
        const { participants, participants_count_by_role } = session;
        const { user, user_session_id } = event.participant;
        let shouldInsertParticipant = true;
        const updatedParticipants = participants.map((p) => {
          if (p.user_session_id === user_session_id) {
            shouldInsertParticipant = false;
            return event.participant;
          }
          return p;
        });
        if (shouldInsertParticipant) {
          updatedParticipants.push(event.participant);
        }
        const increment = shouldInsertParticipant ? 1 : 0;
        return {
          ...session,
          participants: updatedParticipants,
          participants_count_by_role: {
            ...participants_count_by_role,
            [user.role]: (participants_count_by_role[user.role] || 0) + increment
          }
        };
      });
      this.updateParticipantCountFromSession(s);
    };
    this.updateMembers = (event) => {
      this.updateFromCallResponse(event.call);
      this.setCurrentValue(this.membersSubject, (members) => members.map((member) => {
        const memberUpdate = event.members.find((m) => m.user_id === member.user_id);
        return memberUpdate ? memberUpdate : member;
      }));
    };
    this.updateParticipantReaction = (event) => {
      const { user, custom, type, emoji_code } = event.reaction;
      this.setParticipants((participants) => {
        return participants.map((p) => {
          if (p.userId !== user.id)
            return p;
          return {
            ...p,
            reaction: {
              type,
              emoji_code,
              custom
            }
          };
        });
      });
    };
    this.unblockUser = (event) => {
      this.setCurrentValue(this.blockedUserIdsSubject, (current) => {
        if (!current)
          return current;
        return current.filter((id) => id !== event.user.id);
      });
    };
    this.blockUser = (event) => {
      this.setCurrentValue(this.blockedUserIdsSubject, (current) => [
        ...current || [],
        event.user.id
      ]);
    };
    this.updateOwnCapabilities = (event) => {
      var _a;
      if (event.user.id === ((_a = this.localParticipant) == null ? void 0 : _a.userId)) {
        this.setCurrentValue(this.ownCapabilitiesSubject, event.own_capabilities);
      }
    };
    this.updateFromClosedCaptions = (event) => {
      this.setCurrentValue(this.closedCaptionsSubject, (queue2) => {
        const { closed_caption } = event;
        const keyOf = (c) => `${c.speaker_id}/${c.start_time}`;
        const currentKey = keyOf(closed_caption);
        const duplicate = queue2.some((caption) => keyOf(caption) === currentKey);
        if (duplicate)
          return queue2;
        const nextQueue = [...queue2, closed_caption];
        const { visibilityDurationMs = 2700, maxVisibleCaptions = 2 } = this.closedCaptionsSettings || {};
        if (visibilityDurationMs > 0) {
          const taskId = setTimeout(() => {
            this.setCurrentValue(this.closedCaptionsSubject, (captions) => captions.filter((caption) => caption !== closed_caption));
            this.closedCaptionsTasks.delete(currentKey);
          }, visibilityDurationMs);
          this.closedCaptionsTasks.set(currentKey, taskId);
          for (let i = 0; i < nextQueue.length - maxVisibleCaptions; i++) {
            const key = keyOf(nextQueue[i]);
            const task = this.closedCaptionsTasks.get(key);
            clearTimeout(task);
            this.closedCaptionsTasks.delete(key);
          }
        }
        return nextQueue.slice(-maxVisibleCaptions);
      });
    };
    this.participants$ = this.participantsSubject.asObservable().pipe(
      // maintain stable-sort by mutating the participants stored
      // in the original subject
      map((ps) => ps.sort(this.sortParticipantsBy)),
      shareReplay({ bufferSize: 1, refCount: true })
    );
    this.localParticipant$ = this.participants$.pipe(map((participants) => participants.find((p) => p.isLocalParticipant)), shareReplay({ bufferSize: 1, refCount: true }));
    this.remoteParticipants$ = this.participants$.pipe(map((participants) => participants.filter((p) => !p.isLocalParticipant)), shareReplay({ bufferSize: 1, refCount: true }));
    this.pinnedParticipants$ = this.participants$.pipe(map((participants) => participants.filter((p) => !!p.pin)), shareReplay({ bufferSize: 1, refCount: true }));
    this.dominantSpeaker$ = this.participants$.pipe(map((participants) => participants.find((p) => p.isDominantSpeaker)), shareReplay({ bufferSize: 1, refCount: true }));
    this.hasOngoingScreenShare$ = this.participants$.pipe(map((participants) => participants.some((p) => hasScreenShare(p))), distinctUntilChanged(), shareReplay({ bufferSize: 1, refCount: true }));
    this.createdAt$ = this.createdAtSubject.asObservable();
    this.endedAt$ = this.endedAtSubject.asObservable();
    this.startsAt$ = this.startsAtSubject.asObservable();
    this.startedAt$ = this.startedAtSubject.asObservable();
    this.updatedAt$ = this.updatedAtSubject.asObservable();
    this.callStatsReport$ = this.callStatsReportSubject.asObservable();
    this.members$ = this.membersSubject.asObservable();
    this.createdBy$ = this.createdBySubject.asObservable();
    this.custom$ = this.customSubject.asObservable();
    this.egress$ = this.egressSubject.asObservable();
    this.ingress$ = this.ingressSubject.asObservable();
    this.session$ = this.sessionSubject.asObservable();
    this.settings$ = this.settingsSubject.asObservable();
    this.endedBy$ = this.endedBySubject.asObservable();
    this.thumbnails$ = this.thumbnailsSubject.asObservable();
    this.closedCaptions$ = this.closedCaptionsSubject.asObservable();
    const isShallowEqual = (a, b) => {
      if (a.length !== b.length)
        return false;
      for (const item of a)
        if (!b.includes(item))
          return false;
      for (const item of b)
        if (!a.includes(item))
          return false;
      return true;
    };
    const duc = (subject, comparator) => subject.asObservable().pipe(distinctUntilChanged(comparator));
    this.anonymousParticipantCount$ = duc(this.anonymousParticipantCountSubject);
    this.blockedUserIds$ = duc(this.blockedUserIdsSubject, isShallowEqual);
    this.backstage$ = duc(this.backstageSubject);
    this.callingState$ = duc(this.callingStateSubject);
    this.ownCapabilities$ = duc(this.ownCapabilitiesSubject, isShallowEqual);
    this.participantCount$ = duc(this.participantCountSubject);
    this.recording$ = duc(this.recordingSubject);
    this.transcribing$ = duc(this.transcribingSubject);
    this.captioning$ = duc(this.captioningSubject);
    this.eventHandlers = {
      // these events are not updating the call state:
      "call.frame_recording_ready": void 0,
      "call.permission_request": void 0,
      "call.recording_ready": void 0,
      "call.rtmp_broadcast_failed": void 0,
      "call.rtmp_broadcast_started": void 0,
      "call.rtmp_broadcast_stopped": void 0,
      "call.transcription_ready": void 0,
      "call.user_muted": void 0,
      "connection.error": void 0,
      "connection.ok": void 0,
      "health.check": void 0,
      "user.updated": void 0,
      custom: void 0,
      // events that update call state:
      "call.accepted": (e) => this.updateFromCallResponse(e.call),
      "call.blocked_user": this.blockUser,
      "call.closed_caption": this.updateFromClosedCaptions,
      "call.closed_captions_failed": () => {
        this.setCurrentValue(this.captioningSubject, false);
      },
      "call.closed_captions_started": () => {
        this.setCurrentValue(this.captioningSubject, true);
      },
      "call.closed_captions_stopped": () => {
        this.setCurrentValue(this.captioningSubject, false);
      },
      "call.created": (e) => this.updateFromCallResponse(e.call),
      "call.deleted": (e) => this.updateFromCallResponse(e.call),
      "call.ended": (e) => {
        this.updateFromCallResponse(e.call);
        this.setCurrentValue(this.endedBySubject, e.user);
      },
      "call.frame_recording_failed": (e) => {
        this.updateFromCallResponse(e.call);
      },
      "call.frame_recording_started": (e) => {
        this.updateFromCallResponse(e.call);
      },
      "call.frame_recording_stopped": (e) => {
        this.updateFromCallResponse(e.call);
      },
      "call.hls_broadcasting_failed": this.updateFromHLSBroadcastingFailed,
      "call.hls_broadcasting_started": (e) => {
        this.updateFromCallResponse(e.call);
      },
      "call.hls_broadcasting_stopped": this.updateFromHLSBroadcastStopped,
      "call.live_started": (e) => this.updateFromCallResponse(e.call),
      "call.member_added": this.updateFromMemberAdded,
      "call.member_removed": this.updateFromMemberRemoved,
      "call.member_updated_permission": this.updateMembers,
      "call.member_updated": this.updateMembers,
      "call.notification": (e) => {
        this.updateFromCallResponse(e.call);
        this.setMembers(e.members);
      },
      "call.permissions_updated": this.updateOwnCapabilities,
      "call.reaction_new": this.updateParticipantReaction,
      "call.recording_started": () => this.setCurrentValue(this.recordingSubject, true),
      "call.recording_stopped": () => this.setCurrentValue(this.recordingSubject, false),
      "call.recording_failed": () => this.setCurrentValue(this.recordingSubject, false),
      "call.rejected": (e) => this.updateFromCallResponse(e.call),
      "call.ring": (e) => this.updateFromCallResponse(e.call),
      "call.missed": (e) => this.updateFromCallResponse(e.call),
      "call.session_ended": (e) => this.updateFromCallResponse(e.call),
      "call.session_participant_count_updated": this.updateFromSessionParticipantCountUpdate,
      "call.session_participant_joined": this.updateFromSessionParticipantJoined,
      "call.session_participant_left": this.updateFromSessionParticipantLeft,
      "call.session_started": (e) => this.updateFromCallResponse(e.call),
      "call.transcription_started": () => {
        this.setCurrentValue(this.transcribingSubject, true);
      },
      "call.transcription_stopped": () => {
        this.setCurrentValue(this.transcribingSubject, false);
      },
      "call.transcription_failed": () => {
        this.setCurrentValue(this.transcribingSubject, false);
      },
      "call.unblocked_user": this.unblockUser,
      "call.updated": (e) => this.updateFromCallResponse(e.call)
    };
  }
  /**
   * The server-side counted number of participants connected to the current call.
   * This number includes the anonymous participants as well.
   */
  get participantCount() {
    return this.getCurrentValue(this.participantCount$);
  }
  /**
   * The time the call session actually started.
   * Useful for displaying the call duration.
   */
  get startedAt() {
    return this.getCurrentValue(this.startedAt$);
  }
  /**
   * Returns whether closed captions are enabled in the current call.
   */
  get captioning() {
    return this.getCurrentValue(this.captioning$);
  }
  /**
   * The server-side counted number of anonymous participants connected to the current call.
   * This number includes the anonymous participants as well.
   */
  get anonymousParticipantCount() {
    return this.getCurrentValue(this.anonymousParticipantCount$);
  }
  /**
   * The list of participants in the current call.
   */
  get participants() {
    return this.getCurrentValue(this.participants$);
  }
  /**
   * The local participant in the current call.
   */
  get localParticipant() {
    return this.getCurrentValue(this.localParticipant$);
  }
  /**
   * The list of remote participants in the current call.
   */
  get remoteParticipants() {
    return this.getCurrentValue(this.remoteParticipants$);
  }
  /**
   * The dominant speaker in the current call.
   */
  get dominantSpeaker() {
    return this.getCurrentValue(this.dominantSpeaker$);
  }
  /**
   * The list of pinned participants in the current call.
   */
  get pinnedParticipants() {
    return this.getCurrentValue(this.pinnedParticipants$);
  }
  /**
   * Tell if there is an ongoing screen share in this call.
   */
  get hasOngoingScreenShare() {
    return this.getCurrentValue(this.hasOngoingScreenShare$);
  }
  /**
   * The calling state.
   */
  get callingState() {
    return this.getCurrentValue(this.callingState$);
  }
  /**
   * The call stats report.
   */
  get callStatsReport() {
    return this.getCurrentValue(this.callStatsReport$);
  }
  /**
   * The members of the current call.
   */
  get members() {
    return this.getCurrentValue(this.members$);
  }
  /**
   * The capabilities of the current user for the current call.
   */
  get ownCapabilities() {
    return this.getCurrentValue(this.ownCapabilities$);
  }
  /**
   * The backstage state.
   */
  get backstage() {
    return this.getCurrentValue(this.backstage$);
  }
  /**
   * Will provide the list of blocked user IDs.
   */
  get blockedUserIds() {
    return this.getCurrentValue(this.blockedUserIds$);
  }
  /**
   * Will provide the time when this call has been created.
   */
  get createdAt() {
    return this.getCurrentValue(this.createdAt$);
  }
  /**
   * Will provide the time when this call has been ended.
   */
  get endedAt() {
    return this.getCurrentValue(this.endedAt$);
  }
  /**
   * Will provide the time when this call has been scheduled to start.
   */
  get startsAt() {
    return this.getCurrentValue(this.startsAt$);
  }
  /**
   * Will provide the time when this call has been updated.
   */
  get updatedAt() {
    return this.getCurrentValue(this.updatedAt$);
  }
  /**
   * Will provide the user who created this call.
   */
  get createdBy() {
    return this.getCurrentValue(this.createdBy$);
  }
  /**
   * Will provide the custom data of this call.
   */
  get custom() {
    return this.getCurrentValue(this.custom$);
  }
  /**
   * Will provide the egress data of this call.
   */
  get egress() {
    return this.getCurrentValue(this.egress$);
  }
  /**
   * Will provide the ingress data of this call.
   */
  get ingress() {
    return this.getCurrentValue(this.ingress$);
  }
  /**
   * Will provide the recording state of this call.
   */
  get recording() {
    return this.getCurrentValue(this.recording$);
  }
  /**
   * Will provide the session data of this call.
   */
  get session() {
    return this.getCurrentValue(this.session$);
  }
  /**
   * Will provide the settings of this call.
   */
  get settings() {
    return this.getCurrentValue(this.settings$);
  }
  /**
   * Will provide the transcribing state of this call.
   */
  get transcribing() {
    return this.getCurrentValue(this.transcribing$);
  }
  /**
   * Will provide the user who ended this call.
   */
  get endedBy() {
    return this.getCurrentValue(this.endedBy$);
  }
  /**
   * Will provide the thumbnails of this call, if enabled in the call settings.
   */
  get thumbnails() {
    return this.getCurrentValue(this.thumbnails$);
  }
  /**
   * Returns the current queue of closed captions.
   */
  get closedCaptions() {
    return this.getCurrentValue(this.closedCaptions$);
  }
};
var flatten = (report) => {
  const stats = [];
  report.forEach((s) => {
    stats.push(s);
  });
  return stats;
};
var getSdkSignature = (clientDetails) => {
  const { sdk, ...platform2 } = clientDetails;
  const sdkName = getSdkName(sdk);
  const sdkVersion = getSdkVersion(sdk);
  return {
    sdkName,
    sdkVersion,
    ...platform2
  };
};
var getSdkName = (sdk) => {
  return sdk && sdk.type === SdkType.REACT ? "stream-react" : sdk && sdk.type === SdkType.REACT_NATIVE ? "stream-react-native" : "stream-js";
};
var getSdkVersion = (sdk) => {
  return sdk ? `${sdk.major}.${sdk.minor}.${sdk.patch}` : "0.0.0-development";
};
var isSafari = () => {
  if (typeof navigator === "undefined")
    return false;
  return /^((?!chrome|android).)*safari/i.test(navigator.userAgent || "");
};
var isFirefox = () => {
  var _a;
  if (typeof navigator === "undefined")
    return false;
  return (_a = navigator.userAgent) == null ? void 0 : _a.includes("Firefox");
};
var isChrome = () => {
  var _a;
  if (typeof navigator === "undefined")
    return false;
  return (_a = navigator.userAgent) == null ? void 0 : _a.includes("Chrome");
};
var browsers = Object.freeze({
  __proto__: null,
  isChrome,
  isFirefox,
  isSafari
});
var createStatsReporter = ({ subscriber, publisher, state, datacenter, pollingIntervalInMs = 2e3 }) => {
  const logger2 = getLogger(["stats"]);
  const getRawStatsForTrack = async (kind, selector) => {
    if (kind === "subscriber" && subscriber) {
      return subscriber.getStats(selector);
    } else if (kind === "publisher" && publisher) {
      return publisher.getStats(selector);
    } else {
      return void 0;
    }
  };
  const getStatsForStream = async (kind, tracks) => {
    const pc = kind === "subscriber" ? subscriber : publisher;
    if (!pc)
      return [];
    const statsForStream = [];
    for (const track of tracks) {
      const report = await pc.getStats(track);
      const stats = transform(report, {
        trackKind: track.kind,
        kind,
        publisher: void 0
      });
      statsForStream.push(stats);
    }
    return statsForStream;
  };
  const startReportingStatsFor = (sessionId) => {
    sessionIdsToTrack.add(sessionId);
    void run();
  };
  const stopReportingStatsFor = (sessionId) => {
    sessionIdsToTrack.delete(sessionId);
    void run();
  };
  const sessionIdsToTrack = /* @__PURE__ */ new Set();
  const run = async () => {
    const participantStats = {};
    if (sessionIdsToTrack.size > 0) {
      const sessionIds = new Set(sessionIdsToTrack);
      for (const participant of state.participants) {
        if (!sessionIds.has(participant.sessionId))
          continue;
        const { audioStream, isLocalParticipant, sessionId, userId, videoStream } = participant;
        const kind = isLocalParticipant ? "publisher" : "subscriber";
        try {
          const tracks = isLocalParticipant ? (publisher == null ? void 0 : publisher.getPublishedTracks()) || [] : [
            ...(videoStream == null ? void 0 : videoStream.getVideoTracks()) || [],
            ...(audioStream == null ? void 0 : audioStream.getAudioTracks()) || []
          ];
          participantStats[sessionId] = await getStatsForStream(kind, tracks);
        } catch (e) {
          logger2("warn", `Failed to collect ${kind} stats for ${userId}`, e);
        }
      }
    }
    const [subscriberStats, publisherStats] = await Promise.all([
      subscriber.getStats().then((report) => transform(report, {
        kind: "subscriber",
        trackKind: "video",
        publisher
      })).then(aggregate),
      publisher ? publisher.getStats().then((report) => transform(report, {
        kind: "publisher",
        trackKind: "video",
        publisher
      })).then(aggregate) : getEmptyStats()
    ]);
    const [subscriberRawStats, publisherRawStats] = await Promise.all([
      getRawStatsForTrack("subscriber"),
      publisher ? getRawStatsForTrack("publisher") : void 0
    ]);
    state.setCallStatsReport({
      datacenter,
      publisherStats,
      subscriberStats,
      subscriberRawStats,
      publisherRawStats,
      participants: participantStats,
      timestamp: Date.now()
    });
  };
  let timeoutId;
  if (pollingIntervalInMs > 0) {
    const loop = async () => {
      await run().catch((e) => {
        logger2("debug", "Failed to collect stats", e);
      });
      timeoutId = setTimeout(loop, pollingIntervalInMs);
    };
    void loop();
  }
  const stop = () => {
    if (timeoutId) {
      clearTimeout(timeoutId);
    }
  };
  return {
    getRawStatsForTrack,
    getStatsForStream,
    startReportingStatsFor,
    stopReportingStatsFor,
    stop
  };
};
var transform = (report, opts) => {
  const { trackKind, kind, publisher } = opts;
  const direction = kind === "subscriber" ? "inbound-rtp" : "outbound-rtp";
  const stats = flatten(report);
  const streams = stats.filter((stat) => stat.type === direction && stat.kind === trackKind).map((stat) => {
    const rtcStreamStats = stat;
    const codec = stats.find((s) => s.type === "codec" && s.id === rtcStreamStats.codecId);
    const transport = stats.find((s) => s.type === "transport" && s.id === rtcStreamStats.transportId);
    let roundTripTime;
    if (transport && transport.dtlsState === "connected") {
      const candidatePair = stats.find((s) => s.type === "candidate-pair" && s.id === transport.selectedCandidatePairId);
      roundTripTime = candidatePair == null ? void 0 : candidatePair.currentRoundTripTime;
    }
    let trackType;
    if (kind === "publisher" && publisher) {
      const firefox = isFirefox();
      const mediaSource = stats.find((s) => s.type === "media-source" && // Firefox doesn't have mediaSourceId, so we need to guess the media source
      (firefox ? true : s.id === rtcStreamStats.mediaSourceId));
      if (mediaSource) {
        trackType = publisher.getTrackType(mediaSource.trackIdentifier);
      }
    }
    return {
      bytesSent: rtcStreamStats.bytesSent,
      bytesReceived: rtcStreamStats.bytesReceived,
      codec: codec == null ? void 0 : codec.mimeType,
      currentRoundTripTime: roundTripTime,
      frameHeight: rtcStreamStats.frameHeight,
      frameWidth: rtcStreamStats.frameWidth,
      framesPerSecond: rtcStreamStats.framesPerSecond,
      jitter: rtcStreamStats.jitter,
      kind: rtcStreamStats.kind,
      mediaSourceId: rtcStreamStats.mediaSourceId,
      qualityLimitationReason: rtcStreamStats.qualityLimitationReason,
      rid: rtcStreamStats.rid,
      ssrc: rtcStreamStats.ssrc,
      trackType
    };
  });
  return {
    rawStats: report,
    streams,
    timestamp: Date.now()
  };
};
var getEmptyStats = (stats) => {
  return {
    rawReport: stats ?? { streams: [], timestamp: Date.now() },
    totalBytesSent: 0,
    totalBytesReceived: 0,
    averageJitterInMs: 0,
    averageRoundTripTimeInMs: 0,
    qualityLimitationReasons: "none",
    highestFrameWidth: 0,
    highestFrameHeight: 0,
    highestFramesPerSecond: 0,
    codec: "",
    codecPerTrackType: {},
    timestamp: Date.now()
  };
};
var aggregate = (stats) => {
  const aggregatedStats = getEmptyStats(stats);
  let maxArea = -1;
  const area = (w, h) => w * h;
  const qualityLimitationReasons = /* @__PURE__ */ new Set();
  const streams = stats.streams;
  const report = streams.reduce((acc, stream) => {
    acc.totalBytesSent += stream.bytesSent || 0;
    acc.totalBytesReceived += stream.bytesReceived || 0;
    acc.averageJitterInMs += stream.jitter || 0;
    acc.averageRoundTripTimeInMs += stream.currentRoundTripTime || 0;
    const streamArea = area(stream.frameWidth || 0, stream.frameHeight || 0);
    if (streamArea > maxArea) {
      acc.highestFrameWidth = stream.frameWidth || 0;
      acc.highestFrameHeight = stream.frameHeight || 0;
      acc.highestFramesPerSecond = stream.framesPerSecond || 0;
      maxArea = streamArea;
    }
    qualityLimitationReasons.add(stream.qualityLimitationReason || "");
    return acc;
  }, aggregatedStats);
  if (streams.length > 0) {
    report.averageJitterInMs = Math.round(report.averageJitterInMs / streams.length * 1e3);
    report.averageRoundTripTimeInMs = Math.round(report.averageRoundTripTimeInMs / streams.length * 1e3);
    report.codec = streams[0].codec || "";
    report.codecPerTrackType = streams.reduce((acc, stream) => {
      if (stream.trackType) {
        acc[stream.trackType] = stream.codec || "";
      }
      return acc;
    }, {});
  }
  const qualityLimitationReason = [
    qualityLimitationReasons.has("cpu") && "cpu",
    qualityLimitationReasons.has("bandwidth") && "bandwidth",
    qualityLimitationReasons.has("other") && "other"
  ].filter(Boolean).join(", ");
  if (qualityLimitationReason) {
    report.qualityLimitationReasons = qualityLimitationReason;
  }
  return report;
};
var version = "1.20.0";
var [major, minor, patch] = version.split(".");
var sdkInfo = {
  type: SdkType.PLAIN_JAVASCRIPT,
  major,
  minor,
  patch
};
var osInfo;
var deviceInfo;
var webRtcInfo;
var deviceState = { oneofKind: void 0 };
var setSdkInfo = (info) => {
  sdkInfo = info;
};
var getSdkInfo = () => {
  return sdkInfo;
};
var setOSInfo = (info) => {
  osInfo = info;
};
var setDeviceInfo = (info) => {
  deviceInfo = info;
};
var getWebRTCInfo = () => {
  return webRtcInfo;
};
var setWebRTCInfo = (info) => {
  webRtcInfo = info;
};
var setThermalState = (state) => {
  if (!osInfo) {
    deviceState = { oneofKind: void 0 };
    return;
  }
  if (osInfo.name === "android") {
    const thermalState = AndroidThermalState[state] || AndroidThermalState.UNSPECIFIED;
    deviceState = {
      oneofKind: "android",
      android: {
        thermalState,
        isPowerSaverMode: (deviceState == null ? void 0 : deviceState.oneofKind) === "android" && deviceState.android.isPowerSaverMode
      }
    };
  }
  if (osInfo.name.toLowerCase() === "ios") {
    const thermalState = AppleThermalState[state] || AppleThermalState.UNSPECIFIED;
    deviceState = {
      oneofKind: "apple",
      apple: {
        thermalState,
        isLowPowerModeEnabled: (deviceState == null ? void 0 : deviceState.oneofKind) === "apple" && deviceState.apple.isLowPowerModeEnabled
      }
    };
  }
};
var setPowerState = (powerMode) => {
  if (!osInfo) {
    deviceState = { oneofKind: void 0 };
    return;
  }
  if (osInfo.name === "android") {
    deviceState = {
      oneofKind: "android",
      android: {
        thermalState: (deviceState == null ? void 0 : deviceState.oneofKind) === "android" ? deviceState.android.thermalState : AndroidThermalState.UNSPECIFIED,
        isPowerSaverMode: powerMode
      }
    };
  }
  if (osInfo.name.toLowerCase() === "ios") {
    deviceState = {
      oneofKind: "apple",
      apple: {
        thermalState: (deviceState == null ? void 0 : deviceState.oneofKind) === "apple" ? deviceState.apple.thermalState : AppleThermalState.UNSPECIFIED,
        isLowPowerModeEnabled: powerMode
      }
    };
  }
};
var getDeviceState = () => {
  return deviceState;
};
var getClientDetails = async () => {
  if (isReactNative()) {
    return {
      sdk: sdkInfo,
      os: osInfo,
      device: deviceInfo
    };
  }
  const userAgentDataApi = navigator.userAgentData;
  let userAgentData;
  if (userAgentDataApi && userAgentDataApi.getHighEntropyValues) {
    try {
      userAgentData = await userAgentDataApi.getHighEntropyValues([
        "platform",
        "platformVersion"
      ]);
    } catch {
    }
  }
  const userAgent = new import_ua_parser_js.UAParser(navigator.userAgent);
  const { browser, os, device, cpu } = userAgent.getResult();
  return {
    sdk: sdkInfo,
    browser: {
      name: browser.name || navigator.userAgent,
      version: browser.version || ""
    },
    os: {
      name: (userAgentData == null ? void 0 : userAgentData.platform) || os.name || "",
      version: (userAgentData == null ? void 0 : userAgentData.platformVersion) || os.version || "",
      architecture: cpu.architecture || ""
    },
    device: {
      name: [device.vendor, device.model, device.type].filter(Boolean).join(" "),
      version: ""
    }
  };
};
var SfuStatsReporter = class {
  constructor(sfuClient, { options, clientDetails, subscriber, publisher, microphone, camera, state }) {
    this.logger = getLogger(["SfuStatsReporter"]);
    this.inputDevices = /* @__PURE__ */ new Map();
    this.observeDevice = (device, kind) => {
      var _a;
      const { hasBrowserPermission$ } = device.state;
      (_a = this.unsubscribeDevicePermissionsSubscription) == null ? void 0 : _a.call(this);
      this.unsubscribeDevicePermissionsSubscription = createSubscription(combineLatest([hasBrowserPermission$, this.state.ownCapabilities$]), ([hasPermission, ownCapabilities]) => {
        var _a2;
        (_a2 = this.unsubscribeListDevicesSubscription) == null ? void 0 : _a2.call(this);
        const hasCapability = kind === "mic" ? ownCapabilities.includes(OwnCapability.SEND_AUDIO) : ownCapabilities.includes(OwnCapability.SEND_VIDEO);
        if (!hasPermission || !hasCapability) {
          this.inputDevices.set(kind, {
            currentDevice: "",
            availableDevices: [],
            isPermitted: false
          });
          return;
        }
        this.unsubscribeListDevicesSubscription = createSubscription(combineLatest([device.listDevices(), device.state.selectedDevice$]), ([devices, deviceId]) => {
          const selected = devices.find((d) => d.deviceId === deviceId);
          this.inputDevices.set(kind, {
            currentDevice: (selected == null ? void 0 : selected.label) || deviceId || "",
            availableDevices: devices.map((d) => d.label),
            isPermitted: true
          });
        });
      });
    };
    this.sendConnectionTime = (connectionTimeSeconds) => {
      this.sendTelemetryData({
        data: {
          oneofKind: "connectionTimeSeconds",
          connectionTimeSeconds
        }
      });
    };
    this.sendReconnectionTime = (strategy, timeSeconds) => {
      this.sendTelemetryData({
        data: {
          oneofKind: "reconnection",
          reconnection: { strategy, timeSeconds }
        }
      });
    };
    this.sendTelemetryData = (telemetryData) => {
      this.run(telemetryData).catch((err) => {
        this.logger("warn", "Failed to send telemetry data", err);
      });
    };
    this.run = async (telemetry) => {
      var _a, _b;
      const [subscriberStats, publisherStats] = await Promise.all([
        this.subscriber.getStats().then(flatten).then(JSON.stringify),
        ((_a = this.publisher) == null ? void 0 : _a.getStats().then(flatten).then(JSON.stringify)) ?? "[]"
      ]);
      const subscriberTrace = this.subscriber.getTrace();
      const publisherTrace = (_b = this.publisher) == null ? void 0 : _b.getTrace();
      const mediaTrace = tracer.take();
      const sfuTrace = this.sfuClient.getTrace();
      const publisherTraces = [
        ...mediaTrace.snapshot,
        ...(sfuTrace == null ? void 0 : sfuTrace.snapshot) ?? [],
        ...(publisherTrace == null ? void 0 : publisherTrace.snapshot) ?? []
      ];
      try {
        await this.sfuClient.sendStats({
          sdk: this.sdkName,
          sdkVersion: this.sdkVersion,
          webrtcVersion: this.webRTCVersion,
          subscriberStats,
          subscriberRtcStats: subscriberTrace ? JSON.stringify(subscriberTrace.snapshot) : "",
          publisherStats,
          publisherRtcStats: publisherTraces.length > 0 ? JSON.stringify(publisherTraces) : "",
          audioDevices: this.inputDevices.get("mic"),
          videoDevices: this.inputDevices.get("camera"),
          deviceState: getDeviceState(),
          telemetry
        });
      } catch (err) {
        publisherTrace == null ? void 0 : publisherTrace.rollback();
        subscriberTrace == null ? void 0 : subscriberTrace.rollback();
        mediaTrace.rollback();
        sfuTrace == null ? void 0 : sfuTrace.rollback();
        throw err;
      }
    };
    this.start = () => {
      if (this.options.reporting_interval_ms <= 0)
        return;
      this.observeDevice(this.microphone, "mic");
      this.observeDevice(this.camera, "camera");
      clearInterval(this.intervalId);
      this.intervalId = setInterval(() => {
        this.run().catch((err) => {
          this.logger("warn", "Failed to report stats", err);
        });
      }, this.options.reporting_interval_ms);
    };
    this.stop = () => {
      var _a, _b;
      (_a = this.unsubscribeDevicePermissionsSubscription) == null ? void 0 : _a.call(this);
      this.unsubscribeDevicePermissionsSubscription = void 0;
      (_b = this.unsubscribeListDevicesSubscription) == null ? void 0 : _b.call(this);
      this.unsubscribeListDevicesSubscription = void 0;
      this.inputDevices.clear();
      clearInterval(this.intervalId);
      this.intervalId = void 0;
    };
    this.sfuClient = sfuClient;
    this.options = options;
    this.subscriber = subscriber;
    this.publisher = publisher;
    this.microphone = microphone;
    this.camera = camera;
    this.state = state;
    const { sdk, browser } = clientDetails;
    this.sdkName = getSdkName(sdk);
    this.sdkVersion = getSdkVersion(sdk);
    const webRTCInfo = getWebRTCInfo();
    this.webRTCVersion = (webRTCInfo == null ? void 0 : webRTCInfo.version) || `${(browser == null ? void 0 : browser.name) || ""}-${(browser == null ? void 0 : browser.version) || ""}` || "N/A";
  }
};
var traceRTCPeerConnection = (pc, trace) => {
  pc.addEventListener("icecandidate", (e) => {
    trace("onicecandidate", e.candidate);
  });
  pc.addEventListener("track", (e) => {
    const streams = e.streams.map((stream) => `stream:${stream.id}`);
    trace("ontrack", `${e.track.kind}:${e.track.id} ${streams}`);
  });
  pc.addEventListener("signalingstatechange", () => {
    trace("onsignalingstatechange", pc.signalingState);
  });
  pc.addEventListener("iceconnectionstatechange", () => {
    trace("oniceconnectionstatechange", pc.iceConnectionState);
  });
  pc.addEventListener("icegatheringstatechange", () => {
    trace("onicegatheringstatechange", pc.iceGatheringState);
  });
  pc.addEventListener("connectionstatechange", () => {
    trace("onconnectionstatechange", pc.connectionState);
  });
  pc.addEventListener("negotiationneeded", () => {
    trace("onnegotiationneeded", void 0);
  });
  pc.addEventListener("datachannel", ({ channel }) => {
    trace("ondatachannel", [channel.id, channel.label]);
  });
  let prev = {};
  const getStats = () => {
    pc.getStats(null).then((stats) => {
      const now = toObject(stats);
      trace("getstats", deltaCompression(prev, now));
      prev = now;
    }).catch((err) => {
      trace("getstatsOnFailure", err.toString());
    });
  };
  const interval2 = setInterval(() => {
    getStats();
  }, 8e3);
  pc.addEventListener("connectionstatechange", () => {
    const state = pc.connectionState;
    if (state === "connected" || state === "failed") {
      getStats();
    }
  });
  const origClose = pc.close;
  pc.close = function tracedClose() {
    clearInterval(interval2);
    trace("close", void 0);
    return origClose.call(this);
  };
  for (const method of [
    "createOffer",
    "createAnswer",
    "setLocalDescription",
    "setRemoteDescription",
    "addIceCandidate"
  ]) {
    const original = pc[method];
    if (!original)
      continue;
    pc[method] = async function tracedMethod(...args) {
      try {
        trace(method, args);
        const result = await original.apply(this, args);
        trace(`${method}OnSuccess`, result);
        return result;
      } catch (err) {
        trace(`${method}OnFailure`, err.toString());
        throw err;
      }
    };
  }
};
var toObject = (s) => {
  const obj = {};
  s.forEach((v, k) => {
    obj[k] = v;
  });
  return obj;
};
var deltaCompression = (oldStats, newStats) => {
  newStats = JSON.parse(JSON.stringify(newStats));
  for (const [id, report] of Object.entries(newStats)) {
    delete report.id;
    if (!oldStats[id])
      continue;
    for (const [name2, value] of Object.entries(report)) {
      if (value === oldStats[id][name2]) {
        delete report[name2];
      }
    }
  }
  let timestamp2 = -Infinity;
  for (const report of Object.values(newStats)) {
    if (report.timestamp > timestamp2) {
      timestamp2 = report.timestamp;
    }
  }
  for (const report of Object.values(newStats)) {
    if (report.timestamp === timestamp2) {
      report.timestamp = 0;
    }
  }
  newStats.timestamp = timestamp2;
  return newStats;
};
var BasePeerConnection = class {
  /**
   * Constructs a new `BasePeerConnection` instance.
   */
  constructor(peerType, { sfuClient, connectionConfig, state, dispatcher, onUnrecoverableError, logTag, clientDetails, enableTracing }) {
    this.isIceRestarting = false;
    this.isDisposed = false;
    this.subscriptions = [];
    this.on = (event, fn) => {
      this.subscriptions.push(this.dispatcher.on(event, (e) => {
        withoutConcurrency(`pc.${event}`, async () => fn(e)).catch((err) => {
          if (this.isDisposed)
            return;
          this.logger("warn", `Error handling ${event}`, err);
        });
      }));
    };
    this.addTrickledIceCandidates = () => {
      var _a;
      const { iceTrickleBuffer } = this.sfuClient;
      const observable2 = this.peerType === PeerType.SUBSCRIBER ? iceTrickleBuffer.subscriberCandidates : iceTrickleBuffer.publisherCandidates;
      (_a = this.unsubscribeIceTrickle) == null ? void 0 : _a.call(this);
      this.unsubscribeIceTrickle = createSafeAsyncSubscription(observable2, async (candidate) => {
        return this.pc.addIceCandidate(candidate).catch((e) => {
          if (this.isDisposed)
            return;
          this.logger("warn", `ICE candidate error`, e, candidate);
        });
      });
    };
    this.setSfuClient = (sfuClient2) => {
      this.sfuClient = sfuClient2;
    };
    this.getStats = (selector) => {
      return this.pc.getStats(selector);
    };
    this.getTrace = () => {
      var _a;
      return (_a = this.tracer) == null ? void 0 : _a.take();
    };
    this.onIceCandidate = (e) => {
      const { candidate } = e;
      if (!candidate) {
        this.logger("debug", "null ice candidate");
        return;
      }
      const iceCandidate = this.asJSON(candidate);
      this.sfuClient.iceTrickle({ peerType: this.peerType, iceCandidate }).catch((err) => {
        if (this.isDisposed)
          return;
        this.logger("warn", `ICETrickle failed`, err);
      });
    };
    this.asJSON = (candidate) => {
      if (!candidate.usernameFragment) {
        const segments = candidate.candidate.split(" ");
        const ufragIndex = segments.findIndex((s) => s === "ufrag") + 1;
        const usernameFragment = segments[ufragIndex];
        return JSON.stringify({ ...candidate, usernameFragment });
      }
      return JSON.stringify(candidate.toJSON());
    };
    this.onIceConnectionStateChange = () => {
      const state2 = this.pc.iceConnectionState;
      this.logger("debug", `ICE connection state changed`, state2);
      if (this.state.callingState === CallingState.OFFLINE)
        return;
      if (this.state.callingState === CallingState.RECONNECTING)
        return;
      if (this.isIceRestarting)
        return;
      if (state2 === "failed" || state2 === "disconnected") {
        this.logger("debug", `Attempting to restart ICE`);
        this.restartIce().catch((e) => {
          var _a;
          if (this.isDisposed)
            return;
          const reason = `ICE restart failed`;
          this.logger("error", reason, e);
          (_a = this.onUnrecoverableError) == null ? void 0 : _a.call(this, `${reason}: ${e}`);
        });
      }
    };
    this.onIceCandidateError = (e) => {
      const errorMessage = e instanceof RTCPeerConnectionIceErrorEvent && `${e.errorCode}: ${e.errorText}`;
      const iceState = this.pc.iceConnectionState;
      const logLevel = iceState === "connected" || iceState === "checking" ? "debug" : "warn";
      this.logger(logLevel, `ICE Candidate error`, errorMessage);
    };
    this.onIceGatherChange = () => {
      this.logger("debug", `ICE Gathering State`, this.pc.iceGatheringState);
    };
    this.onSignalingChange = () => {
      this.logger("debug", `Signaling state changed`, this.pc.signalingState);
    };
    this.peerType = peerType;
    this.sfuClient = sfuClient;
    this.state = state;
    this.dispatcher = dispatcher;
    this.onUnrecoverableError = onUnrecoverableError;
    this.logger = getLogger([
      peerType === PeerType.SUBSCRIBER ? "Subscriber" : "Publisher",
      logTag
    ]);
    this.pc = new RTCPeerConnection(connectionConfig);
    if (enableTracing) {
      const tag = `${logTag}-${peerType === PeerType.SUBSCRIBER ? "sub" : "pub"}`;
      this.tracer = new Tracer(tag);
      this.tracer.trace("clientDetails", clientDetails);
      this.tracer.trace("create", connectionConfig);
      traceRTCPeerConnection(this.pc, this.tracer.trace);
    }
    this.pc.addEventListener("icecandidate", this.onIceCandidate);
    this.pc.addEventListener("icecandidateerror", this.onIceCandidateError);
    this.pc.addEventListener("iceconnectionstatechange", this.onIceConnectionStateChange);
    this.pc.addEventListener("icegatheringstatechange", this.onIceGatherChange);
    this.pc.addEventListener("signalingstatechange", this.onSignalingChange);
  }
  /**
   * Disposes the `RTCPeerConnection` instance.
   */
  dispose() {
    var _a;
    this.onUnrecoverableError = void 0;
    this.isDisposed = true;
    this.detachEventHandlers();
    this.pc.close();
    (_a = this.tracer) == null ? void 0 : _a.dispose();
  }
  /**
   * Detaches the event handlers from the `RTCPeerConnection`.
   */
  detachEventHandlers() {
    var _a;
    this.pc.removeEventListener("icecandidate", this.onIceCandidate);
    this.pc.removeEventListener("icecandidateerror", this.onIceCandidateError);
    this.pc.removeEventListener("signalingstatechange", this.onSignalingChange);
    this.pc.removeEventListener("iceconnectionstatechange", this.onIceConnectionStateChange);
    this.pc.removeEventListener("icegatheringstatechange", this.onIceGatherChange);
    (_a = this.unsubscribeIceTrickle) == null ? void 0 : _a.call(this);
    this.subscriptions.forEach((unsubscribe) => unsubscribe());
  }
};
var TransceiverCache = class {
  constructor() {
    this.cache = [];
    this.layers = [];
    this.transceiverOrder = [];
    this.add = (publishOption, transceiver) => {
      this.cache.push({ publishOption, transceiver });
      this.transceiverOrder.push(transceiver);
    };
    this.get = (publishOption) => {
      var _a;
      return (_a = this.findTransceiver(publishOption)) == null ? void 0 : _a.transceiver;
    };
    this.has = (publishOption) => {
      return !!this.get(publishOption);
    };
    this.find = (predicate) => {
      return this.cache.find(predicate);
    };
    this.items = () => {
      return this.cache;
    };
    this.indexOf = (transceiver) => {
      return this.transceiverOrder.indexOf(transceiver);
    };
    this.getLayers = (publishOption) => {
      const entry = this.layers.find((item) => item.publishOption.id === publishOption.id && item.publishOption.trackType === publishOption.trackType);
      return entry == null ? void 0 : entry.layers;
    };
    this.setLayers = (publishOption, layers = []) => {
      const entry = this.findLayer(publishOption);
      if (entry) {
        entry.layers = layers;
      } else {
        this.layers.push({ publishOption, layers });
      }
    };
    this.findTransceiver = (publishOption) => {
      return this.cache.find((item) => item.publishOption.id === publishOption.id && item.publishOption.trackType === publishOption.trackType);
    };
    this.findLayer = (publishOption) => {
      return this.layers.find((item) => item.publishOption.id === publishOption.id && item.publishOption.trackType === publishOption.trackType);
    };
  }
};
var ensureExhausted = (x, message) => {
  getLogger(["helpers"])("warn", message, x);
};
var trackTypeToParticipantStreamKey = (trackType) => {
  switch (trackType) {
    case TrackType.SCREEN_SHARE:
      return "screenShareStream";
    case TrackType.SCREEN_SHARE_AUDIO:
      return "screenShareAudioStream";
    case TrackType.VIDEO:
      return "videoStream";
    case TrackType.AUDIO:
      return "audioStream";
    case TrackType.UNSPECIFIED:
      throw new Error("Track type is unspecified");
    default:
      ensureExhausted(trackType, "Unknown track type");
  }
};
var muteTypeToTrackType = (muteType) => {
  switch (muteType) {
    case "audio":
      return TrackType.AUDIO;
    case "video":
      return TrackType.VIDEO;
    case "screenshare":
      return TrackType.SCREEN_SHARE;
    case "screenshare_audio":
      return TrackType.SCREEN_SHARE_AUDIO;
    default:
      ensureExhausted(muteType, "Unknown mute type");
  }
};
var toTrackType = (trackType) => {
  switch (trackType) {
    case "TRACK_TYPE_AUDIO":
      return TrackType.AUDIO;
    case "TRACK_TYPE_VIDEO":
      return TrackType.VIDEO;
    case "TRACK_TYPE_SCREEN_SHARE":
      return TrackType.SCREEN_SHARE;
    case "TRACK_TYPE_SCREEN_SHARE_AUDIO":
      return TrackType.SCREEN_SHARE_AUDIO;
    default:
      return void 0;
  }
};
var isAudioTrackType = (trackType) => trackType === TrackType.AUDIO || trackType === TrackType.SCREEN_SHARE_AUDIO;
var defaultBitratePerRid = {
  q: 3e5,
  h: 75e4,
  f: 125e4
};
var toSvcEncodings = (layers) => {
  if (!layers)
    return;
  const withRid = (rid) => (l) => l.rid === rid;
  const highestLayer = layers.find(withRid("f")) || layers.find(withRid("h")) || layers.find(withRid("q"));
  return [{ ...highestLayer, rid: "q" }];
};
var ridToVideoQuality = (rid) => {
  return rid === "q" ? VideoQuality.LOW_UNSPECIFIED : rid === "h" ? VideoQuality.MID : VideoQuality.HIGH;
};
var toVideoLayers = (layers = []) => {
  return layers.map((layer) => ({
    rid: layer.rid || "",
    bitrate: layer.maxBitrate || 0,
    fps: layer.maxFramerate || 0,
    quality: ridToVideoQuality(layer.rid || ""),
    videoDimension: { width: layer.width, height: layer.height }
  }));
};
var toScalabilityMode = (spatialLayers, temporalLayers) => `L${spatialLayers}T${temporalLayers}${spatialLayers > 1 ? "_KEY" : ""}`;
var computeVideoLayers = (videoTrack, publishOption) => {
  if (isAudioTrackType(publishOption.trackType))
    return;
  const optimalVideoLayers = [];
  const settings = videoTrack.getSettings();
  const { width = 0, height = 0 } = settings;
  const { bitrate, codec, fps, maxSpatialLayers = 3, maxTemporalLayers = 3, videoDimension = { width: 1280, height: 720 } } = publishOption;
  const maxBitrate = getComputedMaxBitrate(videoDimension, width, height, bitrate);
  let downscaleFactor = 1;
  let bitrateFactor = 1;
  const svcCodec = isSvcCodec(codec == null ? void 0 : codec.name);
  for (const rid of ["f", "h", "q"].slice(0, maxSpatialLayers)) {
    const layer = {
      active: true,
      rid,
      width: Math.round(width / downscaleFactor),
      height: Math.round(height / downscaleFactor),
      maxBitrate: Math.round(maxBitrate / bitrateFactor) || defaultBitratePerRid[rid],
      maxFramerate: fps
    };
    if (svcCodec) {
      layer.scalabilityMode = toScalabilityMode(maxSpatialLayers, maxTemporalLayers);
    } else {
      layer.scaleResolutionDownBy = downscaleFactor;
    }
    downscaleFactor *= 2;
    bitrateFactor *= 2;
    optimalVideoLayers.unshift(layer);
  }
  return withSimulcastConstraints(settings, optimalVideoLayers);
};
var getComputedMaxBitrate = (targetResolution, currentWidth, currentHeight, bitrate) => {
  const { width: targetWidth, height: targetHeight } = targetResolution;
  if (currentWidth < targetWidth || currentHeight < targetHeight) {
    const currentPixels = currentWidth * currentHeight;
    const targetPixels = targetWidth * targetHeight;
    const reductionFactor = currentPixels / targetPixels;
    return Math.round(bitrate * reductionFactor);
  }
  return bitrate;
};
var withSimulcastConstraints = (settings, optimalVideoLayers) => {
  let layers;
  const size4 = Math.max(settings.width || 0, settings.height || 0);
  if (size4 <= 320) {
    layers = optimalVideoLayers.filter((layer) => layer.rid === "f");
  } else if (size4 <= 640) {
    layers = optimalVideoLayers.filter((layer) => layer.rid !== "h");
  } else {
    layers = optimalVideoLayers;
  }
  const ridMapping = ["q", "h", "f"];
  return layers.map((layer, index3) => ({
    ...layer,
    rid: ridMapping[index3]
    // reassign rid
  }));
};
var extractMid = (transceiver, transceiverInitIndex, sdp2) => {
  if (transceiver.mid)
    return transceiver.mid;
  if (!sdp2)
    return String(transceiverInitIndex);
  const track = transceiver.sender.track;
  const parsedSdp = (0, import_sdp_transform.parse)(sdp2);
  const media = parsedSdp.media.find((m) => {
    var _a;
    return m.type === track.kind && // if `msid` is not present, we assume that the track is the first one
    (((_a = m.msid) == null ? void 0 : _a.includes(track.id)) ?? true);
  });
  if (typeof (media == null ? void 0 : media.mid) !== "undefined")
    return String(media.mid);
  if (transceiverInitIndex < 0)
    return "";
  return String(transceiverInitIndex);
};
var Publisher = class extends BasePeerConnection {
  /**
   * Constructs a new `Publisher` instance.
   */
  constructor({ publishOptions, ...baseOptions }) {
    super(PeerType.PUBLISHER_UNSPECIFIED, baseOptions);
    this.transceiverCache = new TransceiverCache();
    this.clonedTracks = /* @__PURE__ */ new Set();
    this.publish = async (track, trackType) => {
      if (!this.publishOptions.some((o) => o.trackType === trackType)) {
        throw new Error(`No publish options found for ${TrackType[trackType]}`);
      }
      for (const publishOption of this.publishOptions) {
        if (publishOption.trackType !== trackType)
          continue;
        const trackToPublish = this.cloneTrack(track);
        const transceiver = this.transceiverCache.get(publishOption);
        if (!transceiver) {
          await this.addTransceiver(trackToPublish, publishOption);
        } else {
          const previousTrack = transceiver.sender.track;
          await transceiver.sender.replaceTrack(trackToPublish);
          if (!isReactNative()) {
            this.stopTrack(previousTrack);
          }
        }
      }
    };
    this.addTransceiver = async (track, publishOption) => {
      var _a;
      const videoEncodings = computeVideoLayers(track, publishOption);
      const sendEncodings = isSvcCodec((_a = publishOption.codec) == null ? void 0 : _a.name) ? toSvcEncodings(videoEncodings) : videoEncodings;
      const transceiver = this.pc.addTransceiver(track, {
        direction: "sendonly",
        sendEncodings
      });
      const trackType = publishOption.trackType;
      this.logger("debug", `Added ${TrackType[trackType]} transceiver`);
      this.transceiverCache.add(publishOption, transceiver);
      await this.negotiate();
    };
    this.syncPublishOptions = async () => {
      for (const publishOption of this.publishOptions) {
        const { trackType } = publishOption;
        if (!this.isPublishing(trackType))
          continue;
        if (this.transceiverCache.has(publishOption))
          continue;
        const item = this.transceiverCache.find((i) => !!i.transceiver.sender.track && i.publishOption.trackType === trackType);
        if (!item || !item.transceiver)
          continue;
        const track = this.cloneTrack(item.transceiver.sender.track);
        await this.addTransceiver(track, publishOption);
      }
      for (const item of this.transceiverCache.items()) {
        const { publishOption, transceiver } = item;
        const hasPublishOption = this.publishOptions.some((option) => option.id === publishOption.id && option.trackType === publishOption.trackType);
        if (hasPublishOption)
          continue;
        this.stopTrack(transceiver.sender.track);
        await transceiver.sender.replaceTrack(null);
      }
    };
    this.isPublishing = (trackType) => {
      for (const item of this.transceiverCache.items()) {
        if (item.publishOption.trackType !== trackType)
          continue;
        const track = item.transceiver.sender.track;
        if (!track)
          continue;
        if (track.readyState === "live" && track.enabled)
          return true;
      }
      return false;
    };
    this.getTrackType = (trackId) => {
      var _a;
      for (const transceiverId of this.transceiverCache.items()) {
        const { publishOption, transceiver } = transceiverId;
        if (((_a = transceiver.sender.track) == null ? void 0 : _a.id) === trackId) {
          return publishOption.trackType;
        }
      }
      return void 0;
    };
    this.stopTracks = (...trackTypes) => {
      for (const item of this.transceiverCache.items()) {
        const { publishOption, transceiver } = item;
        if (!trackTypes.includes(publishOption.trackType))
          continue;
        this.stopTrack(transceiver.sender.track);
      }
    };
    this.stopAllTracks = () => {
      for (const { transceiver } of this.transceiverCache.items()) {
        this.stopTrack(transceiver.sender.track);
      }
      for (const track of this.clonedTracks) {
        this.stopTrack(track);
      }
    };
    this.changePublishQuality = async (videoSender) => {
      var _a;
      const { trackType, layers, publishOptionId } = videoSender;
      const enabledLayers = layers.filter((l) => l.active);
      const tag = "Update publish quality:";
      this.logger("info", `${tag} requested layers by SFU:`, enabledLayers);
      const transceiverId = this.transceiverCache.find((t2) => t2.publishOption.id === publishOptionId && t2.publishOption.trackType === trackType);
      const sender = transceiverId == null ? void 0 : transceiverId.transceiver.sender;
      if (!sender) {
        return this.logger("warn", `${tag} no video sender found.`);
      }
      const params = sender.getParameters();
      if (params.encodings.length === 0) {
        return this.logger("warn", `${tag} there are no encodings set.`);
      }
      const codecInUse = (_a = transceiverId == null ? void 0 : transceiverId.publishOption.codec) == null ? void 0 : _a.name;
      const usesSvcCodec = codecInUse && isSvcCodec(codecInUse);
      let changed = false;
      for (const encoder of params.encodings) {
        const layer = usesSvcCodec ? (
          // for SVC, we only have one layer (q) and often rid is omitted
          enabledLayers[0]
        ) : (
          // for non-SVC, we need to find the layer by rid (simulcast)
          enabledLayers.find((l) => l.name === encoder.rid) ?? (params.encodings.length === 1 ? enabledLayers[0] : void 0)
        );
        const shouldActivate = !!(layer == null ? void 0 : layer.active);
        if (shouldActivate !== encoder.active) {
          encoder.active = shouldActivate;
          changed = true;
        }
        if (!layer)
          continue;
        const { maxFramerate, scaleResolutionDownBy, maxBitrate, scalabilityMode } = layer;
        if (scaleResolutionDownBy >= 1 && scaleResolutionDownBy !== encoder.scaleResolutionDownBy) {
          encoder.scaleResolutionDownBy = scaleResolutionDownBy;
          changed = true;
        }
        if (maxBitrate > 0 && maxBitrate !== encoder.maxBitrate) {
          encoder.maxBitrate = maxBitrate;
          changed = true;
        }
        if (maxFramerate > 0 && maxFramerate !== encoder.maxFramerate) {
          encoder.maxFramerate = maxFramerate;
          changed = true;
        }
        if (scalabilityMode && scalabilityMode !== encoder.scalabilityMode) {
          encoder.scalabilityMode = scalabilityMode;
          changed = true;
        }
      }
      const activeEncoders = params.encodings.filter((e) => e.active);
      if (!changed) {
        return this.logger("info", `${tag} no change:`, activeEncoders);
      }
      await sender.setParameters(params);
      this.logger("info", `${tag} enabled rids:`, activeEncoders);
    };
    this.restartIce = async () => {
      this.logger("debug", "Restarting ICE connection");
      const signalingState = this.pc.signalingState;
      if (this.isIceRestarting || signalingState === "have-local-offer") {
        this.logger("debug", "ICE restart is already in progress");
        return;
      }
      await this.negotiate({ iceRestart: true });
    };
    this.negotiate = async (options) => {
      return withoutConcurrency("publisher.negotiate", async () => {
        const offer = await this.pc.createOffer(options);
        const tracks = this.getAnnouncedTracks(offer.sdp);
        if (!tracks.length)
          throw new Error(`Can't negotiate without any tracks`);
        try {
          this.isIceRestarting = (options == null ? void 0 : options.iceRestart) ?? false;
          await this.pc.setLocalDescription(offer);
          const { sdp: sdp2 = "" } = offer;
          const { response } = await this.sfuClient.setPublisher({ sdp: sdp2, tracks });
          if (response.error)
            throw new Error(response.error.message);
          const { sdp: answerSdp } = response;
          await this.pc.setRemoteDescription({ type: "answer", sdp: answerSdp });
        } finally {
          this.isIceRestarting = false;
        }
        this.addTrickledIceCandidates();
      });
    };
    this.getPublishedTracks = () => {
      const tracks = [];
      for (const { transceiver } of this.transceiverCache.items()) {
        const track = transceiver.sender.track;
        if (track && track.readyState === "live")
          tracks.push(track);
      }
      return tracks;
    };
    this.getAnnouncedTracks = (sdp2) => {
      const trackInfos = [];
      for (const bundle of this.transceiverCache.items()) {
        const { transceiver, publishOption } = bundle;
        const track = transceiver.sender.track;
        if (!track)
          continue;
        trackInfos.push(this.toTrackInfo(transceiver, publishOption, sdp2));
      }
      return trackInfos;
    };
    this.getAnnouncedTracksForReconnect = () => {
      var _a;
      const sdp2 = (_a = this.pc.localDescription) == null ? void 0 : _a.sdp;
      const trackInfos = [];
      for (const publishOption of this.publishOptions) {
        const transceiver = this.transceiverCache.get(publishOption);
        if (!transceiver || !transceiver.sender.track)
          continue;
        trackInfos.push(this.toTrackInfo(transceiver, publishOption, sdp2));
      }
      return trackInfos;
    };
    this.toTrackInfo = (transceiver, publishOption, sdp2) => {
      var _a;
      const track = transceiver.sender.track;
      const isTrackLive = track.readyState === "live";
      const layers = isTrackLive ? computeVideoLayers(track, publishOption) : this.transceiverCache.getLayers(publishOption);
      this.transceiverCache.setLayers(publishOption, layers);
      const isAudioTrack = isAudioTrackType(publishOption.trackType);
      const isStereo = isAudioTrack && track.getSettings().channelCount === 2;
      const transceiverIndex = this.transceiverCache.indexOf(transceiver);
      const audioSettings = (_a = this.state.settings) == null ? void 0 : _a.audio;
      return {
        trackId: track.id,
        layers: toVideoLayers(layers),
        trackType: publishOption.trackType,
        mid: extractMid(transceiver, transceiverIndex, sdp2),
        stereo: isStereo,
        dtx: isAudioTrack && !!(audioSettings == null ? void 0 : audioSettings.opus_dtx_enabled),
        red: isAudioTrack && !!(audioSettings == null ? void 0 : audioSettings.redundant_coding_enabled),
        muted: !isTrackLive,
        codec: publishOption.codec,
        publishOptionId: publishOption.id
      };
    };
    this.cloneTrack = (track) => {
      const clone = track.clone();
      this.clonedTracks.add(clone);
      return clone;
    };
    this.stopTrack = (track) => {
      if (!track)
        return;
      track.stop();
      this.clonedTracks.delete(track);
    };
    this.publishOptions = publishOptions;
    this.on("iceRestart", (iceRestart) => {
      if (iceRestart.peerType !== PeerType.PUBLISHER_UNSPECIFIED)
        return;
      this.restartIce().catch((err) => {
        var _a;
        const reason = `ICE restart failed`;
        this.logger("warn", reason, err);
        (_a = this.onUnrecoverableError) == null ? void 0 : _a.call(this, `${reason}: ${err}`);
      });
    });
    this.on("changePublishQuality", async (event) => {
      for (const videoSender of event.videoSenders) {
        await this.changePublishQuality(videoSender);
      }
    });
    this.on("changePublishOptions", (event) => {
      this.publishOptions = event.publishOptions;
      return this.syncPublishOptions();
    });
  }
  /**
   * Disposes this Publisher instance.
   */
  dispose() {
    super.dispose();
    this.stopAllTracks();
    this.clonedTracks.clear();
  }
};
var Subscriber2 = class extends BasePeerConnection {
  /**
   * Constructs a new `Subscriber` instance.
   */
  constructor(opts) {
    super(PeerType.SUBSCRIBER, opts);
    this.restartIce = async () => {
      this.logger("debug", "Restarting ICE connection");
      if (this.pc.signalingState === "have-remote-offer") {
        this.logger("debug", "ICE restart is already in progress");
        return;
      }
      if (this.pc.connectionState === "new") {
        this.logger("debug", `ICE connection is not yet established, skipping restart.`);
        return;
      }
      const previousIsIceRestarting = this.isIceRestarting;
      try {
        this.isIceRestarting = true;
        await this.sfuClient.iceRestart({
          peerType: PeerType.SUBSCRIBER
        });
      } catch (e) {
        this.isIceRestarting = previousIsIceRestarting;
        throw e;
      }
    };
    this.handleOnTrack = (e) => {
      const [primaryStream] = e.streams;
      const [trackId, rawTrackType] = primaryStream.id.split(":");
      const participantToUpdate = this.state.participants.find((p) => p.trackLookupPrefix === trackId);
      this.logger("debug", `[onTrack]: Got remote ${rawTrackType} track for userId: ${participantToUpdate == null ? void 0 : participantToUpdate.userId}`, e.track.id, e.track);
      const trackDebugInfo = `${participantToUpdate == null ? void 0 : participantToUpdate.userId} ${rawTrackType}:${trackId}`;
      e.track.addEventListener("mute", () => {
        this.logger("info", `[onTrack]: Track muted: ${trackDebugInfo}`);
      });
      e.track.addEventListener("unmute", () => {
        this.logger("info", `[onTrack]: Track unmuted: ${trackDebugInfo}`);
      });
      e.track.addEventListener("ended", () => {
        this.logger("info", `[onTrack]: Track ended: ${trackDebugInfo}`);
        this.state.removeOrphanedTrack(primaryStream.id);
      });
      const trackType = toTrackType(rawTrackType);
      if (!trackType) {
        return this.logger("error", `Unknown track type: ${rawTrackType}`);
      }
      if (!participantToUpdate) {
        this.logger("warn", `[onTrack]: Received track for unknown participant: ${trackId}`, e);
        this.state.registerOrphanedTrack({
          id: primaryStream.id,
          trackLookupPrefix: trackId,
          track: primaryStream,
          trackType
        });
        return;
      }
      const streamKindProp = trackTypeToParticipantStreamKey(trackType);
      if (!streamKindProp) {
        this.logger("error", `Unknown track type: ${rawTrackType}`);
        return;
      }
      const previousStream = participantToUpdate[streamKindProp];
      this.state.updateParticipant(participantToUpdate.sessionId, {
        [streamKindProp]: primaryStream
      });
      if (previousStream) {
        this.logger("info", `[onTrack]: Cleaning up previous remote ${e.track.kind} tracks for userId: ${participantToUpdate.userId}`);
        previousStream.getTracks().forEach((t2) => {
          t2.stop();
          previousStream.removeTrack(t2);
        });
      }
    };
    this.negotiate = async (subscriberOffer) => {
      await this.pc.setRemoteDescription({
        type: "offer",
        sdp: subscriberOffer.sdp
      });
      this.addTrickledIceCandidates();
      const answer = await this.pc.createAnswer();
      await this.pc.setLocalDescription(answer);
      await this.sfuClient.sendAnswer({
        peerType: PeerType.SUBSCRIBER,
        sdp: answer.sdp || ""
      });
      this.isIceRestarting = false;
    };
    this.pc.addEventListener("track", this.handleOnTrack);
    this.on("subscriberOffer", async (subscriberOffer) => {
      return this.negotiate(subscriberOffer).catch((err) => {
        this.logger("error", `Negotiation failed.`, err);
      });
    });
  }
  /**
   * Detaches the event handlers from the `RTCPeerConnection`.
   * This is useful when we want to replace the `RTCPeerConnection`
   * instance with a new one (in case of migration).
   */
  detachEventHandlers() {
    super.detachEventHandlers();
    this.pc.removeEventListener("track", this.handleOnTrack);
  }
};
var createWebSocketSignalChannel = (opts) => {
  const { endpoint, onMessage, logTag } = opts;
  const logger2 = getLogger(["SfuClientWS", logTag]);
  logger2("debug", "Creating signaling WS channel:", endpoint);
  const ws = new WebSocket(endpoint);
  ws.binaryType = "arraybuffer";
  ws.addEventListener("error", (e) => {
    logger2("error", "Signaling WS channel error", e);
  });
  ws.addEventListener("close", (e) => {
    logger2("info", "Signaling WS channel is closed", e);
  });
  ws.addEventListener("open", (e) => {
    logger2("info", "Signaling WS channel is open", e);
  });
  ws.addEventListener("message", (e) => {
    try {
      const message = e.data instanceof ArrayBuffer ? SfuEvent.fromBinary(new Uint8Array(e.data)) : SfuEvent.fromJsonString(e.data.toString());
      onMessage(message);
    } catch (err) {
      logger2("error", "Failed to decode a message. Check whether the Proto models match.", { event: e, error: err });
    }
  });
  return ws;
};
var toRtcConfiguration = (config2) => {
  return {
    bundlePolicy: "max-bundle",
    iceServers: config2.map((ice) => ({
      urls: ice.urls,
      username: ice.username,
      credential: ice.password
    }))
  };
};
function makeSafePromise(promise) {
  let isPending = true;
  const safePromise = promise.then((result) => ({ status: "resolved", result }), (error2) => ({ status: "rejected", error: error2 })).finally(() => isPending = false);
  const unwrapPromise = () => safePromise.then((fulfillment) => {
    if (fulfillment.status === "rejected")
      throw fulfillment.error;
    return fulfillment.result;
  });
  unwrapPromise.checkPending = () => isPending;
  return unwrapPromise;
}
var promiseWithResolvers = () => {
  let resolve;
  let reject;
  const promise = new Promise((_resolve, _reject) => {
    resolve = _resolve;
    reject = _reject;
  });
  let isResolved = false;
  let isRejected = false;
  const resolver = (value) => {
    isResolved = true;
    resolve(value);
  };
  const rejecter = (reason) => {
    isRejected = true;
    reject(reason);
  };
  return {
    promise,
    resolve: resolver,
    reject: rejecter,
    isResolved: () => isResolved,
    isRejected: () => isRejected
  };
};
var uninitialized = Symbol("uninitialized");
function lazy(factory) {
  let value = uninitialized;
  return () => {
    if (value === uninitialized) {
      value = factory();
    }
    return value;
  };
}
var timerWorker = {
  src: `const timerIdMapping = new Map();
self.addEventListener('message', (event) => {
    const request = event.data;
    switch (request.type) {
        case 'setTimeout':
        case 'setInterval':
            timerIdMapping.set(request.id, (request.type === 'setTimeout' ? setTimeout : setInterval)(() => {
                tick(request.id);
                if (request.type === 'setTimeout') {
                    timerIdMapping.delete(request.id);
                }
            }, request.timeout));
            break;
        case 'clearTimeout':
        case 'clearInterval':
            (request.type === 'clearTimeout' ? clearTimeout : clearInterval)(timerIdMapping.get(request.id));
            timerIdMapping.delete(request.id);
            break;
    }
});
function tick(id) {
    const message = { type: 'tick', id };
    self.postMessage(message);
}`
};
var TimerWorker = class {
  constructor() {
    this.currentTimerId = 1;
    this.callbacks = /* @__PURE__ */ new Map();
    this.fallback = false;
  }
  setup({ useTimerWorker = true } = {}) {
    if (!useTimerWorker) {
      this.fallback = true;
      return;
    }
    try {
      const source = timerWorker.src;
      const blob = new Blob([source], {
        type: "application/javascript; charset=utf-8"
      });
      const script = URL.createObjectURL(blob);
      this.worker = new Worker(script, { name: "str-timer-worker" });
      this.worker.addEventListener("message", (event) => {
        var _a;
        const { type, id } = event.data;
        if (type === "tick") {
          (_a = this.callbacks.get(id)) == null ? void 0 : _a();
        }
      });
    } catch (err) {
      getLogger(["timer-worker"])("error", err);
      this.fallback = true;
    }
  }
  destroy() {
    var _a;
    this.callbacks.clear();
    (_a = this.worker) == null ? void 0 : _a.terminate();
    this.worker = void 0;
    this.fallback = false;
  }
  get ready() {
    return this.fallback || Boolean(this.worker);
  }
  setInterval(callback, timeout2) {
    return this.setTimer("setInterval", callback, timeout2);
  }
  clearInterval(id) {
    this.clearTimer("clearInterval", id);
  }
  setTimeout(callback, timeout2) {
    return this.setTimer("setTimeout", callback, timeout2);
  }
  clearTimeout(id) {
    this.clearTimer("clearTimeout", id);
  }
  setTimer(type, callback, timeout2) {
    if (!this.ready) {
      this.setup();
    }
    if (this.fallback) {
      return (type === "setTimeout" ? setTimeout : setInterval)(callback, timeout2);
    }
    const id = this.getTimerId();
    this.callbacks.set(id, () => {
      callback();
      if (type === "setTimeout") {
        this.callbacks.delete(id);
      }
    });
    this.sendMessage({ type, id, timeout: timeout2 });
    return id;
  }
  clearTimer(type, id) {
    if (!id) {
      return;
    }
    if (!this.ready) {
      this.setup();
    }
    if (this.fallback) {
      (type === "clearTimeout" ? clearTimeout : clearInterval)(id);
      return;
    }
    this.callbacks.delete(id);
    this.sendMessage({ type, id });
  }
  getTimerId() {
    return this.currentTimerId++;
  }
  sendMessage(message) {
    if (!this.worker) {
      throw new Error("Cannot use timer worker before it's set up");
    }
    this.worker.postMessage(message);
  }
};
var timerWorkerEnabled = false;
var enableTimerWorker = () => {
  timerWorkerEnabled = true;
};
var getTimers = lazy(() => {
  const instance2 = new TimerWorker();
  instance2.setup({ useTimerWorker: timerWorkerEnabled });
  return instance2;
});
var StreamSfuClient = class _StreamSfuClient {
  /**
   * Constructs a new SFU client.
   */
  constructor({ dispatcher, credentials, sessionId, logTag, joinResponseTimeout = 5e3, onSignalClose, streamClient, enableTracing }) {
    this.iceTrickleBuffer = new IceTrickleBuffer();
    this.isLeaving = false;
    this.isClosing = false;
    this.pingIntervalInMs = 10 * 1e3;
    this.unhealthyTimeoutInMs = this.pingIntervalInMs + 5 * 1e3;
    this.joinResponseTask = promiseWithResolvers();
    this.abortController = new AbortController();
    this.createWebSocket = () => {
      this.signalWs = createWebSocketSignalChannel({
        logTag: this.logTag,
        endpoint: `${this.credentials.server.ws_endpoint}?tag=${this.logTag}`,
        onMessage: (message) => {
          this.lastMessageTimestamp = /* @__PURE__ */ new Date();
          this.scheduleConnectionCheck();
          this.dispatcher.dispatch(message, this.logTag);
        }
      });
      this.signalReady = makeSafePromise(Promise.race([
        new Promise((resolve, reject) => {
          const onOpen = () => {
            this.signalWs.removeEventListener("open", onOpen);
            resolve(this.signalWs);
          };
          this.signalWs.addEventListener("open", onOpen);
          this.signalWs.addEventListener("close", (e) => {
            this.handleWebSocketClose(e);
            reject(new Error("SFU WS closed unexpectedly"));
          });
        }),
        new Promise((resolve, reject) => {
          setTimeout(() => reject(new Error("SFU WS connection timed out")), this.joinResponseTimeout);
        })
      ]));
    };
    this.cleanUpWebSocket = () => {
      this.signalWs.removeEventListener("close", this.handleWebSocketClose);
    };
    this.handleWebSocketClose = (e) => {
      var _a;
      this.signalWs.removeEventListener("close", this.handleWebSocketClose);
      getTimers().clearInterval(this.keepAliveInterval);
      clearTimeout(this.connectionCheckTimeout);
      (_a = this.onSignalClose) == null ? void 0 : _a.call(this, `${e.code} ${e.reason}`);
    };
    this.close = (code = _StreamSfuClient.NORMAL_CLOSURE, reason) => {
      this.isClosing = true;
      if (this.signalWs.readyState === WebSocket.OPEN) {
        this.logger("debug", `Closing SFU WS connection: ${code} - ${reason}`);
        this.signalWs.close(code, `js-client: ${reason}`);
        this.cleanUpWebSocket();
      }
      this.dispose();
    };
    this.dispose = () => {
      var _a;
      this.logger("debug", "Disposing SFU client");
      this.unsubscribeIceTrickle();
      this.unsubscribeNetworkChanged();
      clearInterval(this.keepAliveInterval);
      clearTimeout(this.connectionCheckTimeout);
      clearTimeout(this.migrateAwayTimeout);
      this.abortController.abort();
      (_a = this.migrationTask) == null ? void 0 : _a.resolve();
      this.iceTrickleBuffer.dispose();
    };
    this.getTrace = () => {
      var _a;
      return (_a = this.tracer) == null ? void 0 : _a.take();
    };
    this.leaveAndClose = async (reason) => {
      await this.joinTask;
      try {
        this.isLeaving = true;
        await this.notifyLeave(reason);
      } catch (err) {
        this.logger("debug", "Error notifying SFU about leaving call", err);
      }
      this.close(_StreamSfuClient.NORMAL_CLOSURE, reason.substring(0, 115));
    };
    this.updateSubscriptions = async (tracks) => {
      await this.joinTask;
      return retryable(() => this.rpc.updateSubscriptions({ sessionId: this.sessionId, tracks }), this.abortController.signal);
    };
    this.setPublisher = async (data) => {
      await this.joinTask;
      return retryable(() => this.rpc.setPublisher({ ...data, sessionId: this.sessionId }), this.abortController.signal);
    };
    this.sendAnswer = async (data) => {
      await this.joinTask;
      return retryable(() => this.rpc.sendAnswer({ ...data, sessionId: this.sessionId }), this.abortController.signal);
    };
    this.iceTrickle = async (data) => {
      await this.joinTask;
      return retryable(() => this.rpc.iceTrickle({ ...data, sessionId: this.sessionId }), this.abortController.signal);
    };
    this.iceRestart = async (data) => {
      await this.joinTask;
      return retryable(() => this.rpc.iceRestart({ ...data, sessionId: this.sessionId }), this.abortController.signal);
    };
    this.updateMuteStates = async (muteStates) => {
      await this.joinTask;
      return retryable(() => this.rpc.updateMuteStates({ muteStates, sessionId: this.sessionId }), this.abortController.signal);
    };
    this.sendStats = async (stats) => {
      await this.joinTask;
      return retryable(() => this.rpc.sendStats({ ...stats, sessionId: this.sessionId }), this.abortController.signal);
    };
    this.startNoiseCancellation = async () => {
      await this.joinTask;
      return retryable(() => this.rpc.startNoiseCancellation({ sessionId: this.sessionId }), this.abortController.signal);
    };
    this.stopNoiseCancellation = async () => {
      await this.joinTask;
      return retryable(() => this.rpc.stopNoiseCancellation({ sessionId: this.sessionId }), this.abortController.signal);
    };
    this.enterMigration = async (opts = {}) => {
      var _a;
      this.isLeaving = true;
      const { timeout: timeout2 = 7 * 1e3 } = opts;
      (_a = this.migrationTask) == null ? void 0 : _a.reject(new Error("Cancelled previous migration"));
      const task = this.migrationTask = promiseWithResolvers();
      const unsubscribe = this.dispatcher.on("participantMigrationComplete", () => {
        unsubscribe();
        clearTimeout(this.migrateAwayTimeout);
        task.resolve();
      });
      this.migrateAwayTimeout = setTimeout(() => {
        unsubscribe();
        task.reject(new Error(`Migration (${this.logTag}) failed to complete in ${timeout2}ms`));
      }, timeout2);
      return task.promise;
    };
    this.join = async (data) => {
      await this.signalReady();
      if (this.joinResponseTask.isResolved() || this.joinResponseTask.isRejected()) {
        this.joinResponseTask = promiseWithResolvers();
      }
      const current = this.joinResponseTask;
      let timeoutId = void 0;
      const unsubscribe = this.dispatcher.on("joinResponse", (joinResponse) => {
        this.logger("debug", "Received joinResponse", joinResponse);
        clearTimeout(timeoutId);
        unsubscribe();
        this.keepAlive();
        current.resolve(joinResponse);
      });
      timeoutId = setTimeout(() => {
        unsubscribe();
        current.reject(new Error('Waiting for "joinResponse" has timed out'));
      }, this.joinResponseTimeout);
      await this.send(SfuRequest.create({
        requestPayload: {
          oneofKind: "joinRequest",
          joinRequest: JoinRequest.create({
            ...data,
            sessionId: this.sessionId,
            token: this.credentials.token
          })
        }
      }));
      return current.promise;
    };
    this.ping = async () => {
      return this.send(SfuRequest.create({
        requestPayload: {
          oneofKind: "healthCheckRequest",
          healthCheckRequest: {}
        }
      }));
    };
    this.notifyLeave = async (reason) => {
      return this.send(SfuRequest.create({
        requestPayload: {
          oneofKind: "leaveCallRequest",
          leaveCallRequest: {
            sessionId: this.sessionId,
            reason
          }
        }
      }));
    };
    this.send = async (message) => {
      await this.signalReady();
      const msgJson = SfuRequest.toJson(message);
      if (this.signalWs.readyState !== WebSocket.OPEN) {
        this.logger("debug", "Signal WS is not open. Skipping message", msgJson);
        return;
      }
      this.logger("debug", `Sending message to: ${this.edgeName}`, msgJson);
      this.signalWs.send(SfuRequest.toBinary(message));
    };
    this.keepAlive = () => {
      const timers = getTimers();
      timers.clearInterval(this.keepAliveInterval);
      this.keepAliveInterval = timers.setInterval(() => {
        this.ping().catch((e) => {
          this.logger("error", "Error sending healthCheckRequest to SFU", e);
        });
      }, this.pingIntervalInMs);
    };
    this.scheduleConnectionCheck = () => {
      clearTimeout(this.connectionCheckTimeout);
      this.connectionCheckTimeout = setTimeout(() => {
        if (this.lastMessageTimestamp) {
          const timeSinceLastMessage = (/* @__PURE__ */ new Date()).getTime() - this.lastMessageTimestamp.getTime();
          if (timeSinceLastMessage > this.unhealthyTimeoutInMs) {
            this.close(_StreamSfuClient.ERROR_CONNECTION_UNHEALTHY, `SFU connection unhealthy. Didn't receive any message for ${this.unhealthyTimeoutInMs}ms`);
          }
        }
      }, this.unhealthyTimeoutInMs);
    };
    this.dispatcher = dispatcher;
    this.sessionId = sessionId || generateUUIDv4();
    this.onSignalClose = onSignalClose;
    this.credentials = credentials;
    const { server, token } = credentials;
    this.edgeName = server.edge_name;
    this.joinResponseTimeout = joinResponseTimeout;
    this.logTag = logTag;
    this.logger = getLogger(["SfuClient", logTag]);
    this.tracer = enableTracing ? new Tracer(logTag) : void 0;
    this.rpc = createSignalClient({
      baseUrl: server.url,
      interceptors: [
        withHeaders({ Authorization: `Bearer ${token}` }),
        this.tracer && withRequestTracer(this.tracer.trace),
        getLogLevel() === "trace" && withRequestLogger(this.logger, "trace")
      ].filter((v) => !!v)
    });
    this.unsubscribeIceTrickle = dispatcher.on("iceTrickle", (iceTrickle) => {
      this.iceTrickleBuffer.push(iceTrickle);
    });
    this.unsubscribeNetworkChanged = streamClient.on("network.changed", (e) => {
      var _a;
      if (!e.online) {
        this.networkAvailableTask = promiseWithResolvers();
      } else {
        (_a = this.networkAvailableTask) == null ? void 0 : _a.resolve();
      }
    });
    this.createWebSocket();
  }
  get isHealthy() {
    return this.signalWs.readyState === WebSocket.OPEN && this.joinResponseTask.isResolved();
  }
  get joinTask() {
    return this.joinResponseTask.promise;
  }
};
StreamSfuClient.NORMAL_CLOSURE = 1e3;
StreamSfuClient.ERROR_CONNECTION_UNHEALTHY = 4001;
StreamSfuClient.DISPOSE_OLD_SOCKET = 4002;
var watchCallAccepted = (call) => {
  return async function onCallAccepted(event) {
    if (event.user.id === call.currentUserId)
      return;
    const { state } = call;
    if (event.call.created_by.id === call.currentUserId && state.callingState === CallingState.RINGING) {
      await call.join();
    }
  };
};
var watchCallRejected = (call) => {
  return async function onCallRejected(event) {
    if (event.user.id === call.currentUserId)
      return;
    const { call: eventCall } = event;
    const { session: callSession } = eventCall;
    if (!callSession) {
      call.logger("warn", "No call session provided. Ignoring call.rejected event.", event);
      return;
    }
    const rejectedBy = callSession.rejected_by;
    const { members, callingState } = call.state;
    if (callingState !== CallingState.RINGING) {
      call.logger("info", "Call is not in ringing mode (it is either accepted or rejected already). Ignoring call.rejected event.", event);
      return;
    }
    if (call.isCreatedByMe) {
      const everyoneElseRejected = members.filter((m) => m.user_id !== call.currentUserId).every((m) => rejectedBy[m.user_id]);
      if (everyoneElseRejected) {
        call.logger("info", "everyone rejected, leaving the call");
        await call.leave({ reason: "ring: everyone rejected" });
      }
    } else {
      if (rejectedBy[eventCall.created_by.id]) {
        call.logger("info", "call creator rejected, leaving call");
        await call.leave({ reason: "ring: creator rejected" });
      }
    }
  };
};
var watchCallEnded = (call) => {
  return function onCallEnded() {
    const { callingState } = call.state;
    if (callingState !== CallingState.IDLE && callingState !== CallingState.LEFT) {
      call.leave({ reason: "call.ended event received", reject: false }).catch((err) => {
        call.logger("error", "Failed to leave call after call.ended ", err);
      });
    }
  };
};
var watchSfuCallEnded = (call) => {
  return call.on("callEnded", async (e) => {
    if (call.state.callingState === CallingState.LEFT)
      return;
    try {
      call.state.setEndedAt(/* @__PURE__ */ new Date());
      const reason = CallEndedReason[e.reason];
      await call.leave({ reason: `callEnded received: ${reason}` });
    } catch (err) {
      call.logger("error", "Failed to leave call after being ended by the SFU", err);
    }
  });
};
var watchCallGrantsUpdated = (state) => {
  return function onCallGrantsUpdated(event) {
    const { currentGrants } = event;
    if (currentGrants) {
      const { canPublishAudio, canPublishVideo, canScreenshare } = currentGrants;
      const update = {
        [OwnCapability.SEND_AUDIO]: canPublishAudio,
        [OwnCapability.SEND_VIDEO]: canPublishVideo,
        [OwnCapability.SCREENSHARE]: canScreenshare
      };
      const nextCapabilities = state.ownCapabilities.filter((capability) => update[capability] !== false);
      Object.entries(update).forEach(([capability, value]) => {
        if (value && !nextCapabilities.includes(capability)) {
          nextCapabilities.push(capability);
        }
      });
      state.setOwnCapabilities(nextCapabilities);
    }
  };
};
var watchConnectionQualityChanged = (dispatcher, state) => {
  return dispatcher.on("connectionQualityChanged", (e) => {
    const { connectionQualityUpdates } = e;
    if (!connectionQualityUpdates)
      return;
    state.updateParticipants(connectionQualityUpdates.reduce((patches, update) => {
      const { sessionId, connectionQuality } = update;
      patches[sessionId] = {
        connectionQuality
      };
      return patches;
    }, {}));
  });
};
var watchParticipantCountChanged = (dispatcher, state) => {
  return dispatcher.on("healthCheckResponse", (e) => {
    const { participantCount } = e;
    if (participantCount) {
      state.setParticipantCount(participantCount.total);
      state.setAnonymousParticipantCount(participantCount.anonymous);
    }
  });
};
var watchLiveEnded = (dispatcher, call) => {
  return dispatcher.on("error", (e) => {
    if (e.error && e.error.code !== ErrorCode.LIVE_ENDED)
      return;
    call.state.setBackstage(true);
    if (!call.permissionsContext.hasPermission(OwnCapability.JOIN_BACKSTAGE)) {
      call.leave({ reason: "live ended" }).catch((err) => {
        call.logger("error", "Failed to leave call after live ended", err);
      });
    }
  });
};
var watchSfuErrorReports = (dispatcher) => {
  return dispatcher.on("error", (e) => {
    if (!e.error)
      return;
    const logger2 = getLogger(["SfuClient"]);
    const { error: error2, reconnectStrategy } = e;
    logger2("error", "SFU reported error", {
      code: ErrorCode[error2.code],
      reconnectStrategy: WebsocketReconnectStrategy[reconnectStrategy],
      message: error2.message,
      shouldRetry: error2.shouldRetry
    });
  });
};
var watchPinsUpdated = (state) => {
  return function onPinsUpdated(e) {
    const { pins } = e;
    state.setServerSidePins(pins);
  };
};
var handleRemoteSoftMute = (call) => {
  return call.on("trackUnpublished", async (event) => {
    const { cause, type, sessionId } = event;
    const { localParticipant } = call.state;
    if (cause === TrackUnpublishReason.MODERATION && sessionId === (localParticipant == null ? void 0 : localParticipant.sessionId)) {
      const logger2 = call.logger;
      logger2("info", `Local participant's ${TrackType[type]} track is muted remotely`);
      try {
        if (type === TrackType.VIDEO) {
          await call.camera.disable();
        } else if (type === TrackType.AUDIO) {
          await call.microphone.disable();
        } else if (type === TrackType.SCREEN_SHARE || type === TrackType.SCREEN_SHARE_AUDIO) {
          await call.screenShare.disable();
        } else {
          logger2("warn", "Unsupported track type to soft mute", TrackType[type]);
        }
      } catch (error2) {
        logger2("error", "Failed to stop publishing", error2);
      }
    }
  });
};
var pushToIfMissing = (arr, ...values) => {
  for (const v of values) {
    if (!arr.includes(v)) {
      arr.push(v);
    }
  }
  return arr;
};
var watchParticipantJoined = (state) => {
  return function onParticipantJoined(e) {
    const { participant } = e;
    if (!participant)
      return;
    const orphanedTracks = reconcileOrphanedTracks(state, participant);
    state.updateOrAddParticipant(participant.sessionId, Object.assign(participant, orphanedTracks, {
      viewportVisibilityState: {
        videoTrack: VisibilityState.UNKNOWN,
        screenShareTrack: VisibilityState.UNKNOWN
      }
    }));
  };
};
var watchParticipantLeft = (state) => {
  return function onParticipantLeft(e) {
    const { participant } = e;
    if (!participant)
      return;
    state.setParticipants((participants) => participants.filter((p) => p.sessionId !== participant.sessionId));
  };
};
var watchParticipantUpdated = (state) => {
  return function onParticipantUpdated(e) {
    const { participant } = e;
    if (!participant)
      return;
    state.updateParticipant(participant.sessionId, participant);
  };
};
var watchTrackPublished = (state) => {
  return function onTrackPublished(e) {
    const { type, sessionId } = e;
    if (e.participant) {
      const orphanedTracks = reconcileOrphanedTracks(state, e.participant);
      const participant = Object.assign(e.participant, orphanedTracks);
      state.updateOrAddParticipant(sessionId, participant);
    } else {
      state.updateParticipant(sessionId, (p) => ({
        publishedTracks: pushToIfMissing([...p.publishedTracks], type)
      }));
    }
  };
};
var watchTrackUnpublished = (state) => {
  return function onTrackUnpublished(e) {
    const { type, sessionId } = e;
    if (e.participant) {
      const orphanedTracks = reconcileOrphanedTracks(state, e.participant);
      const participant = Object.assign(e.participant, orphanedTracks);
      state.updateOrAddParticipant(sessionId, participant);
    } else {
      state.updateParticipant(sessionId, (p) => ({
        publishedTracks: p.publishedTracks.filter((t2) => t2 !== type)
      }));
    }
  };
};
var reconcileOrphanedTracks = (state, participant) => {
  const orphanTracks = state.takeOrphanedTracks(participant.trackLookupPrefix);
  if (!orphanTracks.length)
    return;
  const reconciledTracks = {};
  for (const orphan of orphanTracks) {
    const key = trackTypeToParticipantStreamKey(orphan.trackType);
    if (!key)
      continue;
    reconciledTracks[key] = orphan.track;
  }
  return reconciledTracks;
};
var watchDominantSpeakerChanged = (dispatcher, state) => {
  return dispatcher.on("dominantSpeakerChanged", (e) => {
    var _a;
    const { sessionId } = e;
    if (sessionId === ((_a = state.dominantSpeaker) == null ? void 0 : _a.sessionId))
      return;
    state.setParticipants((participants) => participants.map((participant) => {
      if (participant.sessionId === sessionId) {
        return {
          ...participant,
          isDominantSpeaker: true
        };
      }
      if (participant.isDominantSpeaker) {
        return {
          ...participant,
          isDominantSpeaker: false
        };
      }
      return participant;
    }));
  });
};
var watchAudioLevelChanged = (dispatcher, state) => {
  return dispatcher.on("audioLevelChanged", (e) => {
    const { audioLevels } = e;
    state.updateParticipants(audioLevels.reduce((patches, current) => {
      patches[current.sessionId] = {
        audioLevel: current.level,
        isSpeaking: current.isSpeaking
      };
      return patches;
    }, {}));
  });
};
var registerEventHandlers = (call, dispatcher) => {
  const state = call.state;
  const eventHandlers = [
    call.on("call.ended", watchCallEnded(call)),
    watchSfuCallEnded(call),
    watchLiveEnded(dispatcher, call),
    watchSfuErrorReports(dispatcher),
    watchConnectionQualityChanged(dispatcher, state),
    watchParticipantCountChanged(dispatcher, state),
    call.on("participantJoined", watchParticipantJoined(state)),
    call.on("participantLeft", watchParticipantLeft(state)),
    call.on("participantUpdated", watchParticipantUpdated(state)),
    call.on("trackPublished", watchTrackPublished(state)),
    call.on("trackUnpublished", watchTrackUnpublished(state)),
    watchAudioLevelChanged(dispatcher, state),
    watchDominantSpeakerChanged(dispatcher, state),
    call.on("callGrantsUpdated", watchCallGrantsUpdated(state)),
    call.on("pinsUpdated", watchPinsUpdated(state)),
    handleRemoteSoftMute(call)
  ];
  if (call.ringing) {
    eventHandlers.push(registerRingingCallEventHandlers(call));
  }
  return () => {
    eventHandlers.forEach((unsubscribe) => unsubscribe());
  };
};
var registerRingingCallEventHandlers = (call) => {
  const coordinatorRingEvents = {
    "call.accepted": watchCallAccepted(call),
    "call.rejected": watchCallRejected(call)
  };
  const eventHandlers = Object.keys(coordinatorRingEvents).map((event) => {
    const eventName = event;
    return call.on(eventName, coordinatorRingEvents[eventName]);
  });
  return () => {
    eventHandlers.forEach((unsubscribe) => unsubscribe());
  };
};
var DEFAULT_THRESHOLD = 0.35;
var ViewportTracker = class {
  constructor() {
    this.elementHandlerMap = /* @__PURE__ */ new Map();
    this.observer = null;
    this.queueSet = /* @__PURE__ */ new Set();
    this.setViewport = (viewportElement, options) => {
      const cleanup2 = () => {
        var _a;
        (_a = this.observer) == null ? void 0 : _a.disconnect();
        this.observer = null;
        this.elementHandlerMap.clear();
      };
      this.observer = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          const handler = this.elementHandlerMap.get(entry.target);
          handler == null ? void 0 : handler(entry);
        });
      }, {
        root: viewportElement,
        ...options,
        threshold: (options == null ? void 0 : options.threshold) ?? DEFAULT_THRESHOLD
      });
      if (this.queueSet.size) {
        this.queueSet.forEach(([queueElement, queueHandler]) => {
          if (!viewportElement.contains(queueElement))
            return;
          this.observer.observe(queueElement);
          this.elementHandlerMap.set(queueElement, queueHandler);
        });
        this.queueSet.clear();
      }
      return cleanup2;
    };
    this.observe = (element, handler) => {
      const queueItem = [element, handler];
      const cleanup2 = () => {
        var _a;
        this.elementHandlerMap.delete(element);
        (_a = this.observer) == null ? void 0 : _a.unobserve(element);
        this.queueSet.delete(queueItem);
      };
      if (this.elementHandlerMap.has(element))
        return cleanup2;
      if (!this.observer) {
        this.queueSet.add(queueItem);
        return cleanup2;
      }
      if (this.observer.root.contains(element)) {
        this.elementHandlerMap.set(element, handler);
        this.observer.observe(element);
      }
      return cleanup2;
    };
  }
};
var DEFAULT_VIEWPORT_VISIBILITY_STATE = {
  videoTrack: VisibilityState.UNKNOWN,
  screenShareTrack: VisibilityState.UNKNOWN
};
var globalOverrideKey = Symbol("globalOverrideKey");
var DynascaleManager = class {
  /**
   * Creates a new DynascaleManager instance.
   */
  constructor(callState, speaker) {
    this.viewportTracker = new ViewportTracker();
    this.logger = getLogger(["DynascaleManager"]);
    this.pendingSubscriptionsUpdate = null;
    this.videoTrackSubscriptionOverridesSubject = new BehaviorSubject({});
    this.videoTrackSubscriptionOverrides$ = this.videoTrackSubscriptionOverridesSubject.asObservable();
    this.incomingVideoSettings$ = this.videoTrackSubscriptionOverrides$.pipe(map((overrides) => {
      const { [globalOverrideKey]: globalSettings, ...participants } = overrides;
      return {
        enabled: (globalSettings == null ? void 0 : globalSettings.enabled) !== false,
        preferredResolution: (globalSettings == null ? void 0 : globalSettings.enabled) ? globalSettings.dimension : void 0,
        participants: Object.fromEntries(Object.entries(participants).map(([sessionId, participantOverride]) => [
          sessionId,
          {
            enabled: (participantOverride == null ? void 0 : participantOverride.enabled) !== false,
            preferredResolution: (participantOverride == null ? void 0 : participantOverride.enabled) ? participantOverride.dimension : void 0
          }
        ])),
        isParticipantVideoEnabled: (sessionId) => {
          var _a, _b;
          return ((_a = overrides[sessionId]) == null ? void 0 : _a.enabled) ?? ((_b = overrides[globalOverrideKey]) == null ? void 0 : _b.enabled) ?? true;
        }
      };
    }), shareReplay(1));
    this.setVideoTrackSubscriptionOverrides = (override, sessionIds) => {
      if (!sessionIds) {
        return setCurrentValue(this.videoTrackSubscriptionOverridesSubject, override ? { [globalOverrideKey]: override } : {});
      }
      return setCurrentValue(this.videoTrackSubscriptionOverridesSubject, (overrides) => ({
        ...overrides,
        ...Object.fromEntries(sessionIds.map((id) => [id, override]))
      }));
    };
    this.applyTrackSubscriptions = (debounceType = DebounceType.SLOW) => {
      if (this.pendingSubscriptionsUpdate) {
        clearTimeout(this.pendingSubscriptionsUpdate);
      }
      const updateSubscriptions = () => {
        var _a;
        this.pendingSubscriptionsUpdate = null;
        (_a = this.sfuClient) == null ? void 0 : _a.updateSubscriptions(this.trackSubscriptions).catch((err) => {
          this.logger("debug", `Failed to update track subscriptions`, err);
        });
      };
      if (debounceType) {
        this.pendingSubscriptionsUpdate = setTimeout(updateSubscriptions, debounceType);
      } else {
        updateSubscriptions();
      }
    };
    this.trackElementVisibility = (element, sessionId, trackType) => {
      const cleanup2 = this.viewportTracker.observe(element, (entry) => {
        this.callState.updateParticipant(sessionId, (participant) => {
          const previousVisibilityState = participant.viewportVisibilityState ?? DEFAULT_VIEWPORT_VISIBILITY_STATE;
          const isVisible = entry.isIntersecting || document.fullscreenElement === element ? VisibilityState.VISIBLE : VisibilityState.INVISIBLE;
          return {
            ...participant,
            viewportVisibilityState: {
              ...previousVisibilityState,
              [trackType]: isVisible
            }
          };
        });
      });
      return () => {
        cleanup2();
        this.callState.updateParticipant(sessionId, (participant) => {
          const previousVisibilityState = participant.viewportVisibilityState ?? DEFAULT_VIEWPORT_VISIBILITY_STATE;
          return {
            ...participant,
            viewportVisibilityState: {
              ...previousVisibilityState,
              [trackType]: VisibilityState.UNKNOWN
            }
          };
        });
      };
    };
    this.setViewport = (element) => {
      return this.viewportTracker.setViewport(element);
    };
    this.bindVideoElement = (videoElement, sessionId, trackType) => {
      const boundParticipant = this.callState.findParticipantBySessionId(sessionId);
      if (!boundParticipant)
        return;
      const requestTrackWithDimensions = (debounceType, dimension) => {
        if (dimension && (dimension.width === 0 || dimension.height === 0)) {
          this.logger("debug", `Ignoring 0x0 dimension`, boundParticipant);
          dimension = void 0;
        }
        this.callState.updateParticipantTracks(trackType, {
          [sessionId]: { dimension }
        });
        this.applyTrackSubscriptions(debounceType);
      };
      const participant$ = this.callState.participants$.pipe(map((participants) => participants.find((participant) => participant.sessionId === sessionId)), takeWhile((participant) => !!participant), distinctUntilChanged(), shareReplay({ bufferSize: 1, refCount: true }));
      let viewportVisibilityState;
      const viewportVisibilityStateSubscription = boundParticipant.isLocalParticipant ? null : participant$.pipe(map((p) => {
        var _a;
        return (_a = p.viewportVisibilityState) == null ? void 0 : _a[trackType];
      }), distinctUntilChanged()).subscribe((nextViewportVisibilityState) => {
        if (!viewportVisibilityState) {
          viewportVisibilityState = nextViewportVisibilityState ?? VisibilityState.UNKNOWN;
          return;
        }
        viewportVisibilityState = nextViewportVisibilityState ?? VisibilityState.UNKNOWN;
        if (nextViewportVisibilityState === VisibilityState.INVISIBLE) {
          return requestTrackWithDimensions(DebounceType.MEDIUM, void 0);
        }
        requestTrackWithDimensions(DebounceType.MEDIUM, {
          width: videoElement.clientWidth,
          height: videoElement.clientHeight
        });
      });
      let lastDimensions;
      const resizeObserver = boundParticipant.isLocalParticipant ? null : new ResizeObserver(() => {
        const currentDimensions = {
          width: videoElement.clientWidth,
          height: videoElement.clientHeight
        };
        if (!lastDimensions) {
          lastDimensions = currentDimensions;
          return;
        }
        if (lastDimensions.width === currentDimensions.width && lastDimensions.height === currentDimensions.height || viewportVisibilityState === VisibilityState.INVISIBLE) {
          return;
        }
        const relativeDelta = Math.max(currentDimensions.width / lastDimensions.width, currentDimensions.height / lastDimensions.height);
        const debounceType = relativeDelta > 1.2 ? DebounceType.IMMEDIATE : DebounceType.MEDIUM;
        requestTrackWithDimensions(debounceType, {
          width: videoElement.clientWidth,
          height: videoElement.clientHeight
        });
        lastDimensions = currentDimensions;
      });
      resizeObserver == null ? void 0 : resizeObserver.observe(videoElement);
      const publishedTracksSubscription = boundParticipant.isLocalParticipant ? null : participant$.pipe(distinctUntilKeyChanged("publishedTracks"), map((p) => trackType === "videoTrack" ? hasVideo(p) : hasScreenShare(p)), distinctUntilChanged()).subscribe((isPublishing) => {
        if (isPublishing) {
          requestTrackWithDimensions(DebounceType.IMMEDIATE, {
            width: videoElement.clientWidth,
            height: videoElement.clientHeight
          });
        } else {
          requestTrackWithDimensions(DebounceType.FAST, void 0);
        }
      });
      videoElement.autoplay = true;
      videoElement.playsInline = true;
      videoElement.muted = true;
      const streamSubscription = participant$.pipe(distinctUntilKeyChanged(trackType === "videoTrack" ? "videoStream" : "screenShareStream")).subscribe((p) => {
        const source = trackType === "videoTrack" ? p.videoStream : p.screenShareStream;
        if (videoElement.srcObject === source)
          return;
        videoElement.srcObject = source ?? null;
        if (isSafari() || isFirefox()) {
          setTimeout(() => {
            videoElement.srcObject = source ?? null;
            videoElement.play().catch((e) => {
              this.logger("warn", `Failed to play stream`, e);
            });
          }, 25);
        }
      });
      return () => {
        requestTrackWithDimensions(DebounceType.FAST, void 0);
        viewportVisibilityStateSubscription == null ? void 0 : viewportVisibilityStateSubscription.unsubscribe();
        publishedTracksSubscription == null ? void 0 : publishedTracksSubscription.unsubscribe();
        streamSubscription.unsubscribe();
        resizeObserver == null ? void 0 : resizeObserver.disconnect();
      };
    };
    this.bindAudioElement = (audioElement, sessionId, trackType) => {
      const participant = this.callState.findParticipantBySessionId(sessionId);
      if (!participant || participant.isLocalParticipant)
        return;
      const participant$ = this.callState.participants$.pipe(map((participants) => participants.find((p) => p.sessionId === sessionId)), takeWhile((p) => !!p), distinctUntilChanged(), shareReplay({ bufferSize: 1, refCount: true }));
      const updateMediaStreamSubscription = participant$.pipe(distinctUntilKeyChanged(trackType === "screenShareAudioTrack" ? "screenShareAudioStream" : "audioStream")).subscribe((p) => {
        const source = trackType === "screenShareAudioTrack" ? p.screenShareAudioStream : p.audioStream;
        if (audioElement.srcObject === source)
          return;
        setTimeout(() => {
          audioElement.srcObject = source ?? null;
          if (audioElement.srcObject) {
            audioElement.play().catch((e) => {
              this.logger("warn", `Failed to play stream`, e);
            });
            const { selectedDevice } = this.speaker.state;
            if (selectedDevice && "setSinkId" in audioElement) {
              audioElement.setSinkId(selectedDevice);
              tracer.trace("navigator.mediaDevices.setSinkId", selectedDevice);
            }
          }
        });
      });
      const sinkIdSubscription = !("setSinkId" in audioElement) ? null : this.speaker.state.selectedDevice$.subscribe((deviceId) => {
        if (deviceId) {
          audioElement.setSinkId(deviceId);
          tracer.trace("navigator.mediaDevices.setSinkId", deviceId);
        }
      });
      const volumeSubscription = combineLatest([
        this.speaker.state.volume$,
        participant$.pipe(distinctUntilKeyChanged("audioVolume"))
      ]).subscribe(([volume, p]) => {
        audioElement.volume = p.audioVolume ?? volume;
      });
      audioElement.autoplay = true;
      return () => {
        sinkIdSubscription == null ? void 0 : sinkIdSubscription.unsubscribe();
        volumeSubscription.unsubscribe();
        updateMediaStreamSubscription.unsubscribe();
      };
    };
    this.callState = callState;
    this.speaker = speaker;
  }
  setSfuClient(sfuClient) {
    this.sfuClient = sfuClient;
  }
  get trackSubscriptions() {
    const subscriptions = [];
    for (const p of this.callState.remoteParticipants) {
      if (p.videoDimension && hasVideo(p)) {
        const override = this.videoTrackSubscriptionOverrides[p.sessionId] ?? this.videoTrackSubscriptionOverrides[globalOverrideKey];
        if ((override == null ? void 0 : override.enabled) !== false) {
          subscriptions.push({
            userId: p.userId,
            sessionId: p.sessionId,
            trackType: TrackType.VIDEO,
            dimension: (override == null ? void 0 : override.dimension) ?? p.videoDimension
          });
        }
      }
      if (p.screenShareDimension && hasScreenShare(p)) {
        subscriptions.push({
          userId: p.userId,
          sessionId: p.sessionId,
          trackType: TrackType.SCREEN_SHARE,
          dimension: p.screenShareDimension
        });
      }
      if (hasScreenShareAudio(p)) {
        subscriptions.push({
          userId: p.userId,
          sessionId: p.sessionId,
          trackType: TrackType.SCREEN_SHARE_AUDIO
        });
      }
    }
    return subscriptions;
  }
  get videoTrackSubscriptionOverrides() {
    return getCurrentValue(this.videoTrackSubscriptionOverrides$);
  }
};
var PermissionsContext = class {
  constructor() {
    this.permissions = [];
    this.setPermissions = (permissions) => {
      this.permissions = permissions || [];
    };
    this.setCallSettings = (settings) => {
      this.settings = settings;
    };
    this.hasPermission = (permission) => {
      return this.permissions.includes(permission);
    };
    this.canPublish = (trackType) => {
      switch (trackType) {
        case TrackType.AUDIO:
          return this.hasPermission(OwnCapability.SEND_AUDIO);
        case TrackType.VIDEO:
          return this.hasPermission(OwnCapability.SEND_VIDEO);
        case TrackType.SCREEN_SHARE:
        case TrackType.SCREEN_SHARE_AUDIO:
          return this.hasPermission(OwnCapability.SCREENSHARE);
        case TrackType.UNSPECIFIED:
          return false;
        default:
          ensureExhausted(trackType, "Unknown track type");
      }
    };
    this.canRequest = (permission, settings = this.settings) => {
      if (!settings)
        return false;
      const { audio, video, screensharing } = settings;
      switch (permission) {
        case OwnCapability.SEND_AUDIO:
          return audio.access_request_enabled;
        case OwnCapability.SEND_VIDEO:
          return video.access_request_enabled;
        case OwnCapability.SCREENSHARE:
          return screensharing.access_request_enabled;
        default:
          return false;
      }
    };
  }
};
var CallType = class {
  /**
   * Constructs a new CallType.
   *
   * @param name the name of the call type.
   * @param options the options for the call type.
   */
  constructor(name2, options = {
    sortParticipantsBy: defaultSortPreset
  }) {
    this.name = name2;
    this.options = options;
  }
};
var CallTypesRegistry = class {
  /**
   * Constructs a new CallTypesRegistry.
   *
   * @param callTypes the initial call types to register.
   */
  constructor(callTypes) {
    this.register = (callType) => {
      this.callTypes[callType.name] = callType;
    };
    this.unregister = (name2) => {
      delete this.callTypes[name2];
    };
    this.get = (name2) => {
      if (!this.callTypes[name2]) {
        this.register(new CallType(name2));
      }
      return this.callTypes[name2];
    };
    this.callTypes = callTypes.reduce((acc, callType) => {
      acc[callType.name] = callType;
      return acc;
    }, {});
  }
};
var CallTypes = new CallTypesRegistry([
  new CallType("default", {
    sortParticipantsBy: defaultSortPreset
  }),
  new CallType("development", {
    sortParticipantsBy: defaultSortPreset
  }),
  new CallType("livestream", {
    sortParticipantsBy: livestreamOrAudioRoomSortPreset
  }),
  new CallType("audio_room", {
    sortParticipantsBy: livestreamOrAudioRoomSortPreset
  })
]);
var BrowserPermission = class {
  constructor(permission) {
    this.permission = permission;
    this.disposeController = new AbortController();
    this.wasPrompted = false;
    this.listeners = /* @__PURE__ */ new Set();
    this.logger = getLogger(["permissions"]);
    const signal = this.disposeController.signal;
    this.ready = (async () => {
      const assumeGranted = () => {
        this.setState("prompt");
      };
      if (!canQueryPermissions()) {
        return assumeGranted();
      }
      try {
        const status = await navigator.permissions.query({
          name: permission.queryName
        });
        if (!signal.aborted) {
          this.setState(status.state);
          status.addEventListener("change", () => this.setState(status.state), {
            signal
          });
        }
      } catch (err) {
        this.logger("debug", "Failed to query permission status", err);
        assumeGranted();
      }
    })();
  }
  dispose() {
    this.state = void 0;
    this.disposeController.abort();
  }
  async getState() {
    await this.ready;
    if (!this.state) {
      throw new Error("BrowserPermission instance possibly disposed");
    }
    return this.state;
  }
  async prompt({ forcePrompt = false, throwOnNotAllowed = false } = {}) {
    return await withoutConcurrency(`permission-prompt-${this.permission.queryName}`, async () => {
      if (await this.getState() !== "prompt" || this.wasPrompted && !forcePrompt) {
        const isGranted = this.state === "granted";
        if (!isGranted && throwOnNotAllowed) {
          throw new Error("Permission was not granted previously, and prompting again is not allowed");
        }
        return isGranted;
      }
      try {
        this.wasPrompted = true;
        this.setState("prompting");
        const stream = await navigator.mediaDevices.getUserMedia(this.permission.constraints);
        disposeOfMediaStream(stream);
        this.setState("granted");
        return true;
      } catch (e) {
        if (e && typeof e === "object" && "name" in e && (e.name === "NotAllowedError" || e.name === "SecurityError")) {
          this.logger("info", "Browser permission was not granted", {
            permission: this.permission
          });
          this.setState("denied");
          if (throwOnNotAllowed) {
            throw e;
          }
          return false;
        }
        this.logger("error", `Failed to getUserMedia`, {
          error: e,
          permission: this.permission
        });
        this.setState("prompt");
        throw e;
      }
    });
  }
  listen(cb) {
    this.listeners.add(cb);
    if (this.state)
      cb(this.state);
    return () => this.listeners.delete(cb);
  }
  asObservable() {
    return this.getStateObservable().pipe(
      // In some browsers, the 'change' event doesn't reliably emit and hence,
      // permissionState stays in 'prompt' state forever.
      // Typically, this happens when a user grants one-time permission.
      // Instead of checking if a permission is granted, we check if it isn't denied
      map((state) => state !== "denied")
    );
  }
  getIsPromptingObservable() {
    return this.getStateObservable().pipe(map((state) => state === "prompting"));
  }
  getStateObservable() {
    return fromEventPattern((handler) => this.listen(handler), (handler, unlisten) => unlisten());
  }
  setState(state) {
    if (this.state !== state) {
      this.state = state;
      this.listeners.forEach((listener) => listener(state));
    }
  }
};
function canQueryPermissions() {
  var _a;
  return !isReactNative() && typeof navigator !== "undefined" && !!((_a = navigator.permissions) == null ? void 0 : _a.query);
}
var getDevices = (permission, kind) => {
  return from((async () => {
    let devices = await navigator.mediaDevices.enumerateDevices();
    const shouldPromptForBrowserPermission = devices.some((device) => device.kind === kind && device.label === "");
    if (shouldPromptForBrowserPermission && await permission.prompt()) {
      devices = await navigator.mediaDevices.enumerateDevices();
    }
    return devices.filter((device) => device.kind === kind && device.label !== "" && device.deviceId !== "default");
  })());
};
var checkIfAudioOutputChangeSupported = () => {
  if (typeof document === "undefined")
    return false;
  const element = document.createElement("audio");
  return "setSinkId" in element;
};
var audioDeviceConstraints = {
  audio: {
    autoGainControl: true,
    noiseSuppression: true,
    echoCancellation: true
  }
};
var videoDeviceConstraints = {
  video: {
    width: 1280,
    height: 720
  }
};
var getAudioBrowserPermission = lazy(() => new BrowserPermission({
  constraints: audioDeviceConstraints,
  queryName: "microphone"
}));
var getVideoBrowserPermission = lazy(() => new BrowserPermission({
  constraints: videoDeviceConstraints,
  queryName: "camera"
}));
var getDeviceChangeObserver = lazy(() => {
  if (!navigator.mediaDevices.addEventListener)
    return from([]);
  return fromEvent(navigator.mediaDevices, "devicechange").pipe(map(() => void 0), debounceTime(500));
});
var getAudioDevices = lazy(() => {
  return merge(getDeviceChangeObserver(), getAudioBrowserPermission().asObservable()).pipe(startWith(void 0), concatMap(() => getDevices(getAudioBrowserPermission(), "audioinput")), shareReplay(1));
});
var getVideoDevices = lazy(() => {
  return merge(getDeviceChangeObserver(), getVideoBrowserPermission().asObservable()).pipe(startWith(void 0), concatMap(() => getDevices(getVideoBrowserPermission(), "videoinput")), shareReplay(1));
});
var getAudioOutputDevices = lazy(() => {
  return merge(getDeviceChangeObserver(), getAudioBrowserPermission().asObservable()).pipe(startWith(void 0), concatMap(() => getDevices(getAudioBrowserPermission(), "audiooutput")), shareReplay(1));
});
var getStream = async (constraints) => {
  const stream = await navigator.mediaDevices.getUserMedia(constraints);
  if (isFirefox()) {
    navigator.mediaDevices.dispatchEvent(new Event("devicechange"));
  }
  return stream;
};
function isNotFoundOrOverconstrainedError(error2) {
  if (!error2 || typeof error2 !== "object") {
    return false;
  }
  if ("name" in error2 && typeof error2.name === "string") {
    const name2 = error2.name;
    if (["OverconstrainedError", "NotFoundError"].includes(name2)) {
      return true;
    }
  }
  if ("message" in error2 && typeof error2.message === "string") {
    const message = error2.message;
    if (message.startsWith("OverconstrainedError")) {
      return true;
    }
  }
  return false;
}
var getAudioStream = async (trackConstraints) => {
  const constraints = {
    audio: {
      ...audioDeviceConstraints.audio,
      ...trackConstraints
    }
  };
  try {
    await getAudioBrowserPermission().prompt({
      throwOnNotAllowed: true,
      forcePrompt: true
    });
    return await getStream(constraints);
  } catch (error2) {
    if (isNotFoundOrOverconstrainedError(error2) && (trackConstraints == null ? void 0 : trackConstraints.deviceId)) {
      const { deviceId, ...relaxedConstraints } = trackConstraints;
      getLogger(["devices"])("warn", "Failed to get audio stream, will try again with relaxed constraints", { error: error2, constraints, relaxedConstraints });
      return getAudioStream(relaxedConstraints);
    }
    getLogger(["devices"])("error", "Failed to get audio stream", {
      error: error2,
      constraints
    });
    throw error2;
  }
};
var getVideoStream = async (trackConstraints) => {
  const constraints = {
    video: {
      ...videoDeviceConstraints.video,
      ...trackConstraints
    }
  };
  try {
    await getVideoBrowserPermission().prompt({
      throwOnNotAllowed: true,
      forcePrompt: true
    });
    return await getStream(constraints);
  } catch (error2) {
    if (isNotFoundOrOverconstrainedError(error2) && (trackConstraints == null ? void 0 : trackConstraints.deviceId)) {
      const { deviceId, ...relaxedConstraints } = trackConstraints;
      getLogger(["devices"])("warn", "Failed to get video stream, will try again with relaxed constraints", { error: error2, constraints, relaxedConstraints });
      return getVideoStream(relaxedConstraints);
    }
    getLogger(["devices"])("error", "Failed to get video stream", {
      error: error2,
      constraints
    });
    throw error2;
  }
};
var getScreenShareStream = async (options) => {
  try {
    return await navigator.mediaDevices.getDisplayMedia({
      video: true,
      audio: {
        channelCount: {
          ideal: 2
        },
        echoCancellation: false,
        autoGainControl: false,
        noiseSuppression: false
      },
      // @ts-expect-error - not present in types yet
      systemAudio: "include",
      ...options
    });
  } catch (e) {
    getLogger(["devices"])("error", "Failed to get screen share stream", e);
    throw e;
  }
};
var deviceIds$ = typeof navigator !== "undefined" && typeof navigator.mediaDevices !== "undefined" ? getDeviceChangeObserver().pipe(startWith(void 0), concatMap(() => navigator.mediaDevices.enumerateDevices()), shareReplay(1)) : void 0;
var disposeOfMediaStream = (stream) => {
  if (!stream.active)
    return;
  stream.getTracks().forEach((track) => {
    track.stop();
  });
  if (typeof stream.release === "function") {
    stream.release();
  }
};
var isMobile = () => /Mobi/i.test(navigator.userAgent);
var InputMediaDeviceManager = class {
  constructor(call, state, trackType) {
    this.call = call;
    this.state = state;
    this.trackType = trackType;
    this.stopOnLeave = true;
    this.subscriptions = [];
    this.isTrackStoppedDueToTrackEnd = false;
    this.filters = [];
    this.statusChangeConcurrencyTag = Symbol("statusChangeConcurrencyTag");
    this.filterRegistrationConcurrencyTag = Symbol("filterRegistrationConcurrencyTag");
    this.dispose = () => {
      this.subscriptions.forEach((s) => s());
    };
    this.logger = getLogger([`${TrackType[trackType].toLowerCase()} manager`]);
    if (deviceIds$ && !isReactNative() && (this.trackType === TrackType.AUDIO || this.trackType === TrackType.VIDEO)) {
      this.handleDisconnectedOrReplacedDevices();
    }
  }
  /**
   * Lists the available audio/video devices
   *
   * Note: It prompts the user for a permission to use devices (if not already granted)
   *
   * @returns an Observable that will be updated if a device is connected or disconnected
   */
  listDevices() {
    return this.getDevices();
  }
  /**
   * Returns `true` when this device is in enabled state.
   */
  get enabled() {
    return this.state.status === "enabled";
  }
  /**
   * Starts stream.
   */
  async enable() {
    this.state.prevStatus = this.state.optimisticStatus;
    if (this.state.optimisticStatus === "enabled") {
      return;
    }
    this.state.setPendingStatus("enabled");
    await withCancellation(this.statusChangeConcurrencyTag, async (signal) => {
      try {
        await this.unmuteStream();
        this.state.setStatus("enabled");
      } finally {
        if (!signal.aborted) {
          this.state.setPendingStatus(this.state.status);
        }
      }
    });
  }
  /**
   * Stops or pauses the stream based on state.disableMode
   * @param {boolean} [forceStop=false] when true, stops the tracks regardless of the state.disableMode
   */
  async disable(forceStop = false) {
    this.state.prevStatus = this.state.optimisticStatus;
    if (!forceStop && this.state.optimisticStatus === "disabled") {
      return;
    }
    this.state.setPendingStatus("disabled");
    await withCancellation(this.statusChangeConcurrencyTag, async (signal) => {
      try {
        const stopTracks = forceStop || this.state.disableMode === "stop-tracks";
        await this.muteStream(stopTracks);
        this.state.setStatus("disabled");
      } finally {
        if (!signal.aborted) {
          this.state.setPendingStatus(this.state.status);
        }
      }
    });
  }
  /**
   * Returns a promise that resolves when all pe
   */
  async statusChangeSettled() {
    await settled(this.statusChangeConcurrencyTag);
  }
  /**
   * If status was previously enabled, it will re-enable the device.
   */
  async resume() {
    if (this.state.prevStatus === "enabled" && this.state.status !== "enabled") {
      await this.enable();
    }
  }
  /**
   * If the current device status is disabled, it will enable the device,
   * else it will disable it.
   */
  async toggle() {
    if (this.state.optimisticStatus === "enabled") {
      return await this.disable();
    } else {
      return await this.enable();
    }
  }
  /**
   * Registers a filter that will be applied to the stream.
   *
   * The registered filter will get the existing stream, and it should return
   * a new stream with the applied filter.
   *
   * @param filter the filter to register.
   * @returns MediaStreamFilterRegistrationResult
   */
  registerFilter(filter2) {
    const entry = {
      start: filter2,
      stop: void 0
    };
    const registered = withoutConcurrency(this.filterRegistrationConcurrencyTag, async () => {
      this.filters.push(entry);
      await this.applySettingsToStream();
    });
    return {
      registered,
      unregister: () => withoutConcurrency(this.filterRegistrationConcurrencyTag, async () => {
        var _a;
        (_a = entry.stop) == null ? void 0 : _a.call(entry);
        this.filters = this.filters.filter((f) => f !== entry);
        await this.applySettingsToStream();
      })
    };
  }
  /**
   * Will set the default constraints for the device.
   *
   * @param constraints the constraints to set.
   */
  setDefaultConstraints(constraints) {
    this.state.setDefaultConstraints(constraints);
  }
  /**
   * Selects a device.
   *
   * Note: This method is not supported in React Native
   * @param deviceId the device id to select.
   */
  async select(deviceId) {
    if (isReactNative()) {
      throw new Error("This method is not supported in React Native. Please visit https://getstream.io/video/docs/reactnative/core/camera-and-microphone/#speaker-management for reference.");
    }
    const prevDeviceId = this.state.selectedDevice;
    if (deviceId === prevDeviceId) {
      return;
    }
    try {
      this.state.setDevice(deviceId);
      await this.applySettingsToStream();
    } catch (error2) {
      this.state.setDevice(prevDeviceId);
      throw error2;
    }
  }
  async applySettingsToStream() {
    await withCancellation(this.statusChangeConcurrencyTag, async () => {
      if (this.enabled) {
        await this.muteStream();
        await this.unmuteStream();
      }
    });
  }
  publishStream(stream) {
    return this.call.publish(stream, this.trackType);
  }
  stopPublishStream() {
    return this.call.stopPublish(this.trackType);
  }
  getTracks() {
    var _a;
    return ((_a = this.state.mediaStream) == null ? void 0 : _a.getTracks()) ?? [];
  }
  async muteStream(stopTracks = true) {
    const mediaStream = this.state.mediaStream;
    if (!mediaStream)
      return;
    this.logger("debug", `${stopTracks ? "Stopping" : "Disabling"} stream`);
    if (this.call.state.callingState === CallingState.JOINED) {
      await this.stopPublishStream();
    }
    this.muteLocalStream(stopTracks);
    const allEnded = this.getTracks().every((t2) => t2.readyState === "ended");
    if (allEnded) {
      if (typeof mediaStream.release === "function") {
        mediaStream.release();
      }
      this.state.setMediaStream(void 0, void 0);
      this.filters.forEach((entry) => {
        var _a;
        return (_a = entry.stop) == null ? void 0 : _a.call(entry);
      });
    }
  }
  disableTracks() {
    this.getTracks().forEach((track) => {
      if (track.enabled)
        track.enabled = false;
    });
  }
  enableTracks() {
    this.getTracks().forEach((track) => {
      if (!track.enabled)
        track.enabled = true;
    });
  }
  stopTracks() {
    this.getTracks().forEach((track) => {
      if (track.readyState === "live")
        track.stop();
    });
  }
  muteLocalStream(stopTracks) {
    if (!this.state.mediaStream) {
      return;
    }
    if (stopTracks) {
      this.stopTracks();
    } else {
      this.disableTracks();
    }
  }
  async unmuteStream() {
    this.logger("debug", "Starting stream");
    let stream;
    let rootStream;
    if (this.state.mediaStream && this.getTracks().every((t2) => t2.readyState === "live")) {
      stream = this.state.mediaStream;
      this.enableTracks();
    } else {
      const defaultConstraints = this.state.defaultConstraints;
      const constraints = {
        ...defaultConstraints,
        deviceId: this.state.selectedDevice ? { exact: this.state.selectedDevice } : void 0
      };
      const chainWith = (parentStream) => async (filterStream) => {
        if (!parentStream)
          return filterStream;
        const parent = await parentStream;
        filterStream.getTracks().forEach((track) => {
          const originalStop = track.stop;
          track.stop = function stop() {
            originalStop.call(track);
            parent.getTracks().forEach((parentTrack) => {
              if (parentTrack.kind === track.kind) {
                parentTrack.stop();
              }
            });
          };
        });
        parent.getTracks().forEach((parentTrack) => {
          const handleParentTrackEnded = () => {
            filterStream.getTracks().forEach((track) => {
              if (parentTrack.kind !== track.kind)
                return;
              track.stop();
              track.dispatchEvent(new Event("ended"));
            });
          };
          parentTrack.addEventListener("ended", handleParentTrackEnded);
          this.subscriptions.push(() => {
            parentTrack.removeEventListener("ended", handleParentTrackEnded);
          });
        });
        return filterStream;
      };
      rootStream = this.getStream(constraints);
      stream = await this.filters.reduce((parent, entry) => parent.then((inputStream) => {
        const { stop, output } = entry.start(inputStream);
        entry.stop = stop;
        return output;
      }).then(chainWith(parent), (error2) => {
        this.logger("warn", "Filter failed to start and will be ignored", error2);
        return parent;
      }), rootStream);
    }
    if (this.call.state.callingState === CallingState.JOINED) {
      await this.publishStream(stream);
    }
    if (this.state.mediaStream !== stream) {
      this.state.setMediaStream(stream, await rootStream);
      const handleTrackEnded = async () => {
        await this.statusChangeSettled();
        if (this.enabled) {
          this.isTrackStoppedDueToTrackEnd = true;
          setTimeout(() => {
            this.isTrackStoppedDueToTrackEnd = false;
          }, 2e3);
          await this.disable();
        }
      };
      const createTrackMuteHandler = (muted) => () => {
        if (!isMobile() || this.trackType !== TrackType.VIDEO)
          return;
        this.call.notifyTrackMuteState(muted, this.trackType).catch((err) => {
          this.logger("warn", "Error while notifying track mute state", err);
        });
      };
      stream.getTracks().forEach((track) => {
        const muteHandler = createTrackMuteHandler(true);
        const unmuteHandler = createTrackMuteHandler(false);
        track.addEventListener("mute", muteHandler);
        track.addEventListener("unmute", unmuteHandler);
        track.addEventListener("ended", handleTrackEnded);
        this.subscriptions.push(() => {
          track.removeEventListener("mute", muteHandler);
          track.removeEventListener("unmute", unmuteHandler);
          track.removeEventListener("ended", handleTrackEnded);
        });
      });
    }
  }
  get mediaDeviceKind() {
    if (this.trackType === TrackType.AUDIO) {
      return "audioinput";
    }
    if (this.trackType === TrackType.VIDEO) {
      return "videoinput";
    }
    return "";
  }
  handleDisconnectedOrReplacedDevices() {
    this.subscriptions.push(createSubscription(combineLatest([
      deviceIds$.pipe(pairwise()),
      this.state.selectedDevice$
    ]), async ([[prevDevices, currentDevices], deviceId]) => {
      try {
        if (!deviceId)
          return;
        await this.statusChangeSettled();
        let isDeviceDisconnected = false;
        let isDeviceReplaced = false;
        const currentDevice = this.findDevice(currentDevices, deviceId);
        const prevDevice = this.findDevice(prevDevices, deviceId);
        if (!currentDevice && prevDevice) {
          isDeviceDisconnected = true;
        } else if (currentDevice && prevDevice && currentDevice.deviceId === prevDevice.deviceId && currentDevice.groupId !== prevDevice.groupId) {
          isDeviceReplaced = true;
        }
        if (isDeviceDisconnected) {
          await this.disable();
          await this.select(void 0);
        }
        if (isDeviceReplaced) {
          if (this.isTrackStoppedDueToTrackEnd && this.state.status === "disabled") {
            await this.enable();
            this.isTrackStoppedDueToTrackEnd = false;
          } else {
            await this.applySettingsToStream();
          }
        }
      } catch (err) {
        this.logger("warn", "Unexpected error while handling disconnected or replaced device", err);
      }
    }));
  }
  findDevice(devices, deviceId) {
    const kind = this.mediaDeviceKind;
    return devices.find((d) => d.deviceId === deviceId && d.kind === kind);
  }
};
var InputMediaDeviceManagerState = class {
  /**
   * Constructs new InputMediaDeviceManagerState instance.
   *
   * @param disableMode the disable mode to use.
   * @param permission the BrowserPermission to use for querying.
   * `undefined` means no permission is required.
   */
  constructor(disableMode = "stop-tracks", permission) {
    this.disableMode = disableMode;
    this.statusSubject = new BehaviorSubject(void 0);
    this.optimisticStatusSubject = new BehaviorSubject(void 0);
    this.mediaStreamSubject = new BehaviorSubject(void 0);
    this.selectedDeviceSubject = new BehaviorSubject(void 0);
    this.defaultConstraintsSubject = new BehaviorSubject(void 0);
    this.mediaStream$ = this.mediaStreamSubject.asObservable();
    this.selectedDevice$ = this.selectedDeviceSubject.asObservable().pipe(distinctUntilChanged());
    this.status$ = this.statusSubject.asObservable().pipe(distinctUntilChanged());
    this.optimisticStatus$ = this.optimisticStatusSubject.asObservable().pipe(distinctUntilChanged());
    this.defaultConstraints$ = this.defaultConstraintsSubject.asObservable();
    this.getCurrentValue = getCurrentValue;
    this.setCurrentValue = setCurrentValue;
    this.hasBrowserPermission$ = permission ? permission.asObservable().pipe(shareReplay(1)) : of(true);
    this.isPromptingPermission$ = permission ? permission.getIsPromptingObservable().pipe(shareReplay(1)) : of(false);
  }
  /**
   * The device status
   */
  get status() {
    return this.getCurrentValue(this.status$);
  }
  /**
   * The requested device status. Useful for optimistic UIs
   */
  get optimisticStatus() {
    return this.getCurrentValue(this.optimisticStatus$);
  }
  /**
   * The currently selected device
   */
  get selectedDevice() {
    return this.getCurrentValue(this.selectedDevice$);
  }
  /**
   * The current media stream, or `undefined` if the device is currently disabled.
   */
  get mediaStream() {
    return this.getCurrentValue(this.mediaStream$);
  }
  /**
   * @internal
   * @param status
   */
  setStatus(status) {
    this.setCurrentValue(this.statusSubject, status);
  }
  /**
   * @internal
   * @param pendingStatus
   */
  setPendingStatus(pendingStatus) {
    this.setCurrentValue(this.optimisticStatusSubject, pendingStatus);
  }
  /**
   * Updates the `mediaStream` state variable.
   *
   * @internal
   * @param stream the stream to set.
   * @param rootStream the root stream, applicable when filters are used
   * as this is the stream that holds the actual deviceId information.
   */
  setMediaStream(stream, rootStream) {
    this.setCurrentValue(this.mediaStreamSubject, stream);
    if (rootStream) {
      this.setDevice(this.getDeviceIdFromStream(rootStream));
    }
  }
  /**
   * @internal
   * @param deviceId the device id to set.
   */
  setDevice(deviceId) {
    this.setCurrentValue(this.selectedDeviceSubject, deviceId);
  }
  /**
   * Gets the default constraints for the device.
   */
  get defaultConstraints() {
    return this.getCurrentValue(this.defaultConstraints$);
  }
  /**
   * Sets the default constraints for the device.
   *
   * @internal
   * @param constraints the constraints to set.
   */
  setDefaultConstraints(constraints) {
    this.setCurrentValue(this.defaultConstraintsSubject, constraints);
  }
};
var CameraManagerState = class extends InputMediaDeviceManagerState {
  constructor() {
    super("stop-tracks", getVideoBrowserPermission());
    this.directionSubject = new BehaviorSubject(void 0);
    this.direction$ = this.directionSubject.asObservable().pipe(distinctUntilChanged());
  }
  /**
   * The preferred camera direction
   * front - means the camera facing the user
   * back - means the camera facing the environment
   */
  get direction() {
    return this.getCurrentValue(this.direction$);
  }
  /**
   * @internal
   */
  setDirection(direction) {
    this.setCurrentValue(this.directionSubject, direction);
  }
  /**
   * @internal
   */
  setMediaStream(stream, rootStream) {
    var _a;
    super.setMediaStream(stream, rootStream);
    if (stream) {
      const direction = isReactNative() ? this.direction : ((_a = stream.getVideoTracks()[0]) == null ? void 0 : _a.getSettings().facingMode) === "environment" ? "back" : "front";
      this.setDirection(direction);
    }
  }
  getDeviceIdFromStream(stream) {
    const [track] = stream.getVideoTracks();
    return track == null ? void 0 : track.getSettings().deviceId;
  }
};
var CameraManager = class extends InputMediaDeviceManager {
  /**
   * Constructs a new CameraManager.
   *
   * @param call the call instance.
   */
  constructor(call) {
    super(call, new CameraManagerState(), TrackType.VIDEO);
    this.targetResolution = {
      width: 1280,
      height: 720
    };
  }
  isDirectionSupportedByDevice() {
    return isReactNative() || isMobile();
  }
  /**
   * Select the camera direction.
   *
   * @param direction the direction of the camera to select.
   */
  async selectDirection(direction) {
    if (this.isDirectionSupportedByDevice()) {
      if (isReactNative()) {
        const videoTrack = this.getTracks()[0];
        if (!videoTrack) {
          this.logger("warn", "No video track found to do direction selection");
          return;
        }
        await videoTrack.applyConstraints({
          facingMode: direction === "front" ? "user" : "environment"
        });
        this.state.setDirection(direction);
        this.state.setDevice(void 0);
      } else {
        this.state.setDirection(direction);
        this.state.setDevice(void 0);
        this.getTracks().forEach((track) => {
          track.stop();
        });
        await this.unmuteStream();
      }
    } else {
      this.logger("warn", "Camera direction ignored for desktop devices");
    }
  }
  /**
   * Flips the camera direction: if it's front it will change to back, if it's back, it will change to front.
   *
   * Note: if there is no available camera with the desired direction, this method will do nothing.
   * @returns
   */
  async flip() {
    const newDirection = this.state.direction === "front" ? "back" : "front";
    await this.selectDirection(newDirection);
  }
  /**
   * @internal
   */
  async selectTargetResolution(resolution) {
    this.targetResolution.height = resolution.height;
    this.targetResolution.width = resolution.width;
    if (this.state.optimisticStatus === "enabled") {
      try {
        await this.statusChangeSettled();
      } catch (error2) {
        this.logger("warn", "could not apply target resolution", error2);
      }
    }
    if (this.enabled && this.state.mediaStream) {
      const [videoTrack] = this.state.mediaStream.getVideoTracks();
      if (!videoTrack)
        return;
      const { width, height } = videoTrack.getSettings();
      if (width !== this.targetResolution.width || height !== this.targetResolution.height) {
        await this.applySettingsToStream();
        this.logger("debug", `${width}x${height} target resolution applied to media stream`);
      }
    }
  }
  /**
   * Applies the video settings to the camera.
   *
   * @param settings the video settings to apply.
   * @param publish whether to publish the stream after applying the settings.
   */
  async apply(settings, publish2) {
    var _a;
    const hasPublishedVideo = !!((_a = this.call.state.localParticipant) == null ? void 0 : _a.videoStream);
    const hasPermission = this.call.permissionsContext.hasPermission(OwnCapability.SEND_AUDIO);
    if (hasPublishedVideo || !hasPermission)
      return;
    await this.statusChangeSettled();
    const { target_resolution, camera_facing, camera_default_on } = settings;
    await this.selectTargetResolution(target_resolution);
    if (!this.state.direction && !this.state.selectedDevice) {
      this.state.setDirection(camera_facing === "front" ? "front" : "back");
    }
    if (!publish2)
      return;
    const { mediaStream } = this.state;
    if (this.enabled && mediaStream) {
      await this.publishStream(mediaStream);
    } else if (this.state.status === void 0 && camera_default_on) {
      await this.enable();
    }
  }
  getDevices() {
    return getVideoDevices();
  }
  getStream(constraints) {
    constraints.width = this.targetResolution.width;
    constraints.height = this.targetResolution.height;
    if (!constraints.deviceId && this.state.direction && this.isDirectionSupportedByDevice()) {
      constraints.facingMode = this.state.direction === "front" ? "user" : "environment";
    }
    return getVideoStream(constraints);
  }
};
var MicrophoneManagerState = class extends InputMediaDeviceManagerState {
  constructor(disableMode) {
    super(disableMode, getAudioBrowserPermission());
    this.speakingWhileMutedSubject = new BehaviorSubject(false);
    this.speakingWhileMuted$ = this.speakingWhileMutedSubject.asObservable().pipe(distinctUntilChanged());
  }
  /**
   * `true` if the user's microphone is muted but they'are speaking.
   *
   * This feature is not available in the React Native SDK.
   */
  get speakingWhileMuted() {
    return this.getCurrentValue(this.speakingWhileMuted$);
  }
  /**
   * @internal
   */
  setSpeakingWhileMuted(isSpeaking) {
    this.setCurrentValue(this.speakingWhileMutedSubject, isSpeaking);
  }
  getDeviceIdFromStream(stream) {
    const [track] = stream.getAudioTracks();
    return track == null ? void 0 : track.getSettings().deviceId;
  }
};
var DETECTION_FREQUENCY_IN_MS = 500;
var AUDIO_LEVEL_THRESHOLD = 150;
var FFT_SIZE = 128;
var createSoundDetector = (audioStream, onSoundDetectedStateChanged, options = {}) => {
  const { detectionFrequencyInMs = DETECTION_FREQUENCY_IN_MS, audioLevelThreshold = AUDIO_LEVEL_THRESHOLD, fftSize = FFT_SIZE, destroyStreamOnStop = true } = options;
  const audioContext = new AudioContext();
  const analyser = audioContext.createAnalyser();
  analyser.fftSize = fftSize;
  const microphone = audioContext.createMediaStreamSource(audioStream);
  microphone.connect(analyser);
  const intervalId = setInterval(() => {
    var _a;
    const data = new Uint8Array(analyser.frequencyBinCount);
    analyser.getByteFrequencyData(data);
    const isSoundDetected = data.some((value) => value >= audioLevelThreshold);
    const averagedDataValue = data.reduce((pv, cv) => pv + cv, 0) / data.length;
    const percentage = averagedDataValue > audioLevelThreshold ? 100 : Math.round(averagedDataValue / audioLevelThreshold * 100);
    if ((_a = audioStream.getAudioTracks()[0]) == null ? void 0 : _a.enabled) {
      onSoundDetectedStateChanged({ isSoundDetected, audioLevel: percentage });
    } else {
      onSoundDetectedStateChanged({ isSoundDetected: false, audioLevel: 0 });
    }
  }, detectionFrequencyInMs);
  return async function stop() {
    clearInterval(intervalId);
    microphone.disconnect();
    analyser.disconnect();
    if (audioContext.state !== "closed") {
      await audioContext.close();
    }
    if (destroyStreamOnStop) {
      audioStream.getTracks().forEach((track) => {
        track.stop();
        audioStream.removeTrack(track);
      });
    }
  };
};
var RNSpeechDetector = class {
  constructor() {
    this.pc1 = new RTCPeerConnection({});
    this.pc2 = new RTCPeerConnection({});
  }
  /**
   * Starts the speech detection.
   */
  async start(onSoundDetectedStateChanged) {
    try {
      this.cleanupAudioStream();
      const audioStream = await navigator.mediaDevices.getUserMedia({
        audio: true
      });
      this.audioStream = audioStream;
      this.pc1.addEventListener("icecandidate", async (e) => {
        await this.pc2.addIceCandidate(e.candidate);
      });
      this.pc2.addEventListener("icecandidate", async (e) => {
        await this.pc1.addIceCandidate(e.candidate);
      });
      this.pc2.addEventListener("track", (e) => {
        e.streams[0].getTracks().forEach((track) => {
          track._setVolume(0);
        });
      });
      audioStream.getTracks().forEach((track) => this.pc1.addTrack(track, audioStream));
      const offer = await this.pc1.createOffer({});
      await this.pc2.setRemoteDescription(offer);
      await this.pc1.setLocalDescription(offer);
      const answer = await this.pc2.createAnswer();
      await this.pc1.setRemoteDescription(answer);
      await this.pc2.setLocalDescription(answer);
      const unsub = this.onSpeakingDetectedStateChange(onSoundDetectedStateChanged);
      return () => {
        unsub();
        this.stop();
      };
    } catch (error2) {
      const logger2 = getLogger(["RNSpeechDetector"]);
      logger2("error", "error handling permissions: ", error2);
      return () => {
      };
    }
  }
  /**
   * Stops the speech detection and releases all allocated resources.
   */
  stop() {
    this.pc1.close();
    this.pc2.close();
    this.cleanupAudioStream();
  }
  /**
   * Public method that detects the audio levels and returns the status.
   */
  onSpeakingDetectedStateChange(onSoundDetectedStateChanged) {
    const initialBaselineNoiseLevel = 0.13;
    let baselineNoiseLevel = initialBaselineNoiseLevel;
    let speechDetected = false;
    let speechTimer;
    let silenceTimer;
    const audioLevelHistory = [];
    const historyLength = 10;
    const silenceThreshold = 1.1;
    const resetThreshold = 0.9;
    const speechTimeout = 500;
    const silenceTimeout = 5e3;
    const checkAudioLevel = async () => {
      try {
        const stats = await this.pc1.getStats();
        const report = flatten(stats);
        const audioMediaSourceStats = report.find((stat) => stat.type === "media-source" && stat.kind === "audio");
        if (audioMediaSourceStats) {
          const { audioLevel } = audioMediaSourceStats;
          if (audioLevel) {
            audioLevelHistory.push(audioLevel);
            if (audioLevelHistory.length > historyLength) {
              audioLevelHistory.shift();
            }
            const avgAudioLevel = audioLevelHistory.reduce((a, b) => a + b, 0) / audioLevelHistory.length;
            if (avgAudioLevel < baselineNoiseLevel * silenceThreshold) {
              if (!silenceTimer) {
                silenceTimer = setTimeout(() => {
                  baselineNoiseLevel = Math.min(avgAudioLevel * resetThreshold, initialBaselineNoiseLevel);
                }, silenceTimeout);
              }
            } else {
              clearTimeout(silenceTimer);
              silenceTimer = void 0;
            }
            if (avgAudioLevel > baselineNoiseLevel * 1.5) {
              if (!speechDetected) {
                speechDetected = true;
                onSoundDetectedStateChanged({
                  isSoundDetected: true,
                  audioLevel
                });
              }
              clearTimeout(speechTimer);
              speechTimer = setTimeout(() => {
                speechDetected = false;
                onSoundDetectedStateChanged({
                  isSoundDetected: false,
                  audioLevel: 0
                });
              }, speechTimeout);
            }
          }
        }
      } catch (error2) {
        const logger2 = getLogger(["RNSpeechDetector"]);
        logger2("error", "error checking audio level from stats", error2);
      }
    };
    const intervalId = setInterval(checkAudioLevel, 100);
    return () => {
      clearInterval(intervalId);
      clearTimeout(speechTimer);
      clearTimeout(silenceTimer);
    };
  }
  cleanupAudioStream() {
    if (!this.audioStream) {
      return;
    }
    this.audioStream.getTracks().forEach((track) => track.stop());
    if (
      // @ts-expect-error release() is present in react-native-webrtc
      typeof this.audioStream.release === "function"
    ) {
      this.audioStream.release();
    }
  }
};
var MicrophoneManager = class extends InputMediaDeviceManager {
  constructor(call, disableMode = "stop-tracks") {
    super(call, new MicrophoneManagerState(disableMode), TrackType.AUDIO);
    this.speakingWhileMutedNotificationEnabled = true;
    this.soundDetectorConcurrencyTag = Symbol("soundDetectorConcurrencyTag");
    this.subscriptions.push(createSafeAsyncSubscription(combineLatest([
      this.call.state.callingState$,
      this.call.state.ownCapabilities$,
      this.state.selectedDevice$,
      this.state.status$
    ]), async ([callingState, ownCapabilities, deviceId, status]) => {
      try {
        if (callingState === CallingState.LEFT) {
          await this.stopSpeakingWhileMutedDetection();
        }
        if (callingState !== CallingState.JOINED)
          return;
        if (!this.speakingWhileMutedNotificationEnabled)
          return;
        if (ownCapabilities.includes(OwnCapability.SEND_AUDIO)) {
          if (status === "disabled") {
            await this.startSpeakingWhileMutedDetection(deviceId);
          } else {
            await this.stopSpeakingWhileMutedDetection();
          }
        } else {
          await this.stopSpeakingWhileMutedDetection();
        }
      } catch (err) {
        this.logger("warn", "Could not enable speaking while muted", err);
      }
    }));
    this.subscriptions.push(createSubscription(this.call.state.callingState$, (callingState) => {
      var _a, _b;
      if (!this.noiseCancellationRegistration || !this.noiseCancellation)
        return;
      const autoOn = ((_b = (_a = this.call.state.settings) == null ? void 0 : _a.audio.noise_cancellation) == null ? void 0 : _b.mode) === NoiseCancellationSettingsModeEnum.AUTO_ON;
      if (autoOn && callingState === CallingState.JOINED) {
        this.noiseCancellationRegistration.then(() => {
          var _a2;
          return (_a2 = this.noiseCancellation) == null ? void 0 : _a2.enable();
        }).catch((err) => {
          this.logger("warn", `Failed to enable noise cancellation`, err);
          return this.call.notifyNoiseCancellationStopped();
        });
      } else if (callingState === CallingState.LEFT) {
        this.noiseCancellationRegistration.then(() => {
          var _a2;
          return (_a2 = this.noiseCancellation) == null ? void 0 : _a2.disable();
        }).catch((err) => {
          this.logger("warn", `Failed to disable noise cancellation`, err);
        });
      }
    }));
  }
  /**
   * Enables noise cancellation for the microphone.
   *
   * Note: not supported in React Native.
   * @param noiseCancellation - a noise cancellation instance to use.
   */
  async enableNoiseCancellation(noiseCancellation) {
    if (isReactNative()) {
      throw new Error("Noise cancellation is not supported in React Native");
    }
    const { ownCapabilities, settings } = this.call.state;
    const hasNoiseCancellationCapability = ownCapabilities.includes(OwnCapability.ENABLE_NOISE_CANCELLATION);
    if (!hasNoiseCancellationCapability) {
      throw new Error("Noise cancellation is not available.");
    }
    const noiseCancellationSettings = settings == null ? void 0 : settings.audio.noise_cancellation;
    if (!noiseCancellationSettings || noiseCancellationSettings.mode === NoiseCancellationSettingsModeEnum.DISABLED) {
      throw new Error("Noise cancellation is disabled for this call type.");
    }
    try {
      this.noiseCancellation = noiseCancellation;
      this.noiseCancellationChangeUnsubscribe = this.noiseCancellation.on("change", (enabled) => {
        if (enabled) {
          this.call.notifyNoiseCancellationStarting().catch((err) => {
            this.logger("warn", `notifyNoiseCancellationStart failed`, err);
          });
        } else {
          this.call.notifyNoiseCancellationStopped().catch((err) => {
            this.logger("warn", `notifyNoiseCancellationStop failed`, err);
          });
        }
      });
      const registrationResult = this.registerFilter(noiseCancellation.toFilter());
      this.noiseCancellationRegistration = registrationResult.registered;
      this.unregisterNoiseCancellation = registrationResult.unregister;
      await this.noiseCancellationRegistration;
      if (noiseCancellationSettings.mode === NoiseCancellationSettingsModeEnum.AUTO_ON && this.call.state.callingState === CallingState.JOINED) {
        noiseCancellation.enable();
      }
    } catch (e) {
      this.logger("warn", "Failed to enable noise cancellation", e);
      await this.disableNoiseCancellation().catch((err) => {
        this.logger("warn", "Failed to disable noise cancellation", err);
      });
    }
  }
  /**
   * Disables noise cancellation for the microphone.
   *
   * Note: not supported in React Native.
   */
  async disableNoiseCancellation() {
    var _a;
    if (isReactNative()) {
      throw new Error("Noise cancellation is not supported in React Native");
    }
    await (((_a = this.unregisterNoiseCancellation) == null ? void 0 : _a.call(this)) ?? Promise.resolve()).then(() => {
      var _a2;
      return (_a2 = this.noiseCancellation) == null ? void 0 : _a2.disable();
    }).then(() => {
      var _a2;
      return (_a2 = this.noiseCancellationChangeUnsubscribe) == null ? void 0 : _a2.call(this);
    }).catch((err) => {
      this.logger("warn", "Failed to unregister noise cancellation", err);
    });
    await this.call.notifyNoiseCancellationStopped();
  }
  /**
   * Enables speaking while muted notification.
   */
  async enableSpeakingWhileMutedNotification() {
    this.speakingWhileMutedNotificationEnabled = true;
    if (this.state.status === "disabled") {
      await this.startSpeakingWhileMutedDetection(this.state.selectedDevice);
    }
  }
  /**
   * Disables speaking while muted notification.
   */
  async disableSpeakingWhileMutedNotification() {
    this.speakingWhileMutedNotificationEnabled = false;
    await this.stopSpeakingWhileMutedDetection();
  }
  /**
   * Applies the audio settings to the microphone.
   * @param settings the audio settings to apply.
   * @param publish whether to publish the stream after applying the settings.
   */
  async apply(settings, publish2) {
    var _a;
    if (!publish2)
      return;
    const hasPublishedAudio = !!((_a = this.call.state.localParticipant) == null ? void 0 : _a.audioStream);
    const hasPermission = this.call.permissionsContext.hasPermission(OwnCapability.SEND_AUDIO);
    if (hasPublishedAudio || !hasPermission)
      return;
    await this.statusChangeSettled();
    const { mediaStream } = this.state;
    if (this.enabled && mediaStream) {
      await this.publishStream(mediaStream);
    } else if (this.state.status === void 0 && settings.mic_default_on) {
      await this.enable();
    }
  }
  getDevices() {
    return getAudioDevices();
  }
  getStream(constraints) {
    return getAudioStream(constraints);
  }
  async startSpeakingWhileMutedDetection(deviceId) {
    await withoutConcurrency(this.soundDetectorConcurrencyTag, async () => {
      await this.stopSpeakingWhileMutedDetection();
      if (isReactNative()) {
        this.rnSpeechDetector = new RNSpeechDetector();
        const unsubscribe = await this.rnSpeechDetector.start((event) => {
          this.state.setSpeakingWhileMuted(event.isSoundDetected);
        });
        this.soundDetectorCleanup = () => {
          unsubscribe();
          this.rnSpeechDetector = void 0;
        };
      } else {
        const stream = await this.getStream({
          deviceId: { exact: deviceId }
        });
        this.soundDetectorCleanup = createSoundDetector(stream, (event) => {
          this.state.setSpeakingWhileMuted(event.isSoundDetected);
        });
      }
    });
  }
  async stopSpeakingWhileMutedDetection() {
    await withoutConcurrency(this.soundDetectorConcurrencyTag, async () => {
      if (!this.soundDetectorCleanup)
        return;
      const soundDetectorCleanup = this.soundDetectorCleanup;
      this.soundDetectorCleanup = void 0;
      this.state.setSpeakingWhileMuted(false);
      await soundDetectorCleanup();
    });
  }
};
var ScreenShareState = class extends InputMediaDeviceManagerState {
  constructor() {
    super(...arguments);
    this.audioEnabledSubject = new BehaviorSubject(true);
    this.settingsSubject = new BehaviorSubject(void 0);
    this.audioEnabled$ = this.audioEnabledSubject.asObservable().pipe(distinctUntilChanged());
    this.settings$ = this.settingsSubject.asObservable();
    this.getDeviceIdFromStream = (stream) => {
      const [track] = stream.getTracks();
      return track == null ? void 0 : track.getSettings().deviceId;
    };
  }
  /**
   * The current screen share audio status.
   */
  get audioEnabled() {
    return this.getCurrentValue(this.audioEnabled$);
  }
  /**
   * Set the current screen share audio status.
   */
  setAudioEnabled(isEnabled) {
    this.setCurrentValue(this.audioEnabledSubject, isEnabled);
  }
  /**
   * The current screen share settings.
   */
  get settings() {
    return this.getCurrentValue(this.settings$);
  }
  /**
   * Set the current screen share settings.
   *
   * @param settings the screen share settings to set.
   */
  setSettings(settings) {
    this.setCurrentValue(this.settingsSubject, settings);
  }
};
var ScreenShareManager = class extends InputMediaDeviceManager {
  constructor(call) {
    super(call, new ScreenShareState(), TrackType.SCREEN_SHARE);
    this.subscriptions.push(createSubscription(call.state.settings$, (settings) => {
      const maybeTargetResolution = settings == null ? void 0 : settings.screensharing.target_resolution;
      if (maybeTargetResolution) {
        this.setDefaultConstraints({
          video: {
            width: maybeTargetResolution.width,
            height: maybeTargetResolution.height
          }
        });
      }
    }));
  }
  /**
   * Will enable screen share audio options on supported platforms.
   *
   * Note: for ongoing screen share, audio won't be enabled until you
   * re-publish the screen share stream.
   */
  enableScreenShareAudio() {
    this.state.setAudioEnabled(true);
  }
  /**
   * Will disable screen share audio options on supported platforms.
   */
  async disableScreenShareAudio() {
    var _a;
    this.state.setAudioEnabled(false);
    if ((_a = this.call.publisher) == null ? void 0 : _a.isPublishing(TrackType.SCREEN_SHARE_AUDIO)) {
      await this.call.stopPublish(TrackType.SCREEN_SHARE_AUDIO);
    }
  }
  /**
   * Returns the current screen share settings.
   */
  getSettings() {
    return this.state.settings;
  }
  /**
   * Sets the current screen share settings.
   *
   * @param settings the settings to set.
   */
  setSettings(settings) {
    this.state.setSettings(settings);
  }
  getDevices() {
    return of([]);
  }
  getStream(constraints) {
    if (!this.state.audioEnabled) {
      constraints.audio = false;
    }
    return getScreenShareStream(constraints);
  }
  async stopPublishStream() {
    return this.call.stopPublish(TrackType.SCREEN_SHARE, TrackType.SCREEN_SHARE_AUDIO);
  }
  /**
   * Overrides the default `select` method to throw an error.
   */
  async select() {
    throw new Error("This method is not supported in for Screen Share");
  }
};
var SpeakerState = class {
  constructor() {
    this.selectedDeviceSubject = new BehaviorSubject("");
    this.volumeSubject = new BehaviorSubject(1);
    this.isDeviceSelectionSupported = checkIfAudioOutputChangeSupported();
    this.getCurrentValue = getCurrentValue;
    this.setCurrentValue = setCurrentValue;
    this.selectedDevice$ = this.selectedDeviceSubject.asObservable().pipe(distinctUntilChanged());
    this.volume$ = this.volumeSubject.asObservable().pipe(distinctUntilChanged());
  }
  /**
   * The currently selected device
   *
   * Note: this feature is not supported in React Native
   */
  get selectedDevice() {
    return this.getCurrentValue(this.selectedDevice$);
  }
  /**
   * The currently selected volume
   *
   * Note: this feature is not supported in React Native
   */
  get volume() {
    return this.getCurrentValue(this.volume$);
  }
  /**
   * @internal
   * @param deviceId
   */
  setDevice(deviceId) {
    this.setCurrentValue(this.selectedDeviceSubject, deviceId);
  }
  /**
   * @internal
   * @param volume
   */
  setVolume(volume) {
    this.setCurrentValue(this.volumeSubject, volume);
  }
};
var SpeakerManager = class {
  constructor(call) {
    this.state = new SpeakerState();
    this.subscriptions = [];
    this.dispose = () => {
      this.subscriptions.forEach((s) => s.unsubscribe());
    };
    this.call = call;
    if (deviceIds$ && !isReactNative()) {
      this.subscriptions.push(combineLatest([deviceIds$, this.state.selectedDevice$]).subscribe(([devices, deviceId]) => {
        if (!deviceId) {
          return;
        }
        const device = devices.find((d) => d.deviceId === deviceId && d.kind === "audiooutput");
        if (!device) {
          this.select("");
        }
      }));
    }
  }
  /**
   * Lists the available audio output devices
   *
   * Note: It prompts the user for a permission to use devices (if not already granted)
   * Note: This method is not supported in React Native
   *
   * @returns an Observable that will be updated if a device is connected or disconnected
   */
  listDevices() {
    if (isReactNative()) {
      throw new Error("This feature is not supported in React Native. Please visit https://getstream.io/video/docs/reactnative/core/camera-and-microphone/#speaker-management for more details");
    }
    return getAudioOutputDevices();
  }
  /**
   * Select a device.
   *
   * Note: This method is not supported in React Native
   *
   * @param deviceId empty string means the system default
   */
  select(deviceId) {
    if (isReactNative()) {
      throw new Error("This feature is not supported in React Native. Please visit https://getstream.io/video/docs/reactnative/core/camera-and-microphone/#speaker-management for more details");
    }
    this.state.setDevice(deviceId);
  }
  /**
   * Set the volume of the audio elements
   * @param volume a number between 0 and 1.
   *
   * Note: This method is not supported in React Native
   */
  setVolume(volume) {
    if (isReactNative()) {
      throw new Error("This feature is not supported in React Native. Please visit https://getstream.io/video/docs/reactnative/core/camera-and-microphone/#speaker-management for more details");
    }
    if (volume && (volume < 0 || volume > 1)) {
      throw new Error("Volume must be between 0 and 1");
    }
    this.state.setVolume(volume);
  }
  /**
   * Set the volume of a participant.
   *
   * Note: This method is not supported in React Native.
   *
   * @param sessionId the participant's session id.
   * @param volume a number between 0 and 1. Set it to `undefined` to use the default volume.
   */
  setParticipantVolume(sessionId, volume) {
    if (isReactNative()) {
      throw new Error("This feature is not supported in React Native. Please visit https://getstream.io/video/docs/reactnative/core/camera-and-microphone/#speaker-management for more details");
    }
    if (volume && (volume < 0 || volume > 1)) {
      throw new Error("Volume must be between 0 and 1, or undefined");
    }
    this.call.state.updateParticipant(sessionId, { audioVolume: volume });
  }
};
var Call = class {
  /**
   * Constructs a new `Call` instance.
   *
   * NOTE: Don't call the constructor directly, instead
   * Use the [`StreamVideoClient.call`](./StreamVideoClient.md/#call)
   * method to construct a `Call` instance.
   */
  constructor({ type, id, streamClient, members, ownCapabilities, sortParticipantsBy, clientStore, ringing = false, watching = false }) {
    this.state = new CallState();
    this.permissionsContext = new PermissionsContext();
    this.dispatcher = new Dispatcher();
    this.sfuClientTag = 0;
    this.reconnectConcurrencyTag = Symbol("reconnectConcurrencyTag");
    this.reconnectAttempts = 0;
    this.reconnectStrategy = WebsocketReconnectStrategy.UNSPECIFIED;
    this.reconnectReason = "";
    this.fastReconnectDeadlineSeconds = 0;
    this.disconnectionTimeoutSeconds = 0;
    this.lastOfflineTimestamp = 0;
    this.trackPublishOrder = [];
    this.hasJoinedOnce = false;
    this.deviceSettingsAppliedOnce = false;
    this.initialized = false;
    this.joinLeaveConcurrencyTag = Symbol("joinLeaveConcurrencyTag");
    this.leaveCallHooks = /* @__PURE__ */ new Set();
    this.streamClientEventHandlers = /* @__PURE__ */ new Map();
    this.setup = async () => {
      await withoutConcurrency(this.joinLeaveConcurrencyTag, async () => {
        if (this.initialized)
          return;
        this.leaveCallHooks.add(this.on("all", (event) => {
          this.state.updateFromEvent(event);
        }));
        this.leaveCallHooks.add(this.on("changePublishOptions", (event) => {
          this.currentPublishOptions = event.publishOptions;
        }));
        this.leaveCallHooks.add(registerEventHandlers(this, this.dispatcher));
        this.registerEffects();
        this.registerReconnectHandlers();
        if (this.state.callingState === CallingState.LEFT) {
          this.state.setCallingState(CallingState.IDLE);
        }
        this.initialized = true;
      });
    };
    this.registerEffects = () => {
      this.leaveCallHooks.add(
        // handles updating the permissions context when the settings change.
        createSubscription(this.state.settings$, (settings) => {
          if (!settings)
            return;
          this.permissionsContext.setCallSettings(settings);
        })
      );
      this.leaveCallHooks.add(
        // handle the case when the user permissions are modified.
        createSafeAsyncSubscription(this.state.ownCapabilities$, this.handleOwnCapabilitiesUpdated)
      );
      this.leaveCallHooks.add(
        // handles the case when the user is blocked by the call owner.
        createSubscription(this.state.blockedUserIds$, async (blockedUserIds) => {
          if (!blockedUserIds || blockedUserIds.length === 0)
            return;
          const currentUserId = this.currentUserId;
          if (currentUserId && blockedUserIds.includes(currentUserId)) {
            this.logger("info", "Leaving call because of being blocked");
            await this.leave({ reason: "user blocked" }).catch((err) => {
              this.logger("error", "Error leaving call after being blocked", err);
            });
          }
        })
      );
      this.leaveCallHooks.add(
        // cancel auto-drop when call is accepted or rejected
        createSubscription(this.state.session$, (session) => {
          var _a;
          if (!this.ringing)
            return;
          const receiverId = (_a = this.clientStore.connectedUser) == null ? void 0 : _a.id;
          if (!receiverId)
            return;
          const isAcceptedByMe = Boolean(session == null ? void 0 : session.accepted_by[receiverId]);
          const isRejectedByMe = Boolean(session == null ? void 0 : session.rejected_by[receiverId]);
          if (isAcceptedByMe || isRejectedByMe) {
            this.cancelAutoDrop();
          }
          const isAcceptedElsewhere = isAcceptedByMe && this.state.callingState === CallingState.RINGING;
          if ((isAcceptedElsewhere || isRejectedByMe) && !hasPending(this.joinLeaveConcurrencyTag)) {
            this.leave().catch(() => {
              this.logger("error", "Could not leave a call that was accepted or rejected elsewhere");
            });
          }
        })
      );
      this.leaveCallHooks.add(
        // "ringing" mode effects and event handlers
        createSubscription(this.ringingSubject, (isRinging) => {
          var _a, _b;
          if (!isRinging)
            return;
          const callSession = this.state.session;
          const receiver_id = (_a = this.clientStore.connectedUser) == null ? void 0 : _a.id;
          const ended_at = callSession == null ? void 0 : callSession.ended_at;
          const created_by_id = (_b = this.state.createdBy) == null ? void 0 : _b.id;
          const rejected_by = callSession == null ? void 0 : callSession.rejected_by;
          const accepted_by = callSession == null ? void 0 : callSession.accepted_by;
          let leaveCallIdle = false;
          if (ended_at) {
            leaveCallIdle = true;
          } else if (created_by_id && rejected_by) {
            if (rejected_by[created_by_id]) {
              leaveCallIdle = true;
            }
          } else if (receiver_id && rejected_by) {
            if (rejected_by[receiver_id]) {
              leaveCallIdle = true;
            }
          } else if (receiver_id && accepted_by) {
            if (accepted_by[receiver_id]) {
              leaveCallIdle = true;
            }
          }
          if (leaveCallIdle) {
            if (this.state.callingState !== CallingState.IDLE) {
              this.state.setCallingState(CallingState.IDLE);
            }
          } else {
            if (this.state.callingState === CallingState.IDLE) {
              this.state.setCallingState(CallingState.RINGING);
            }
            this.scheduleAutoDrop();
            this.leaveCallHooks.add(registerRingingCallEventHandlers(this));
          }
        })
      );
    };
    this.handleOwnCapabilitiesUpdated = async (ownCapabilities2) => {
      this.permissionsContext.setPermissions(ownCapabilities2);
      if (!this.publisher)
        return;
      const permissionToTrackType = {
        [OwnCapability.SEND_AUDIO]: TrackType.AUDIO,
        [OwnCapability.SEND_VIDEO]: TrackType.VIDEO,
        [OwnCapability.SCREENSHARE]: TrackType.SCREEN_SHARE
      };
      for (const [permission, trackType] of Object.entries(permissionToTrackType)) {
        const hasPermission = this.permissionsContext.hasPermission(permission);
        if (hasPermission)
          continue;
        try {
          switch (trackType) {
            case TrackType.AUDIO:
              if (this.microphone.enabled)
                await this.microphone.disable();
              break;
            case TrackType.VIDEO:
              if (this.camera.enabled)
                await this.camera.disable();
              break;
            case TrackType.SCREEN_SHARE:
              if (this.screenShare.enabled)
                await this.screenShare.disable();
              break;
          }
        } catch (err) {
          this.logger("error", `Can't disable mic/camera/screenshare after revoked permissions`, err);
        }
      }
    };
    this.on = (eventName, fn) => {
      if (isSfuEvent(eventName)) {
        return this.dispatcher.on(eventName, fn);
      }
      const offHandler = this.streamClient.on(eventName, (e) => {
        const event = e;
        if (event.call_cid && event.call_cid === this.cid) {
          fn(event);
        }
      });
      this.streamClientEventHandlers.set(fn, offHandler);
      return () => {
        this.off(eventName, fn);
      };
    };
    this.off = (eventName, fn) => {
      if (isSfuEvent(eventName)) {
        return this.dispatcher.off(eventName, fn);
      }
      const registeredOffHandler = this.streamClientEventHandlers.get(fn);
      if (registeredOffHandler) {
        registeredOffHandler();
      }
    };
    this.leave = async ({ reject, reason = "user is leaving the call" } = {}) => {
      await withoutConcurrency(this.joinLeaveConcurrencyTag, async () => {
        var _a, _b, _c, _d, _e;
        const callingState = this.state.callingState;
        if (callingState === CallingState.LEFT) {
          throw new Error("Cannot leave call that has already been left.");
        }
        if (callingState === CallingState.JOINING) {
          const waitUntilCallJoined = () => {
            return new Promise((resolve) => {
              this.state.callingState$.pipe(takeWhile((state) => state !== CallingState.JOINED, true)).subscribe(() => resolve());
            });
          };
          await waitUntilCallJoined();
        }
        if (callingState === CallingState.RINGING && reject !== false) {
          if (reject) {
            await this.reject("decline");
          } else {
            const hasOtherParticipants = this.state.remoteParticipants.length > 0;
            if (this.isCreatedByMe && !hasOtherParticipants) {
              await this.reject("cancel");
            }
          }
        }
        (_a = this.statsReporter) == null ? void 0 : _a.stop();
        this.statsReporter = void 0;
        (_b = this.sfuStatsReporter) == null ? void 0 : _b.stop();
        this.sfuStatsReporter = void 0;
        (_c = this.subscriber) == null ? void 0 : _c.dispose();
        this.subscriber = void 0;
        (_d = this.publisher) == null ? void 0 : _d.dispose();
        this.publisher = void 0;
        await ((_e = this.sfuClient) == null ? void 0 : _e.leaveAndClose(reason));
        this.sfuClient = void 0;
        this.dynascaleManager.setSfuClient(void 0);
        this.state.setCallingState(CallingState.LEFT);
        this.state.setParticipants([]);
        this.state.dispose();
        this.leaveCallHooks.forEach((hook) => hook());
        this.initialized = false;
        this.hasJoinedOnce = false;
        this.ringingSubject.next(false);
        this.cancelAutoDrop();
        this.clientStore.unregisterCall(this);
        this.camera.dispose();
        this.microphone.dispose();
        this.screenShare.dispose();
        this.speaker.dispose();
        const stopOnLeavePromises = [];
        if (this.camera.stopOnLeave) {
          stopOnLeavePromises.push(this.camera.disable(true));
        }
        if (this.microphone.stopOnLeave) {
          stopOnLeavePromises.push(this.microphone.disable(true));
        }
        if (this.screenShare.stopOnLeave) {
          stopOnLeavePromises.push(this.screenShare.disable(true));
        }
        await Promise.all(stopOnLeavePromises);
      });
    };
    this.updateFromRingingEvent = async (event) => {
      await this.setup();
      const { created_by, settings } = event.call;
      const creator = this.state.members.find((m) => m.user.id === created_by.id);
      if (!creator) {
        this.state.setMembers(event.members);
      } else {
        this.state.setMembers([creator, ...event.members]);
      }
      this.state.updateFromCallResponse(event.call);
      this.watching = true;
      this.ringingSubject.next(true);
      const calls = this.clientStore.calls.filter((c) => c.cid !== this.cid);
      this.clientStore.setCalls([this, ...calls]);
      await this.applyDeviceConfig(settings, false);
    };
    this.get = async (params) => {
      await this.setup();
      const response = await this.streamClient.get(this.streamClientBasePath, params);
      this.state.updateFromCallResponse(response.call);
      this.state.setMembers(response.members);
      this.state.setOwnCapabilities(response.own_capabilities);
      if (params == null ? void 0 : params.ring) {
        this.ringingSubject.next(true);
      }
      if (this.streamClient._hasConnectionID()) {
        this.watching = true;
        this.clientStore.registerCall(this);
      }
      await this.applyDeviceConfig(response.call.settings, false);
      return response;
    };
    this.getOrCreate = async (data) => {
      await this.setup();
      const response = await this.streamClient.post(this.streamClientBasePath, data);
      this.state.updateFromCallResponse(response.call);
      this.state.setMembers(response.members);
      this.state.setOwnCapabilities(response.own_capabilities);
      if (data == null ? void 0 : data.ring) {
        this.ringingSubject.next(true);
      }
      if (this.streamClient._hasConnectionID()) {
        this.watching = true;
        this.clientStore.registerCall(this);
      }
      await this.applyDeviceConfig(response.call.settings, false);
      return response;
    };
    this.create = async (data) => {
      return this.getOrCreate(data);
    };
    this.delete = async (data = {}) => {
      return this.streamClient.post(`${this.streamClientBasePath}/delete`, data);
    };
    this.ring = async () => {
      return await this.get({ ring: true });
    };
    this.notify = async () => {
      return await this.get({ notify: true });
    };
    this.accept = async () => {
      return this.streamClient.post(`${this.streamClientBasePath}/accept`);
    };
    this.reject = async (reason = "decline") => {
      return this.streamClient.post(`${this.streamClientBasePath}/reject`, { reason });
    };
    this.join = async ({ maxJoinRetries = 3, ...data } = {}) => {
      await this.setup();
      const callingState = this.state.callingState;
      if ([CallingState.JOINED, CallingState.JOINING].includes(callingState)) {
        throw new Error(`Illegal State: call.join() shall be called only once`);
      }
      this.state.setCallingState(CallingState.JOINING);
      maxJoinRetries = Math.max(maxJoinRetries, 1);
      for (let attempt = 0; attempt < maxJoinRetries; attempt++) {
        try {
          this.logger("trace", `Joining call (${attempt})`, this.cid);
          return await this.doJoin(data);
        } catch (err) {
          this.logger("warn", `Failed to join call (${attempt})`, this.cid);
          if (attempt === maxJoinRetries - 1) {
            this.state.setCallingState(callingState);
            throw err;
          }
        }
        await sleep(retryInterval(attempt));
      }
    };
    this.doJoin = async (data) => {
      var _a, _b, _c, _d;
      const connectStartTime = Date.now();
      const callingState = this.state.callingState;
      this.joinCallData = data;
      this.logger("debug", "Starting join flow");
      this.state.setCallingState(CallingState.JOINING);
      const performingMigration = this.reconnectStrategy === WebsocketReconnectStrategy.MIGRATE;
      const performingRejoin = this.reconnectStrategy === WebsocketReconnectStrategy.REJOIN;
      const performingFastReconnect = this.reconnectStrategy === WebsocketReconnectStrategy.FAST;
      let statsOptions = (_a = this.sfuStatsReporter) == null ? void 0 : _a.options;
      if (!this.credentials || !statsOptions || performingRejoin || performingMigration) {
        try {
          const joinResponse = await this.doJoinRequest(data);
          this.credentials = joinResponse.credentials;
          statsOptions = joinResponse.stats_options;
        } catch (error2) {
          const avoidRestoreState = this.state.callingState === CallingState.OFFLINE;
          if (!avoidRestoreState) {
            this.state.setCallingState(callingState);
          }
          throw error2;
        }
      }
      const previousSfuClient = this.sfuClient;
      const previousSessionId = previousSfuClient == null ? void 0 : previousSfuClient.sessionId;
      const isWsHealthy = !!(previousSfuClient == null ? void 0 : previousSfuClient.isHealthy);
      const sfuClient = performingRejoin || performingMigration || !isWsHealthy ? new StreamSfuClient({
        logTag: String(++this.sfuClientTag),
        dispatcher: this.dispatcher,
        credentials: this.credentials,
        streamClient: this.streamClient,
        enableTracing: statsOptions.enable_rtc_stats,
        // a new session_id is necessary for the REJOIN strategy.
        // we use the previous session_id if available
        sessionId: performingRejoin ? void 0 : previousSessionId,
        onSignalClose: (reason) => this.handleSfuSignalClose(sfuClient, reason)
      }) : previousSfuClient;
      this.sfuClient = sfuClient;
      this.dynascaleManager.setSfuClient(sfuClient);
      const clientDetails = await getClientDetails();
      if (previousSfuClient !== sfuClient) {
        const [subscriberSdp, publisherSdp] = await Promise.all([
          getGenericSdp("recvonly"),
          getGenericSdp("sendonly")
        ]);
        const isReconnecting = this.reconnectStrategy !== WebsocketReconnectStrategy.UNSPECIFIED;
        const reconnectDetails = isReconnecting ? this.getReconnectDetails(data == null ? void 0 : data.migrating_from, previousSessionId) : void 0;
        const preferredPublishOptions = !isReconnecting ? this.getPreferredPublishOptions() : this.currentPublishOptions || [];
        const preferredSubscribeOptions = !isReconnecting ? this.getPreferredSubscribeOptions() : [];
        try {
          const { callState, fastReconnectDeadlineSeconds, publishOptions } = await sfuClient.join({
            subscriberSdp,
            publisherSdp,
            clientDetails,
            fastReconnect: performingFastReconnect,
            reconnectDetails,
            preferredPublishOptions,
            preferredSubscribeOptions
          });
          this.currentPublishOptions = publishOptions;
          this.fastReconnectDeadlineSeconds = fastReconnectDeadlineSeconds;
          if (callState) {
            this.state.updateFromSfuCallState(callState, sfuClient.sessionId, reconnectDetails);
          }
        } catch (error2) {
          this.logger("warn", "Join SFU request failed", error2);
          sfuClient.close(StreamSfuClient.ERROR_CONNECTION_UNHEALTHY, "Join request failed, connection considered unhealthy");
          this.state.setCallingState(callingState);
          throw error2;
        }
      }
      if (!performingMigration) {
        this.state.setCallingState(CallingState.JOINED);
      }
      this.hasJoinedOnce = true;
      if (performingFastReconnect) {
        await this.restoreICE(sfuClient, { includeSubscriber: false });
      } else {
        const connectionConfig = toRtcConfiguration(this.credentials.ice_servers);
        this.initPublisherAndSubscriber({
          sfuClient,
          connectionConfig,
          clientDetails,
          statsOptions,
          publishOptions: this.currentPublishOptions || [],
          closePreviousInstances: !performingMigration
        });
      }
      if (!performingRejoin && !performingFastReconnect && !performingMigration) {
        (_b = this.sfuStatsReporter) == null ? void 0 : _b.sendConnectionTime((Date.now() - connectStartTime) / 1e3);
      }
      if (performingRejoin) {
        const strategy = WebsocketReconnectStrategy[this.reconnectStrategy];
        await (previousSfuClient == null ? void 0 : previousSfuClient.leaveAndClose(`Closing previous WS after reconnect with strategy: ${strategy}`));
      } else if (!isWsHealthy) {
        previousSfuClient == null ? void 0 : previousSfuClient.close(StreamSfuClient.DISPOSE_OLD_SOCKET, "Closing unhealthy WS after reconnect");
      }
      if (!this.deviceSettingsAppliedOnce && this.state.settings) {
        await this.applyDeviceConfig(this.state.settings, true);
        this.deviceSettingsAppliedOnce = true;
      }
      (_c = this.joinCallData) == null ? true : delete _c.ring;
      (_d = this.joinCallData) == null ? true : delete _d.notify;
      this.reconnectStrategy = WebsocketReconnectStrategy.UNSPECIFIED;
      this.reconnectReason = "";
      this.logger("info", `Joined call ${this.cid}`);
    };
    this.getReconnectDetails = (migratingFromSfuId, previousSessionId) => {
      var _a;
      const strategy = this.reconnectStrategy;
      const performingRejoin = strategy === WebsocketReconnectStrategy.REJOIN;
      const announcedTracks = ((_a = this.publisher) == null ? void 0 : _a.getAnnouncedTracksForReconnect()) || [];
      return {
        strategy,
        announcedTracks,
        subscriptions: this.dynascaleManager.trackSubscriptions,
        reconnectAttempt: this.reconnectAttempts,
        fromSfuId: migratingFromSfuId || "",
        previousSessionId: performingRejoin ? previousSessionId || "" : "",
        reason: this.reconnectReason
      };
    };
    this.getPreferredPublishOptions = () => {
      const { preferredCodec, fmtpLine, preferredBitrate, maxSimulcastLayers } = this.clientPublishOptions || {};
      if (!preferredCodec && !preferredBitrate && !maxSimulcastLayers)
        return [];
      const codec = preferredCodec ? Codec.create({ name: preferredCodec.split("/").pop(), fmtp: fmtpLine }) : void 0;
      const preferredPublishOptions = [
        PublishOption.create({
          trackType: TrackType.VIDEO,
          codec,
          bitrate: preferredBitrate,
          maxSpatialLayers: maxSimulcastLayers
        })
      ];
      const screenShareSettings = this.screenShare.getSettings();
      if (screenShareSettings) {
        preferredPublishOptions.push(PublishOption.create({
          trackType: TrackType.SCREEN_SHARE,
          fps: screenShareSettings.maxFramerate,
          bitrate: screenShareSettings.maxBitrate
        }));
      }
      return preferredPublishOptions;
    };
    this.getPreferredSubscribeOptions = () => {
      const { subscriberCodec, subscriberFmtpLine } = this.clientPublishOptions || {};
      if (!subscriberCodec || !subscriberFmtpLine)
        return [];
      return [
        SubscribeOption.create({
          trackType: TrackType.VIDEO,
          codecs: [
            { name: subscriberCodec.split("/").pop(), fmtp: subscriberFmtpLine }
          ]
        })
      ];
    };
    this.restoreICE = async (nextSfuClient, opts = {}) => {
      const { includeSubscriber = true, includePublisher = true } = opts;
      if (this.subscriber) {
        this.subscriber.setSfuClient(nextSfuClient);
        if (includeSubscriber) {
          await this.subscriber.restartIce();
        }
      }
      if (this.publisher) {
        this.publisher.setSfuClient(nextSfuClient);
        if (includePublisher) {
          await this.publisher.restartIce();
        }
      }
    };
    this.initPublisherAndSubscriber = (opts) => {
      var _a, _b, _c;
      const { sfuClient, connectionConfig, clientDetails, statsOptions, publishOptions, closePreviousInstances } = opts;
      const { enable_rtc_stats: enableTracing } = statsOptions;
      if (closePreviousInstances && this.subscriber) {
        this.subscriber.dispose();
      }
      this.subscriber = new Subscriber2({
        sfuClient,
        dispatcher: this.dispatcher,
        state: this.state,
        connectionConfig,
        logTag: String(this.sfuClientTag),
        clientDetails,
        enableTracing,
        onUnrecoverableError: (reason) => {
          this.reconnect(WebsocketReconnectStrategy.REJOIN, reason).catch((err) => {
            this.logger("warn", `[Reconnect] Error reconnecting after a subscriber error: ${reason}`, err);
          });
        }
      });
      const isAnonymous = ((_a = this.streamClient.user) == null ? void 0 : _a.type) === "anonymous";
      if (!isAnonymous) {
        if (closePreviousInstances && this.publisher) {
          this.publisher.dispose();
        }
        this.publisher = new Publisher({
          sfuClient,
          dispatcher: this.dispatcher,
          state: this.state,
          connectionConfig,
          publishOptions,
          logTag: String(this.sfuClientTag),
          clientDetails,
          enableTracing,
          onUnrecoverableError: (reason) => {
            this.reconnect(WebsocketReconnectStrategy.REJOIN, reason).catch((err) => {
              this.logger("warn", `[Reconnect] Error reconnecting after a publisher error: ${reason}`, err);
            });
          }
        });
      }
      tracer.setEnabled(enableTracing);
      (_b = this.statsReporter) == null ? void 0 : _b.stop();
      this.statsReporter = createStatsReporter({
        subscriber: this.subscriber,
        publisher: this.publisher,
        state: this.state,
        datacenter: sfuClient.edgeName
      });
      (_c = this.sfuStatsReporter) == null ? void 0 : _c.stop();
      if ((statsOptions == null ? void 0 : statsOptions.reporting_interval_ms) > 0) {
        this.sfuStatsReporter = new SfuStatsReporter(sfuClient, {
          clientDetails,
          options: statsOptions,
          subscriber: this.subscriber,
          publisher: this.publisher,
          microphone: this.microphone,
          camera: this.camera,
          state: this.state
        });
        this.sfuStatsReporter.start();
      }
    };
    this.doJoinRequest = async (data) => {
      const location = await this.streamClient.getLocationHint();
      const request = { ...data, location };
      const joinResponse = await this.streamClient.post(`${this.streamClientBasePath}/join`, request);
      this.state.updateFromCallResponse(joinResponse.call);
      this.state.setMembers(joinResponse.members);
      this.state.setOwnCapabilities(joinResponse.own_capabilities);
      if (data == null ? void 0 : data.ring) {
        this.ringingSubject.next(true);
      }
      const isReconnecting = this.reconnectStrategy !== WebsocketReconnectStrategy.UNSPECIFIED;
      if (!isReconnecting && this.ringing && !this.isCreatedByMe) {
        await this.accept();
      }
      if (this.streamClient._hasConnectionID()) {
        this.watching = true;
        this.clientStore.registerCall(this);
      }
      return joinResponse;
    };
    this.handleSfuSignalClose = (sfuClient, reason) => {
      this.logger("debug", "[Reconnect] SFU signal connection closed");
      const { callingState } = this.state;
      if (
        // SFU WS closed before we finished current join,
        // no need to schedule reconnecting
        callingState === CallingState.JOINING || // we are already in the process of reconnecting,
        // no need to schedule another one
        callingState === CallingState.RECONNECTING || // SFU WS closed as a result of unsuccessful join,
        // and no further retries need to be made
        callingState === CallingState.IDLE || callingState === CallingState.LEFT
      )
        return;
      if (sfuClient.isLeaving || sfuClient.isClosing)
        return;
      this.reconnect(WebsocketReconnectStrategy.REJOIN, reason).catch((err) => {
        this.logger("warn", "[Reconnect] Error reconnecting", err);
      });
    };
    this.reconnect = async (strategy, reason) => {
      if (this.state.callingState === CallingState.RECONNECTING || this.state.callingState === CallingState.RECONNECTING_FAILED)
        return;
      return withoutConcurrency(this.reconnectConcurrencyTag, async () => {
        var _a;
        this.logger("info", `[Reconnect] Reconnecting with strategy ${WebsocketReconnectStrategy[strategy]}`);
        const reconnectStartTime = Date.now();
        this.reconnectStrategy = strategy;
        this.reconnectReason = reason;
        do {
          if (this.disconnectionTimeoutSeconds > 0 && (Date.now() - reconnectStartTime) / 1e3 > this.disconnectionTimeoutSeconds) {
            this.logger("warn", "[Reconnect] Stopping reconnection attempts after reaching disconnection timeout");
            this.state.setCallingState(CallingState.RECONNECTING_FAILED);
            return;
          }
          if (this.reconnectStrategy !== WebsocketReconnectStrategy.FAST) {
            this.reconnectAttempts++;
          }
          const current = WebsocketReconnectStrategy[this.reconnectStrategy];
          try {
            await ((_a = this.networkAvailableTask) == null ? void 0 : _a.promise);
            switch (this.reconnectStrategy) {
              case WebsocketReconnectStrategy.UNSPECIFIED:
              case WebsocketReconnectStrategy.DISCONNECT:
                this.logger("debug", `[Reconnect] No-op strategy ${current}`);
                break;
              case WebsocketReconnectStrategy.FAST:
                await this.reconnectFast();
                break;
              case WebsocketReconnectStrategy.REJOIN:
                await this.reconnectRejoin();
                break;
              case WebsocketReconnectStrategy.MIGRATE:
                await this.reconnectMigrate();
                break;
              default:
                ensureExhausted(this.reconnectStrategy, "Unknown reconnection strategy");
                break;
            }
            break;
          } catch (error2) {
            if (this.state.callingState === CallingState.OFFLINE) {
              this.logger("trace", `[Reconnect] Can't reconnect while offline, stopping reconnection attempts`);
              break;
            }
            if (error2 instanceof ErrorFromResponse && error2.unrecoverable) {
              this.logger("warn", `[Reconnect] Can't reconnect due to coordinator unrecoverable error`, error2);
              this.state.setCallingState(CallingState.RECONNECTING_FAILED);
              return;
            }
            this.logger("warn", `[Reconnect] ${current} (${this.reconnectAttempts}) failed. Attempting with REJOIN`, error2);
            await sleep(500);
            this.reconnectStrategy = WebsocketReconnectStrategy.REJOIN;
          }
        } while (this.state.callingState !== CallingState.JOINED && this.state.callingState !== CallingState.RECONNECTING_FAILED && this.state.callingState !== CallingState.LEFT);
      });
    };
    this.reconnectFast = async () => {
      var _a;
      const reconnectStartTime = Date.now();
      this.reconnectStrategy = WebsocketReconnectStrategy.FAST;
      this.state.setCallingState(CallingState.RECONNECTING);
      await this.doJoin(this.joinCallData);
      (_a = this.sfuStatsReporter) == null ? void 0 : _a.sendReconnectionTime(WebsocketReconnectStrategy.FAST, (Date.now() - reconnectStartTime) / 1e3);
    };
    this.reconnectRejoin = async () => {
      var _a;
      const reconnectStartTime = Date.now();
      this.reconnectStrategy = WebsocketReconnectStrategy.REJOIN;
      this.state.setCallingState(CallingState.RECONNECTING);
      await this.doJoin(this.joinCallData);
      await this.restorePublishedTracks();
      this.restoreSubscribedTracks();
      (_a = this.sfuStatsReporter) == null ? void 0 : _a.sendReconnectionTime(WebsocketReconnectStrategy.REJOIN, (Date.now() - reconnectStartTime) / 1e3);
    };
    this.reconnectMigrate = async () => {
      var _a, _b;
      const reconnectStartTime = Date.now();
      const currentSfuClient = this.sfuClient;
      if (!currentSfuClient) {
        throw new Error("Cannot migrate without an active SFU client");
      }
      this.reconnectStrategy = WebsocketReconnectStrategy.MIGRATE;
      this.state.setCallingState(CallingState.MIGRATING);
      const currentSubscriber = this.subscriber;
      const currentPublisher = this.publisher;
      currentSubscriber == null ? void 0 : currentSubscriber.detachEventHandlers();
      currentPublisher == null ? void 0 : currentPublisher.detachEventHandlers();
      const migrationTask = makeSafePromise(currentSfuClient.enterMigration());
      try {
        const currentSfu = currentSfuClient.edgeName;
        await this.doJoin({ ...this.joinCallData, migrating_from: currentSfu });
      } finally {
        (_a = this.joinCallData) == null ? true : delete _a.migrating_from;
      }
      await this.restorePublishedTracks();
      this.restoreSubscribedTracks();
      try {
        await migrationTask();
        this.state.setCallingState(CallingState.JOINED);
      } finally {
        currentSubscriber == null ? void 0 : currentSubscriber.dispose();
        currentPublisher == null ? void 0 : currentPublisher.dispose();
        currentSfuClient.close(StreamSfuClient.NORMAL_CLOSURE, "Migrating away");
      }
      (_b = this.sfuStatsReporter) == null ? void 0 : _b.sendReconnectionTime(WebsocketReconnectStrategy.MIGRATE, (Date.now() - reconnectStartTime) / 1e3);
    };
    this.registerReconnectHandlers = () => {
      const unregisterGoAway = this.on("goAway", () => {
        this.reconnect(WebsocketReconnectStrategy.MIGRATE, "goAway").catch((err) => this.logger("warn", "[Reconnect] Error reconnecting", err));
      });
      const unregisterOnError = this.on("error", (e) => {
        const { reconnectStrategy: strategy, error: error2 } = e;
        if (strategy === WebsocketReconnectStrategy.UNSPECIFIED)
          return;
        if (strategy === WebsocketReconnectStrategy.DISCONNECT) {
          this.leave({ reason: "SFU instructed to disconnect" }).catch((err) => {
            this.logger("warn", `Can't leave call after disconnect request`, err);
          });
        } else {
          this.reconnect(strategy, (error2 == null ? void 0 : error2.message) || "SFU Error").catch((err) => {
            this.logger("warn", "[Reconnect] Error reconnecting", err);
          });
        }
      });
      const unregisterNetworkChanged = this.streamClient.on("network.changed", (e) => {
        var _a, _b, _c, _d;
        if (!e.online) {
          this.logger("debug", "[Reconnect] Going offline");
          if (!this.hasJoinedOnce)
            return;
          this.lastOfflineTimestamp = Date.now();
          const networkAvailableTask = promiseWithResolvers();
          networkAvailableTask.promise.then(() => {
            let strategy = WebsocketReconnectStrategy.FAST;
            if (this.lastOfflineTimestamp) {
              const offline = (Date.now() - this.lastOfflineTimestamp) / 1e3;
              if (offline > this.fastReconnectDeadlineSeconds) {
                strategy = WebsocketReconnectStrategy.REJOIN;
              }
            }
            this.reconnect(strategy, "Going online").catch((err) => {
              this.logger("warn", "[Reconnect] Error reconnecting after going online", err);
            });
          });
          this.networkAvailableTask = networkAvailableTask;
          (_a = this.sfuStatsReporter) == null ? void 0 : _a.stop();
          this.state.setCallingState(CallingState.OFFLINE);
        } else {
          this.logger("debug", "[Reconnect] Going online");
          (_b = this.sfuClient) == null ? void 0 : _b.close(StreamSfuClient.DISPOSE_OLD_SOCKET, "Closing WS to reconnect after going online");
          (_c = this.networkAvailableTask) == null ? void 0 : _c.resolve();
          this.networkAvailableTask = void 0;
          (_d = this.sfuStatsReporter) == null ? void 0 : _d.start();
        }
      });
      this.leaveCallHooks.add(unregisterGoAway).add(unregisterOnError).add(unregisterNetworkChanged);
    };
    this.restorePublishedTracks = async () => {
      for (const trackType of this.trackPublishOrder) {
        let mediaStream;
        switch (trackType) {
          case TrackType.AUDIO:
            mediaStream = this.microphone.state.mediaStream;
            break;
          case TrackType.VIDEO:
            mediaStream = this.camera.state.mediaStream;
            break;
          case TrackType.SCREEN_SHARE:
            mediaStream = this.screenShare.state.mediaStream;
            break;
          // screen share audio can't exist without a screen share, so we handle it there
          case TrackType.SCREEN_SHARE_AUDIO:
          case TrackType.UNSPECIFIED:
            break;
          default:
            ensureExhausted(trackType, "Unknown track type");
            break;
        }
        if (mediaStream)
          await this.publish(mediaStream, trackType);
      }
    };
    this.restoreSubscribedTracks = () => {
      const { remoteParticipants } = this.state;
      if (remoteParticipants.length <= 0)
        return;
      this.dynascaleManager.applyTrackSubscriptions(void 0);
    };
    this.publishVideoStream = async (videoStream) => {
      await this.publish(videoStream, TrackType.VIDEO);
    };
    this.publishAudioStream = async (audioStream) => {
      await this.publish(audioStream, TrackType.AUDIO);
    };
    this.publishScreenShareStream = async (screenShareStream) => {
      await this.publish(screenShareStream, TrackType.SCREEN_SHARE);
    };
    this.publish = async (mediaStream, trackType) => {
      if (!this.sfuClient)
        throw new Error(`Call not joined yet.`);
      await this.sfuClient.joinTask;
      if (!this.permissionsContext.canPublish(trackType)) {
        throw new Error(`No permission to publish ${TrackType[trackType]}`);
      }
      if (!this.publisher)
        throw new Error("Publisher is not initialized");
      const [track] = isAudioTrackType(trackType) ? mediaStream.getAudioTracks() : mediaStream.getVideoTracks();
      if (!track) {
        throw new Error(`There is no ${TrackType[trackType]} track in the stream`);
      }
      if (track.readyState === "ended") {
        throw new Error(`Can't publish ended tracks.`);
      }
      pushToIfMissing(this.trackPublishOrder, trackType);
      await this.publisher.publish(track, trackType);
      const trackTypes = [trackType];
      if (trackType === TrackType.SCREEN_SHARE) {
        const [audioTrack] = mediaStream.getAudioTracks();
        if (audioTrack) {
          pushToIfMissing(this.trackPublishOrder, TrackType.SCREEN_SHARE_AUDIO);
          await this.publisher.publish(audioTrack, TrackType.SCREEN_SHARE_AUDIO);
          trackTypes.push(TrackType.SCREEN_SHARE_AUDIO);
        }
      }
      await this.updateLocalStreamState(mediaStream, ...trackTypes);
    };
    this.stopPublish = async (...trackTypes) => {
      if (!this.sfuClient || !this.publisher)
        return;
      this.publisher.stopTracks(...trackTypes);
      await this.updateLocalStreamState(void 0, ...trackTypes);
    };
    this.updateLocalStreamState = async (mediaStream, ...trackTypes) => {
      if (!this.sfuClient || !this.sfuClient.sessionId)
        return;
      await this.notifyTrackMuteState(!mediaStream, ...trackTypes);
      const { sessionId } = this.sfuClient;
      for (const trackType of trackTypes) {
        const streamStateProp = trackTypeToParticipantStreamKey(trackType);
        if (!streamStateProp)
          continue;
        this.state.updateParticipant(sessionId, (p) => ({
          publishedTracks: mediaStream ? pushToIfMissing([...p.publishedTracks], trackType) : p.publishedTracks.filter((t2) => t2 !== trackType),
          [streamStateProp]: mediaStream
        }));
      }
    };
    this.updatePublishOptions = (options) => {
      this.logger("warn", "[call.updatePublishOptions]: You are manually overriding the publish options for this call. This is not recommended, and it can cause call stability/compatibility issues. Use with caution.");
      if (this.state.callingState === CallingState.JOINED) {
        this.logger("warn", "Updating publish options after joining the call does not have an effect");
      }
      this.clientPublishOptions = { ...this.clientPublishOptions, ...options };
    };
    this.notifyNoiseCancellationStarting = async () => {
      var _a;
      return (_a = this.sfuClient) == null ? void 0 : _a.startNoiseCancellation().catch((err) => {
        this.logger("warn", "Failed to notify start of noise cancellation", err);
      });
    };
    this.notifyNoiseCancellationStopped = async () => {
      var _a;
      return (_a = this.sfuClient) == null ? void 0 : _a.stopNoiseCancellation().catch((err) => {
        this.logger("warn", "Failed to notify stop of noise cancellation", err);
      });
    };
    this.notifyTrackMuteState = async (muted, ...trackTypes) => {
      if (!this.sfuClient)
        return;
      await this.sfuClient.updateMuteStates(trackTypes.map((trackType) => ({ trackType, muted })));
    };
    this.startReportingStatsFor = (sessionId) => {
      var _a;
      return (_a = this.statsReporter) == null ? void 0 : _a.startReportingStatsFor(sessionId);
    };
    this.stopReportingStatsFor = (sessionId) => {
      var _a;
      return (_a = this.statsReporter) == null ? void 0 : _a.stopReportingStatsFor(sessionId);
    };
    this.resetReaction = (sessionId) => {
      this.state.updateParticipant(sessionId, {
        reaction: void 0
      });
    };
    this.setSortParticipantsBy = (criteria) => {
      return this.state.setSortParticipantsBy(criteria);
    };
    this.sendReaction = async (reaction) => {
      return this.streamClient.post(`${this.streamClientBasePath}/reaction`, reaction);
    };
    this.blockUser = async (userId) => {
      return this.streamClient.post(`${this.streamClientBasePath}/block`, {
        user_id: userId
      });
    };
    this.unblockUser = async (userId) => {
      return this.streamClient.post(`${this.streamClientBasePath}/unblock`, {
        user_id: userId
      });
    };
    this.muteSelf = (type2) => {
      const myUserId = this.currentUserId;
      if (myUserId) {
        return this.muteUser(myUserId, type2);
      }
    };
    this.muteOthers = (type2) => {
      const trackType = muteTypeToTrackType(type2);
      if (!trackType)
        return;
      const userIdsToMute = [];
      for (const participant of this.state.remoteParticipants) {
        if (participant.publishedTracks.includes(trackType)) {
          userIdsToMute.push(participant.userId);
        }
      }
      if (userIdsToMute.length > 0) {
        return this.muteUser(userIdsToMute, type2);
      }
    };
    this.muteUser = (userId, type2) => {
      return this.streamClient.post(`${this.streamClientBasePath}/mute_users`, {
        user_ids: Array.isArray(userId) ? userId : [userId],
        [type2]: true
      });
    };
    this.muteAllUsers = (type2) => {
      return this.streamClient.post(`${this.streamClientBasePath}/mute_users`, {
        mute_all_users: true,
        [type2]: true
      });
    };
    this.startRecording = async (request) => {
      return this.streamClient.post(`${this.streamClientBasePath}/start_recording`, request ? request : {});
    };
    this.stopRecording = async () => {
      return this.streamClient.post(`${this.streamClientBasePath}/stop_recording`, {});
    };
    this.startTranscription = async (request) => {
      return this.streamClient.post(`${this.streamClientBasePath}/start_transcription`, request);
    };
    this.stopTranscription = async () => {
      return this.streamClient.post(`${this.streamClientBasePath}/stop_transcription`);
    };
    this.startClosedCaptions = async (options) => {
      const trx = this.state.setCaptioning(true);
      try {
        return await this.streamClient.post(`${this.streamClientBasePath}/start_closed_captions`, options);
      } catch (err) {
        trx.rollback();
        throw err;
      }
    };
    this.stopClosedCaptions = async (options) => {
      const trx = this.state.setCaptioning(false);
      try {
        return await this.streamClient.post(`${this.streamClientBasePath}/stop_closed_captions`, options);
      } catch (err) {
        trx.rollback();
        throw err;
      }
    };
    this.updateClosedCaptionSettings = (config2) => {
      this.state.updateClosedCaptionSettings(config2);
    };
    this.requestPermissions = async (data) => {
      const { permissions } = data;
      const canRequestPermissions = permissions.every((permission) => this.permissionsContext.canRequest(permission));
      if (!canRequestPermissions) {
        throw new Error(`You are not allowed to request permissions: ${permissions.join(", ")}`);
      }
      return this.streamClient.post(`${this.streamClientBasePath}/request_permission`, data);
    };
    this.grantPermissions = async (userId, permissions) => {
      return this.updateUserPermissions({
        user_id: userId,
        grant_permissions: permissions
      });
    };
    this.revokePermissions = async (userId, permissions) => {
      return this.updateUserPermissions({
        user_id: userId,
        revoke_permissions: permissions
      });
    };
    this.updateUserPermissions = async (data) => {
      return this.streamClient.post(`${this.streamClientBasePath}/user_permissions`, data);
    };
    this.goLive = async (data = {}, params) => {
      return this.streamClient.post(`${this.streamClientBasePath}/go_live`, data, params);
    };
    this.stopLive = async (data = {}) => {
      return this.streamClient.post(`${this.streamClientBasePath}/stop_live`, data);
    };
    this.startHLS = async () => {
      return this.streamClient.post(`${this.streamClientBasePath}/start_broadcasting`, {});
    };
    this.stopHLS = async () => {
      return this.streamClient.post(`${this.streamClientBasePath}/stop_broadcasting`, {});
    };
    this.startRTMPBroadcasts = async (data) => {
      return this.streamClient.post(`${this.streamClientBasePath}/rtmp_broadcasts`, data);
    };
    this.stopAllRTMPBroadcasts = async () => {
      return this.streamClient.post(`${this.streamClientBasePath}/rtmp_broadcasts/stop`);
    };
    this.stopRTMPBroadcast = async (name2) => {
      return this.streamClient.post(`${this.streamClientBasePath}/rtmp_broadcasts/${name2}/stop`);
    };
    this.startFrameRecording = async (data) => {
      return this.streamClient.post(`${this.streamClientBasePath}/start_frame_recording`, data);
    };
    this.stopFrameRecording = async () => {
      return this.streamClient.post(`${this.streamClientBasePath}/stop_frame_recording`);
    };
    this.update = async (updates) => {
      const response = await this.streamClient.patch(`${this.streamClientBasePath}`, updates);
      const { call, members: members2, own_capabilities } = response;
      this.state.updateFromCallResponse(call);
      this.state.setMembers(members2);
      this.state.setOwnCapabilities(own_capabilities);
      return response;
    };
    this.endCall = async () => {
      return this.streamClient.post(`${this.streamClientBasePath}/mark_ended`);
    };
    this.pin = (sessionId) => {
      this.state.updateParticipant(sessionId, {
        pin: {
          isLocalPin: true,
          pinnedAt: Date.now()
        }
      });
    };
    this.unpin = (sessionId) => {
      this.state.updateParticipant(sessionId, {
        pin: void 0
      });
    };
    this.pinForEveryone = async (request) => {
      return this.streamClient.post(`${this.streamClientBasePath}/pin`, request);
    };
    this.unpinForEveryone = async (request) => {
      return this.streamClient.post(`${this.streamClientBasePath}/unpin`, request);
    };
    this.queryMembers = (request) => {
      return this.streamClient.post("/call/members", {
        ...request || {},
        id: this.id,
        type: this.type
      });
    };
    this.updateCallMembers = async (data) => {
      return this.streamClient.post(`${this.streamClientBasePath}/members`, data);
    };
    this.scheduleAutoDrop = () => {
      this.cancelAutoDrop();
      const settings = this.state.settings;
      if (!settings)
        return;
      if (this.state.callingState !== CallingState.RINGING)
        return;
      const timeoutInMs = this.isCreatedByMe ? settings.ring.auto_cancel_timeout_ms : settings.ring.incoming_call_timeout_ms;
      if (timeoutInMs <= 0)
        return;
      this.dropTimeout = setTimeout(() => {
        if (this.state.callingState !== CallingState.RINGING)
          return;
        this.leave({ reject: true, reason: "timeout" }).catch((err) => {
          this.logger("error", "Failed to drop call", err);
        });
      }, timeoutInMs);
    };
    this.cancelAutoDrop = () => {
      clearTimeout(this.dropTimeout);
      this.dropTimeout = void 0;
    };
    this.queryRecordings = async (callSessionId) => {
      let endpoint = this.streamClientBasePath;
      if (callSessionId) {
        endpoint = `${endpoint}/${callSessionId}`;
      }
      return this.streamClient.get(`${endpoint}/recordings`);
    };
    this.queryTranscriptions = async () => {
      return this.streamClient.get(`${this.streamClientBasePath}/transcriptions`);
    };
    this.getCallStats = async (callSessionID) => {
      const endpoint = `${this.streamClientBasePath}/stats/${callSessionID}`;
      return this.streamClient.get(endpoint);
    };
    this.getCallReport = async (callSessionID = "") => {
      const endpoint = `${this.streamClientBasePath}/report`;
      const params = callSessionID !== "" ? { session_id: callSessionID } : {};
      return this.streamClient.get(endpoint, params);
    };
    this.submitFeedback = async (rating, { reason, custom } = {}) => {
      var _a;
      const { sdkName, sdkVersion, ...platform2 } = getSdkSignature(await getClientDetails());
      return this.streamClient.post(`${this.streamClientBasePath}/feedback`, {
        rating,
        reason,
        user_session_id: (_a = this.sfuClient) == null ? void 0 : _a.sessionId,
        sdk: sdkName,
        sdk_version: sdkVersion,
        custom: {
          ...custom,
          "x-stream-platform-data": platform2
        }
      });
    };
    this.sendCustomEvent = async (payload) => {
      return this.streamClient.post(`${this.streamClientBasePath}/event`, { custom: payload });
    };
    this.applyDeviceConfig = async (settings, publish2) => {
      await this.camera.apply(settings.video, publish2).catch((err) => {
        this.logger("warn", "Camera init failed", err);
      });
      await this.microphone.apply(settings.audio, publish2).catch((err) => {
        this.logger("warn", "Mic init failed", err);
      });
    };
    this.trackElementVisibility = (element, sessionId, trackType) => {
      return this.dynascaleManager.trackElementVisibility(element, sessionId, trackType);
    };
    this.setViewport = (element) => {
      return this.dynascaleManager.setViewport(element);
    };
    this.bindVideoElement = (videoElement, sessionId, trackType) => {
      const unbind = this.dynascaleManager.bindVideoElement(videoElement, sessionId, trackType);
      if (!unbind)
        return;
      this.leaveCallHooks.add(unbind);
      return () => {
        this.leaveCallHooks.delete(unbind);
        unbind();
      };
    };
    this.bindAudioElement = (audioElement, sessionId, trackType = "audioTrack") => {
      const unbind = this.dynascaleManager.bindAudioElement(audioElement, sessionId, trackType);
      if (!unbind)
        return;
      this.leaveCallHooks.add(unbind);
      return () => {
        this.leaveCallHooks.delete(unbind);
        unbind();
      };
    };
    this.bindCallThumbnailElement = (imageElement, opts = {}) => {
      const handleError = () => {
        imageElement.src = opts.fallbackImageSource || "https://getstream.io/random_svg/?name=x&id=x";
      };
      const unsubscribe = createSubscription(this.state.thumbnails$, (thumbnails) => {
        if (!thumbnails)
          return;
        imageElement.addEventListener("error", handleError);
        const thumbnailUrl = new URL(thumbnails.image_url);
        thumbnailUrl.searchParams.set("w", String(imageElement.clientWidth));
        thumbnailUrl.searchParams.set("h", String(imageElement.clientHeight));
        imageElement.src = thumbnailUrl.toString();
      });
      return () => {
        unsubscribe();
        imageElement.removeEventListener("error", handleError);
      };
    };
    this.setPreferredIncomingVideoResolution = (resolution, sessionIds) => {
      this.dynascaleManager.setVideoTrackSubscriptionOverrides(resolution ? {
        enabled: true,
        dimension: resolution
      } : void 0, sessionIds);
      this.dynascaleManager.applyTrackSubscriptions();
    };
    this.setIncomingVideoEnabled = (enabled) => {
      this.dynascaleManager.setVideoTrackSubscriptionOverrides(enabled ? void 0 : { enabled: false });
      this.dynascaleManager.applyTrackSubscriptions();
    };
    this.setDisconnectionTimeout = (timeoutSeconds) => {
      this.disconnectionTimeoutSeconds = timeoutSeconds;
    };
    this.type = type;
    this.id = id;
    this.cid = `${type}:${id}`;
    this.ringingSubject = new BehaviorSubject(ringing);
    this.watching = watching;
    this.streamClient = streamClient;
    this.clientStore = clientStore;
    this.streamClientBasePath = `/call/${this.type}/${this.id}`;
    this.logger = getLogger(["Call"]);
    const callTypeConfig = CallTypes.get(type);
    const participantSorter = sortParticipantsBy || callTypeConfig.options.sortParticipantsBy;
    if (participantSorter) {
      this.state.setSortParticipantsBy(participantSorter);
    }
    this.state.setMembers(members || []);
    this.state.setOwnCapabilities(ownCapabilities || []);
    this.state.setCallingState(ringing ? CallingState.RINGING : CallingState.IDLE);
    this.camera = new CameraManager(this);
    this.microphone = new MicrophoneManager(this);
    this.speaker = new SpeakerManager(this);
    this.screenShare = new ScreenShareManager(this);
    this.dynascaleManager = new DynascaleManager(this.state, this.speaker);
  }
  /**
   * A flag indicating whether the call is "ringing" type of call.
   */
  get ringing() {
    return getCurrentValue(this.ringingSubject);
  }
  /**
   * Retrieves the current user ID.
   */
  get currentUserId() {
    var _a;
    return (_a = this.clientStore.connectedUser) == null ? void 0 : _a.id;
  }
  /**
   * A flag indicating whether the call was created by the current user.
   */
  get isCreatedByMe() {
    var _a;
    return ((_a = this.state.createdBy) == null ? void 0 : _a.id) === this.currentUserId;
  }
};
var https = null;
var StableWSConnection = class {
  constructor(client) {
    this._log = (msg, extra = {}, level2 = "info") => {
      this.client.logger(level2, `connection:${msg}`, extra);
    };
    this.setClient = (client2) => {
      this.client = client2;
    };
    this._buildUrl = () => {
      const params = new URLSearchParams();
      params.set("api_key", this.client.key);
      params.set("stream-auth-type", this.client.getAuthType());
      params.set("X-Stream-Client", this.client.getUserAgent());
      return `${this.client.wsBaseURL}/connect?${params.toString()}`;
    };
    this.onlineStatusChanged = (event) => {
      if (event.type === "offline") {
        this._log("onlineStatusChanged() - Status changing to offline");
        this._setHealth(false, true);
      } else if (event.type === "online") {
        this._log(`onlineStatusChanged() - Status changing to online. isHealthy: ${this.isHealthy}`);
        if (!this.isHealthy) {
          this._reconnect({ interval: 10 });
        }
      }
    };
    this.onopen = (wsID) => {
      var _a;
      if (this.wsID !== wsID)
        return;
      const user = this.client.user;
      if (!user) {
        this.client.logger("error", `User not set, can't connect to WS`);
        return;
      }
      const token = this.client._getToken();
      if (!token) {
        this.client.logger("error", `Token not set, can't connect authenticate`);
        return;
      }
      const authMessage = JSON.stringify({
        token,
        user_details: {
          id: user.id,
          name: user.name,
          image: user.image,
          custom: user.custom
        }
      });
      this._log(`onopen() - Sending auth message ${authMessage}`, {}, "trace");
      (_a = this.ws) == null ? void 0 : _a.send(authMessage);
      this._log("onopen() - onopen callback", { wsID });
    };
    this.onmessage = (wsID, event) => {
      var _a, _b;
      if (this.wsID !== wsID)
        return;
      this._log("onmessage() - onmessage callback", { event, wsID });
      const data = typeof event.data === "string" ? JSON.parse(event.data) : null;
      if (!this.isConnectionOpenResolved && data && data.type === "connection.error") {
        this.isConnectionOpenResolved = true;
        if (data.error) {
          (_a = this.rejectConnectionOpen) == null ? void 0 : _a.call(this, this._errorFromWSEvent(data, false));
          return;
        }
      }
      this.lastEvent = /* @__PURE__ */ new Date();
      if (data && (data.type === "health.check" || data.type === "connection.ok")) {
        this.scheduleNextPing();
      }
      if (data && data.type === "connection.ok") {
        (_b = this.resolveConnectionOpen) == null ? void 0 : _b.call(this, data);
        this._setHealth(true);
      }
      if (data && data.type === "connection.error" && data.error) {
        const { code } = data.error;
        this.isHealthy = false;
        this.isConnecting = false;
        this.consecutiveFailures += 1;
        if (code === KnownCodes.TOKEN_EXPIRED && !this.client.tokenManager.isStatic()) {
          clearTimeout(this.connectionCheckTimeoutRef);
          this._log("connect() - WS failure due to expired token, so going to try to reload token and reconnect");
          this._reconnect({ refreshToken: true });
        }
      }
      if (data) {
        data.received_at = /* @__PURE__ */ new Date();
        this.client.dispatchEvent(data);
      }
      this.scheduleConnectionCheck();
    };
    this.onclose = (wsID, event) => {
      var _a, _b;
      if (this.wsID !== wsID)
        return;
      this._log("onclose() - onclose callback - " + event.code, { event, wsID });
      if (event.code === KnownCodes.WS_CLOSED_SUCCESS) {
        const error2 = new Error(`WS connection reject with error ${event.reason}`);
        error2.reason = event.reason;
        error2.code = event.code;
        error2.wasClean = event.wasClean;
        error2.target = event.target;
        (_a = this.rejectConnectionOpen) == null ? void 0 : _a.call(this, error2);
        this._log(`onclose() - WS connection reject with error ${event.reason}`, {
          event
        });
      } else {
        this.consecutiveFailures += 1;
        this.totalFailures += 1;
        this._setHealth(false);
        this.isConnecting = false;
        (_b = this.rejectConnectionOpen) == null ? void 0 : _b.call(this, this._errorFromWSEvent(event));
        this._log(`onclose() - WS connection closed. Calling reconnect ...`, {
          event
        });
        this._reconnect();
      }
    };
    this.onerror = (wsID, event) => {
      var _a;
      if (this.wsID !== wsID)
        return;
      this.consecutiveFailures += 1;
      this.totalFailures += 1;
      this._setHealth(false);
      this.isConnecting = false;
      (_a = this.rejectConnectionOpen) == null ? void 0 : _a.call(this, new Error(`WebSocket error: ${event}`));
      this._log(`onerror() - WS connection resulted into error`, { event });
      this._reconnect();
    };
    this._setHealth = (healthy, dispatchImmediately = false) => {
      if (healthy === this.isHealthy)
        return;
      this.isHealthy = healthy;
      if (this.isHealthy || dispatchImmediately) {
        this.client.dispatchEvent({
          type: "connection.changed",
          online: this.isHealthy
        });
        return;
      }
      setTimeout(() => {
        if (this.isHealthy)
          return;
        this.client.dispatchEvent({
          type: "connection.changed",
          online: this.isHealthy
        });
      }, 5e3);
    };
    this._errorFromWSEvent = (event, isWSFailure = true) => {
      let code;
      let statusCode;
      let message;
      if (isCloseEvent(event)) {
        code = event.code;
        message = event.reason;
        statusCode = 0;
      } else {
        const { error: error3 } = event;
        code = error3.code;
        message = error3.message;
        statusCode = error3.StatusCode;
      }
      const msg = `WS failed with code: ${code} and reason: ${message}`;
      this._log(msg, { event }, "warn");
      const error2 = new Error(msg);
      error2.code = code;
      error2.StatusCode = statusCode;
      error2.isWSFailure = isWSFailure;
      return error2;
    };
    this._setupConnectionPromise = () => {
      this.isConnectionOpenResolved = false;
      this.connectionOpenSafe = makeSafePromise(new Promise((resolve, reject) => {
        this.resolveConnectionOpen = resolve;
        this.rejectConnectionOpen = reject;
      }));
    };
    this.scheduleNextPing = () => {
      const timers = getTimers();
      if (this.healthCheckTimeoutRef) {
        timers.clearTimeout(this.healthCheckTimeoutRef);
      }
      this.healthCheckTimeoutRef = timers.setTimeout(() => {
        var _a;
        const data = [{ type: "health.check", client_id: this.client.clientID }];
        try {
          (_a = this.ws) == null ? void 0 : _a.send(JSON.stringify(data));
        } catch {
        }
      }, this.pingInterval);
    };
    this.scheduleConnectionCheck = () => {
      clearTimeout(this.connectionCheckTimeoutRef);
      this.connectionCheckTimeoutRef = setTimeout(() => {
        const now = /* @__PURE__ */ new Date();
        if (this.lastEvent && now.getTime() - this.lastEvent.getTime() > this.connectionCheckTimeout) {
          this._log("scheduleConnectionCheck - going to reconnect");
          this._setHealth(false);
          this._reconnect();
        }
      }, this.connectionCheckTimeout);
    };
    this.client = client;
    this.consecutiveFailures = 0;
    this.totalFailures = 0;
    this.isConnecting = false;
    this.isDisconnected = false;
    this.isConnectionOpenResolved = false;
    this.isHealthy = false;
    this.wsID = 1;
    this.lastEvent = null;
    this.pingInterval = 25 * 1e3;
    this.connectionCheckTimeout = this.pingInterval + 10 * 1e3;
    addConnectionEventListeners(this.onlineStatusChanged);
  }
  /**
   * connect - Connect to the WS URL
   * the default 15s timeout allows between 2~3 tries
   * @return {ConnectAPIResponse<ConnectedEvent>} Promise that completes once the first health check message is received
   */
  async connect(timeout2 = 15e3) {
    if (this.isConnecting) {
      throw Error(`You've called connect twice, can only attempt 1 connection at the time`);
    }
    this.isDisconnected = false;
    try {
      const healthCheck = await this._connect();
      this.consecutiveFailures = 0;
      this._log(`connect() - Established ws connection with healthcheck: ${healthCheck}`);
    } catch (error2) {
      this.isHealthy = false;
      this.consecutiveFailures += 1;
      if (
        // @ts-expect-error type issue
        error2.code === KnownCodes.TOKEN_EXPIRED && !this.client.tokenManager.isStatic()
      ) {
        this._log("connect() - WS failure due to expired token, so going to try to reload token and reconnect");
        this._reconnect({ refreshToken: true });
      } else {
        if (!error2.isWSFailure) {
          throw new Error(JSON.stringify({
            // @ts-expect-error type issue
            code: error2.code,
            // @ts-expect-error type issue
            StatusCode: error2.StatusCode,
            // @ts-expect-error type issue
            message: error2.message,
            // @ts-expect-error type issue
            isWSFailure: error2.isWSFailure
          }));
        }
      }
    }
    return await this._waitForHealthy(timeout2);
  }
  /**
   * _waitForHealthy polls the promise connection to see if its resolved until it times out
   * the default 15s timeout allows between 2~3 tries
   * @param timeout duration(ms)
   */
  async _waitForHealthy(timeout2 = 15e3) {
    return Promise.race([
      (async () => {
        const interval2 = 50;
        for (let i = 0; i <= timeout2; i += interval2) {
          try {
            return await this.connectionOpen;
          } catch (error2) {
            if (i === timeout2) {
              throw new Error(JSON.stringify({
                code: error2.code,
                StatusCode: error2.StatusCode,
                message: error2.message,
                isWSFailure: error2.isWSFailure
              }));
            }
            await sleep(interval2);
          }
        }
      })(),
      (async () => {
        await sleep(timeout2);
        this.isConnecting = false;
        throw new Error(JSON.stringify({
          code: "",
          StatusCode: "",
          message: "initial WS connection could not be established",
          isWSFailure: true
        }));
      })()
    ]);
  }
  /**
   * disconnect - Disconnect the connection and doesn't recover...
   *
   */
  disconnect(timeout2) {
    this._log(`disconnect() - Closing the websocket connection for wsID ${this.wsID}`);
    this.wsID += 1;
    this.isConnecting = false;
    this.isDisconnected = true;
    if (this.healthCheckTimeoutRef) {
      getTimers().clearInterval(this.healthCheckTimeoutRef);
    }
    if (this.connectionCheckTimeoutRef) {
      clearInterval(this.connectionCheckTimeoutRef);
    }
    removeConnectionEventListeners(this.onlineStatusChanged);
    this.isHealthy = false;
    let isClosedPromise;
    const { ws } = this;
    if (ws && ws.close && ws.readyState === ws.OPEN) {
      isClosedPromise = new Promise((resolve) => {
        const onclose = (event) => {
          this._log(`disconnect() - resolving isClosedPromise ${event ? "with" : "without"} close frame`, { event });
          resolve();
        };
        ws.onclose = onclose;
        setTimeout(onclose, timeout2 != null ? timeout2 : 1e3);
      });
      this._log(`disconnect() - Manually closed connection by calling client.disconnect()`);
      ws.close(KnownCodes.WS_CLOSED_SUCCESS, "Manually closed connection by calling client.disconnect()");
    } else {
      this._log(`disconnect() - ws connection doesn't exist or it is already closed.`);
      isClosedPromise = Promise.resolve();
    }
    delete this.ws;
    return isClosedPromise;
  }
  /**
   * _connect - Connect to the WS endpoint
   *
   * @return {ConnectAPIResponse<ConnectedEvent>} Promise that completes once the first health check message is received
   */
  async _connect() {
    var _a, _b, _c, _d;
    if (this.isConnecting)
      return;
    this.isConnecting = true;
    let isTokenReady = false;
    try {
      this._log(`_connect() - waiting for token`);
      await this.client.tokenManager.tokenReady();
      isTokenReady = true;
    } catch {
    }
    try {
      if (!isTokenReady) {
        this._log(`_connect() - tokenProvider failed before, so going to retry`);
        await this.client.tokenManager.loadToken();
      }
      if (!this.client.isConnectionIsPromisePending) {
        this.client._setupConnectionIdPromise();
      }
      this._setupConnectionPromise();
      const wsURL = this._buildUrl();
      this._log(`_connect() - Connecting to ${wsURL}`);
      const WS = this.client.options.WebSocketImpl ?? WebSocket;
      this.ws = new WS(wsURL);
      this.ws.onopen = this.onopen.bind(this, this.wsID);
      this.ws.onclose = this.onclose.bind(this, this.wsID);
      this.ws.onerror = this.onerror.bind(this, this.wsID);
      this.ws.onmessage = this.onmessage.bind(this, this.wsID);
      const response = await this.connectionOpen;
      this.isConnecting = false;
      if (response) {
        this.connectionID = response.connection_id;
        (_b = (_a = this.client).resolveConnectionId) == null ? void 0 : _b.call(_a, this.connectionID);
        return response;
      }
    } catch (err) {
      this.client._setupConnectionIdPromise();
      this.isConnecting = false;
      this._log(`_connect() - Error - `, err);
      (_d = (_c = this.client).rejectConnectionId) == null ? void 0 : _d.call(_c, err);
      throw err;
    }
  }
  /**
   * _reconnect - Retry the connection to WS endpoint
   *
   * @param {{ interval?: number; refreshToken?: boolean }} options Following options are available
   *
   * - `interval`	{int}			number of ms that function should wait before reconnecting
   * - `refreshToken` {boolean}	reload/refresh user token be refreshed before attempting reconnection.
   */
  async _reconnect(options = {}) {
    this._log("_reconnect() - Initiating the reconnect");
    if (this.isConnecting || this.isHealthy) {
      this._log("_reconnect() - Abort (1) since already connecting or healthy");
      return;
    }
    let interval2 = options.interval;
    if (!interval2) {
      interval2 = retryInterval(this.consecutiveFailures);
    }
    await sleep(interval2);
    if (this.isConnecting || this.isHealthy) {
      this._log("_reconnect() - Abort (2) since already connecting or healthy");
      return;
    }
    if (this.isDisconnected) {
      this._log("_reconnect() - Abort (3) since disconnect() is called");
      return;
    }
    this._log("_reconnect() - Destroying current WS connection");
    this._destroyCurrentWSConnection();
    if (options.refreshToken) {
      await this.client.tokenManager.loadToken();
    }
    try {
      await this._connect();
      this._log("_reconnect() - Waiting for recoverCallBack");
      this._log("_reconnect() - Finished recoverCallBack");
      this.consecutiveFailures = 0;
    } catch (error2) {
      this.isHealthy = false;
      this.consecutiveFailures += 1;
      if (error2.code === KnownCodes.TOKEN_EXPIRED && !this.client.tokenManager.isStatic()) {
        this._log("_reconnect() - WS failure due to expired token, so going to try to reload token and reconnect");
        return this._reconnect({ refreshToken: true });
      }
      if (error2.isWSFailure) {
        this._log("_reconnect() - WS failure, so going to try to reconnect");
        this._reconnect();
      }
    }
    this._log("_reconnect() - == END ==");
  }
  /**
   * _destroyCurrentWSConnection - Removes the current WS connection
   *
   */
  _destroyCurrentWSConnection() {
    var _a;
    this.wsID += 1;
    try {
      (_a = this == null ? void 0 : this.ws) == null ? void 0 : _a.close();
    } catch {
    }
  }
  get connectionOpen() {
    var _a;
    return (_a = this.connectionOpenSafe) == null ? void 0 : _a.call(this);
  }
};
function getUserFromToken(token) {
  const fragments = token.split(".");
  if (fragments.length !== 3) {
    return "";
  }
  const b64Payload = fragments[1];
  const payload = decodeBase64(b64Payload);
  const data = JSON.parse(payload);
  return data.user_id;
}
var decodeBase64 = (s) => {
  const e = {}, w = String.fromCharCode, L = s.length;
  let i, b = 0, c, x, l = 0, a, r = "";
  const A = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (i = 0; i < 64; i++) {
    e[A.charAt(i)] = i;
  }
  for (x = 0; x < L; x++) {
    c = e[s.charAt(x)];
    b = (b << 6) + c;
    l += 6;
    while (l >= 8) {
      if ((a = b >>> (l -= 8) & 255) || x < L - 2)
        r += w(a);
    }
  }
  return r;
};
var TokenManager = class {
  constructor(secret) {
    this.loadTokenPromise = null;
    this.type = "static";
    this.setTokenOrProvider = async (tokenOrProvider, user, isAnonymous) => {
      this.user = user;
      this.isAnonymous = isAnonymous;
      this.validateToken(tokenOrProvider);
      if (isFunction2(tokenOrProvider)) {
        this.tokenProvider = tokenOrProvider;
        this.type = "provider";
      }
      if (typeof tokenOrProvider === "string") {
        this.token = tokenOrProvider;
        this.type = "static";
      }
      await this.loadToken();
    };
    this.reset = () => {
      this.token = void 0;
      this.tokenProvider = void 0;
      this.type = "static";
      this.user = void 0;
      this.loadTokenPromise = null;
    };
    this.validateToken = (tokenOrProvider) => {
      if (this.user && this.isAnonymous && !tokenOrProvider)
        return;
      if (!this.secret && !tokenOrProvider) {
        throw new Error("User token can not be empty");
      }
      if (typeof tokenOrProvider !== "string" && !isFunction2(tokenOrProvider)) {
        throw new Error("User token should either be a string or a function");
      }
      if (typeof tokenOrProvider === "string") {
        if (this.isAnonymous && tokenOrProvider === "")
          return;
        const tokenUserId = getUserFromToken(tokenOrProvider);
        if (tokenOrProvider != null && (tokenUserId == null || tokenUserId === "" || !this.isAnonymous && tokenUserId !== this.user.id)) {
          throw new Error("userToken does not have a user_id or is not matching with user.id");
        }
      }
    };
    this.tokenReady = () => this.loadTokenPromise;
    this.loadToken = () => {
      this.loadTokenPromise = new Promise(async (resolve, reject) => {
        if (this.type === "static") {
          return resolve(this.token);
        }
        if (this.tokenProvider && typeof this.tokenProvider !== "string") {
          try {
            const token = await this.tokenProvider();
            this.validateToken(token);
            this.token = token;
          } catch (e) {
            return reject(new Error(`Call to tokenProvider failed with message: ${e}`));
          }
          resolve(this.token);
        }
      });
      return this.loadTokenPromise;
    };
    this.getToken = () => {
      if (this.token) {
        return this.token;
      }
      if (this.user && !this.token) {
        return this.token;
      }
      throw new Error(`User token is not set. Either client.connectUser wasn't called or client.disconnect was called`);
    };
    this.isStatic = () => this.type === "static";
    this.secret = secret;
  }
};
var getLocationHint = async (hintUrl = `https://hint.stream-io-video.com/`, timeout2 = 2e3, maxAttempts = 3) => {
  const logger2 = getLogger(["location-hint"]);
  let attempt = 0;
  let locationHint = "ERR";
  do {
    const abortController = new AbortController();
    const timeoutId = setTimeout(() => abortController.abort(), timeout2);
    try {
      const response = await fetch(hintUrl, {
        method: "HEAD",
        signal: abortController.signal
      });
      const awsPop = response.headers.get("x-amz-cf-pop") || "ERR";
      logger2("debug", `Location header: ${awsPop}`);
      locationHint = awsPop.substring(0, 3);
    } catch (e) {
      logger2("warn", `Failed to get location hint from ${hintUrl}`, e);
      locationHint = "ERR";
    } finally {
      clearTimeout(timeoutId);
    }
  } while (locationHint === "ERR" && ++attempt < maxAttempts);
  return locationHint;
};
var StreamClient = class {
  /**
   * Initialize a client.
   *
   * @param {string} key - the api key
   * @param {StreamClientOptions} [options] - additional options, here you can pass custom options to axios instance
   * @param {string} [options.secret] - the api secret
   * @param {boolean} [options.browser] - enforce the client to be in browser mode
   * @param {boolean} [options.warmUp] - default to false, if true, client will open a connection as soon as possible to speed up following requests
   * @param {Logger} [options.Logger] - custom logger
   * @param {number} [options.timeout] - default to 3000
   * @param {httpsAgent} [options.httpsAgent] - custom httpsAgent, in node it's default to https.agent()
   */
  constructor(key, options) {
    var _a;
    this.listeners = {};
    this.getAuthType = () => {
      return this.anonymous ? "anonymous" : "jwt";
    };
    this.setBaseURL = (baseURL) => {
      this.baseURL = baseURL;
      this.wsBaseURL = this.baseURL.replace("http", "ws").replace(":3030", ":8800");
    };
    this.getLocationHint = async (hintUrl, timeout2) => {
      const hint = await this.locationHint;
      if (!hint || hint === "ERR") {
        this.locationHint = getLocationHint(hintUrl ?? this.options.locationHintUrl, timeout2 ?? this.options.locationHintTimeout);
        return this.locationHint;
      }
      return hint;
    };
    this._getConnectionID = () => {
      var _a2;
      return (_a2 = this.wsConnection) == null ? void 0 : _a2.connectionID;
    };
    this._hasConnectionID = () => Boolean(this._getConnectionID());
    this.connectUser = async (user, tokenOrProvider) => {
      if (!user.id) {
        throw new Error('The "id" field on the user is missing');
      }
      if (this.userID === user.id && this.connectUserTask) {
        this.logger("warn", "Consecutive calls to connectUser is detected, ideally you should only call this function once in your app.");
        return this.connectUserTask;
      }
      if (this.userID) {
        throw new Error("Use client.disconnect() before trying to connect as a different user. connectUser was called twice.");
      }
      if ((this.secret || this.node) && !this.options.allowServerSideConnect) {
        this.logger("warn", "Please do not use connectUser server side. Use our @stream-io/node-sdk instead: https://getstream.io/video/docs/api/");
      }
      this.userID = user.id;
      this.anonymous = false;
      await this.tokenManager.setTokenOrProvider(tokenOrProvider, user, false);
      this._setUser(user);
      this.connectUserTask = this.openConnection();
      try {
        addConnectionEventListeners(this.updateNetworkConnectionStatus);
        return await this.connectUserTask;
      } catch (err) {
        if (this.persistUserOnConnectionFailure) {
          await this.closeConnection();
        } else {
          await this.disconnectUser();
        }
        throw err;
      }
    };
    this._setUser = (user) => {
      this.user = user;
      this.userID = user.id;
      this._user = { ...user };
    };
    this.closeConnection = async (timeout2) => {
      var _a2;
      await ((_a2 = this.wsConnection) == null ? void 0 : _a2.disconnect(timeout2));
    };
    this.openConnection = async () => {
      var _a2, _b, _c;
      if (!this.userID) {
        throw Error("UserWithId is not set on client, use client.connectUser or client.connectAnonymousUser instead");
      }
      const wsPromise = (_a2 = this.wsPromiseSafe) == null ? void 0 : _a2.call(this);
      if (((_b = this.wsConnection) == null ? void 0 : _b.isConnecting) && wsPromise) {
        this.logger("info", "client:openConnection() - connection already in progress");
        return await wsPromise;
      }
      if (((_c = this.wsConnection) == null ? void 0 : _c.isHealthy) && this._hasConnectionID()) {
        this.logger("info", "client:openConnection() - openConnection called twice, healthy connection already exists");
        return;
      }
      this._setupConnectionIdPromise();
      this.clientID = `${this.userID}--${generateUUIDv4()}`;
      const newWsPromise = this.connect();
      this.wsPromiseSafe = makeSafePromise(newWsPromise);
      return await newWsPromise;
    };
    this.disconnectUser = async (timeout2) => {
      this.logger("info", "client:disconnect() - Disconnecting the client");
      delete this.user;
      delete this._user;
      delete this.userID;
      this.anonymous = false;
      await this.closeConnection(timeout2);
      removeConnectionEventListeners(this.updateNetworkConnectionStatus);
      this.tokenManager.reset();
      this.connectionIdPromiseSafe = void 0;
      this.rejectConnectionId = void 0;
      this.resolveConnectionId = void 0;
    };
    this.connectGuestUser = async (user) => {
      this.guestUserCreatePromise = this.doAxiosRequest("post", "/guest", { user }, { publicEndpoint: true });
      const response = await this.guestUserCreatePromise;
      this.guestUserCreatePromise.finally(() => this.guestUserCreatePromise = void 0);
      return this.connectUser(response.user, response.access_token);
    };
    this.connectAnonymousUser = async (user, tokenOrProvider) => {
      var _a2;
      addConnectionEventListeners(this.updateNetworkConnectionStatus);
      this._setupConnectionIdPromise();
      this.anonymous = true;
      await this.tokenManager.setTokenOrProvider(tokenOrProvider, user, true);
      this._setUser(user);
      (_a2 = this.resolveConnectionId) == null ? void 0 : _a2.call(this);
    };
    this.on = (eventName, callback) => {
      var _a2;
      if (!this.listeners[eventName]) {
        this.listeners[eventName] = [];
      }
      this.logger("debug", `Adding listener for ${eventName} event`);
      (_a2 = this.listeners[eventName]) == null ? void 0 : _a2.push(callback);
      return () => {
        this.off(eventName, callback);
      };
    };
    this.off = (eventName, callback) => {
      var _a2;
      if (!this.listeners[eventName]) {
        this.listeners[eventName] = [];
      }
      this.logger("debug", `Removing listener for ${eventName} event`);
      this.listeners[eventName] = (_a2 = this.listeners[eventName]) == null ? void 0 : _a2.filter((value) => value !== callback);
    };
    this._setupConnectionIdPromise = () => {
      this.connectionIdPromiseSafe = makeSafePromise(new Promise((resolve, reject) => {
        this.resolveConnectionId = resolve;
        this.rejectConnectionId = reject;
      }));
    };
    this._logApiRequest = (type, url, data, config2) => {
      if (getLogLevel() !== "trace")
        return;
      this.logger("trace", `client: ${type} - Request - ${url}`, {
        payload: data,
        config: config2
      });
    };
    this._logApiResponse = (type, url, response) => {
      if (getLogLevel() !== "trace")
        return;
      this.logger("trace", `client:${type} - Response - url: ${url} > status ${response.status}`, {
        response
      });
    };
    this._logApiError = (type, url, error2) => {
      this.logger("error", `client:${type} - Error - url: ${url}`, {
        url,
        error: error2
      });
    };
    this.doAxiosRequest = async (type, url, data, options2 = {}) => {
      var _a2, _b;
      if (!options2.publicEndpoint) {
        await Promise.all([
          this.tokenManager.tokenReady(),
          this.guestUserCreatePromise
        ]);
        try {
          await this.connectionIdPromise;
        } catch {
          await ((_a2 = this.wsConnection) == null ? void 0 : _a2._waitForHealthy());
          await this.connectionIdPromise;
        }
      }
      const requestConfig = this._enrichAxiosOptions(options2);
      try {
        let response;
        this._logApiRequest(type, url, data, requestConfig);
        switch (type) {
          case "get":
            response = await this.axiosInstance.get(url, requestConfig);
            break;
          case "delete":
            response = await this.axiosInstance.delete(url, requestConfig);
            break;
          case "post":
            response = await this.axiosInstance.post(url, data, requestConfig);
            break;
          case "put":
            response = await this.axiosInstance.put(url, data, requestConfig);
            break;
          case "patch":
            response = await this.axiosInstance.patch(url, data, requestConfig);
            break;
          case "options":
            response = await this.axiosInstance.options(url, requestConfig);
            break;
          default:
            throw new Error("Invalid request type");
        }
        this._logApiResponse(type, url, response);
        this.consecutiveFailures = 0;
        return this.handleResponse(response);
      } catch (e) {
        e.client_request_id = (_b = requestConfig.headers) == null ? void 0 : _b["x-client-request-id"];
        this.consecutiveFailures += 1;
        if (e.response) {
          this._logApiError(type, url, e.response);
          if (e.response.data.code === KnownCodes.TOKEN_EXPIRED && !this.tokenManager.isStatic()) {
            if (this.consecutiveFailures > 1) {
              await sleep(retryInterval(this.consecutiveFailures));
            }
            await this.tokenManager.loadToken();
            return await this.doAxiosRequest(type, url, data, options2);
          }
          return this.handleResponse(e.response);
        } else {
          this._logApiError(type, url, e);
          throw e;
        }
      }
    };
    this.get = (url, params) => {
      return this.doAxiosRequest("get", url, null, {
        params
      });
    };
    this.put = (url, data, params) => {
      return this.doAxiosRequest("put", url, data, { params });
    };
    this.post = (url, data, params) => {
      return this.doAxiosRequest("post", url, data, { params });
    };
    this.patch = (url, data, params) => {
      return this.doAxiosRequest("patch", url, data, { params });
    };
    this.delete = (url, params) => {
      return this.doAxiosRequest("delete", url, null, {
        params
      });
    };
    this.errorFromResponse = (response) => {
      const { data, status } = response;
      const err = new ErrorFromResponse();
      err.message = `Stream error code ${data.code}: ${data.message}`;
      err.code = data.code;
      err.unrecoverable = data.unrecoverable;
      err.response = response;
      err.status = status;
      return err;
    };
    this.handleResponse = (response) => {
      const data = response.data;
      if (isErrorResponse(response)) {
        throw this.errorFromResponse(response);
      }
      return data;
    };
    this.dispatchEvent = (event) => {
      this.logger("debug", `Dispatching event: ${event.type}`, event);
      if (!this.listeners)
        return;
      for (const listener of this.listeners.all || []) {
        listener(event);
      }
      for (const listener of this.listeners[event.type] || []) {
        listener(event);
      }
    };
    this.connect = async () => {
      if (!this.userID || !this._user) {
        throw Error("Call connectUser or connectAnonymousUser before starting the connection");
      }
      if (!this.wsBaseURL)
        throw Error("Websocket base url not set");
      if (!this.clientID)
        throw Error("clientID is not set");
      this.wsConnection = new StableWSConnection(this);
      this.logger("info", "StreamClient.connect: this.wsConnection.connect()");
      return await this.wsConnection.connect(this.defaultWSTimeout);
    };
    this.getUserAgent = () => {
      if (!this.cachedUserAgent) {
        const { clientAppIdentifier = {} } = this.options;
        const { sdkName = "js", sdkVersion = "1.20.0", ...extras } = clientAppIdentifier;
        this.cachedUserAgent = [
          `stream-video-${sdkName}-v${sdkVersion}`,
          ...Object.entries(extras).map(([key2, value]) => `${key2}=${value}`),
          `client_bundle=${"browser-esm"}`
        ].join("|");
      }
      return this.cachedUserAgent;
    };
    this._enrichAxiosOptions = (options2 = {
      params: {},
      headers: {},
      config: {}
    }) => {
      var _a2;
      const token = options2.publicEndpoint && !this.user ? void 0 : this._getToken();
      const authorization = token ? { Authorization: token } : void 0;
      if (!((_a2 = options2.headers) == null ? void 0 : _a2["x-client-request-id"])) {
        options2.headers = {
          ...options2.headers,
          "x-client-request-id": generateUUIDv4()
        };
      }
      return {
        params: {
          user_id: this.userID,
          connection_id: this._getConnectionID(),
          api_key: this.key,
          ...options2.params
        },
        headers: {
          ...authorization,
          "stream-auth-type": options2.publicEndpoint && !this.user ? "anonymous" : this.getAuthType(),
          "X-Stream-Client": this.getUserAgent(),
          ...options2.headers
        },
        ...options2.config,
        ...this.options.axiosRequestConfig
      };
    };
    this._getToken = () => {
      if (!this.tokenManager)
        return null;
      return this.tokenManager.getToken();
    };
    this.updateNetworkConnectionStatus = (event) => {
      if (event.type === "offline") {
        this.logger("debug", "device went offline");
        this.dispatchEvent({ type: "network.changed", online: false });
      } else if (event.type === "online") {
        this.logger("debug", "device went online");
        this.dispatchEvent({ type: "network.changed", online: true });
      }
    };
    this.key = key;
    this.secret = options == null ? void 0 : options.secret;
    const inputOptions = options ? options : {
      browser: typeof window !== "undefined"
    };
    this.browser = inputOptions.browser || typeof window !== "undefined";
    this.node = !this.browser;
    if (this.browser) {
      this.locationHint = getLocationHint(options == null ? void 0 : options.locationHintUrl, options == null ? void 0 : options.locationHintTimeout, options == null ? void 0 : options.locationHintMaxAttempts);
    }
    this.options = {
      timeout: 5e3,
      withCredentials: false,
      // making sure cookies are not sent
      ...inputOptions
    };
    if (this.node && !this.options.httpsAgent) {
      this.options.httpsAgent = new https.Agent({
        keepAlive: true,
        keepAliveMsecs: 3e3
      });
    }
    this.setBaseURL(this.options.baseURL || "https://video.stream-io-api.com/video");
    this.axiosInstance = axios_default.create({
      ...this.options,
      baseURL: this.baseURL
    });
    this.wsConnection = null;
    this.wsPromiseSafe = null;
    this.connectUserTask = null;
    this.anonymous = false;
    this.persistUserOnConnectionFailure = (_a = this.options) == null ? void 0 : _a.persistUserOnConnectionFailure;
    this.tokenManager = new TokenManager(this.secret);
    this.consecutiveFailures = 0;
    this.defaultWSTimeout = this.options.defaultWsTimeout ?? 15e3;
    this.logger = isFunction2(inputOptions.logger) ? inputOptions.logger : () => null;
  }
  get connectionIdPromise() {
    var _a;
    return (_a = this.connectionIdPromiseSafe) == null ? void 0 : _a.call(this);
  }
  get isConnectionIsPromisePending() {
    var _a;
    return ((_a = this.connectionIdPromiseSafe) == null ? void 0 : _a.checkPending()) ?? false;
  }
  get wsPromise() {
    var _a;
    return (_a = this.wsPromiseSafe) == null ? void 0 : _a.call(this);
  }
};
var getInstanceKey = (apiKey, user) => {
  return `${apiKey}/${user.id}`;
};
var getClientAppIdentifier = (options) => {
  const appId = (options == null ? void 0 : options.clientAppIdentifier) || {};
  const sdkInfo2 = getSdkInfo();
  if (sdkInfo2) {
    appId.sdkName = SdkType[sdkInfo2.type].toLowerCase();
    appId.sdkVersion = `${sdkInfo2.major}.${sdkInfo2.minor}.${sdkInfo2.patch}`;
  }
  return appId;
};
var createCoordinatorClient = (apiKey, options) => {
  const clientAppIdentifier = getClientAppIdentifier(options);
  const coordinatorLogger = getLogger(["coordinator"]);
  return new StreamClient(apiKey, {
    persistUserOnConnectionFailure: true,
    ...options,
    clientAppIdentifier,
    logger: coordinatorLogger
  });
};
var createTokenOrProvider = (options) => {
  const { token, tokenProvider } = options;
  if (token && tokenProvider) {
    let initialTokenUsed = false;
    return async function wrappedTokenProvider() {
      if (!initialTokenUsed) {
        initialTokenUsed = true;
        return token;
      }
      return tokenProvider();
    };
  }
  return token || tokenProvider;
};
var StreamVideoClient = class _StreamVideoClient {
  constructor(apiKeyOrArgs, opts) {
    this.effectsRegistered = false;
    this.eventHandlersToUnregister = [];
    this.connectionConcurrencyTag = Symbol("connectionConcurrencyTag");
    this.registerClientInstance = (apiKey2, user) => {
      const instanceKey = getInstanceKey(apiKey2, user);
      if (_StreamVideoClient._instances.has(instanceKey)) {
        this.logger("warn", `A StreamVideoClient already exists for ${user.id}; Prefer using getOrCreateInstance method`);
      }
      _StreamVideoClient._instances.set(instanceKey, this);
    };
    this.registerEffects = () => {
      if (this.effectsRegistered)
        return;
      this.eventHandlersToUnregister.push(this.on("connection.changed", (event) => {
        if (!event.online)
          return;
        const callsToReWatch = this.writeableStateStore.calls.filter((call) => call.watching).map((call) => call.cid);
        if (callsToReWatch.length <= 0)
          return;
        this.logger("info", `Rewatching calls ${callsToReWatch.join(", ")}`);
        this.queryCalls({
          watch: true,
          filter_conditions: { cid: { $in: callsToReWatch } },
          sort: [{ field: "cid", direction: 1 }]
        }).catch((err) => {
          this.logger("error", "Failed to re-watch calls", err);
        });
      }));
      this.eventHandlersToUnregister.push(this.on("call.created", (event) => {
        var _a;
        const { call, members } = event;
        if (((_a = this.state.connectedUser) == null ? void 0 : _a.id) === call.created_by.id) {
          this.logger("warn", "Received `call.created` sent by the current user");
          return;
        }
        this.logger("info", `New call created and registered: ${call.cid}`);
        const newCall = new Call({
          streamClient: this.streamClient,
          type: call.type,
          id: call.id,
          members,
          clientStore: this.writeableStateStore
        });
        newCall.state.updateFromCallResponse(call);
        this.writeableStateStore.registerCall(newCall);
      }));
      this.eventHandlersToUnregister.push(this.on("call.ring", async (event) => {
        var _a;
        const { call, members } = event;
        if (((_a = this.state.connectedUser) == null ? void 0 : _a.id) === call.created_by.id) {
          this.logger("debug", "Received `call.ring` sent by the current user so ignoring the event");
          return;
        }
        const theCall = this.writeableStateStore.findCall(call.type, call.id);
        if (theCall) {
          await theCall.updateFromRingingEvent(event);
        } else {
          const newCallInstance = new Call({
            streamClient: this.streamClient,
            type: call.type,
            id: call.id,
            members,
            clientStore: this.writeableStateStore,
            ringing: true
          });
          await newCallInstance.get();
        }
      }));
      this.effectsRegistered = true;
    };
    this.connectUser = async (user, tokenOrProvider) => {
      if (user.type === "anonymous") {
        user.id = "!anon";
        return this.connectAnonymousUser(user, tokenOrProvider);
      }
      const connectUserResponse = await withoutConcurrency(this.connectionConcurrencyTag, async () => {
        const client = this.streamClient;
        const { onConnectUserError, persistUserOnConnectionFailure } = client.options;
        let { maxConnectUserRetries = 5 } = client.options;
        maxConnectUserRetries = Math.max(maxConnectUserRetries, 1);
        const errorQueue = [];
        for (let attempt = 0; attempt < maxConnectUserRetries; attempt++) {
          try {
            this.logger("trace", `Connecting user (${attempt})`, user);
            return user.type === "guest" ? await client.connectGuestUser(user) : await client.connectUser(user, tokenOrProvider);
          } catch (err) {
            this.logger("warn", `Failed to connect a user (${attempt})`, err);
            errorQueue.push(err);
            if (attempt === maxConnectUserRetries - 1) {
              onConnectUserError == null ? void 0 : onConnectUserError(err, errorQueue);
              throw err;
            }
            if (persistUserOnConnectionFailure) {
              await client.disconnectUser();
            }
            await sleep(retryInterval(attempt));
          }
        }
      });
      if (connectUserResponse == null ? void 0 : connectUserResponse.me) {
        this.writeableStateStore.setConnectedUser(connectUserResponse.me);
      }
      this.registerEffects();
      return connectUserResponse;
    };
    this.disconnectUser = async (timeout2) => {
      await withoutConcurrency(this.connectionConcurrencyTag, async () => {
        const { user, key } = this.streamClient;
        if (!user)
          return;
        await this.streamClient.disconnectUser(timeout2);
        if (user.id) {
          _StreamVideoClient._instances.delete(getInstanceKey(key, user));
        }
        this.eventHandlersToUnregister.forEach((unregister) => unregister());
        this.eventHandlersToUnregister = [];
        this.effectsRegistered = false;
        this.writeableStateStore.setConnectedUser(void 0);
      });
    };
    this.on = (eventName, callback) => {
      return this.streamClient.on(eventName, callback);
    };
    this.off = (eventName, callback) => {
      return this.streamClient.off(eventName, callback);
    };
    this.call = (type, id) => {
      return new Call({
        streamClient: this.streamClient,
        id,
        type,
        clientStore: this.writeableStateStore
      });
    };
    this.createGuestUser = async (data) => {
      return this.streamClient.doAxiosRequest("post", "/guest", data, { publicEndpoint: true });
    };
    this.queryCalls = async (data = {}) => {
      const response = await this.streamClient.post("/calls", data);
      const calls = [];
      for (const c of response.calls) {
        const call = new Call({
          streamClient: this.streamClient,
          id: c.call.id,
          type: c.call.type,
          members: c.members,
          ownCapabilities: c.own_capabilities,
          watching: data.watch,
          clientStore: this.writeableStateStore
        });
        call.state.updateFromCallResponse(c.call);
        await call.applyDeviceConfig(c.call.settings, false);
        if (data.watch) {
          await call.setup();
          this.writeableStateStore.registerCall(call);
        }
        calls.push(call);
      }
      return {
        ...response,
        calls
      };
    };
    this.queryCallStats = async (data = {}) => {
      return this.streamClient.post(`/call/stats`, data);
    };
    this.queryAggregateCallStats = async (data = {}) => {
      return this.streamClient.post(`/stats`, data);
    };
    this.edges = async () => {
      return this.streamClient.get(`/edges`);
    };
    this.addDevice = async (id, push_provider, push_provider_name, userID, voip_token) => {
      return await this.streamClient.post("/devices", {
        id,
        push_provider,
        voip_token,
        ...userID != null ? { user_id: userID } : {},
        ...push_provider_name != null ? { push_provider_name } : {}
      });
    };
    this.addVoipDevice = async (id, push_provider, push_provider_name, userID) => {
      return await this.addDevice(id, push_provider, push_provider_name, userID, true);
    };
    this.getDevices = async (userID) => {
      return await this.streamClient.get("/devices", userID ? { user_id: userID } : {});
    };
    this.removeDevice = async (id, userID) => {
      return await this.streamClient.delete("/devices", {
        id,
        ...userID ? { user_id: userID } : {}
      });
    };
    this.onRingingCall = async (call_cid) => {
      let call = this.state.calls.find((c) => c.cid === call_cid && c.ringing);
      if (!call) {
        const [callType, callId] = call_cid.split(":");
        call = new Call({
          streamClient: this.streamClient,
          type: callType,
          id: callId,
          clientStore: this.writeableStateStore,
          ringing: true
        });
        await call.get();
      }
      return call;
    };
    this.connectAnonymousUser = async (user, tokenOrProvider) => {
      return withoutConcurrency(this.connectionConcurrencyTag, () => this.streamClient.connectAnonymousUser(user, tokenOrProvider));
    };
    const apiKey = typeof apiKeyOrArgs === "string" ? apiKeyOrArgs : apiKeyOrArgs.apiKey;
    const clientOptions = typeof apiKeyOrArgs === "string" ? opts : apiKeyOrArgs.options;
    if (clientOptions == null ? void 0 : clientOptions.enableTimerWorker)
      enableTimerWorker();
    const rootLogger = (clientOptions == null ? void 0 : clientOptions.logger) || logToConsole;
    setLogger(rootLogger, (clientOptions == null ? void 0 : clientOptions.logLevel) || "warn");
    this.logger = getLogger(["client"]);
    this.streamClient = createCoordinatorClient(apiKey, clientOptions);
    this.writeableStateStore = new StreamVideoWriteableStateStore();
    this.readOnlyStateStore = new StreamVideoReadOnlyStateStore(this.writeableStateStore);
    if (typeof apiKeyOrArgs !== "string" && apiKeyOrArgs.user) {
      const user = apiKeyOrArgs.user;
      if (user.type === "anonymous")
        user.id = "!anon";
      if (user.id)
        this.registerClientInstance(apiKey, user);
      const tokenOrProvider = createTokenOrProvider(apiKeyOrArgs);
      this.connectUser(user, tokenOrProvider).catch((err) => {
        this.logger("error", "Failed to connect", err);
      });
    }
  }
  /**
   * Gets or creates a StreamVideoClient instance based on the given options.
   */
  static getOrCreateInstance(args) {
    const { apiKey, user, token, tokenProvider } = args;
    if (!user.id && user.type !== "anonymous") {
      throw new Error("user.id is required for a non-anonymous user");
    }
    if (!token && !tokenProvider && user.type !== "anonymous" && user.type !== "guest") {
      throw new Error("tokenProvider or token is required for a authenticated users");
    }
    return _StreamVideoClient._instances.get(getInstanceKey(apiKey, user)) || new _StreamVideoClient(args);
  }
  /**
   * Return the reactive state store, use this if you want to be notified about changes to the client state
   */
  get state() {
    return this.readOnlyStateStore;
  }
};
StreamVideoClient._instances = /* @__PURE__ */ new Map();

// node_modules/@stream-io/video-react-bindings/dist/index.es.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_react = __toESM(require_react());

// node_modules/@stream-io/video-react-bindings/node_modules/i18next/dist/esm/i18next.js
var isString = (obj) => typeof obj === "string";
var defer2 = () => {
  let res;
  let rej;
  const promise = new Promise((resolve, reject) => {
    res = resolve;
    rej = reject;
  });
  promise.resolve = res;
  promise.reject = rej;
  return promise;
};
var makeString = (object) => {
  if (object == null) return "";
  return "" + object;
};
var copy2 = (a, s, t2) => {
  a.forEach((m) => {
    if (s[m]) t2[m] = s[m];
  });
};
var lastOfPathSeparatorRegExp = /###/g;
var cleanKey = (key) => key && key.indexOf("###") > -1 ? key.replace(lastOfPathSeparatorRegExp, ".") : key;
var canNotTraverseDeeper = (object) => !object || isString(object);
var getLastOfPath = (object, path, Empty) => {
  const stack = !isString(path) ? path : path.split(".");
  let stackIndex = 0;
  while (stackIndex < stack.length - 1) {
    if (canNotTraverseDeeper(object)) return {};
    const key = cleanKey(stack[stackIndex]);
    if (!object[key] && Empty) object[key] = new Empty();
    if (Object.prototype.hasOwnProperty.call(object, key)) {
      object = object[key];
    } else {
      object = {};
    }
    ++stackIndex;
  }
  if (canNotTraverseDeeper(object)) return {};
  return {
    obj: object,
    k: cleanKey(stack[stackIndex])
  };
};
var setPath = (object, path, newValue) => {
  const {
    obj,
    k
  } = getLastOfPath(object, path, Object);
  if (obj !== void 0 || path.length === 1) {
    obj[k] = newValue;
    return;
  }
  let e = path[path.length - 1];
  let p = path.slice(0, path.length - 1);
  let last3 = getLastOfPath(object, p, Object);
  while (last3.obj === void 0 && p.length) {
    e = `${p[p.length - 1]}.${e}`;
    p = p.slice(0, p.length - 1);
    last3 = getLastOfPath(object, p, Object);
    if (last3 && last3.obj && typeof last3.obj[`${last3.k}.${e}`] !== "undefined") {
      last3.obj = void 0;
    }
  }
  last3.obj[`${last3.k}.${e}`] = newValue;
};
var pushPath = (object, path, newValue, concat3) => {
  const {
    obj,
    k
  } = getLastOfPath(object, path, Object);
  obj[k] = obj[k] || [];
  obj[k].push(newValue);
};
var getPath = (object, path) => {
  const {
    obj,
    k
  } = getLastOfPath(object, path);
  if (!obj) return void 0;
  return obj[k];
};
var getPathWithDefaults = (data, defaultData, key) => {
  const value = getPath(data, key);
  if (value !== void 0) {
    return value;
  }
  return getPath(defaultData, key);
};
var deepExtend = (target, source, overwrite) => {
  for (const prop in source) {
    if (prop !== "__proto__" && prop !== "constructor") {
      if (prop in target) {
        if (isString(target[prop]) || target[prop] instanceof String || isString(source[prop]) || source[prop] instanceof String) {
          if (overwrite) target[prop] = source[prop];
        } else {
          deepExtend(target[prop], source[prop], overwrite);
        }
      } else {
        target[prop] = source[prop];
      }
    }
  }
  return target;
};
var regexEscape = (str) => str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
var _entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
var escape = (data) => {
  if (isString(data)) {
    return data.replace(/[&<>"'\/]/g, (s) => _entityMap[s]);
  }
  return data;
};
var RegExpCache = class {
  constructor(capacity) {
    this.capacity = capacity;
    this.regExpMap = /* @__PURE__ */ new Map();
    this.regExpQueue = [];
  }
  getRegExp(pattern) {
    const regExpFromCache = this.regExpMap.get(pattern);
    if (regExpFromCache !== void 0) {
      return regExpFromCache;
    }
    const regExpNew = new RegExp(pattern);
    if (this.regExpQueue.length === this.capacity) {
      this.regExpMap.delete(this.regExpQueue.shift());
    }
    this.regExpMap.set(pattern, regExpNew);
    this.regExpQueue.push(pattern);
    return regExpNew;
  }
};
var chars = [" ", ",", "?", "!", ";"];
var looksLikeObjectPathRegExpCache = new RegExpCache(20);
var looksLikeObjectPath = (key, nsSeparator, keySeparator) => {
  nsSeparator = nsSeparator || "";
  keySeparator = keySeparator || "";
  const possibleChars = chars.filter((c) => nsSeparator.indexOf(c) < 0 && keySeparator.indexOf(c) < 0);
  if (possibleChars.length === 0) return true;
  const r = looksLikeObjectPathRegExpCache.getRegExp(`(${possibleChars.map((c) => c === "?" ? "\\?" : c).join("|")})`);
  let matched = !r.test(key);
  if (!matched) {
    const ki = key.indexOf(keySeparator);
    if (ki > 0 && !r.test(key.substring(0, ki))) {
      matched = true;
    }
  }
  return matched;
};
var deepFind = function(obj, path) {
  let keySeparator = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (!obj) return void 0;
  if (obj[path]) return obj[path];
  const tokens = path.split(keySeparator);
  let current = obj;
  for (let i = 0; i < tokens.length; ) {
    if (!current || typeof current !== "object") {
      return void 0;
    }
    let next;
    let nextPath = "";
    for (let j = i; j < tokens.length; ++j) {
      if (j !== i) {
        nextPath += keySeparator;
      }
      nextPath += tokens[j];
      next = current[nextPath];
      if (next !== void 0) {
        if (["string", "number", "boolean"].indexOf(typeof next) > -1 && j < tokens.length - 1) {
          continue;
        }
        i += j - i + 1;
        break;
      }
    }
    current = next;
  }
  return current;
};
var getCleanedCode = (code) => code && code.replace("_", "-");
var consoleLogger = {
  type: "logger",
  log(args) {
    this.output("log", args);
  },
  warn(args) {
    this.output("warn", args);
  },
  error(args) {
    this.output("error", args);
  },
  output(type, args) {
    if (console && console[type]) console[type].apply(console, args);
  }
};
var Logger = class _Logger {
  constructor(concreteLogger) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.init(concreteLogger, options);
  }
  init(concreteLogger) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.prefix = options.prefix || "i18next:";
    this.logger = concreteLogger || consoleLogger;
    this.options = options;
    this.debug = options.debug;
  }
  log() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return this.forward(args, "log", "", true);
  }
  warn() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return this.forward(args, "warn", "", true);
  }
  error() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    return this.forward(args, "error", "");
  }
  deprecate() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    return this.forward(args, "warn", "WARNING DEPRECATED: ", true);
  }
  forward(args, lvl, prefix, debugOnly) {
    if (debugOnly && !this.debug) return null;
    if (isString(args[0])) args[0] = `${prefix}${this.prefix} ${args[0]}`;
    return this.logger[lvl](args);
  }
  create(moduleName) {
    return new _Logger(this.logger, {
      ...{
        prefix: `${this.prefix}:${moduleName}:`
      },
      ...this.options
    });
  }
  clone(options) {
    options = options || this.options;
    options.prefix = options.prefix || this.prefix;
    return new _Logger(this.logger, options);
  }
};
var baseLogger = new Logger();
var EventEmitter = class {
  constructor() {
    this.observers = {};
  }
  on(events2, listener) {
    events2.split(" ").forEach((event) => {
      if (!this.observers[event]) this.observers[event] = /* @__PURE__ */ new Map();
      const numListeners = this.observers[event].get(listener) || 0;
      this.observers[event].set(listener, numListeners + 1);
    });
    return this;
  }
  off(event, listener) {
    if (!this.observers[event]) return;
    if (!listener) {
      delete this.observers[event];
      return;
    }
    this.observers[event].delete(listener);
  }
  emit(event) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    if (this.observers[event]) {
      const cloned = Array.from(this.observers[event].entries());
      cloned.forEach((_ref) => {
        let [observer, numTimesAdded] = _ref;
        for (let i = 0; i < numTimesAdded; i++) {
          observer(...args);
        }
      });
    }
    if (this.observers["*"]) {
      const cloned = Array.from(this.observers["*"].entries());
      cloned.forEach((_ref2) => {
        let [observer, numTimesAdded] = _ref2;
        for (let i = 0; i < numTimesAdded; i++) {
          observer.apply(observer, [event, ...args]);
        }
      });
    }
  }
};
var ResourceStore = class extends EventEmitter {
  constructor(data) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    super();
    this.data = data || {};
    this.options = options;
    if (this.options.keySeparator === void 0) {
      this.options.keySeparator = ".";
    }
    if (this.options.ignoreJSONStructure === void 0) {
      this.options.ignoreJSONStructure = true;
    }
  }
  addNamespaces(ns) {
    if (this.options.ns.indexOf(ns) < 0) {
      this.options.ns.push(ns);
    }
  }
  removeNamespaces(ns) {
    const index3 = this.options.ns.indexOf(ns);
    if (index3 > -1) {
      this.options.ns.splice(index3, 1);
    }
  }
  getResource(lng, ns, key) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    const ignoreJSONStructure = options.ignoreJSONStructure !== void 0 ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;
    let path;
    if (lng.indexOf(".") > -1) {
      path = lng.split(".");
    } else {
      path = [lng, ns];
      if (key) {
        if (Array.isArray(key)) {
          path.push(...key);
        } else if (isString(key) && keySeparator) {
          path.push(...key.split(keySeparator));
        } else {
          path.push(key);
        }
      }
    }
    const result = getPath(this.data, path);
    if (!result && !ns && !key && lng.indexOf(".") > -1) {
      lng = path[0];
      ns = path[1];
      key = path.slice(2).join(".");
    }
    if (result || !ignoreJSONStructure || !isString(key)) return result;
    return deepFind(this.data && this.data[lng] && this.data[lng][ns], key, keySeparator);
  }
  addResource(lng, ns, key, value) {
    let options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
      silent: false
    };
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    let path = [lng, ns];
    if (key) path = path.concat(keySeparator ? key.split(keySeparator) : key);
    if (lng.indexOf(".") > -1) {
      path = lng.split(".");
      value = ns;
      ns = path[1];
    }
    this.addNamespaces(ns);
    setPath(this.data, path, value);
    if (!options.silent) this.emit("added", lng, ns, key, value);
  }
  addResources(lng, ns, resources) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
      silent: false
    };
    for (const m in resources) {
      if (isString(resources[m]) || Array.isArray(resources[m])) this.addResource(lng, ns, m, resources[m], {
        silent: true
      });
    }
    if (!options.silent) this.emit("added", lng, ns, resources);
  }
  addResourceBundle(lng, ns, resources, deep, overwrite) {
    let options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
      silent: false,
      skipCopy: false
    };
    let path = [lng, ns];
    if (lng.indexOf(".") > -1) {
      path = lng.split(".");
      deep = resources;
      resources = ns;
      ns = path[1];
    }
    this.addNamespaces(ns);
    let pack = getPath(this.data, path) || {};
    if (!options.skipCopy) resources = JSON.parse(JSON.stringify(resources));
    if (deep) {
      deepExtend(pack, resources, overwrite);
    } else {
      pack = {
        ...pack,
        ...resources
      };
    }
    setPath(this.data, path, pack);
    if (!options.silent) this.emit("added", lng, ns, resources);
  }
  removeResourceBundle(lng, ns) {
    if (this.hasResourceBundle(lng, ns)) {
      delete this.data[lng][ns];
    }
    this.removeNamespaces(ns);
    this.emit("removed", lng, ns);
  }
  hasResourceBundle(lng, ns) {
    return this.getResource(lng, ns) !== void 0;
  }
  getResourceBundle(lng, ns) {
    if (!ns) ns = this.options.defaultNS;
    if (this.options.compatibilityAPI === "v1") return {
      ...{},
      ...this.getResource(lng, ns)
    };
    return this.getResource(lng, ns);
  }
  getDataByLanguage(lng) {
    return this.data[lng];
  }
  hasLanguageSomeTranslations(lng) {
    const data = this.getDataByLanguage(lng);
    const n = data && Object.keys(data) || [];
    return !!n.find((v) => data[v] && Object.keys(data[v]).length > 0);
  }
  toJSON() {
    return this.data;
  }
};
var postProcessor = {
  processors: {},
  addPostProcessor(module) {
    this.processors[module.name] = module;
  },
  handle(processors, value, key, options, translator) {
    processors.forEach((processor) => {
      if (this.processors[processor]) value = this.processors[processor].process(value, key, options, translator);
    });
    return value;
  }
};
var checkedLoadedFor = {};
var Translator = class _Translator extends EventEmitter {
  constructor(services) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super();
    copy2(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], services, this);
    this.options = options;
    if (this.options.keySeparator === void 0) {
      this.options.keySeparator = ".";
    }
    this.logger = baseLogger.create("translator");
  }
  changeLanguage(lng) {
    if (lng) this.language = lng;
  }
  exists(key) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    };
    if (key === void 0 || key === null) {
      return false;
    }
    const resolved2 = this.resolve(key, options);
    return resolved2 && resolved2.res !== void 0;
  }
  extractFromKey(key, options) {
    let nsSeparator = options.nsSeparator !== void 0 ? options.nsSeparator : this.options.nsSeparator;
    if (nsSeparator === void 0) nsSeparator = ":";
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    let namespaces = options.ns || this.options.defaultNS || [];
    const wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;
    const seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !options.keySeparator && !this.options.userDefinedNsSeparator && !options.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);
    if (wouldCheckForNsInKey && !seemsNaturalLanguage) {
      const m = key.match(this.interpolator.nestingRegexp);
      if (m && m.length > 0) {
        return {
          key,
          namespaces: isString(namespaces) ? [namespaces] : namespaces
        };
      }
      const parts = key.split(nsSeparator);
      if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();
      key = parts.join(keySeparator);
    }
    return {
      key,
      namespaces: isString(namespaces) ? [namespaces] : namespaces
    };
  }
  translate(keys, options, lastKey) {
    if (typeof options !== "object" && this.options.overloadTranslationOptionHandler) {
      options = this.options.overloadTranslationOptionHandler(arguments);
    }
    if (typeof options === "object") options = {
      ...options
    };
    if (!options) options = {};
    if (keys === void 0 || keys === null) return "";
    if (!Array.isArray(keys)) keys = [String(keys)];
    const returnDetails = options.returnDetails !== void 0 ? options.returnDetails : this.options.returnDetails;
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    const {
      key,
      namespaces
    } = this.extractFromKey(keys[keys.length - 1], options);
    const namespace = namespaces[namespaces.length - 1];
    const lng = options.lng || this.language;
    const appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
    if (lng && lng.toLowerCase() === "cimode") {
      if (appendNamespaceToCIMode) {
        const nsSeparator = options.nsSeparator || this.options.nsSeparator;
        if (returnDetails) {
          return {
            res: `${namespace}${nsSeparator}${key}`,
            usedKey: key,
            exactUsedKey: key,
            usedLng: lng,
            usedNS: namespace,
            usedParams: this.getUsedParamsDetails(options)
          };
        }
        return `${namespace}${nsSeparator}${key}`;
      }
      if (returnDetails) {
        return {
          res: key,
          usedKey: key,
          exactUsedKey: key,
          usedLng: lng,
          usedNS: namespace,
          usedParams: this.getUsedParamsDetails(options)
        };
      }
      return key;
    }
    const resolved2 = this.resolve(keys, options);
    let res = resolved2 && resolved2.res;
    const resUsedKey = resolved2 && resolved2.usedKey || key;
    const resExactUsedKey = resolved2 && resolved2.exactUsedKey || key;
    const resType = Object.prototype.toString.apply(res);
    const noObject = ["[object Number]", "[object Function]", "[object RegExp]"];
    const joinArrays = options.joinArrays !== void 0 ? options.joinArrays : this.options.joinArrays;
    const handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
    const handleAsObject = !isString(res) && typeof res !== "boolean" && typeof res !== "number";
    if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(isString(joinArrays) && Array.isArray(res))) {
      if (!options.returnObjects && !this.options.returnObjects) {
        if (!this.options.returnedObjectHandler) {
          this.logger.warn("accessing an object - but returnObjects options is not enabled!");
        }
        const r = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, {
          ...options,
          ns: namespaces
        }) : `key '${key} (${this.language})' returned an object instead of string.`;
        if (returnDetails) {
          resolved2.res = r;
          resolved2.usedParams = this.getUsedParamsDetails(options);
          return resolved2;
        }
        return r;
      }
      if (keySeparator) {
        const resTypeIsArray = Array.isArray(res);
        const copy3 = resTypeIsArray ? [] : {};
        const newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
        for (const m in res) {
          if (Object.prototype.hasOwnProperty.call(res, m)) {
            const deepKey = `${newKeyToUse}${keySeparator}${m}`;
            copy3[m] = this.translate(deepKey, {
              ...options,
              ...{
                joinArrays: false,
                ns: namespaces
              }
            });
            if (copy3[m] === deepKey) copy3[m] = res[m];
          }
        }
        res = copy3;
      }
    } else if (handleAsObjectInI18nFormat && isString(joinArrays) && Array.isArray(res)) {
      res = res.join(joinArrays);
      if (res) res = this.extendTranslation(res, keys, options, lastKey);
    } else {
      let usedDefault = false;
      let usedKey = false;
      const needsPluralHandling = options.count !== void 0 && !isString(options.count);
      const hasDefaultValue = _Translator.hasDefaultValue(options);
      const defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, options) : "";
      const defaultValueSuffixOrdinalFallback = options.ordinal && needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, {
        ordinal: false
      }) : "";
      const needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && this.pluralResolver.shouldUseIntlApi();
      const defaultValue = needsZeroSuffixLookup && options[`defaultValue${this.options.pluralSeparator}zero`] || options[`defaultValue${defaultValueSuffix}`] || options[`defaultValue${defaultValueSuffixOrdinalFallback}`] || options.defaultValue;
      if (!this.isValidLookup(res) && hasDefaultValue) {
        usedDefault = true;
        res = defaultValue;
      }
      if (!this.isValidLookup(res)) {
        usedKey = true;
        res = key;
      }
      const missingKeyNoValueFallbackToKey = options.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;
      const resForMissing = missingKeyNoValueFallbackToKey && usedKey ? void 0 : res;
      const updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
      if (usedKey || usedDefault || updateMissing) {
        this.logger.log(updateMissing ? "updateKey" : "missingKey", lng, namespace, key, updateMissing ? defaultValue : res);
        if (keySeparator) {
          const fk = this.resolve(key, {
            ...options,
            keySeparator: false
          });
          if (fk && fk.res) this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
        }
        let lngs = [];
        const fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);
        if (this.options.saveMissingTo === "fallback" && fallbackLngs && fallbackLngs[0]) {
          for (let i = 0; i < fallbackLngs.length; i++) {
            lngs.push(fallbackLngs[i]);
          }
        } else if (this.options.saveMissingTo === "all") {
          lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);
        } else {
          lngs.push(options.lng || this.language);
        }
        const send = (l, k, specificDefaultValue) => {
          const defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;
          if (this.options.missingKeyHandler) {
            this.options.missingKeyHandler(l, namespace, k, defaultForMissing, updateMissing, options);
          } else if (this.backendConnector && this.backendConnector.saveMissing) {
            this.backendConnector.saveMissing(l, namespace, k, defaultForMissing, updateMissing, options);
          }
          this.emit("missingKey", l, namespace, k, res);
        };
        if (this.options.saveMissing) {
          if (this.options.saveMissingPlurals && needsPluralHandling) {
            lngs.forEach((language) => {
              const suffixes = this.pluralResolver.getSuffixes(language, options);
              if (needsZeroSuffixLookup && options[`defaultValue${this.options.pluralSeparator}zero`] && suffixes.indexOf(`${this.options.pluralSeparator}zero`) < 0) {
                suffixes.push(`${this.options.pluralSeparator}zero`);
              }
              suffixes.forEach((suffix) => {
                send([language], key + suffix, options[`defaultValue${suffix}`] || defaultValue);
              });
            });
          } else {
            send(lngs, key, defaultValue);
          }
        }
      }
      res = this.extendTranslation(res, keys, options, resolved2, lastKey);
      if (usedKey && res === key && this.options.appendNamespaceToMissingKey) res = `${namespace}:${key}`;
      if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {
        if (this.options.compatibilityAPI !== "v1") {
          res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${namespace}:${key}` : key, usedDefault ? res : void 0);
        } else {
          res = this.options.parseMissingKeyHandler(res);
        }
      }
    }
    if (returnDetails) {
      resolved2.res = res;
      resolved2.usedParams = this.getUsedParamsDetails(options);
      return resolved2;
    }
    return res;
  }
  extendTranslation(res, key, options, resolved2, lastKey) {
    var _this = this;
    if (this.i18nFormat && this.i18nFormat.parse) {
      res = this.i18nFormat.parse(res, {
        ...this.options.interpolation.defaultVariables,
        ...options
      }, options.lng || this.language || resolved2.usedLng, resolved2.usedNS, resolved2.usedKey, {
        resolved: resolved2
      });
    } else if (!options.skipInterpolation) {
      if (options.interpolation) this.interpolator.init({
        ...options,
        ...{
          interpolation: {
            ...this.options.interpolation,
            ...options.interpolation
          }
        }
      });
      const skipOnVariables = isString(res) && (options && options.interpolation && options.interpolation.skipOnVariables !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
      let nestBef;
      if (skipOnVariables) {
        const nb = res.match(this.interpolator.nestingRegexp);
        nestBef = nb && nb.length;
      }
      let data = options.replace && !isString(options.replace) ? options.replace : options;
      if (this.options.interpolation.defaultVariables) data = {
        ...this.options.interpolation.defaultVariables,
        ...data
      };
      res = this.interpolator.interpolate(res, data, options.lng || this.language || resolved2.usedLng, options);
      if (skipOnVariables) {
        const na = res.match(this.interpolator.nestingRegexp);
        const nestAft = na && na.length;
        if (nestBef < nestAft) options.nest = false;
      }
      if (!options.lng && this.options.compatibilityAPI !== "v1" && resolved2 && resolved2.res) options.lng = this.language || resolved2.usedLng;
      if (options.nest !== false) res = this.interpolator.nest(res, function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        if (lastKey && lastKey[0] === args[0] && !options.context) {
          _this.logger.warn(`It seems you are nesting recursively key: ${args[0]} in key: ${key[0]}`);
          return null;
        }
        return _this.translate(...args, key);
      }, options);
      if (options.interpolation) this.interpolator.reset();
    }
    const postProcess = options.postProcess || this.options.postProcess;
    const postProcessorNames = isString(postProcess) ? [postProcess] : postProcess;
    if (res !== void 0 && res !== null && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false) {
      res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? {
        i18nResolved: {
          ...resolved2,
          usedParams: this.getUsedParamsDetails(options)
        },
        ...options
      } : options, this);
    }
    return res;
  }
  resolve(keys) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let found;
    let usedKey;
    let exactUsedKey;
    let usedLng;
    let usedNS;
    if (isString(keys)) keys = [keys];
    keys.forEach((k) => {
      if (this.isValidLookup(found)) return;
      const extracted = this.extractFromKey(k, options);
      const key = extracted.key;
      usedKey = key;
      let namespaces = extracted.namespaces;
      if (this.options.fallbackNS) namespaces = namespaces.concat(this.options.fallbackNS);
      const needsPluralHandling = options.count !== void 0 && !isString(options.count);
      const needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && this.pluralResolver.shouldUseIntlApi();
      const needsContextHandling = options.context !== void 0 && (isString(options.context) || typeof options.context === "number") && options.context !== "";
      const codes = options.lngs ? options.lngs : this.languageUtils.toResolveHierarchy(options.lng || this.language, options.fallbackLng);
      namespaces.forEach((ns) => {
        if (this.isValidLookup(found)) return;
        usedNS = ns;
        if (!checkedLoadedFor[`${codes[0]}-${ns}`] && this.utils && this.utils.hasLoadedNamespace && !this.utils.hasLoadedNamespace(usedNS)) {
          checkedLoadedFor[`${codes[0]}-${ns}`] = true;
          this.logger.warn(`key "${usedKey}" for languages "${codes.join(", ")}" won't get resolved as namespace "${usedNS}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
        }
        codes.forEach((code) => {
          if (this.isValidLookup(found)) return;
          usedLng = code;
          const finalKeys = [key];
          if (this.i18nFormat && this.i18nFormat.addLookupKeys) {
            this.i18nFormat.addLookupKeys(finalKeys, key, code, ns, options);
          } else {
            let pluralSuffix;
            if (needsPluralHandling) pluralSuffix = this.pluralResolver.getSuffix(code, options.count, options);
            const zeroSuffix = `${this.options.pluralSeparator}zero`;
            const ordinalPrefix = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
            if (needsPluralHandling) {
              finalKeys.push(key + pluralSuffix);
              if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                finalKeys.push(key + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
              }
              if (needsZeroSuffixLookup) {
                finalKeys.push(key + zeroSuffix);
              }
            }
            if (needsContextHandling) {
              const contextKey = `${key}${this.options.contextSeparator}${options.context}`;
              finalKeys.push(contextKey);
              if (needsPluralHandling) {
                finalKeys.push(contextKey + pluralSuffix);
                if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                  finalKeys.push(contextKey + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
                }
                if (needsZeroSuffixLookup) {
                  finalKeys.push(contextKey + zeroSuffix);
                }
              }
            }
          }
          let possibleKey;
          while (possibleKey = finalKeys.pop()) {
            if (!this.isValidLookup(found)) {
              exactUsedKey = possibleKey;
              found = this.getResource(code, ns, possibleKey, options);
            }
          }
        });
      });
    });
    return {
      res: found,
      usedKey,
      exactUsedKey,
      usedLng,
      usedNS
    };
  }
  isValidLookup(res) {
    return res !== void 0 && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === "");
  }
  getResource(code, ns, key) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    if (this.i18nFormat && this.i18nFormat.getResource) return this.i18nFormat.getResource(code, ns, key, options);
    return this.resourceStore.getResource(code, ns, key, options);
  }
  getUsedParamsDetails() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const optionsKeys = ["defaultValue", "ordinal", "context", "replace", "lng", "lngs", "fallbackLng", "ns", "keySeparator", "nsSeparator", "returnObjects", "returnDetails", "joinArrays", "postProcess", "interpolation"];
    const useOptionsReplaceForData = options.replace && !isString(options.replace);
    let data = useOptionsReplaceForData ? options.replace : options;
    if (useOptionsReplaceForData && typeof options.count !== "undefined") {
      data.count = options.count;
    }
    if (this.options.interpolation.defaultVariables) {
      data = {
        ...this.options.interpolation.defaultVariables,
        ...data
      };
    }
    if (!useOptionsReplaceForData) {
      data = {
        ...data
      };
      for (const key of optionsKeys) {
        delete data[key];
      }
    }
    return data;
  }
  static hasDefaultValue(options) {
    const prefix = "defaultValue";
    for (const option in options) {
      if (Object.prototype.hasOwnProperty.call(options, option) && prefix === option.substring(0, prefix.length) && void 0 !== options[option]) {
        return true;
      }
    }
    return false;
  }
};
var capitalize = (string) => string.charAt(0).toUpperCase() + string.slice(1);
var LanguageUtil = class {
  constructor(options) {
    this.options = options;
    this.supportedLngs = this.options.supportedLngs || false;
    this.logger = baseLogger.create("languageUtils");
  }
  getScriptPartFromCode(code) {
    code = getCleanedCode(code);
    if (!code || code.indexOf("-") < 0) return null;
    const p = code.split("-");
    if (p.length === 2) return null;
    p.pop();
    if (p[p.length - 1].toLowerCase() === "x") return null;
    return this.formatLanguageCode(p.join("-"));
  }
  getLanguagePartFromCode(code) {
    code = getCleanedCode(code);
    if (!code || code.indexOf("-") < 0) return code;
    const p = code.split("-");
    return this.formatLanguageCode(p[0]);
  }
  formatLanguageCode(code) {
    if (isString(code) && code.indexOf("-") > -1) {
      if (typeof Intl !== "undefined" && typeof Intl.getCanonicalLocales !== "undefined") {
        try {
          let formattedCode = Intl.getCanonicalLocales(code)[0];
          if (formattedCode && this.options.lowerCaseLng) {
            formattedCode = formattedCode.toLowerCase();
          }
          if (formattedCode) return formattedCode;
        } catch (e) {
        }
      }
      const specialCases = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
      let p = code.split("-");
      if (this.options.lowerCaseLng) {
        p = p.map((part) => part.toLowerCase());
      } else if (p.length === 2) {
        p[0] = p[0].toLowerCase();
        p[1] = p[1].toUpperCase();
        if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());
      } else if (p.length === 3) {
        p[0] = p[0].toLowerCase();
        if (p[1].length === 2) p[1] = p[1].toUpperCase();
        if (p[0] !== "sgn" && p[2].length === 2) p[2] = p[2].toUpperCase();
        if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());
        if (specialCases.indexOf(p[2].toLowerCase()) > -1) p[2] = capitalize(p[2].toLowerCase());
      }
      return p.join("-");
    }
    return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
  }
  isSupportedCode(code) {
    if (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) {
      code = this.getLanguagePartFromCode(code);
    }
    return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;
  }
  getBestMatchFromCodes(codes) {
    if (!codes) return null;
    let found;
    codes.forEach((code) => {
      if (found) return;
      const cleanedLng = this.formatLanguageCode(code);
      if (!this.options.supportedLngs || this.isSupportedCode(cleanedLng)) found = cleanedLng;
    });
    if (!found && this.options.supportedLngs) {
      codes.forEach((code) => {
        if (found) return;
        const lngOnly = this.getLanguagePartFromCode(code);
        if (this.isSupportedCode(lngOnly)) return found = lngOnly;
        found = this.options.supportedLngs.find((supportedLng) => {
          if (supportedLng === lngOnly) return supportedLng;
          if (supportedLng.indexOf("-") < 0 && lngOnly.indexOf("-") < 0) return;
          if (supportedLng.indexOf("-") > 0 && lngOnly.indexOf("-") < 0 && supportedLng.substring(0, supportedLng.indexOf("-")) === lngOnly) return supportedLng;
          if (supportedLng.indexOf(lngOnly) === 0 && lngOnly.length > 1) return supportedLng;
        });
      });
    }
    if (!found) found = this.getFallbackCodes(this.options.fallbackLng)[0];
    return found;
  }
  getFallbackCodes(fallbacks, code) {
    if (!fallbacks) return [];
    if (typeof fallbacks === "function") fallbacks = fallbacks(code);
    if (isString(fallbacks)) fallbacks = [fallbacks];
    if (Array.isArray(fallbacks)) return fallbacks;
    if (!code) return fallbacks.default || [];
    let found = fallbacks[code];
    if (!found) found = fallbacks[this.getScriptPartFromCode(code)];
    if (!found) found = fallbacks[this.formatLanguageCode(code)];
    if (!found) found = fallbacks[this.getLanguagePartFromCode(code)];
    if (!found) found = fallbacks.default;
    return found || [];
  }
  toResolveHierarchy(code, fallbackCode) {
    const fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);
    const codes = [];
    const addCode = (c) => {
      if (!c) return;
      if (this.isSupportedCode(c)) {
        codes.push(c);
      } else {
        this.logger.warn(`rejecting language code not found in supportedLngs: ${c}`);
      }
    };
    if (isString(code) && (code.indexOf("-") > -1 || code.indexOf("_") > -1)) {
      if (this.options.load !== "languageOnly") addCode(this.formatLanguageCode(code));
      if (this.options.load !== "languageOnly" && this.options.load !== "currentOnly") addCode(this.getScriptPartFromCode(code));
      if (this.options.load !== "currentOnly") addCode(this.getLanguagePartFromCode(code));
    } else if (isString(code)) {
      addCode(this.formatLanguageCode(code));
    }
    fallbackCodes.forEach((fc) => {
      if (codes.indexOf(fc) < 0) addCode(this.formatLanguageCode(fc));
    });
    return codes;
  }
};
var sets = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he", "iw"],
  nr: [1, 2, 20, 21],
  fc: 22
}];
var _rulesPluralsTypes = {
  1: (n) => Number(n > 1),
  2: (n) => Number(n != 1),
  3: (n) => 0,
  4: (n) => Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2),
  5: (n) => Number(n == 0 ? 0 : n == 1 ? 1 : n == 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5),
  6: (n) => Number(n == 1 ? 0 : n >= 2 && n <= 4 ? 1 : 2),
  7: (n) => Number(n == 1 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2),
  8: (n) => Number(n == 1 ? 0 : n == 2 ? 1 : n != 8 && n != 11 ? 2 : 3),
  9: (n) => Number(n >= 2),
  10: (n) => Number(n == 1 ? 0 : n == 2 ? 1 : n < 7 ? 2 : n < 11 ? 3 : 4),
  11: (n) => Number(n == 1 || n == 11 ? 0 : n == 2 || n == 12 ? 1 : n > 2 && n < 20 ? 2 : 3),
  12: (n) => Number(n % 10 != 1 || n % 100 == 11),
  13: (n) => Number(n !== 0),
  14: (n) => Number(n == 1 ? 0 : n == 2 ? 1 : n == 3 ? 2 : 3),
  15: (n) => Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2),
  16: (n) => Number(n % 10 == 1 && n % 100 != 11 ? 0 : n !== 0 ? 1 : 2),
  17: (n) => Number(n == 1 || n % 10 == 1 && n % 100 != 11 ? 0 : 1),
  18: (n) => Number(n == 0 ? 0 : n == 1 ? 1 : 2),
  19: (n) => Number(n == 1 ? 0 : n == 0 || n % 100 > 1 && n % 100 < 11 ? 1 : n % 100 > 10 && n % 100 < 20 ? 2 : 3),
  20: (n) => Number(n == 1 ? 0 : n == 0 || n % 100 > 0 && n % 100 < 20 ? 1 : 2),
  21: (n) => Number(n % 100 == 1 ? 1 : n % 100 == 2 ? 2 : n % 100 == 3 || n % 100 == 4 ? 3 : 0),
  22: (n) => Number(n == 1 ? 0 : n == 2 ? 1 : (n < 0 || n > 10) && n % 10 == 0 ? 2 : 3)
};
var nonIntlVersions = ["v1", "v2", "v3"];
var intlVersions = ["v4"];
var suffixesOrder = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
};
var createRules = () => {
  const rules = {};
  sets.forEach((set) => {
    set.lngs.forEach((l) => {
      rules[l] = {
        numbers: set.nr,
        plurals: _rulesPluralsTypes[set.fc]
      };
    });
  });
  return rules;
};
var PluralResolver = class {
  constructor(languageUtils) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.languageUtils = languageUtils;
    this.options = options;
    this.logger = baseLogger.create("pluralResolver");
    if ((!this.options.compatibilityJSON || intlVersions.includes(this.options.compatibilityJSON)) && (typeof Intl === "undefined" || !Intl.PluralRules)) {
      this.options.compatibilityJSON = "v3";
      this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.");
    }
    this.rules = createRules();
    this.pluralRulesCache = {};
  }
  addRule(lng, obj) {
    this.rules[lng] = obj;
  }
  clearCache() {
    this.pluralRulesCache = {};
  }
  getRule(code) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (this.shouldUseIntlApi()) {
      const cleanedCode = getCleanedCode(code === "dev" ? "en" : code);
      const type = options.ordinal ? "ordinal" : "cardinal";
      const cacheKey = JSON.stringify({
        cleanedCode,
        type
      });
      if (cacheKey in this.pluralRulesCache) {
        return this.pluralRulesCache[cacheKey];
      }
      let rule;
      try {
        rule = new Intl.PluralRules(cleanedCode, {
          type
        });
      } catch (err) {
        if (!code.match(/-|_/)) return;
        const lngPart = this.languageUtils.getLanguagePartFromCode(code);
        rule = this.getRule(lngPart, options);
      }
      this.pluralRulesCache[cacheKey] = rule;
      return rule;
    }
    return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];
  }
  needsPlural(code) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const rule = this.getRule(code, options);
    if (this.shouldUseIntlApi()) {
      return rule && rule.resolvedOptions().pluralCategories.length > 1;
    }
    return rule && rule.numbers.length > 1;
  }
  getPluralFormsOfKey(code, key) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return this.getSuffixes(code, options).map((suffix) => `${key}${suffix}`);
  }
  getSuffixes(code) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const rule = this.getRule(code, options);
    if (!rule) {
      return [];
    }
    if (this.shouldUseIntlApi()) {
      return rule.resolvedOptions().pluralCategories.sort((pluralCategory1, pluralCategory2) => suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2]).map((pluralCategory) => `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ""}${pluralCategory}`);
    }
    return rule.numbers.map((number) => this.getSuffix(code, number, options));
  }
  getSuffix(code, count3) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const rule = this.getRule(code, options);
    if (rule) {
      if (this.shouldUseIntlApi()) {
        return `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ""}${rule.select(count3)}`;
      }
      return this.getSuffixRetroCompatible(rule, count3);
    }
    this.logger.warn(`no plural rule found for: ${code}`);
    return "";
  }
  getSuffixRetroCompatible(rule, count3) {
    const idx = rule.noAbs ? rule.plurals(count3) : rule.plurals(Math.abs(count3));
    let suffix = rule.numbers[idx];
    if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
      if (suffix === 2) {
        suffix = "plural";
      } else if (suffix === 1) {
        suffix = "";
      }
    }
    const returnSuffix = () => this.options.prepend && suffix.toString() ? this.options.prepend + suffix.toString() : suffix.toString();
    if (this.options.compatibilityJSON === "v1") {
      if (suffix === 1) return "";
      if (typeof suffix === "number") return `_plural_${suffix.toString()}`;
      return returnSuffix();
    } else if (this.options.compatibilityJSON === "v2") {
      return returnSuffix();
    } else if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
      return returnSuffix();
    }
    return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
  }
  shouldUseIntlApi() {
    return !nonIntlVersions.includes(this.options.compatibilityJSON);
  }
};
var deepFindWithDefaults = function(data, defaultData, key) {
  let keySeparator = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : ".";
  let ignoreJSONStructure = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
  let path = getPathWithDefaults(data, defaultData, key);
  if (!path && ignoreJSONStructure && isString(key)) {
    path = deepFind(data, key, keySeparator);
    if (path === void 0) path = deepFind(defaultData, key, keySeparator);
  }
  return path;
};
var regexSafe = (val) => val.replace(/\$/g, "$$$$");
var Interpolator = class {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = baseLogger.create("interpolator");
    this.options = options;
    this.format = options.interpolation && options.interpolation.format || ((value) => value);
    this.init(options);
  }
  init() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!options.interpolation) options.interpolation = {
      escapeValue: true
    };
    const {
      escape: escape$1,
      escapeValue,
      useRawValueToEscape,
      prefix,
      prefixEscaped,
      suffix,
      suffixEscaped,
      formatSeparator,
      unescapeSuffix,
      unescapePrefix,
      nestingPrefix,
      nestingPrefixEscaped,
      nestingSuffix,
      nestingSuffixEscaped,
      nestingOptionsSeparator,
      maxReplaces,
      alwaysFormat
    } = options.interpolation;
    this.escape = escape$1 !== void 0 ? escape$1 : escape;
    this.escapeValue = escapeValue !== void 0 ? escapeValue : true;
    this.useRawValueToEscape = useRawValueToEscape !== void 0 ? useRawValueToEscape : false;
    this.prefix = prefix ? regexEscape(prefix) : prefixEscaped || "{{";
    this.suffix = suffix ? regexEscape(suffix) : suffixEscaped || "}}";
    this.formatSeparator = formatSeparator || ",";
    this.unescapePrefix = unescapeSuffix ? "" : unescapePrefix || "-";
    this.unescapeSuffix = this.unescapePrefix ? "" : unescapeSuffix || "";
    this.nestingPrefix = nestingPrefix ? regexEscape(nestingPrefix) : nestingPrefixEscaped || regexEscape("$t(");
    this.nestingSuffix = nestingSuffix ? regexEscape(nestingSuffix) : nestingSuffixEscaped || regexEscape(")");
    this.nestingOptionsSeparator = nestingOptionsSeparator || ",";
    this.maxReplaces = maxReplaces || 1e3;
    this.alwaysFormat = alwaysFormat !== void 0 ? alwaysFormat : false;
    this.resetRegExp();
  }
  reset() {
    if (this.options) this.init(this.options);
  }
  resetRegExp() {
    const getOrResetRegExp = (existingRegExp, pattern) => {
      if (existingRegExp && existingRegExp.source === pattern) {
        existingRegExp.lastIndex = 0;
        return existingRegExp;
      }
      return new RegExp(pattern, "g");
    };
    this.regexp = getOrResetRegExp(this.regexp, `${this.prefix}(.+?)${this.suffix}`);
    this.regexpUnescape = getOrResetRegExp(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`);
    this.nestingRegexp = getOrResetRegExp(this.nestingRegexp, `${this.nestingPrefix}(.+?)${this.nestingSuffix}`);
  }
  interpolate(str, data, lng, options) {
    let match;
    let value;
    let replaces;
    const defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
    const handleFormat = (key) => {
      if (key.indexOf(this.formatSeparator) < 0) {
        const path = deepFindWithDefaults(data, defaultData, key, this.options.keySeparator, this.options.ignoreJSONStructure);
        return this.alwaysFormat ? this.format(path, void 0, lng, {
          ...options,
          ...data,
          interpolationkey: key
        }) : path;
      }
      const p = key.split(this.formatSeparator);
      const k = p.shift().trim();
      const f = p.join(this.formatSeparator).trim();
      return this.format(deepFindWithDefaults(data, defaultData, k, this.options.keySeparator, this.options.ignoreJSONStructure), f, lng, {
        ...options,
        ...data,
        interpolationkey: k
      });
    };
    this.resetRegExp();
    const missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;
    const skipOnVariables = options && options.interpolation && options.interpolation.skipOnVariables !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
    const todos = [{
      regex: this.regexpUnescape,
      safeValue: (val) => regexSafe(val)
    }, {
      regex: this.regexp,
      safeValue: (val) => this.escapeValue ? regexSafe(this.escape(val)) : regexSafe(val)
    }];
    todos.forEach((todo) => {
      replaces = 0;
      while (match = todo.regex.exec(str)) {
        const matchedVar = match[1].trim();
        value = handleFormat(matchedVar);
        if (value === void 0) {
          if (typeof missingInterpolationHandler === "function") {
            const temp = missingInterpolationHandler(str, match, options);
            value = isString(temp) ? temp : "";
          } else if (options && Object.prototype.hasOwnProperty.call(options, matchedVar)) {
            value = "";
          } else if (skipOnVariables) {
            value = match[0];
            continue;
          } else {
            this.logger.warn(`missed to pass in variable ${matchedVar} for interpolating ${str}`);
            value = "";
          }
        } else if (!isString(value) && !this.useRawValueToEscape) {
          value = makeString(value);
        }
        const safeValue = todo.safeValue(value);
        str = str.replace(match[0], safeValue);
        if (skipOnVariables) {
          todo.regex.lastIndex += value.length;
          todo.regex.lastIndex -= match[0].length;
        } else {
          todo.regex.lastIndex = 0;
        }
        replaces++;
        if (replaces >= this.maxReplaces) {
          break;
        }
      }
    });
    return str;
  }
  nest(str, fc) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let match;
    let value;
    let clonedOptions;
    const handleHasOptions = (key, inheritedOptions) => {
      const sep = this.nestingOptionsSeparator;
      if (key.indexOf(sep) < 0) return key;
      const c = key.split(new RegExp(`${sep}[ ]*{`));
      let optionsString = `{${c[1]}`;
      key = c[0];
      optionsString = this.interpolate(optionsString, clonedOptions);
      const matchedSingleQuotes = optionsString.match(/'/g);
      const matchedDoubleQuotes = optionsString.match(/"/g);
      if (matchedSingleQuotes && matchedSingleQuotes.length % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {
        optionsString = optionsString.replace(/'/g, '"');
      }
      try {
        clonedOptions = JSON.parse(optionsString);
        if (inheritedOptions) clonedOptions = {
          ...inheritedOptions,
          ...clonedOptions
        };
      } catch (e) {
        this.logger.warn(`failed parsing options string in nesting for key ${key}`, e);
        return `${key}${sep}${optionsString}`;
      }
      if (clonedOptions.defaultValue && clonedOptions.defaultValue.indexOf(this.prefix) > -1) delete clonedOptions.defaultValue;
      return key;
    };
    while (match = this.nestingRegexp.exec(str)) {
      let formatters = [];
      clonedOptions = {
        ...options
      };
      clonedOptions = clonedOptions.replace && !isString(clonedOptions.replace) ? clonedOptions.replace : clonedOptions;
      clonedOptions.applyPostProcessor = false;
      delete clonedOptions.defaultValue;
      let doReduce = false;
      if (match[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match[1])) {
        const r = match[1].split(this.formatSeparator).map((elem) => elem.trim());
        match[1] = r.shift();
        formatters = r;
        doReduce = true;
      }
      value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);
      if (value && match[0] === str && !isString(value)) return value;
      if (!isString(value)) value = makeString(value);
      if (!value) {
        this.logger.warn(`missed to resolve ${match[1]} for nesting ${str}`);
        value = "";
      }
      if (doReduce) {
        value = formatters.reduce((v, f) => this.format(v, f, options.lng, {
          ...options,
          interpolationkey: match[1].trim()
        }), value.trim());
      }
      str = str.replace(match[0], value);
      this.regexp.lastIndex = 0;
    }
    return str;
  }
};
var parseFormatStr = (formatStr) => {
  let formatName = formatStr.toLowerCase().trim();
  const formatOptions = {};
  if (formatStr.indexOf("(") > -1) {
    const p = formatStr.split("(");
    formatName = p[0].toLowerCase().trim();
    const optStr = p[1].substring(0, p[1].length - 1);
    if (formatName === "currency" && optStr.indexOf(":") < 0) {
      if (!formatOptions.currency) formatOptions.currency = optStr.trim();
    } else if (formatName === "relativetime" && optStr.indexOf(":") < 0) {
      if (!formatOptions.range) formatOptions.range = optStr.trim();
    } else {
      const opts = optStr.split(";");
      opts.forEach((opt) => {
        if (opt) {
          const [key, ...rest] = opt.split(":");
          const val = rest.join(":").trim().replace(/^'+|'+$/g, "");
          const trimmedKey = key.trim();
          if (!formatOptions[trimmedKey]) formatOptions[trimmedKey] = val;
          if (val === "false") formatOptions[trimmedKey] = false;
          if (val === "true") formatOptions[trimmedKey] = true;
          if (!isNaN(val)) formatOptions[trimmedKey] = parseInt(val, 10);
        }
      });
    }
  }
  return {
    formatName,
    formatOptions
  };
};
var createCachedFormatter = (fn) => {
  const cache = {};
  return (val, lng, options) => {
    let optForCache = options;
    if (options && options.interpolationkey && options.formatParams && options.formatParams[options.interpolationkey] && options[options.interpolationkey]) {
      optForCache = {
        ...optForCache,
        [options.interpolationkey]: void 0
      };
    }
    const key = lng + JSON.stringify(optForCache);
    let formatter = cache[key];
    if (!formatter) {
      formatter = fn(getCleanedCode(lng), options);
      cache[key] = formatter;
    }
    return formatter(val);
  };
};
var Formatter = class {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = baseLogger.create("formatter");
    this.options = options;
    this.formats = {
      number: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.NumberFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val);
      }),
      currency: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.NumberFormat(lng, {
          ...opt,
          style: "currency"
        });
        return (val) => formatter.format(val);
      }),
      datetime: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.DateTimeFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val);
      }),
      relativetime: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.RelativeTimeFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val, opt.range || "day");
      }),
      list: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.ListFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val);
      })
    };
    this.init(options);
  }
  init(services) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    };
    this.formatSeparator = options.interpolation.formatSeparator || ",";
  }
  add(name2, fc) {
    this.formats[name2.toLowerCase().trim()] = fc;
  }
  addCached(name2, fc) {
    this.formats[name2.toLowerCase().trim()] = createCachedFormatter(fc);
  }
  format(value, format, lng) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const formats = format.split(this.formatSeparator);
    if (formats.length > 1 && formats[0].indexOf("(") > 1 && formats[0].indexOf(")") < 0 && formats.find((f) => f.indexOf(")") > -1)) {
      const lastIndex = formats.findIndex((f) => f.indexOf(")") > -1);
      formats[0] = [formats[0], ...formats.splice(1, lastIndex)].join(this.formatSeparator);
    }
    const result = formats.reduce((mem, f) => {
      const {
        formatName,
        formatOptions
      } = parseFormatStr(f);
      if (this.formats[formatName]) {
        let formatted = mem;
        try {
          const valOptions = options && options.formatParams && options.formatParams[options.interpolationkey] || {};
          const l = valOptions.locale || valOptions.lng || options.locale || options.lng || lng;
          formatted = this.formats[formatName](mem, l, {
            ...formatOptions,
            ...options,
            ...valOptions
          });
        } catch (error2) {
          this.logger.warn(error2);
        }
        return formatted;
      } else {
        this.logger.warn(`there was no format function for ${formatName}`);
      }
      return mem;
    }, value);
    return result;
  }
};
var removePending = (q, name2) => {
  if (q.pending[name2] !== void 0) {
    delete q.pending[name2];
    q.pendingCount--;
  }
};
var Connector = class extends EventEmitter {
  constructor(backend, store, services) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    super();
    this.backend = backend;
    this.store = store;
    this.services = services;
    this.languageUtils = services.languageUtils;
    this.options = options;
    this.logger = baseLogger.create("backendConnector");
    this.waitingReads = [];
    this.maxParallelReads = options.maxParallelReads || 10;
    this.readingCalls = 0;
    this.maxRetries = options.maxRetries >= 0 ? options.maxRetries : 5;
    this.retryTimeout = options.retryTimeout >= 1 ? options.retryTimeout : 350;
    this.state = {};
    this.queue = [];
    if (this.backend && this.backend.init) {
      this.backend.init(services, options.backend, options);
    }
  }
  queueLoad(languages, namespaces, options, callback) {
    const toLoad = {};
    const pending = {};
    const toLoadLanguages = {};
    const toLoadNamespaces = {};
    languages.forEach((lng) => {
      let hasAllNamespaces = true;
      namespaces.forEach((ns) => {
        const name2 = `${lng}|${ns}`;
        if (!options.reload && this.store.hasResourceBundle(lng, ns)) {
          this.state[name2] = 2;
        } else if (this.state[name2] < 0) ;
        else if (this.state[name2] === 1) {
          if (pending[name2] === void 0) pending[name2] = true;
        } else {
          this.state[name2] = 1;
          hasAllNamespaces = false;
          if (pending[name2] === void 0) pending[name2] = true;
          if (toLoad[name2] === void 0) toLoad[name2] = true;
          if (toLoadNamespaces[ns] === void 0) toLoadNamespaces[ns] = true;
        }
      });
      if (!hasAllNamespaces) toLoadLanguages[lng] = true;
    });
    if (Object.keys(toLoad).length || Object.keys(pending).length) {
      this.queue.push({
        pending,
        pendingCount: Object.keys(pending).length,
        loaded: {},
        errors: [],
        callback
      });
    }
    return {
      toLoad: Object.keys(toLoad),
      pending: Object.keys(pending),
      toLoadLanguages: Object.keys(toLoadLanguages),
      toLoadNamespaces: Object.keys(toLoadNamespaces)
    };
  }
  loaded(name2, err, data) {
    const s = name2.split("|");
    const lng = s[0];
    const ns = s[1];
    if (err) this.emit("failedLoading", lng, ns, err);
    if (!err && data) {
      this.store.addResourceBundle(lng, ns, data, void 0, void 0, {
        skipCopy: true
      });
    }
    this.state[name2] = err ? -1 : 2;
    if (err && data) this.state[name2] = 0;
    const loaded = {};
    this.queue.forEach((q) => {
      pushPath(q.loaded, [lng], ns);
      removePending(q, name2);
      if (err) q.errors.push(err);
      if (q.pendingCount === 0 && !q.done) {
        Object.keys(q.loaded).forEach((l) => {
          if (!loaded[l]) loaded[l] = {};
          const loadedKeys = q.loaded[l];
          if (loadedKeys.length) {
            loadedKeys.forEach((n) => {
              if (loaded[l][n] === void 0) loaded[l][n] = true;
            });
          }
        });
        q.done = true;
        if (q.errors.length) {
          q.callback(q.errors);
        } else {
          q.callback();
        }
      }
    });
    this.emit("loaded", loaded);
    this.queue = this.queue.filter((q) => !q.done);
  }
  read(lng, ns, fcName) {
    let tried = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
    let wait = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout;
    let callback = arguments.length > 5 ? arguments[5] : void 0;
    if (!lng.length) return callback(null, {});
    if (this.readingCalls >= this.maxParallelReads) {
      this.waitingReads.push({
        lng,
        ns,
        fcName,
        tried,
        wait,
        callback
      });
      return;
    }
    this.readingCalls++;
    const resolver = (err, data) => {
      this.readingCalls--;
      if (this.waitingReads.length > 0) {
        const next = this.waitingReads.shift();
        this.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);
      }
      if (err && data && tried < this.maxRetries) {
        setTimeout(() => {
          this.read.call(this, lng, ns, fcName, tried + 1, wait * 2, callback);
        }, wait);
        return;
      }
      callback(err, data);
    };
    const fc = this.backend[fcName].bind(this.backend);
    if (fc.length === 2) {
      try {
        const r = fc(lng, ns);
        if (r && typeof r.then === "function") {
          r.then((data) => resolver(null, data)).catch(resolver);
        } else {
          resolver(null, r);
        }
      } catch (err) {
        resolver(err);
      }
      return;
    }
    return fc(lng, ns, resolver);
  }
  prepareLoading(languages, namespaces) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let callback = arguments.length > 3 ? arguments[3] : void 0;
    if (!this.backend) {
      this.logger.warn("No backend was added via i18next.use. Will not load resources.");
      return callback && callback();
    }
    if (isString(languages)) languages = this.languageUtils.toResolveHierarchy(languages);
    if (isString(namespaces)) namespaces = [namespaces];
    const toLoad = this.queueLoad(languages, namespaces, options, callback);
    if (!toLoad.toLoad.length) {
      if (!toLoad.pending.length) callback();
      return null;
    }
    toLoad.toLoad.forEach((name2) => {
      this.loadOne(name2);
    });
  }
  load(languages, namespaces, callback) {
    this.prepareLoading(languages, namespaces, {}, callback);
  }
  reload(languages, namespaces, callback) {
    this.prepareLoading(languages, namespaces, {
      reload: true
    }, callback);
  }
  loadOne(name2) {
    let prefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    const s = name2.split("|");
    const lng = s[0];
    const ns = s[1];
    this.read(lng, ns, "read", void 0, void 0, (err, data) => {
      if (err) this.logger.warn(`${prefix}loading namespace ${ns} for language ${lng} failed`, err);
      if (!err && data) this.logger.log(`${prefix}loaded namespace ${ns} for language ${lng}`, data);
      this.loaded(name2, err, data);
    });
  }
  saveMissing(languages, namespace, key, fallbackValue, isUpdate) {
    let options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
    let clb = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : () => {
    };
    if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {
      this.logger.warn(`did not save key "${key}" as the namespace "${namespace}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
      return;
    }
    if (key === void 0 || key === null || key === "") return;
    if (this.backend && this.backend.create) {
      const opts = {
        ...options,
        isUpdate
      };
      const fc = this.backend.create.bind(this.backend);
      if (fc.length < 6) {
        try {
          let r;
          if (fc.length === 5) {
            r = fc(languages, namespace, key, fallbackValue, opts);
          } else {
            r = fc(languages, namespace, key, fallbackValue);
          }
          if (r && typeof r.then === "function") {
            r.then((data) => clb(null, data)).catch(clb);
          } else {
            clb(null, r);
          }
        } catch (err) {
          clb(err);
        }
      } else {
        fc(languages, namespace, key, fallbackValue, clb, opts);
      }
    }
    if (!languages || !languages[0]) return;
    this.store.addResource(languages[0], namespace, key, fallbackValue);
  }
};
var get = () => ({
  debug: false,
  initImmediate: true,
  ns: ["translation"],
  defaultNS: ["translation"],
  fallbackLng: ["dev"],
  fallbackNS: false,
  supportedLngs: false,
  nonExplicitSupportedLngs: false,
  load: "all",
  preload: false,
  simplifyPluralSuffix: true,
  keySeparator: ".",
  nsSeparator: ":",
  pluralSeparator: "_",
  contextSeparator: "_",
  partialBundledLanguages: false,
  saveMissing: false,
  updateMissing: false,
  saveMissingTo: "fallback",
  saveMissingPlurals: true,
  missingKeyHandler: false,
  missingInterpolationHandler: false,
  postProcess: false,
  postProcessPassResolved: false,
  returnNull: false,
  returnEmptyString: true,
  returnObjects: false,
  joinArrays: false,
  returnedObjectHandler: false,
  parseMissingKeyHandler: false,
  appendNamespaceToMissingKey: false,
  appendNamespaceToCIMode: false,
  overloadTranslationOptionHandler: (args) => {
    let ret = {};
    if (typeof args[1] === "object") ret = args[1];
    if (isString(args[1])) ret.defaultValue = args[1];
    if (isString(args[2])) ret.tDescription = args[2];
    if (typeof args[2] === "object" || typeof args[3] === "object") {
      const options = args[3] || args[2];
      Object.keys(options).forEach((key) => {
        ret[key] = options[key];
      });
    }
    return ret;
  },
  interpolation: {
    escapeValue: true,
    format: (value) => value,
    prefix: "{{",
    suffix: "}}",
    formatSeparator: ",",
    unescapePrefix: "-",
    nestingPrefix: "$t(",
    nestingSuffix: ")",
    nestingOptionsSeparator: ",",
    maxReplaces: 1e3,
    skipOnVariables: true
  }
});
var transformOptions = (options) => {
  if (isString(options.ns)) options.ns = [options.ns];
  if (isString(options.fallbackLng)) options.fallbackLng = [options.fallbackLng];
  if (isString(options.fallbackNS)) options.fallbackNS = [options.fallbackNS];
  if (options.supportedLngs && options.supportedLngs.indexOf("cimode") < 0) {
    options.supportedLngs = options.supportedLngs.concat(["cimode"]);
  }
  return options;
};
var noop2 = () => {
};
var bindMemberFunctions = (inst) => {
  const mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));
  mems.forEach((mem) => {
    if (typeof inst[mem] === "function") {
      inst[mem] = inst[mem].bind(inst);
    }
  });
};
var I18n = class _I18n extends EventEmitter {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 ? arguments[1] : void 0;
    super();
    this.options = transformOptions(options);
    this.services = {};
    this.logger = baseLogger;
    this.modules = {
      external: []
    };
    bindMemberFunctions(this);
    if (callback && !this.isInitialized && !options.isClone) {
      if (!this.options.initImmediate) {
        this.init(options, callback);
        return this;
      }
      setTimeout(() => {
        this.init(options, callback);
      }, 0);
    }
  }
  init() {
    var _this = this;
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 ? arguments[1] : void 0;
    this.isInitializing = true;
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    if (!options.defaultNS && options.defaultNS !== false && options.ns) {
      if (isString(options.ns)) {
        options.defaultNS = options.ns;
      } else if (options.ns.indexOf("translation") < 0) {
        options.defaultNS = options.ns[0];
      }
    }
    const defOpts = get();
    this.options = {
      ...defOpts,
      ...this.options,
      ...transformOptions(options)
    };
    if (this.options.compatibilityAPI !== "v1") {
      this.options.interpolation = {
        ...defOpts.interpolation,
        ...this.options.interpolation
      };
    }
    if (options.keySeparator !== void 0) {
      this.options.userDefinedKeySeparator = options.keySeparator;
    }
    if (options.nsSeparator !== void 0) {
      this.options.userDefinedNsSeparator = options.nsSeparator;
    }
    const createClassOnDemand = (ClassOrObject) => {
      if (!ClassOrObject) return null;
      if (typeof ClassOrObject === "function") return new ClassOrObject();
      return ClassOrObject;
    };
    if (!this.options.isClone) {
      if (this.modules.logger) {
        baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
      } else {
        baseLogger.init(null, this.options);
      }
      let formatter;
      if (this.modules.formatter) {
        formatter = this.modules.formatter;
      } else if (typeof Intl !== "undefined") {
        formatter = Formatter;
      }
      const lu = new LanguageUtil(this.options);
      this.store = new ResourceStore(this.options.resources, this.options);
      const s = this.services;
      s.logger = baseLogger;
      s.resourceStore = this.store;
      s.languageUtils = lu;
      s.pluralResolver = new PluralResolver(lu, {
        prepend: this.options.pluralSeparator,
        compatibilityJSON: this.options.compatibilityJSON,
        simplifyPluralSuffix: this.options.simplifyPluralSuffix
      });
      if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {
        s.formatter = createClassOnDemand(formatter);
        s.formatter.init(s, this.options);
        this.options.interpolation.format = s.formatter.format.bind(s.formatter);
      }
      s.interpolator = new Interpolator(this.options);
      s.utils = {
        hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
      };
      s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);
      s.backendConnector.on("*", function(event) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        _this.emit(event, ...args);
      });
      if (this.modules.languageDetector) {
        s.languageDetector = createClassOnDemand(this.modules.languageDetector);
        if (s.languageDetector.init) s.languageDetector.init(s, this.options.detection, this.options);
      }
      if (this.modules.i18nFormat) {
        s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
        if (s.i18nFormat.init) s.i18nFormat.init(this);
      }
      this.translator = new Translator(this.services, this.options);
      this.translator.on("*", function(event) {
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }
        _this.emit(event, ...args);
      });
      this.modules.external.forEach((m) => {
        if (m.init) m.init(this);
      });
    }
    this.format = this.options.interpolation.format;
    if (!callback) callback = noop2;
    if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
      const codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
      if (codes.length > 0 && codes[0] !== "dev") this.options.lng = codes[0];
    }
    if (!this.services.languageDetector && !this.options.lng) {
      this.logger.warn("init: no languageDetector is used and no lng is defined");
    }
    const storeApi = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
    storeApi.forEach((fcName) => {
      this[fcName] = function() {
        return _this.store[fcName](...arguments);
      };
    });
    const storeApiChained = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
    storeApiChained.forEach((fcName) => {
      this[fcName] = function() {
        _this.store[fcName](...arguments);
        return _this;
      };
    });
    const deferred = defer2();
    const load = () => {
      const finish = (err, t2) => {
        this.isInitializing = false;
        if (this.isInitialized && !this.initializedStoreOnce) this.logger.warn("init: i18next is already initialized. You should call init just once!");
        this.isInitialized = true;
        if (!this.options.isClone) this.logger.log("initialized", this.options);
        this.emit("initialized", this.options);
        deferred.resolve(t2);
        callback(err, t2);
      };
      if (this.languages && this.options.compatibilityAPI !== "v1" && !this.isInitialized) return finish(null, this.t.bind(this));
      this.changeLanguage(this.options.lng, finish);
    };
    if (this.options.resources || !this.options.initImmediate) {
      load();
    } else {
      setTimeout(load, 0);
    }
    return deferred;
  }
  loadResources(language) {
    let callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop2;
    let usedCallback = callback;
    const usedLng = isString(language) ? language : this.language;
    if (typeof language === "function") usedCallback = language;
    if (!this.options.resources || this.options.partialBundledLanguages) {
      if (usedLng && usedLng.toLowerCase() === "cimode" && (!this.options.preload || this.options.preload.length === 0)) return usedCallback();
      const toLoad = [];
      const append = (lng) => {
        if (!lng) return;
        if (lng === "cimode") return;
        const lngs = this.services.languageUtils.toResolveHierarchy(lng);
        lngs.forEach((l) => {
          if (l === "cimode") return;
          if (toLoad.indexOf(l) < 0) toLoad.push(l);
        });
      };
      if (!usedLng) {
        const fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        fallbacks.forEach((l) => append(l));
      } else {
        append(usedLng);
      }
      if (this.options.preload) {
        this.options.preload.forEach((l) => append(l));
      }
      this.services.backendConnector.load(toLoad, this.options.ns, (e) => {
        if (!e && !this.resolvedLanguage && this.language) this.setResolvedLanguage(this.language);
        usedCallback(e);
      });
    } else {
      usedCallback(null);
    }
  }
  reloadResources(lngs, ns, callback) {
    const deferred = defer2();
    if (typeof lngs === "function") {
      callback = lngs;
      lngs = void 0;
    }
    if (typeof ns === "function") {
      callback = ns;
      ns = void 0;
    }
    if (!lngs) lngs = this.languages;
    if (!ns) ns = this.options.ns;
    if (!callback) callback = noop2;
    this.services.backendConnector.reload(lngs, ns, (err) => {
      deferred.resolve();
      callback(err);
    });
    return deferred;
  }
  use(module) {
    if (!module) throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
    if (!module.type) throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
    if (module.type === "backend") {
      this.modules.backend = module;
    }
    if (module.type === "logger" || module.log && module.warn && module.error) {
      this.modules.logger = module;
    }
    if (module.type === "languageDetector") {
      this.modules.languageDetector = module;
    }
    if (module.type === "i18nFormat") {
      this.modules.i18nFormat = module;
    }
    if (module.type === "postProcessor") {
      postProcessor.addPostProcessor(module);
    }
    if (module.type === "formatter") {
      this.modules.formatter = module;
    }
    if (module.type === "3rdParty") {
      this.modules.external.push(module);
    }
    return this;
  }
  setResolvedLanguage(l) {
    if (!l || !this.languages) return;
    if (["cimode", "dev"].indexOf(l) > -1) return;
    for (let li = 0; li < this.languages.length; li++) {
      const lngInLngs = this.languages[li];
      if (["cimode", "dev"].indexOf(lngInLngs) > -1) continue;
      if (this.store.hasLanguageSomeTranslations(lngInLngs)) {
        this.resolvedLanguage = lngInLngs;
        break;
      }
    }
  }
  changeLanguage(lng, callback) {
    var _this2 = this;
    this.isLanguageChangingTo = lng;
    const deferred = defer2();
    this.emit("languageChanging", lng);
    const setLngProps = (l) => {
      this.language = l;
      this.languages = this.services.languageUtils.toResolveHierarchy(l);
      this.resolvedLanguage = void 0;
      this.setResolvedLanguage(l);
    };
    const done = (err, l) => {
      if (l) {
        setLngProps(l);
        this.translator.changeLanguage(l);
        this.isLanguageChangingTo = void 0;
        this.emit("languageChanged", l);
        this.logger.log("languageChanged", l);
      } else {
        this.isLanguageChangingTo = void 0;
      }
      deferred.resolve(function() {
        return _this2.t(...arguments);
      });
      if (callback) callback(err, function() {
        return _this2.t(...arguments);
      });
    };
    const setLng = (lngs) => {
      if (!lng && !lngs && this.services.languageDetector) lngs = [];
      const l = isString(lngs) ? lngs : this.services.languageUtils.getBestMatchFromCodes(lngs);
      if (l) {
        if (!this.language) {
          setLngProps(l);
        }
        if (!this.translator.language) this.translator.changeLanguage(l);
        if (this.services.languageDetector && this.services.languageDetector.cacheUserLanguage) this.services.languageDetector.cacheUserLanguage(l);
      }
      this.loadResources(l, (err) => {
        done(err, l);
      });
    };
    if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
      setLng(this.services.languageDetector.detect());
    } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
      if (this.services.languageDetector.detect.length === 0) {
        this.services.languageDetector.detect().then(setLng);
      } else {
        this.services.languageDetector.detect(setLng);
      }
    } else {
      setLng(lng);
    }
    return deferred;
  }
  getFixedT(lng, ns, keyPrefix) {
    var _this3 = this;
    const fixedT = function(key, opts) {
      let options;
      if (typeof opts !== "object") {
        for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
          rest[_key3 - 2] = arguments[_key3];
        }
        options = _this3.options.overloadTranslationOptionHandler([key, opts].concat(rest));
      } else {
        options = {
          ...opts
        };
      }
      options.lng = options.lng || fixedT.lng;
      options.lngs = options.lngs || fixedT.lngs;
      options.ns = options.ns || fixedT.ns;
      if (options.keyPrefix !== "") options.keyPrefix = options.keyPrefix || keyPrefix || fixedT.keyPrefix;
      const keySeparator = _this3.options.keySeparator || ".";
      let resultKey;
      if (options.keyPrefix && Array.isArray(key)) {
        resultKey = key.map((k) => `${options.keyPrefix}${keySeparator}${k}`);
      } else {
        resultKey = options.keyPrefix ? `${options.keyPrefix}${keySeparator}${key}` : key;
      }
      return _this3.t(resultKey, options);
    };
    if (isString(lng)) {
      fixedT.lng = lng;
    } else {
      fixedT.lngs = lng;
    }
    fixedT.ns = ns;
    fixedT.keyPrefix = keyPrefix;
    return fixedT;
  }
  t() {
    return this.translator && this.translator.translate(...arguments);
  }
  exists() {
    return this.translator && this.translator.exists(...arguments);
  }
  setDefaultNamespace(ns) {
    this.options.defaultNS = ns;
  }
  hasLoadedNamespace(ns) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!this.isInitialized) {
      this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages);
      return false;
    }
    if (!this.languages || !this.languages.length) {
      this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages);
      return false;
    }
    const lng = options.lng || this.resolvedLanguage || this.languages[0];
    const fallbackLng = this.options ? this.options.fallbackLng : false;
    const lastLng = this.languages[this.languages.length - 1];
    if (lng.toLowerCase() === "cimode") return true;
    const loadNotPending = (l, n) => {
      const loadState = this.services.backendConnector.state[`${l}|${n}`];
      return loadState === -1 || loadState === 0 || loadState === 2;
    };
    if (options.precheck) {
      const preResult = options.precheck(this, loadNotPending);
      if (preResult !== void 0) return preResult;
    }
    if (this.hasResourceBundle(lng, ns)) return true;
    if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages) return true;
    if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;
    return false;
  }
  loadNamespaces(ns, callback) {
    const deferred = defer2();
    if (!this.options.ns) {
      if (callback) callback();
      return Promise.resolve();
    }
    if (isString(ns)) ns = [ns];
    ns.forEach((n) => {
      if (this.options.ns.indexOf(n) < 0) this.options.ns.push(n);
    });
    this.loadResources((err) => {
      deferred.resolve();
      if (callback) callback(err);
    });
    return deferred;
  }
  loadLanguages(lngs, callback) {
    const deferred = defer2();
    if (isString(lngs)) lngs = [lngs];
    const preloaded = this.options.preload || [];
    const newLngs = lngs.filter((lng) => preloaded.indexOf(lng) < 0 && this.services.languageUtils.isSupportedCode(lng));
    if (!newLngs.length) {
      if (callback) callback();
      return Promise.resolve();
    }
    this.options.preload = preloaded.concat(newLngs);
    this.loadResources((err) => {
      deferred.resolve();
      if (callback) callback(err);
    });
    return deferred;
  }
  dir(lng) {
    if (!lng) lng = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language);
    if (!lng) return "rtl";
    const rtlLngs = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"];
    const languageUtils = this.services && this.services.languageUtils || new LanguageUtil(get());
    return rtlLngs.indexOf(languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
  }
  static createInstance() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 ? arguments[1] : void 0;
    return new _I18n(options, callback);
  }
  cloneInstance() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop2;
    const forkResourceStore = options.forkResourceStore;
    if (forkResourceStore) delete options.forkResourceStore;
    const mergedOptions = {
      ...this.options,
      ...options,
      ...{
        isClone: true
      }
    };
    const clone = new _I18n(mergedOptions);
    if (options.debug !== void 0 || options.prefix !== void 0) {
      clone.logger = clone.logger.clone(options);
    }
    const membersToCopy = ["store", "services", "language"];
    membersToCopy.forEach((m) => {
      clone[m] = this[m];
    });
    clone.services = {
      ...this.services
    };
    clone.services.utils = {
      hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
    };
    if (forkResourceStore) {
      clone.store = new ResourceStore(this.store.data, mergedOptions);
      clone.services.resourceStore = clone.store;
    }
    clone.translator = new Translator(clone.services, mergedOptions);
    clone.translator.on("*", function(event) {
      for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        args[_key4 - 1] = arguments[_key4];
      }
      clone.emit(event, ...args);
    });
    clone.init(mergedOptions, callback);
    clone.translator.options = mergedOptions;
    clone.translator.backendConnector.services.utils = {
      hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
    };
    return clone;
  }
  toJSON() {
    return {
      options: this.options,
      store: this.store,
      language: this.language,
      languages: this.languages,
      resolvedLanguage: this.resolvedLanguage
    };
  }
};
var instance = I18n.createInstance();
instance.createInstance = I18n.createInstance;
var createInstance = instance.createInstance;
var dir = instance.dir;
var init = instance.init;
var loadResources = instance.loadResources;
var reloadResources = instance.reloadResources;
var use = instance.use;
var changeLanguage = instance.changeLanguage;
var getFixedT = instance.getFixedT;
var t = instance.t;
var exists = instance.exists;
var setDefaultNamespace = instance.setDefaultNamespace;
var hasLoadedNamespace = instance.hasLoadedNamespace;
var loadNamespaces = instance.loadNamespaces;
var loadLanguages = instance.loadLanguages;

// node_modules/@stream-io/video-react-bindings/dist/index.es.js
var StreamCallContext = (0, import_react.createContext)(void 0);
var StreamCallProvider = (props) => {
  const { call, children } = props;
  return (0, import_jsx_runtime.jsx)(StreamCallContext.Provider, { value: call, children });
};
var useCall = () => {
  return (0, import_react.useContext)(StreamCallContext);
};
var DEFAULT_NAMESPACE = "stream-video";
var DEFAULT_CONFIG = {
  debug: false,
  currentLanguage: "en",
  fallbackLanguage: false
};
var mapToRegistry = (translationsMap, namespace) => Object.entries(translationsMap).reduce((acc, [lng, translations2]) => {
  acc[lng] = { [namespace]: translations2 };
  return acc;
}, {});
var DEFAULT_TRANSLATIONS_REGISTRY = mapToRegistry({}, DEFAULT_NAMESPACE);
var defaultTranslationFunction = (key) => key;
var StreamI18n = class {
  /** Simple logger function */
  constructor(options = {}) {
    this.t = defaultTranslationFunction;
    this.init = async () => {
      try {
        this.t = await this.i18nInstance.init();
      } catch (e) {
        console.error(`Failed to initialize translations: ${JSON.stringify(e)}`);
      }
      return this;
    };
    this.changeLanguage = async (language, onChange) => {
      if (!this._checkIsInitialized())
        return;
      const browserLanguage = typeof window !== "undefined" && window.navigator ? window.navigator.language : void 0;
      await this.i18nInstance.changeLanguage(language || browserLanguage);
      onChange == null ? void 0 : onChange(this.currentLanguage);
    };
    this.registerTranslationsForLanguage = ({ lng, translations: translations2 }) => {
      if (!this._checkIsInitialized())
        return;
      this.i18nInstance.addResourceBundle(lng, DEFAULT_NAMESPACE, translations2, true, true);
    };
    this._checkIsInitialized = () => {
      if (!this.i18nInstance.isInitialized) {
        console.warn("I18n instance is not initialized. Call yourStreamI18nInstance.init().");
      }
      return this.i18nInstance.isInitialized;
    };
    const { debug = DEFAULT_CONFIG.debug, currentLanguage = DEFAULT_CONFIG.currentLanguage, fallbackLanguage = DEFAULT_CONFIG.fallbackLanguage, translationsOverrides } = options;
    this.i18nInstance = instance.createInstance({
      debug,
      defaultNS: DEFAULT_NAMESPACE,
      fallbackLng: fallbackLanguage,
      interpolation: { escapeValue: false },
      keySeparator: false,
      lng: currentLanguage,
      nsSeparator: false,
      parseMissingKeyHandler: (key) => {
        return key;
      },
      resources: DEFAULT_TRANSLATIONS_REGISTRY
    });
    if (translationsOverrides) {
      this.i18nInstance.on("initialized", () => {
        Object.entries(translationsOverrides).forEach(([lng, translations2]) => {
          this.registerTranslationsForLanguage({ lng, translations: translations2 });
        });
      });
    }
  }
  get currentLanguage() {
    this._checkIsInitialized();
    return this.i18nInstance.language;
  }
  get isInitialized() {
    return this.i18nInstance.isInitialized;
  }
};
var StreamI18nContext = (0, import_react.createContext)({
  t: defaultTranslationFunction
});
var StreamI18nProvider = ({ children, ...createI18nParams }) => {
  const { i18n, t: t2 } = useCreateI18n(createI18nParams);
  return (0, import_jsx_runtime.jsx)(StreamI18nContext.Provider, { value: { t: t2, i18n }, children });
};
var useCreateI18n = ({ i18nInstance, language, fallbackLanguage, translationsOverrides }) => {
  const [i18n] = (0, import_react.useState)(() => i18nInstance || new StreamI18n({
    currentLanguage: language,
    fallbackLanguage,
    translationsOverrides
  }));
  const [t2, setTranslationFn] = (0, import_react.useState)(() => defaultTranslationFunction);
  (0, import_react.useEffect)(() => {
    const { isInitialized } = i18n;
    if (!isInitialized) {
      i18n.init().then((_i18n) => setTranslationFn(() => _i18n.i18nInstance.t));
      return;
    }
    if (language && (i18n == null ? void 0 : i18n.currentLanguage) !== language) {
      i18n.changeLanguage(language).catch((err) => {
        console.log("Error while changing language", err);
      });
    }
  }, [i18n, i18nInstance, language, translationsOverrides]);
  return { i18n, t: t2 };
};
var useI18n = () => (0, import_react.useContext)(StreamI18nContext);
var StreamVideoContext = (0, import_react.createContext)(void 0);
var StreamVideoProvider = ({ children, client, i18nInstance, language, translationsOverrides }) => {
  return (0, import_jsx_runtime.jsx)(StreamVideoContext.Provider, { value: client, children: (0, import_jsx_runtime.jsx)(StreamI18nProvider, { i18nInstance, language, translationsOverrides, children }) });
};
var useStreamVideoClient = () => {
  return (0, import_react.useContext)(StreamVideoContext);
};
var isReactNative2 = () => {
  var _a;
  if (typeof navigator === "undefined")
    return false;
  return ((_a = navigator.product) == null ? void 0 : _a.toLowerCase()) === "reactnative";
};
var useObservableValue = (observable$, defaultValue) => {
  const [value, setValue] = (0, import_react.useState)(() => {
    try {
      return rxUtils.getCurrentValue(observable$);
    } catch (err) {
      if (typeof defaultValue === "undefined")
        throw err;
      return defaultValue;
    }
  });
  (0, import_react.useEffect)(() => {
    return rxUtils.createSubscription(observable$, setValue, (err) => {
      console.log("An error occurred while reading an observable", err);
      if (defaultValue)
        setValue(defaultValue);
    });
  }, [defaultValue, observable$]);
  return value;
};
var EMPTY_DEVICES_ARRAY = Object.freeze([]);
var useCallState = () => {
  const call = useCall();
  if (!call) {
    const message = 'You are using useCallState() outside a Call context. Please wrap your component in <StreamCall /> and provide a "call" instance.';
    console.warn(message);
    return new CallState();
  }
  return call.state;
};
var useIsCallRecordingInProgress = () => {
  const { recording$ } = useCallState();
  return useObservableValue(recording$);
};
var useIsCallHLSBroadcastingInProgress = () => {
  const { egress$ } = useCallState();
  const egress = useObservableValue(egress$);
  if (!egress)
    return false;
  return egress.broadcasting;
};
var useIsCallLive = () => {
  const { backstage$ } = useCallState();
  const isBackstageOn = useObservableValue(backstage$);
  return !isBackstageOn;
};
var useCallBlockedUserIds = () => {
  const { blockedUserIds$ } = useCallState();
  return useObservableValue(blockedUserIds$);
};
var useCallCreatedAt = () => {
  const { createdAt$ } = useCallState();
  return useObservableValue(createdAt$);
};
var useCallEndedAt = () => {
  const { endedAt$ } = useCallState();
  return useObservableValue(endedAt$);
};
var useCallStartsAt = () => {
  const { startsAt$ } = useCallState();
  return useObservableValue(startsAt$);
};
var useCallUpdatedAt = () => {
  const { updatedAt$ } = useCallState();
  return useObservableValue(updatedAt$);
};
var useCallCreatedBy = () => {
  const { createdBy$ } = useCallState();
  return useObservableValue(createdBy$);
};
var useCallCustomData = () => {
  const { custom$ } = useCallState();
  return useObservableValue(custom$);
};
var useCallEgress = () => {
  const { egress$ } = useCallState();
  return useObservableValue(egress$);
};
var useCallIngress = () => {
  const { ingress$ } = useCallState();
  return useObservableValue(ingress$);
};
var useCallSession = () => {
  const { session$ } = useCallState();
  return useObservableValue(session$);
};
var useCallSettings = () => {
  const { settings$ } = useCallState();
  return useObservableValue(settings$);
};
var useIsCallTranscribingInProgress = () => {
  const { transcribing$ } = useCallState();
  return useObservableValue(transcribing$);
};
var useCallEndedBy = () => {
  const { endedBy$ } = useCallState();
  return useObservableValue(endedBy$);
};
var useHasOngoingScreenShare = () => {
  const { hasOngoingScreenShare$ } = useCallState();
  return useObservableValue(hasOngoingScreenShare$);
};
var useCallStatsReport = () => {
  const { callStatsReport$ } = useCallState();
  return useObservableValue(callStatsReport$);
};
var useDominantSpeaker = () => {
  const { dominantSpeaker$ } = useCallState();
  return useObservableValue(dominantSpeaker$);
};
var useCallMembers = () => {
  const { members$ } = useCallState();
  return useObservableValue(members$);
};
var useCallCallingState = () => {
  const { callingState$ } = useCallState();
  return useObservableValue(callingState$);
};
var useCallStartedAt = () => {
  const { startedAt$ } = useCallState();
  return useObservableValue(startedAt$);
};
var useParticipants = ({ sortBy } = {}) => {
  const { participants$ } = useCallState();
  const participants = useObservableValue(participants$);
  return (0, import_react.useMemo)(() => {
    if (sortBy) {
      return [...participants].sort(sortBy);
    }
    return participants;
  }, [participants, sortBy]);
};
var useLocalParticipant = () => {
  const { localParticipant$ } = useCallState();
  return useObservableValue(localParticipant$);
};
var useRemoteParticipants = () => {
  const { remoteParticipants$ } = useCallState();
  return useObservableValue(remoteParticipants$);
};
var useParticipantCount = () => {
  const { participantCount$ } = useCallState();
  return useObservableValue(participantCount$);
};
var useAnonymousParticipantCount = () => {
  const { anonymousParticipantCount$ } = useCallState();
  return useObservableValue(anonymousParticipantCount$);
};
var useCallThumbnail = () => {
  const { thumbnails$ } = useCallState();
  return useObservableValue(thumbnails$);
};
var useOwnCapabilities = () => {
  const { ownCapabilities$ } = useCallState();
  return useObservableValue(ownCapabilities$);
};
var useHasPermissions = (...permissions) => {
  const capabilities = useOwnCapabilities();
  return permissions.every((permission) => capabilities == null ? void 0 : capabilities.includes(permission));
};
var useCameraState = () => {
  const call = useCall();
  const { camera } = call;
  const { state } = camera;
  const direction = useObservableValue(state.direction$);
  const mediaStream = useObservableValue(state.mediaStream$);
  const selectedDevice = useObservableValue(state.selectedDevice$);
  const { getDevices: getDevices2 } = useLazyDeviceList(camera);
  const hasBrowserPermission = useObservableValue(state.hasBrowserPermission$);
  const isPromptingPermission = useObservableValue(state.isPromptingPermission$);
  return {
    camera,
    direction,
    mediaStream,
    get devices() {
      return getDevices2();
    },
    hasBrowserPermission,
    isPromptingPermission,
    selectedDevice,
    ...getComputedStatus(useObservableValue(state.status$), useObservableValue(state.optimisticStatus$))
  };
};
var useMicrophoneState = () => {
  const call = useCall();
  const { microphone } = call;
  const { state } = microphone;
  const mediaStream = useObservableValue(state.mediaStream$);
  const selectedDevice = useObservableValue(state.selectedDevice$);
  const { getDevices: getDevices2 } = useLazyDeviceList(microphone);
  const hasBrowserPermission = useObservableValue(state.hasBrowserPermission$);
  const isPromptingPermission = useObservableValue(state.isPromptingPermission$);
  const isSpeakingWhileMuted = useObservableValue(state.speakingWhileMuted$);
  return {
    microphone,
    mediaStream,
    get devices() {
      return getDevices2();
    },
    selectedDevice,
    hasBrowserPermission,
    isPromptingPermission,
    isSpeakingWhileMuted,
    ...getComputedStatus(useObservableValue(state.status$), useObservableValue(state.optimisticStatus$))
  };
};
var useSpeakerState = () => {
  if (isReactNative2()) {
    throw new Error("This feature is not supported in React Native. Please visit https://getstream.io/video/docs/reactnative/core/camera-and-microphone/#speaker-management for more details");
  }
  const call = useCall();
  const { speaker } = call;
  const { getDevices: getDevices2 } = useLazyDeviceList(speaker);
  const selectedDevice = useObservableValue(speaker.state.selectedDevice$);
  return {
    speaker,
    get devices() {
      return getDevices2();
    },
    selectedDevice,
    isDeviceSelectionSupported: speaker.state.isDeviceSelectionSupported
  };
};
var useScreenShareState = () => {
  const call = useCall();
  const { screenShare } = call;
  return {
    screenShare,
    mediaStream: useObservableValue(screenShare.state.mediaStream$),
    ...getComputedStatus(useObservableValue(screenShare.state.status$), useObservableValue(screenShare.state.optimisticStatus$))
  };
};
var useIncomingVideoSettings = () => {
  const call = useCall();
  const settings = useObservableValue(call.dynascaleManager.incomingVideoSettings$);
  return settings;
};
var useCallClosedCaptions = () => {
  const { closedCaptions$ } = useCallState();
  return useObservableValue(closedCaptions$);
};
var useIsCallCaptioningInProgress = () => {
  const { captioning$ } = useCallState();
  return useObservableValue(captioning$);
};
function getComputedStatus(status, pendingStatus) {
  const optimisticStatus = pendingStatus ?? status;
  return {
    status,
    optimisticStatus,
    isEnabled: status === "enabled",
    isMute: status !== "enabled",
    optimisticIsMute: optimisticStatus !== "enabled",
    isTogglePending: optimisticStatus !== status
  };
}
function useLazyDeviceList(manager) {
  const placeholderDevices$ = (0, import_react.useMemo)(() => of(EMPTY_DEVICES_ARRAY), []);
  const [devices$, setDevices$] = (0, import_react.useState)(placeholderDevices$);
  const devices = useObservableValue(devices$, EMPTY_DEVICES_ARRAY);
  const getDevices2 = () => {
    if (devices$ === placeholderDevices$) {
      setDevices$(manager.listDevices());
    }
    return devices;
  };
  return { getDevices: getDevices2 };
}
var CallStateHooks = Object.freeze({
  __proto__: null,
  useAnonymousParticipantCount,
  useCallBlockedUserIds,
  useCallCallingState,
  useCallClosedCaptions,
  useCallCreatedAt,
  useCallCreatedBy,
  useCallCustomData,
  useCallEgress,
  useCallEndedAt,
  useCallEndedBy,
  useCallIngress,
  useCallMembers,
  useCallSession,
  useCallSettings,
  useCallStartedAt,
  useCallStartsAt,
  useCallState,
  useCallStatsReport,
  useCallThumbnail,
  useCallUpdatedAt,
  useCameraState,
  useDominantSpeaker,
  useHasOngoingScreenShare,
  useHasPermissions,
  useIncomingVideoSettings,
  useIsCallCaptioningInProgress,
  useIsCallHLSBroadcastingInProgress,
  useIsCallLive,
  useIsCallRecordingInProgress,
  useIsCallTranscribingInProgress,
  useLocalParticipant,
  useMicrophoneState,
  useOwnCapabilities,
  useParticipantCount,
  useParticipants,
  useRemoteParticipants,
  useScreenShareState,
  useSpeakerState
});
var useStore = () => {
  const client = useStreamVideoClient();
  if (!client) {
    throw new Error(`StreamVideoClient isn't initialized or this hook is called outside of <StreamVideo> context.`);
  }
  return client.state;
};
var useCalls = () => {
  const { calls$ } = useStore();
  return useObservableValue(calls$);
};
var useConnectedUser = () => {
  const { connectedUser$ } = useStore();
  return useObservableValue(connectedUser$);
};
var useToggleCallRecording = () => {
  const call = useCall();
  const isCallRecordingInProgress = useIsCallRecordingInProgress();
  const [isAwaitingResponse, setIsAwaitingResponse] = (0, import_react.useState)(false);
  (0, import_react.useEffect)(() => {
    setIsAwaitingResponse((isAwaiting) => {
      if (isAwaiting)
        return false;
      return isAwaiting;
    });
  }, [isCallRecordingInProgress]);
  const toggleCallRecording = (0, import_react.useCallback)(async () => {
    try {
      setIsAwaitingResponse(true);
      if (isCallRecordingInProgress) {
        await (call == null ? void 0 : call.stopRecording());
      } else {
        await (call == null ? void 0 : call.startRecording());
      }
    } catch (e) {
      console.error(`Failed start recording`, e);
      throw e;
    }
  }, [call, isCallRecordingInProgress]);
  return { toggleCallRecording, isAwaitingResponse, isCallRecordingInProgress };
};
var useCallStateHooks = () => CallStateHooks;
var Restricted = ({ canRequestOnly, hasPermissionsOnly, requiredGrants, requireAll = true, children }) => {
  const call = useCall();
  const { useCallSettings: useCallSettings2, useOwnCapabilities: useOwnCapabilities2 } = useCallStateHooks();
  const ownCapabilities = useOwnCapabilities2();
  const settings = useCallSettings2();
  const hasPermissions = requiredGrants[requireAll ? "every" : "some"]((capability) => ownCapabilities == null ? void 0 : ownCapabilities.includes(capability));
  if (hasPermissionsOnly)
    return hasPermissions ? (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children }) : null;
  const canRequest = requiredGrants.some((capability) => call == null ? void 0 : call.permissionsContext.canRequest(capability, settings));
  if (canRequestOnly)
    return canRequest ? (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children }) : null;
  if (hasPermissions || canRequest)
    return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children });
  return null;
};

// node_modules/@stream-io/video-react-sdk/dist/index.es.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime());
var import_react4 = __toESM(require_react());

// node_modules/@floating-ui/react/dist/floating-ui.react.mjs
var React3 = __toESM(require_react(), 1);

// node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle2(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isTopLayer(element) {
  return [":popover-open", ":modal"].some((selector) => {
    try {
      return element.matches(selector);
    } catch (e) {
      return false;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle2(elementOrCss) : elementOrCss;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle2(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}

// node_modules/@floating-ui/react/dist/floating-ui.react.utils.mjs
var React = __toESM(require_react(), 1);
var import_react2 = __toESM(require_react(), 1);

// node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var sides = ["top", "right", "bottom", "left"];
var alignments = ["start", "end"];
var placements = sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
var min2 = Math.min;
var max2 = Math.max;
var round = Math.round;
var floor = Math.floor;
var createCoords = (v) => ({
  x: v,
  y: v
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max2(start, min2(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}

// node_modules/tabbable/dist/index.esm.js
var candidateSelectors = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"];
var candidateSelector = candidateSelectors.join(",");
var NoElement = typeof Element === "undefined";
var matches = NoElement ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
var getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {
  var _element$getRootNode;
  return element === null || element === void 0 ? void 0 : (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element);
} : function(element) {
  return element === null || element === void 0 ? void 0 : element.ownerDocument;
};
var isInert = function isInert2(node, lookUp) {
  var _node$getAttribute;
  if (lookUp === void 0) {
    lookUp = true;
  }
  var inertAtt = node === null || node === void 0 ? void 0 : (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, "inert");
  var inert = inertAtt === "" || inertAtt === "true";
  var result = inert || lookUp && node && isInert2(node.parentNode);
  return result;
};
var isContentEditable = function isContentEditable2(node) {
  var _node$getAttribute2;
  var attValue = node === null || node === void 0 ? void 0 : (_node$getAttribute2 = node.getAttribute) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.call(node, "contenteditable");
  return attValue === "" || attValue === "true";
};
var getCandidates = function getCandidates2(el, includeContainer, filter2) {
  if (isInert(el)) {
    return [];
  }
  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
  if (includeContainer && matches.call(el, candidateSelector)) {
    candidates.unshift(el);
  }
  candidates = candidates.filter(filter2);
  return candidates;
};
var getCandidatesIteratively = function getCandidatesIteratively2(elements, includeContainer, options) {
  var candidates = [];
  var elementsToCheck = Array.from(elements);
  while (elementsToCheck.length) {
    var element = elementsToCheck.shift();
    if (isInert(element, false)) {
      continue;
    }
    if (element.tagName === "SLOT") {
      var assigned = element.assignedElements();
      var content = assigned.length ? assigned : element.children;
      var nestedCandidates = getCandidatesIteratively2(content, true, options);
      if (options.flatten) {
        candidates.push.apply(candidates, nestedCandidates);
      } else {
        candidates.push({
          scopeParent: element,
          candidates: nestedCandidates
        });
      }
    } else {
      var validCandidate = matches.call(element, candidateSelector);
      if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {
        candidates.push(element);
      }
      var shadowRoot = element.shadowRoot || // check for an undisclosed shadow
      typeof options.getShadowRoot === "function" && options.getShadowRoot(element);
      var validShadowRoot = !isInert(shadowRoot, false) && (!options.shadowRootFilter || options.shadowRootFilter(element));
      if (shadowRoot && validShadowRoot) {
        var _nestedCandidates = getCandidatesIteratively2(shadowRoot === true ? element.children : shadowRoot.children, true, options);
        if (options.flatten) {
          candidates.push.apply(candidates, _nestedCandidates);
        } else {
          candidates.push({
            scopeParent: element,
            candidates: _nestedCandidates
          });
        }
      } else {
        elementsToCheck.unshift.apply(elementsToCheck, element.children);
      }
    }
  }
  return candidates;
};
var hasTabIndex = function hasTabIndex2(node) {
  return !isNaN(parseInt(node.getAttribute("tabindex"), 10));
};
var getTabIndex = function getTabIndex2(node) {
  if (!node) {
    throw new Error("No node provided");
  }
  if (node.tabIndex < 0) {
    if ((/^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || isContentEditable(node)) && !hasTabIndex(node)) {
      return 0;
    }
  }
  return node.tabIndex;
};
var getSortOrderTabIndex = function getSortOrderTabIndex2(node, isScope) {
  var tabIndex = getTabIndex(node);
  if (tabIndex < 0 && isScope && !hasTabIndex(node)) {
    return 0;
  }
  return tabIndex;
};
var sortOrderedTabbables = function sortOrderedTabbables2(a, b) {
  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;
};
var isInput = function isInput2(node) {
  return node.tagName === "INPUT";
};
var isHiddenInput = function isHiddenInput2(node) {
  return isInput(node) && node.type === "hidden";
};
var isDetailsWithSummary = function isDetailsWithSummary2(node) {
  var r = node.tagName === "DETAILS" && Array.prototype.slice.apply(node.children).some(function(child) {
    return child.tagName === "SUMMARY";
  });
  return r;
};
var getCheckedRadio = function getCheckedRadio2(nodes, form) {
  for (var i = 0; i < nodes.length; i++) {
    if (nodes[i].checked && nodes[i].form === form) {
      return nodes[i];
    }
  }
};
var isTabbableRadio = function isTabbableRadio2(node) {
  if (!node.name) {
    return true;
  }
  var radioScope = node.form || getRootNode(node);
  var queryRadios = function queryRadios2(name2) {
    return radioScope.querySelectorAll('input[type="radio"][name="' + name2 + '"]');
  };
  var radioSet;
  if (typeof window !== "undefined" && typeof window.CSS !== "undefined" && typeof window.CSS.escape === "function") {
    radioSet = queryRadios(window.CSS.escape(node.name));
  } else {
    try {
      radioSet = queryRadios(node.name);
    } catch (err) {
      console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", err.message);
      return false;
    }
  }
  var checked = getCheckedRadio(radioSet, node.form);
  return !checked || checked === node;
};
var isRadio = function isRadio2(node) {
  return isInput(node) && node.type === "radio";
};
var isNonTabbableRadio = function isNonTabbableRadio2(node) {
  return isRadio(node) && !isTabbableRadio(node);
};
var isNodeAttached = function isNodeAttached2(node) {
  var _nodeRoot;
  var nodeRoot = node && getRootNode(node);
  var nodeRootHost = (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host;
  var attached = false;
  if (nodeRoot && nodeRoot !== node) {
    var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;
    attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null && _nodeRootHost$ownerDo !== void 0 && _nodeRootHost$ownerDo.contains(nodeRootHost) || node !== null && node !== void 0 && (_node$ownerDocument = node.ownerDocument) !== null && _node$ownerDocument !== void 0 && _node$ownerDocument.contains(node));
    while (!attached && nodeRootHost) {
      var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;
      nodeRoot = getRootNode(nodeRootHost);
      nodeRootHost = (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host;
      attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null && _nodeRootHost2$ownerD !== void 0 && _nodeRootHost2$ownerD.contains(nodeRootHost));
    }
  }
  return attached;
};
var isZeroArea = function isZeroArea2(node) {
  var _node$getBoundingClie = node.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
  return width === 0 && height === 0;
};
var isHidden = function isHidden2(node, _ref) {
  var displayCheck = _ref.displayCheck, getShadowRoot = _ref.getShadowRoot;
  if (getComputedStyle(node).visibility === "hidden") {
    return true;
  }
  var isDirectSummary = matches.call(node, "details>summary:first-of-type");
  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
  if (matches.call(nodeUnderDetails, "details:not([open]) *")) {
    return true;
  }
  if (!displayCheck || displayCheck === "full" || displayCheck === "legacy-full") {
    if (typeof getShadowRoot === "function") {
      var originalNode = node;
      while (node) {
        var parentElement = node.parentElement;
        var rootNode = getRootNode(node);
        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true) {
          return isZeroArea(node);
        } else if (node.assignedSlot) {
          node = node.assignedSlot;
        } else if (!parentElement && rootNode !== node.ownerDocument) {
          node = rootNode.host;
        } else {
          node = parentElement;
        }
      }
      node = originalNode;
    }
    if (isNodeAttached(node)) {
      return !node.getClientRects().length;
    }
    if (displayCheck !== "legacy-full") {
      return true;
    }
  } else if (displayCheck === "non-zero-area") {
    return isZeroArea(node);
  }
  return false;
};
var isDisabledFromFieldset = function isDisabledFromFieldset2(node) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
    var parentNode = node.parentElement;
    while (parentNode) {
      if (parentNode.tagName === "FIELDSET" && parentNode.disabled) {
        for (var i = 0; i < parentNode.children.length; i++) {
          var child = parentNode.children.item(i);
          if (child.tagName === "LEGEND") {
            return matches.call(parentNode, "fieldset[disabled] *") ? true : !child.contains(node);
          }
        }
        return true;
      }
      parentNode = parentNode.parentElement;
    }
  }
  return false;
};
var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options, node) {
  if (node.disabled || // we must do an inert look up to filter out any elements inside an inert ancestor
  //  because we're limited in the type of selectors we can use in JSDom (see related
  //  note related to `candidateSelectors`)
  isInert(node) || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus
  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
    return false;
  }
  return true;
};
var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options, node) {
  if (isNonTabbableRadio(node) || getTabIndex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {
    return false;
  }
  return true;
};
var isValidShadowRootTabbable = function isValidShadowRootTabbable2(shadowHostNode) {
  var tabIndex = parseInt(shadowHostNode.getAttribute("tabindex"), 10);
  if (isNaN(tabIndex) || tabIndex >= 0) {
    return true;
  }
  return false;
};
var sortByOrder = function sortByOrder2(candidates) {
  var regularTabbables = [];
  var orderedTabbables = [];
  candidates.forEach(function(item, i) {
    var isScope = !!item.scopeParent;
    var element = isScope ? item.scopeParent : item;
    var candidateTabindex = getSortOrderTabIndex(element, isScope);
    var elements = isScope ? sortByOrder2(item.candidates) : element;
    if (candidateTabindex === 0) {
      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);
    } else {
      orderedTabbables.push({
        documentOrder: i,
        tabIndex: candidateTabindex,
        item,
        isScope,
        content: elements
      });
    }
  });
  return orderedTabbables.sort(sortOrderedTabbables).reduce(function(acc, sortable) {
    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
    return acc;
  }, []).concat(regularTabbables);
};
var tabbable = function tabbable2(container, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([container], options.includeContainer, {
      filter: isNodeMatchingSelectorTabbable.bind(null, options),
      flatten: false,
      getShadowRoot: options.getShadowRoot,
      shadowRootFilter: isValidShadowRootTabbable
    });
  } else {
    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));
  }
  return sortByOrder(candidates);
};
var focusable = function focusable2(container, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([container], options.includeContainer, {
      filter: isNodeMatchingSelectorFocusable.bind(null, options),
      flatten: true,
      getShadowRoot: options.getShadowRoot
    });
  } else {
    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));
  }
  return candidates;
};
var isTabbable = function isTabbable2(node, options) {
  options = options || {};
  if (!node) {
    throw new Error("No node provided");
  }
  if (matches.call(node, candidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorTabbable(options, node);
};
var focusableCandidateSelector = candidateSelectors.concat("iframe").join(",");

// node_modules/@floating-ui/react/dist/floating-ui.react.utils.mjs
function getPlatform() {
  const uaData = navigator.userAgentData;
  if (uaData != null && uaData.platform) {
    return uaData.platform;
  }
  return navigator.platform;
}
function getUserAgent() {
  const uaData = navigator.userAgentData;
  if (uaData && Array.isArray(uaData.brands)) {
    return uaData.brands.map((_ref) => {
      let {
        brand,
        version: version3
      } = _ref;
      return brand + "/" + version3;
    }).join(" ");
  }
  return navigator.userAgent;
}
function isSafari2() {
  return /apple/i.test(navigator.vendor);
}
function isAndroid() {
  const re = /android/i;
  return re.test(getPlatform()) || re.test(getUserAgent());
}
function isJSDOM() {
  return getUserAgent().includes("jsdom/");
}
var FOCUSABLE_ATTRIBUTE = "data-floating-ui-focusable";
var TYPEABLE_SELECTOR = "input:not([type='hidden']):not([disabled]),[contenteditable]:not([contenteditable='false']),textarea:not([disabled])";
var ARROW_LEFT = "ArrowLeft";
var ARROW_RIGHT = "ArrowRight";
var ARROW_UP = "ArrowUp";
var ARROW_DOWN = "ArrowDown";
function activeElement(doc) {
  let activeElement2 = doc.activeElement;
  while (((_activeElement = activeElement2) == null || (_activeElement = _activeElement.shadowRoot) == null ? void 0 : _activeElement.activeElement) != null) {
    var _activeElement;
    activeElement2 = activeElement2.shadowRoot.activeElement;
  }
  return activeElement2;
}
function contains(parent, child) {
  if (!parent || !child) {
    return false;
  }
  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode();
  if (parent.contains(child)) {
    return true;
  }
  if (rootNode && isShadowRoot(rootNode)) {
    let next = child;
    while (next) {
      if (parent === next) {
        return true;
      }
      next = next.parentNode || next.host;
    }
  }
  return false;
}
function getTarget(event) {
  if ("composedPath" in event) {
    return event.composedPath()[0];
  }
  return event.target;
}
function isEventTargetWithin(event, node) {
  if (node == null) {
    return false;
  }
  if ("composedPath" in event) {
    return event.composedPath().includes(node);
  }
  const e = event;
  return e.target != null && node.contains(e.target);
}
function isRootElement(element) {
  return element.matches("html,body");
}
function getDocument(node) {
  return (node == null ? void 0 : node.ownerDocument) || document;
}
function isTypeableElement(element) {
  return isHTMLElement(element) && element.matches(TYPEABLE_SELECTOR);
}
function isTypeableCombobox(element) {
  if (!element) return false;
  return element.getAttribute("role") === "combobox" && isTypeableElement(element);
}
function getFloatingFocusElement(floatingElement) {
  if (!floatingElement) {
    return null;
  }
  return floatingElement.hasAttribute(FOCUSABLE_ATTRIBUTE) ? floatingElement : floatingElement.querySelector("[" + FOCUSABLE_ATTRIBUTE + "]") || floatingElement;
}
function getNodeChildren(nodes, id, onlyOpenChildren) {
  if (onlyOpenChildren === void 0) {
    onlyOpenChildren = true;
  }
  let allChildren = nodes.filter((node) => {
    var _node$context;
    return node.parentId === id && ((_node$context = node.context) == null ? void 0 : _node$context.open);
  });
  let currentChildren = allChildren;
  while (currentChildren.length) {
    currentChildren = onlyOpenChildren ? nodes.filter((node) => {
      var _currentChildren;
      return (_currentChildren = currentChildren) == null ? void 0 : _currentChildren.some((n) => {
        var _node$context2;
        return node.parentId === n.id && ((_node$context2 = node.context) == null ? void 0 : _node$context2.open);
      });
    }) : nodes;
    allChildren = allChildren.concat(currentChildren);
  }
  return allChildren;
}
function getDeepestNode(nodes, id) {
  let deepestNodeId;
  let maxDepth = -1;
  function findDeepest(nodeId, depth) {
    if (depth > maxDepth) {
      deepestNodeId = nodeId;
      maxDepth = depth;
    }
    const children = getNodeChildren(nodes, nodeId);
    children.forEach((child) => {
      findDeepest(child.id, depth + 1);
    });
  }
  findDeepest(id, 0);
  return nodes.find((node) => node.id === deepestNodeId);
}
function getNodeAncestors(nodes, id) {
  var _nodes$find;
  let allAncestors = [];
  let currentParentId = (_nodes$find = nodes.find((node) => node.id === id)) == null ? void 0 : _nodes$find.parentId;
  while (currentParentId) {
    const currentNode = nodes.find((node) => node.id === currentParentId);
    currentParentId = currentNode == null ? void 0 : currentNode.parentId;
    if (currentNode) {
      allAncestors = allAncestors.concat(currentNode);
    }
  }
  return allAncestors;
}
function stopEvent(event) {
  event.preventDefault();
  event.stopPropagation();
}
function isReactEvent(event) {
  return "nativeEvent" in event;
}
function isVirtualClick(event) {
  if (event.mozInputSource === 0 && event.isTrusted) {
    return true;
  }
  if (isAndroid() && event.pointerType) {
    return event.type === "click" && event.buttons === 1;
  }
  return event.detail === 0 && !event.pointerType;
}
function isVirtualPointerEvent(event) {
  if (isJSDOM()) return false;
  return !isAndroid() && event.width === 0 && event.height === 0 || isAndroid() && event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === "mouse" || // iOS VoiceOver returns 0.333• for width/height.
  event.width < 1 && event.height < 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === "touch";
}
function isMouseLikePointerType(pointerType, strict) {
  const values = ["mouse", "pen"];
  if (!strict) {
    values.push("", void 0);
  }
  return values.includes(pointerType);
}
var index = typeof document !== "undefined" ? import_react2.useLayoutEffect : import_react2.useEffect;
var SafeReact = {
  ...React
};
function useLatestRef(value) {
  const ref = React.useRef(value);
  index(() => {
    ref.current = value;
  });
  return ref;
}
var useInsertionEffect = SafeReact.useInsertionEffect;
var useSafeInsertionEffect = useInsertionEffect || ((fn) => fn());
function useEffectEvent(callback) {
  const ref = React.useRef(() => {
    if (true) {
      throw new Error("Cannot call an event handler while rendering.");
    }
  });
  useSafeInsertionEffect(() => {
    ref.current = callback;
  });
  return React.useCallback(function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return ref.current == null ? void 0 : ref.current(...args);
  }, []);
}
function isDifferentGridRow(index3, cols, prevRow) {
  return Math.floor(index3 / cols) !== prevRow;
}
function isIndexOutOfListBounds(listRef, index3) {
  return index3 < 0 || index3 >= listRef.current.length;
}
function getMinListIndex(listRef, disabledIndices) {
  return findNonDisabledListIndex(listRef, {
    disabledIndices
  });
}
function getMaxListIndex(listRef, disabledIndices) {
  return findNonDisabledListIndex(listRef, {
    decrement: true,
    startingIndex: listRef.current.length,
    disabledIndices
  });
}
function findNonDisabledListIndex(listRef, _temp) {
  let {
    startingIndex = -1,
    decrement = false,
    disabledIndices,
    amount = 1
  } = _temp === void 0 ? {} : _temp;
  let index3 = startingIndex;
  do {
    index3 += decrement ? -amount : amount;
  } while (index3 >= 0 && index3 <= listRef.current.length - 1 && isListIndexDisabled(listRef, index3, disabledIndices));
  return index3;
}
function getGridNavigatedIndex(listRef, _ref) {
  let {
    event,
    orientation,
    loop,
    rtl,
    cols,
    disabledIndices,
    minIndex,
    maxIndex,
    prevIndex,
    stopEvent: stop = false
  } = _ref;
  let nextIndex = prevIndex;
  if (event.key === ARROW_UP) {
    stop && stopEvent(event);
    if (prevIndex === -1) {
      nextIndex = maxIndex;
    } else {
      nextIndex = findNonDisabledListIndex(listRef, {
        startingIndex: nextIndex,
        amount: cols,
        decrement: true,
        disabledIndices
      });
      if (loop && (prevIndex - cols < minIndex || nextIndex < 0)) {
        const col = prevIndex % cols;
        const maxCol = maxIndex % cols;
        const offset4 = maxIndex - (maxCol - col);
        if (maxCol === col) {
          nextIndex = maxIndex;
        } else {
          nextIndex = maxCol > col ? offset4 : offset4 - cols;
        }
      }
    }
    if (isIndexOutOfListBounds(listRef, nextIndex)) {
      nextIndex = prevIndex;
    }
  }
  if (event.key === ARROW_DOWN) {
    stop && stopEvent(event);
    if (prevIndex === -1) {
      nextIndex = minIndex;
    } else {
      nextIndex = findNonDisabledListIndex(listRef, {
        startingIndex: prevIndex,
        amount: cols,
        disabledIndices
      });
      if (loop && prevIndex + cols > maxIndex) {
        nextIndex = findNonDisabledListIndex(listRef, {
          startingIndex: prevIndex % cols - cols,
          amount: cols,
          disabledIndices
        });
      }
    }
    if (isIndexOutOfListBounds(listRef, nextIndex)) {
      nextIndex = prevIndex;
    }
  }
  if (orientation === "both") {
    const prevRow = floor(prevIndex / cols);
    if (event.key === (rtl ? ARROW_LEFT : ARROW_RIGHT)) {
      stop && stopEvent(event);
      if (prevIndex % cols !== cols - 1) {
        nextIndex = findNonDisabledListIndex(listRef, {
          startingIndex: prevIndex,
          disabledIndices
        });
        if (loop && isDifferentGridRow(nextIndex, cols, prevRow)) {
          nextIndex = findNonDisabledListIndex(listRef, {
            startingIndex: prevIndex - prevIndex % cols - 1,
            disabledIndices
          });
        }
      } else if (loop) {
        nextIndex = findNonDisabledListIndex(listRef, {
          startingIndex: prevIndex - prevIndex % cols - 1,
          disabledIndices
        });
      }
      if (isDifferentGridRow(nextIndex, cols, prevRow)) {
        nextIndex = prevIndex;
      }
    }
    if (event.key === (rtl ? ARROW_RIGHT : ARROW_LEFT)) {
      stop && stopEvent(event);
      if (prevIndex % cols !== 0) {
        nextIndex = findNonDisabledListIndex(listRef, {
          startingIndex: prevIndex,
          decrement: true,
          disabledIndices
        });
        if (loop && isDifferentGridRow(nextIndex, cols, prevRow)) {
          nextIndex = findNonDisabledListIndex(listRef, {
            startingIndex: prevIndex + (cols - prevIndex % cols),
            decrement: true,
            disabledIndices
          });
        }
      } else if (loop) {
        nextIndex = findNonDisabledListIndex(listRef, {
          startingIndex: prevIndex + (cols - prevIndex % cols),
          decrement: true,
          disabledIndices
        });
      }
      if (isDifferentGridRow(nextIndex, cols, prevRow)) {
        nextIndex = prevIndex;
      }
    }
    const lastRow = floor(maxIndex / cols) === prevRow;
    if (isIndexOutOfListBounds(listRef, nextIndex)) {
      if (loop && lastRow) {
        nextIndex = event.key === (rtl ? ARROW_RIGHT : ARROW_LEFT) ? maxIndex : findNonDisabledListIndex(listRef, {
          startingIndex: prevIndex - prevIndex % cols - 1,
          disabledIndices
        });
      } else {
        nextIndex = prevIndex;
      }
    }
  }
  return nextIndex;
}
function createGridCellMap(sizes, cols, dense) {
  const cellMap = [];
  let startIndex = 0;
  sizes.forEach((_ref2, index3) => {
    let {
      width,
      height
    } = _ref2;
    if (width > cols) {
      if (true) {
        throw new Error("[Floating UI]: Invalid grid - item width at index " + index3 + " is greater than grid columns");
      }
    }
    let itemPlaced = false;
    if (dense) {
      startIndex = 0;
    }
    while (!itemPlaced) {
      const targetCells = [];
      for (let i = 0; i < width; i++) {
        for (let j = 0; j < height; j++) {
          targetCells.push(startIndex + i + j * cols);
        }
      }
      if (startIndex % cols + width <= cols && targetCells.every((cell) => cellMap[cell] == null)) {
        targetCells.forEach((cell) => {
          cellMap[cell] = index3;
        });
        itemPlaced = true;
      } else {
        startIndex++;
      }
    }
  });
  return [...cellMap];
}
function getGridCellIndexOfCorner(index3, sizes, cellMap, cols, corner) {
  if (index3 === -1) return -1;
  const firstCellIndex = cellMap.indexOf(index3);
  const sizeItem = sizes[index3];
  switch (corner) {
    case "tl":
      return firstCellIndex;
    case "tr":
      if (!sizeItem) {
        return firstCellIndex;
      }
      return firstCellIndex + sizeItem.width - 1;
    case "bl":
      if (!sizeItem) {
        return firstCellIndex;
      }
      return firstCellIndex + (sizeItem.height - 1) * cols;
    case "br":
      return cellMap.lastIndexOf(index3);
  }
}
function getGridCellIndices(indices, cellMap) {
  return cellMap.flatMap((index3, cellIndex) => indices.includes(index3) ? [cellIndex] : []);
}
function isListIndexDisabled(listRef, index3, disabledIndices) {
  if (disabledIndices) {
    return disabledIndices.includes(index3);
  }
  const element = listRef.current[index3];
  return element == null || element.hasAttribute("disabled") || element.getAttribute("aria-disabled") === "true";
}
var getTabbableOptions = () => ({
  getShadowRoot: true,
  displayCheck: (
    // JSDOM does not support the `tabbable` library. To solve this we can
    // check if `ResizeObserver` is a real function (not polyfilled), which
    // determines if the current environment is JSDOM-like.
    typeof ResizeObserver === "function" && ResizeObserver.toString().includes("[native code]") ? "full" : "none"
  )
});
function getTabbableIn(container, dir2) {
  const list = tabbable(container, getTabbableOptions());
  const len = list.length;
  if (len === 0) return;
  const active = activeElement(getDocument(container));
  const index3 = list.indexOf(active);
  const nextIndex = index3 === -1 ? dir2 === 1 ? 0 : len - 1 : index3 + dir2;
  return list[nextIndex];
}
function getNextTabbable(referenceElement) {
  return getTabbableIn(getDocument(referenceElement).body, 1) || referenceElement;
}
function getPreviousTabbable(referenceElement) {
  return getTabbableIn(getDocument(referenceElement).body, -1) || referenceElement;
}
function isOutsideEvent(event, container) {
  const containerElement = container || event.currentTarget;
  const relatedTarget = event.relatedTarget;
  return !relatedTarget || !contains(containerElement, relatedTarget);
}
function disableFocusInside(container) {
  const tabbableElements = tabbable(container, getTabbableOptions());
  tabbableElements.forEach((element) => {
    element.dataset.tabindex = element.getAttribute("tabindex") || "";
    element.setAttribute("tabindex", "-1");
  });
}
function enableFocusInside(container) {
  const elements = container.querySelectorAll("[data-tabindex]");
  elements.forEach((element) => {
    const tabindex = element.dataset.tabindex;
    delete element.dataset.tabindex;
    if (tabindex) {
      element.setAttribute("tabindex", tabindex);
    } else {
      element.removeAttribute("tabindex");
    }
  });
}

// node_modules/@floating-ui/react/dist/floating-ui.react.mjs
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var ReactDOM2 = __toESM(require_react_dom(), 1);

// node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config2) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config2;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name: name2,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name2]: {
        ...middlewareData[name2],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var arrow = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x,
      y,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x,
      y
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min2(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min2(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max3 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset4 = clamp(min$1, center, max3);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset4 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max3 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset4,
        centerOffset: center - offset4 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x,
        y,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min3 = mainAxisCoord + overflow[minSide];
        const max3 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min3, mainAxisCoord, max3);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min3 = crossAxisCoord + overflow[minSide];
        const max3 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min3, crossAxisCoord, max3);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
var size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min2(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min2(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max2(overflow.left, 0);
        const xMax = max2(overflow.right, 0);
        const yMin = max2(overflow.top, 0);
        const yMax = max2(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max2(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max2(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};

// node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css = getComputedStyle2(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
var noOffsets = createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle2(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
  if (ignoreScrollbarX === void 0) {
    ignoreScrollbarX = false;
  }
  const htmlRect = documentElement.getBoundingClientRect();
  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (
    // RTL <body> scrollbar.
    getWindowScrollBarX(documentElement, htmlRect)
  ));
  const y = htmlRect.top + scroll.scrollTop;
  return {
    x,
    y
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max2(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max2(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle2(body).direction === "rtl") {
    x += max2(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle2(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle2(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max2(rect.top, accRect.top);
    accRect.right = min2(rect.right, accRect.right);
    accRect.bottom = min2(rect.bottom, accRect.bottom);
    accRect.left = max2(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle2(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle2(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
var getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle2(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function rectsAreEqual(a, b) {
  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup2() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip2, threshold) {
    if (skip2 === void 0) {
      skip2 = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup2();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip2) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max2(0, min2(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup2;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame: animationFrame2 = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame2) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame2 ? getBoundingClientRect(reference) : null;
  if (animationFrame2) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame2) {
      cancelAnimationFrame(frameId);
    }
  };
}
var offset2 = offset;
var shift2 = shift;
var flip2 = flip;
var size2 = size;
var arrow2 = arrow;
var computePosition2 = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs
var React2 = __toESM(require_react(), 1);
var import_react3 = __toESM(require_react(), 1);
var ReactDOM = __toESM(require_react_dom(), 1);
var index2 = typeof document !== "undefined" ? import_react3.useLayoutEffect : import_react3.useEffect;
function deepEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (typeof a !== typeof b) {
    return false;
  }
  if (typeof a === "function" && a.toString() === b.toString()) {
    return true;
  }
  let length;
  let i;
  let keys;
  if (a && b && typeof a === "object") {
    if (Array.isArray(a)) {
      length = a.length;
      if (length !== b.length) return false;
      for (i = length; i-- !== 0; ) {
        if (!deepEqual(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) {
      return false;
    }
    for (i = length; i-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b, keys[i])) {
        return false;
      }
    }
    for (i = length; i-- !== 0; ) {
      const key = keys[i];
      if (key === "_owner" && a.$$typeof) {
        continue;
      }
      if (!deepEqual(a[key], b[key])) {
        return false;
      }
    }
    return true;
  }
  return a !== a && b !== b;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef2(value) {
  const ref = React2.useRef(value);
  index2(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform: transform2 = true,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = React2.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = React2.useState(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const [_reference, _setReference] = React2.useState(null);
  const [_floating, _setFloating] = React2.useState(null);
  const setReference = React2.useCallback((node) => {
    if (node !== referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  const setFloating = React2.useCallback((node) => {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = React2.useRef(null);
  const floatingRef = React2.useRef(null);
  const dataRef = React2.useRef(data);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef2(whileElementsMounted);
  const platformRef = useLatestRef2(platform2);
  const openRef = useLatestRef2(open);
  const update = React2.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config2 = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config2.platform = platformRef.current;
    }
    computePosition2(referenceRef.current, floatingRef.current, config2).then((data2) => {
      const fullData = {
        ...data2,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: openRef.current !== false
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        ReactDOM.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef, openRef]);
  index2(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = React2.useRef(false);
  index2(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index2(() => {
    if (referenceEl) referenceRef.current = referenceEl;
    if (floatingEl) floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      }
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = React2.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = React2.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = React2.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x = roundByDPR(elements.floating, data.x);
    const y = roundByDPR(elements.floating, data.y);
    if (transform2) {
      return {
        ...initialStyles,
        transform: "translate(" + x + "px, " + y + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x,
      top: y
    };
  }, [strategy, transform2, elements.floating, data.x, data.y]);
  return React2.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}
var arrow$1 = (options) => {
  function isRef(value) {
    return {}.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(state) {
      const {
        element,
        padding
      } = typeof options === "function" ? options(state) : options;
      if (element && isRef(element)) {
        if (element.current != null) {
          return arrow2({
            element: element.current,
            padding
          }).fn(state);
        }
        return {};
      }
      if (element) {
        return arrow2({
          element,
          padding
        }).fn(state);
      }
      return {};
    }
  };
};
var offset3 = (options, deps) => ({
  ...offset2(options),
  options: [options, deps]
});
var shift3 = (options, deps) => ({
  ...shift2(options),
  options: [options, deps]
});
var flip3 = (options, deps) => ({
  ...flip2(options),
  options: [options, deps]
});
var size3 = (options, deps) => ({
  ...size2(options),
  options: [options, deps]
});
var arrow3 = (options, deps) => ({
  ...arrow$1(options),
  options: [options, deps]
});

// node_modules/@floating-ui/react/dist/floating-ui.react.mjs
function useMergeRefs(refs) {
  const cleanupRef = React3.useRef(void 0);
  const refEffect = React3.useCallback((instance2) => {
    const cleanups = refs.map((ref) => {
      if (ref == null) {
        return;
      }
      if (typeof ref === "function") {
        const refCallback = ref;
        const refCleanup = refCallback(instance2);
        return typeof refCleanup === "function" ? refCleanup : () => {
          refCallback(null);
        };
      }
      ref.current = instance2;
      return () => {
        ref.current = null;
      };
    });
    return () => {
      cleanups.forEach((refCleanup) => refCleanup == null ? void 0 : refCleanup());
    };
  }, refs);
  return React3.useMemo(() => {
    if (refs.every((ref) => ref == null)) {
      return null;
    }
    return (value) => {
      if (cleanupRef.current) {
        cleanupRef.current();
        cleanupRef.current = void 0;
      }
      if (value != null) {
        cleanupRef.current = refEffect(value);
      }
    };
  }, refs);
}
function sortByDocumentPosition(a, b) {
  const position = a.compareDocumentPosition(b);
  if (position & Node.DOCUMENT_POSITION_FOLLOWING || position & Node.DOCUMENT_POSITION_CONTAINED_BY) {
    return -1;
  }
  if (position & Node.DOCUMENT_POSITION_PRECEDING || position & Node.DOCUMENT_POSITION_CONTAINS) {
    return 1;
  }
  return 0;
}
var FloatingListContext = React3.createContext({
  register: () => {
  },
  unregister: () => {
  },
  map: /* @__PURE__ */ new Map(),
  elementsRef: {
    current: []
  }
});
function FloatingList(props) {
  const {
    children,
    elementsRef,
    labelsRef
  } = props;
  const [nodes, setNodes] = React3.useState(() => /* @__PURE__ */ new Set());
  const register = React3.useCallback((node) => {
    setNodes((prevSet) => new Set(prevSet).add(node));
  }, []);
  const unregister = React3.useCallback((node) => {
    setNodes((prevSet) => {
      const set = new Set(prevSet);
      set.delete(node);
      return set;
    });
  }, []);
  const map2 = React3.useMemo(() => {
    const newMap = /* @__PURE__ */ new Map();
    const sortedNodes = Array.from(nodes.keys()).sort(sortByDocumentPosition);
    sortedNodes.forEach((node, index3) => {
      newMap.set(node, index3);
    });
    return newMap;
  }, [nodes]);
  return (0, import_jsx_runtime2.jsx)(FloatingListContext.Provider, {
    value: React3.useMemo(() => ({
      register,
      unregister,
      map: map2,
      elementsRef,
      labelsRef
    }), [register, unregister, map2, elementsRef, labelsRef]),
    children
  });
}
function useListItem(props) {
  if (props === void 0) {
    props = {};
  }
  const {
    label
  } = props;
  const {
    register,
    unregister,
    map: map2,
    elementsRef,
    labelsRef
  } = React3.useContext(FloatingListContext);
  const [index3, setIndex] = React3.useState(null);
  const componentRef = React3.useRef(null);
  const ref = React3.useCallback((node) => {
    componentRef.current = node;
    if (index3 !== null) {
      elementsRef.current[index3] = node;
      if (labelsRef) {
        var _node$textContent;
        const isLabelDefined = label !== void 0;
        labelsRef.current[index3] = isLabelDefined ? label : (_node$textContent = node == null ? void 0 : node.textContent) != null ? _node$textContent : null;
      }
    }
  }, [index3, elementsRef, labelsRef, label]);
  index(() => {
    const node = componentRef.current;
    if (node) {
      register(node);
      return () => {
        unregister(node);
      };
    }
  }, [register, unregister]);
  index(() => {
    const index4 = componentRef.current ? map2.get(componentRef.current) : null;
    if (index4 != null) {
      setIndex(index4);
    }
  }, [map2]);
  return React3.useMemo(() => ({
    ref,
    index: index3 == null ? -1 : index3
  }), [index3, ref]);
}
var FOCUSABLE_ATTRIBUTE2 = "data-floating-ui-focusable";
var ACTIVE_KEY = "active";
var SELECTED_KEY = "selected";
var ARROW_LEFT2 = "ArrowLeft";
var ARROW_RIGHT2 = "ArrowRight";
var ARROW_UP2 = "ArrowUp";
var ARROW_DOWN2 = "ArrowDown";
function renderJsx(render, computedProps) {
  if (typeof render === "function") {
    return render(computedProps);
  }
  if (render) {
    return React3.cloneElement(render, computedProps);
  }
  return (0, import_jsx_runtime2.jsx)("div", {
    ...computedProps
  });
}
var CompositeContext = React3.createContext({
  activeIndex: 0,
  onNavigate: () => {
  }
});
var horizontalKeys = [ARROW_LEFT2, ARROW_RIGHT2];
var verticalKeys = [ARROW_UP2, ARROW_DOWN2];
var allKeys = [...horizontalKeys, ...verticalKeys];
var Composite = React3.forwardRef(function Composite2(props, forwardedRef) {
  const {
    render,
    orientation = "both",
    loop = true,
    rtl = false,
    cols = 1,
    disabledIndices,
    activeIndex: externalActiveIndex,
    onNavigate: externalSetActiveIndex,
    itemSizes,
    dense = false,
    ...domProps
  } = props;
  const [internalActiveIndex, internalSetActiveIndex] = React3.useState(0);
  const activeIndex = externalActiveIndex != null ? externalActiveIndex : internalActiveIndex;
  const onNavigate = useEffectEvent(externalSetActiveIndex != null ? externalSetActiveIndex : internalSetActiveIndex);
  const elementsRef = React3.useRef([]);
  const renderElementProps = render && typeof render !== "function" ? render.props : {};
  const contextValue = React3.useMemo(() => ({
    activeIndex,
    onNavigate
  }), [activeIndex, onNavigate]);
  const isGrid = cols > 1;
  function handleKeyDown(event) {
    if (!allKeys.includes(event.key)) return;
    let nextIndex = activeIndex;
    const minIndex = getMinListIndex(elementsRef, disabledIndices);
    const maxIndex = getMaxListIndex(elementsRef, disabledIndices);
    const horizontalEndKey = rtl ? ARROW_LEFT2 : ARROW_RIGHT2;
    const horizontalStartKey = rtl ? ARROW_RIGHT2 : ARROW_LEFT2;
    if (isGrid) {
      const sizes = itemSizes || Array.from({
        length: elementsRef.current.length
      }, () => ({
        width: 1,
        height: 1
      }));
      const cellMap = createGridCellMap(sizes, cols, dense);
      const minGridIndex = cellMap.findIndex((index3) => index3 != null && !isListIndexDisabled(elementsRef, index3, disabledIndices));
      const maxGridIndex = cellMap.reduce((foundIndex, index3, cellIndex) => index3 != null && !isListIndexDisabled(elementsRef, index3, disabledIndices) ? cellIndex : foundIndex, -1);
      const maybeNextIndex = cellMap[getGridNavigatedIndex({
        current: cellMap.map((itemIndex) => itemIndex ? elementsRef.current[itemIndex] : null)
      }, {
        event,
        orientation,
        loop,
        rtl,
        cols,
        // treat undefined (empty grid spaces) as disabled indices so we
        // don't end up in them
        disabledIndices: getGridCellIndices([...disabledIndices || elementsRef.current.map((_, index3) => isListIndexDisabled(elementsRef, index3) ? index3 : void 0), void 0], cellMap),
        minIndex: minGridIndex,
        maxIndex: maxGridIndex,
        prevIndex: getGridCellIndexOfCorner(
          activeIndex > maxIndex ? minIndex : activeIndex,
          sizes,
          cellMap,
          cols,
          // use a corner matching the edge closest to the direction we're
          // moving in so we don't end up in the same item. Prefer
          // top/left over bottom/right.
          event.key === ARROW_DOWN2 ? "bl" : event.key === horizontalEndKey ? "tr" : "tl"
        )
      })];
      if (maybeNextIndex != null) {
        nextIndex = maybeNextIndex;
      }
    }
    const toEndKeys = {
      horizontal: [horizontalEndKey],
      vertical: [ARROW_DOWN2],
      both: [horizontalEndKey, ARROW_DOWN2]
    }[orientation];
    const toStartKeys = {
      horizontal: [horizontalStartKey],
      vertical: [ARROW_UP2],
      both: [horizontalStartKey, ARROW_UP2]
    }[orientation];
    const preventedKeys = isGrid ? allKeys : {
      horizontal: horizontalKeys,
      vertical: verticalKeys,
      both: allKeys
    }[orientation];
    if (nextIndex === activeIndex && [...toEndKeys, ...toStartKeys].includes(event.key)) {
      if (loop && nextIndex === maxIndex && toEndKeys.includes(event.key)) {
        nextIndex = minIndex;
      } else if (loop && nextIndex === minIndex && toStartKeys.includes(event.key)) {
        nextIndex = maxIndex;
      } else {
        nextIndex = findNonDisabledListIndex(elementsRef, {
          startingIndex: nextIndex,
          decrement: toStartKeys.includes(event.key),
          disabledIndices
        });
      }
    }
    if (nextIndex !== activeIndex && !isIndexOutOfListBounds(elementsRef, nextIndex)) {
      var _elementsRef$current$;
      event.stopPropagation();
      if (preventedKeys.includes(event.key)) {
        event.preventDefault();
      }
      onNavigate(nextIndex);
      (_elementsRef$current$ = elementsRef.current[nextIndex]) == null || _elementsRef$current$.focus();
    }
  }
  const computedProps = {
    ...domProps,
    ...renderElementProps,
    ref: forwardedRef,
    "aria-orientation": orientation === "both" ? void 0 : orientation,
    onKeyDown(e) {
      domProps.onKeyDown == null || domProps.onKeyDown(e);
      renderElementProps.onKeyDown == null || renderElementProps.onKeyDown(e);
      handleKeyDown(e);
    }
  };
  return (0, import_jsx_runtime2.jsx)(CompositeContext.Provider, {
    value: contextValue,
    children: (0, import_jsx_runtime2.jsx)(FloatingList, {
      elementsRef,
      children: renderJsx(render, computedProps)
    })
  });
});
var CompositeItem = React3.forwardRef(function CompositeItem2(props, forwardedRef) {
  const {
    render,
    ...domProps
  } = props;
  const renderElementProps = render && typeof render !== "function" ? render.props : {};
  const {
    activeIndex,
    onNavigate
  } = React3.useContext(CompositeContext);
  const {
    ref,
    index: index3
  } = useListItem();
  const mergedRef = useMergeRefs([ref, forwardedRef, renderElementProps.ref]);
  const isActive = activeIndex === index3;
  const computedProps = {
    ...domProps,
    ...renderElementProps,
    ref: mergedRef,
    tabIndex: isActive ? 0 : -1,
    "data-active": isActive ? "" : void 0,
    onFocus(e) {
      domProps.onFocus == null || domProps.onFocus(e);
      renderElementProps.onFocus == null || renderElementProps.onFocus(e);
      onNavigate(index3);
    }
  };
  return renderJsx(render, computedProps);
});
var SafeReact2 = {
  ...React3
};
var serverHandoffComplete = false;
var count2 = 0;
var genId = () => (
  // Ensure the id is unique with multiple independent versions of Floating UI
  // on <React 18
  "floating-ui-" + Math.random().toString(36).slice(2, 6) + count2++
);
function useFloatingId() {
  const [id, setId] = React3.useState(() => serverHandoffComplete ? genId() : void 0);
  index(() => {
    if (id == null) {
      setId(genId());
    }
  }, []);
  React3.useEffect(() => {
    serverHandoffComplete = true;
  }, []);
  return id;
}
var useReactId = SafeReact2.useId;
var useId = useReactId || useFloatingId;
var devMessageSet;
if (true) {
  devMessageSet = /* @__PURE__ */ new Set();
}
function warn() {
  var _devMessageSet;
  for (var _len = arguments.length, messages = new Array(_len), _key = 0; _key < _len; _key++) {
    messages[_key] = arguments[_key];
  }
  const message = "Floating UI: " + messages.join(" ");
  if (!((_devMessageSet = devMessageSet) != null && _devMessageSet.has(message))) {
    var _devMessageSet2;
    (_devMessageSet2 = devMessageSet) == null || _devMessageSet2.add(message);
    console.warn(message);
  }
}
function error() {
  var _devMessageSet3;
  for (var _len2 = arguments.length, messages = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    messages[_key2] = arguments[_key2];
  }
  const message = "Floating UI: " + messages.join(" ");
  if (!((_devMessageSet3 = devMessageSet) != null && _devMessageSet3.has(message))) {
    var _devMessageSet4;
    (_devMessageSet4 = devMessageSet) == null || _devMessageSet4.add(message);
    console.error(message);
  }
}
var FloatingArrow = React3.forwardRef(function FloatingArrow2(props, ref) {
  const {
    context: {
      placement,
      elements: {
        floating
      },
      middlewareData: {
        arrow: arrow4,
        shift: shift4
      }
    },
    width = 14,
    height = 7,
    tipRadius = 0,
    strokeWidth = 0,
    staticOffset,
    stroke,
    d,
    style: {
      transform: transform2,
      ...restStyle
    } = {},
    ...rest
  } = props;
  if (true) {
    if (!ref) {
      warn("The `ref` prop is required for `FloatingArrow`.");
    }
  }
  const clipPathId = useId();
  const [isRTL2, setIsRTL] = React3.useState(false);
  index(() => {
    if (!floating) return;
    const isRTL3 = getComputedStyle2(floating).direction === "rtl";
    if (isRTL3) {
      setIsRTL(true);
    }
  }, [floating]);
  if (!floating) {
    return null;
  }
  const [side, alignment] = placement.split("-");
  const isVerticalSide = side === "top" || side === "bottom";
  let computedStaticOffset = staticOffset;
  if (isVerticalSide && shift4 != null && shift4.x || !isVerticalSide && shift4 != null && shift4.y) {
    computedStaticOffset = null;
  }
  const computedStrokeWidth = strokeWidth * 2;
  const halfStrokeWidth = computedStrokeWidth / 2;
  const svgX = width / 2 * (tipRadius / -8 + 1);
  const svgY = height / 2 * tipRadius / 4;
  const isCustomShape = !!d;
  const yOffsetProp = computedStaticOffset && alignment === "end" ? "bottom" : "top";
  let xOffsetProp = computedStaticOffset && alignment === "end" ? "right" : "left";
  if (computedStaticOffset && isRTL2) {
    xOffsetProp = alignment === "end" ? "left" : "right";
  }
  const arrowX = (arrow4 == null ? void 0 : arrow4.x) != null ? computedStaticOffset || arrow4.x : "";
  const arrowY = (arrow4 == null ? void 0 : arrow4.y) != null ? computedStaticOffset || arrow4.y : "";
  const dValue = d || "M0,0" + (" H" + width) + (" L" + (width - svgX) + "," + (height - svgY)) + (" Q" + width / 2 + "," + height + " " + svgX + "," + (height - svgY)) + " Z";
  const rotation = {
    top: isCustomShape ? "rotate(180deg)" : "",
    left: isCustomShape ? "rotate(90deg)" : "rotate(-90deg)",
    bottom: isCustomShape ? "" : "rotate(180deg)",
    right: isCustomShape ? "rotate(-90deg)" : "rotate(90deg)"
  }[side];
  return (0, import_jsx_runtime2.jsxs)("svg", {
    ...rest,
    "aria-hidden": true,
    ref,
    width: isCustomShape ? width : width + computedStrokeWidth,
    height: width,
    viewBox: "0 0 " + width + " " + (height > width ? height : width),
    style: {
      position: "absolute",
      pointerEvents: "none",
      [xOffsetProp]: arrowX,
      [yOffsetProp]: arrowY,
      [side]: isVerticalSide || isCustomShape ? "100%" : "calc(100% - " + computedStrokeWidth / 2 + "px)",
      transform: [rotation, transform2].filter((t2) => !!t2).join(" "),
      ...restStyle
    },
    children: [computedStrokeWidth > 0 && (0, import_jsx_runtime2.jsx)("path", {
      clipPath: "url(#" + clipPathId + ")",
      fill: "none",
      stroke,
      strokeWidth: computedStrokeWidth + (d ? 0 : 1),
      d: dValue
    }), (0, import_jsx_runtime2.jsx)("path", {
      stroke: computedStrokeWidth && !d ? rest.fill : "none",
      d: dValue
    }), (0, import_jsx_runtime2.jsx)("clipPath", {
      id: clipPathId,
      children: (0, import_jsx_runtime2.jsx)("rect", {
        x: -halfStrokeWidth,
        y: halfStrokeWidth * (isCustomShape ? -1 : 1),
        width: width + computedStrokeWidth,
        height: width
      })
    })]
  });
});
function createEventEmitter() {
  const map2 = /* @__PURE__ */ new Map();
  return {
    emit(event, data) {
      var _map$get;
      (_map$get = map2.get(event)) == null || _map$get.forEach((listener) => listener(data));
    },
    on(event, listener) {
      if (!map2.has(event)) {
        map2.set(event, /* @__PURE__ */ new Set());
      }
      map2.get(event).add(listener);
    },
    off(event, listener) {
      var _map$get2;
      (_map$get2 = map2.get(event)) == null || _map$get2.delete(listener);
    }
  };
}
var FloatingNodeContext = React3.createContext(null);
var FloatingTreeContext = React3.createContext(null);
var useFloatingParentNodeId = () => {
  var _React$useContext;
  return ((_React$useContext = React3.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;
};
var useFloatingTree = () => React3.useContext(FloatingTreeContext);
function createAttribute(name2) {
  return "data-floating-ui-" + name2;
}
function clearTimeoutIfSet(timeoutRef) {
  if (timeoutRef.current !== -1) {
    clearTimeout(timeoutRef.current);
    timeoutRef.current = -1;
  }
}
var safePolygonIdentifier = createAttribute("safe-polygon");
function getDelay(value, prop, pointerType) {
  if (pointerType && !isMouseLikePointerType(pointerType)) {
    return 0;
  }
  if (typeof value === "number") {
    return value;
  }
  if (typeof value === "function") {
    const result = value();
    if (typeof result === "number") {
      return result;
    }
    return result == null ? void 0 : result[prop];
  }
  return value == null ? void 0 : value[prop];
}
function getRestMs(value) {
  if (typeof value === "function") {
    return value();
  }
  return value;
}
function useHover(context2, props) {
  if (props === void 0) {
    props = {};
  }
  const {
    open,
    onOpenChange,
    dataRef,
    events: events2,
    elements
  } = context2;
  const {
    enabled = true,
    delay: delay3 = 0,
    handleClose = null,
    mouseOnly = false,
    restMs = 0,
    move = true
  } = props;
  const tree = useFloatingTree();
  const parentId = useFloatingParentNodeId();
  const handleCloseRef = useLatestRef(handleClose);
  const delayRef = useLatestRef(delay3);
  const openRef = useLatestRef(open);
  const restMsRef = useLatestRef(restMs);
  const pointerTypeRef = React3.useRef();
  const timeoutRef = React3.useRef(-1);
  const handlerRef = React3.useRef();
  const restTimeoutRef = React3.useRef(-1);
  const blockMouseMoveRef = React3.useRef(true);
  const performedPointerEventsMutationRef = React3.useRef(false);
  const unbindMouseMoveRef = React3.useRef(() => {
  });
  const restTimeoutPendingRef = React3.useRef(false);
  const isHoverOpen = React3.useCallback(() => {
    var _dataRef$current$open;
    const type = (_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type;
    return (type == null ? void 0 : type.includes("mouse")) && type !== "mousedown";
  }, [dataRef]);
  React3.useEffect(() => {
    if (!enabled) return;
    function onOpenChange2(_ref) {
      let {
        open: open2
      } = _ref;
      if (!open2) {
        clearTimeoutIfSet(timeoutRef);
        clearTimeoutIfSet(restTimeoutRef);
        blockMouseMoveRef.current = true;
        restTimeoutPendingRef.current = false;
      }
    }
    events2.on("openchange", onOpenChange2);
    return () => {
      events2.off("openchange", onOpenChange2);
    };
  }, [enabled, events2]);
  React3.useEffect(() => {
    if (!enabled) return;
    if (!handleCloseRef.current) return;
    if (!open) return;
    function onLeave(event) {
      if (isHoverOpen()) {
        onOpenChange(false, event, "hover");
      }
    }
    const html = getDocument(elements.floating).documentElement;
    html.addEventListener("mouseleave", onLeave);
    return () => {
      html.removeEventListener("mouseleave", onLeave);
    };
  }, [elements.floating, open, onOpenChange, enabled, handleCloseRef, isHoverOpen]);
  const closeWithDelay = React3.useCallback(function(event, runElseBranch, reason) {
    if (runElseBranch === void 0) {
      runElseBranch = true;
    }
    if (reason === void 0) {
      reason = "hover";
    }
    const closeDelay = getDelay(delayRef.current, "close", pointerTypeRef.current);
    if (closeDelay && !handlerRef.current) {
      clearTimeoutIfSet(timeoutRef);
      timeoutRef.current = window.setTimeout(() => onOpenChange(false, event, reason), closeDelay);
    } else if (runElseBranch) {
      clearTimeoutIfSet(timeoutRef);
      onOpenChange(false, event, reason);
    }
  }, [delayRef, onOpenChange]);
  const cleanupMouseMoveHandler = useEffectEvent(() => {
    unbindMouseMoveRef.current();
    handlerRef.current = void 0;
  });
  const clearPointerEvents = useEffectEvent(() => {
    if (performedPointerEventsMutationRef.current) {
      const body = getDocument(elements.floating).body;
      body.style.pointerEvents = "";
      body.removeAttribute(safePolygonIdentifier);
      performedPointerEventsMutationRef.current = false;
    }
  });
  const isClickLikeOpenEvent = useEffectEvent(() => {
    return dataRef.current.openEvent ? ["click", "mousedown"].includes(dataRef.current.openEvent.type) : false;
  });
  React3.useEffect(() => {
    if (!enabled) return;
    function onReferenceMouseEnter(event) {
      clearTimeoutIfSet(timeoutRef);
      blockMouseMoveRef.current = false;
      if (mouseOnly && !isMouseLikePointerType(pointerTypeRef.current) || getRestMs(restMsRef.current) > 0 && !getDelay(delayRef.current, "open")) {
        return;
      }
      const openDelay = getDelay(delayRef.current, "open", pointerTypeRef.current);
      if (openDelay) {
        timeoutRef.current = window.setTimeout(() => {
          if (!openRef.current) {
            onOpenChange(true, event, "hover");
          }
        }, openDelay);
      } else if (!open) {
        onOpenChange(true, event, "hover");
      }
    }
    function onReferenceMouseLeave(event) {
      if (isClickLikeOpenEvent()) {
        clearPointerEvents();
        return;
      }
      unbindMouseMoveRef.current();
      const doc = getDocument(elements.floating);
      clearTimeoutIfSet(restTimeoutRef);
      restTimeoutPendingRef.current = false;
      if (handleCloseRef.current && dataRef.current.floatingContext) {
        if (!open) {
          clearTimeoutIfSet(timeoutRef);
        }
        handlerRef.current = handleCloseRef.current({
          ...dataRef.current.floatingContext,
          tree,
          x: event.clientX,
          y: event.clientY,
          onClose() {
            clearPointerEvents();
            cleanupMouseMoveHandler();
            if (!isClickLikeOpenEvent()) {
              closeWithDelay(event, true, "safe-polygon");
            }
          }
        });
        const handler = handlerRef.current;
        doc.addEventListener("mousemove", handler);
        unbindMouseMoveRef.current = () => {
          doc.removeEventListener("mousemove", handler);
        };
        return;
      }
      const shouldClose = pointerTypeRef.current === "touch" ? !contains(elements.floating, event.relatedTarget) : true;
      if (shouldClose) {
        closeWithDelay(event);
      }
    }
    function onScrollMouseLeave(event) {
      if (isClickLikeOpenEvent()) return;
      if (!dataRef.current.floatingContext) return;
      handleCloseRef.current == null || handleCloseRef.current({
        ...dataRef.current.floatingContext,
        tree,
        x: event.clientX,
        y: event.clientY,
        onClose() {
          clearPointerEvents();
          cleanupMouseMoveHandler();
          if (!isClickLikeOpenEvent()) {
            closeWithDelay(event);
          }
        }
      })(event);
    }
    function onFloatingMouseEnter() {
      clearTimeoutIfSet(timeoutRef);
    }
    function onFloatingMouseLeave(event) {
      if (!isClickLikeOpenEvent()) {
        closeWithDelay(event, false);
      }
    }
    if (isElement(elements.domReference)) {
      const reference2 = elements.domReference;
      const floating = elements.floating;
      if (open) {
        reference2.addEventListener("mouseleave", onScrollMouseLeave);
      }
      if (move) {
        reference2.addEventListener("mousemove", onReferenceMouseEnter, {
          once: true
        });
      }
      reference2.addEventListener("mouseenter", onReferenceMouseEnter);
      reference2.addEventListener("mouseleave", onReferenceMouseLeave);
      if (floating) {
        floating.addEventListener("mouseleave", onScrollMouseLeave);
        floating.addEventListener("mouseenter", onFloatingMouseEnter);
        floating.addEventListener("mouseleave", onFloatingMouseLeave);
      }
      return () => {
        if (open) {
          reference2.removeEventListener("mouseleave", onScrollMouseLeave);
        }
        if (move) {
          reference2.removeEventListener("mousemove", onReferenceMouseEnter);
        }
        reference2.removeEventListener("mouseenter", onReferenceMouseEnter);
        reference2.removeEventListener("mouseleave", onReferenceMouseLeave);
        if (floating) {
          floating.removeEventListener("mouseleave", onScrollMouseLeave);
          floating.removeEventListener("mouseenter", onFloatingMouseEnter);
          floating.removeEventListener("mouseleave", onFloatingMouseLeave);
        }
      };
    }
  }, [elements, enabled, context2, mouseOnly, move, closeWithDelay, cleanupMouseMoveHandler, clearPointerEvents, onOpenChange, open, openRef, tree, delayRef, handleCloseRef, dataRef, isClickLikeOpenEvent, restMsRef]);
  index(() => {
    var _handleCloseRef$curre;
    if (!enabled) return;
    if (open && (_handleCloseRef$curre = handleCloseRef.current) != null && _handleCloseRef$curre.__options.blockPointerEvents && isHoverOpen()) {
      performedPointerEventsMutationRef.current = true;
      const floatingEl = elements.floating;
      if (isElement(elements.domReference) && floatingEl) {
        var _tree$nodesRef$curren;
        const body = getDocument(elements.floating).body;
        body.setAttribute(safePolygonIdentifier, "");
        const ref = elements.domReference;
        const parentFloating = tree == null || (_tree$nodesRef$curren = tree.nodesRef.current.find((node) => node.id === parentId)) == null || (_tree$nodesRef$curren = _tree$nodesRef$curren.context) == null ? void 0 : _tree$nodesRef$curren.elements.floating;
        if (parentFloating) {
          parentFloating.style.pointerEvents = "";
        }
        body.style.pointerEvents = "none";
        ref.style.pointerEvents = "auto";
        floatingEl.style.pointerEvents = "auto";
        return () => {
          body.style.pointerEvents = "";
          ref.style.pointerEvents = "";
          floatingEl.style.pointerEvents = "";
        };
      }
    }
  }, [enabled, open, parentId, elements, tree, handleCloseRef, isHoverOpen]);
  index(() => {
    if (!open) {
      pointerTypeRef.current = void 0;
      restTimeoutPendingRef.current = false;
      cleanupMouseMoveHandler();
      clearPointerEvents();
    }
  }, [open, cleanupMouseMoveHandler, clearPointerEvents]);
  React3.useEffect(() => {
    return () => {
      cleanupMouseMoveHandler();
      clearTimeoutIfSet(timeoutRef);
      clearTimeoutIfSet(restTimeoutRef);
      clearPointerEvents();
    };
  }, [enabled, elements.domReference, cleanupMouseMoveHandler, clearPointerEvents]);
  const reference = React3.useMemo(() => {
    function setPointerRef(event) {
      pointerTypeRef.current = event.pointerType;
    }
    return {
      onPointerDown: setPointerRef,
      onPointerEnter: setPointerRef,
      onMouseMove(event) {
        const {
          nativeEvent
        } = event;
        function handleMouseMove() {
          if (!blockMouseMoveRef.current && !openRef.current) {
            onOpenChange(true, nativeEvent, "hover");
          }
        }
        if (mouseOnly && !isMouseLikePointerType(pointerTypeRef.current)) {
          return;
        }
        if (open || getRestMs(restMsRef.current) === 0) {
          return;
        }
        if (restTimeoutPendingRef.current && event.movementX ** 2 + event.movementY ** 2 < 2) {
          return;
        }
        clearTimeoutIfSet(restTimeoutRef);
        if (pointerTypeRef.current === "touch") {
          handleMouseMove();
        } else {
          restTimeoutPendingRef.current = true;
          restTimeoutRef.current = window.setTimeout(handleMouseMove, getRestMs(restMsRef.current));
        }
      }
    };
  }, [mouseOnly, onOpenChange, open, openRef, restMsRef]);
  return React3.useMemo(() => enabled ? {
    reference
  } : {}, [enabled, reference]);
}
var NOOP = () => {
};
var FloatingDelayGroupContext = React3.createContext({
  delay: 0,
  initialDelay: 0,
  timeoutMs: 0,
  currentId: null,
  setCurrentId: NOOP,
  setState: NOOP,
  isInstantPhase: false
});
var NextFloatingDelayGroupContext = React3.createContext({
  hasProvider: false,
  timeoutMs: 0,
  delayRef: {
    current: 0
  },
  initialDelayRef: {
    current: 0
  },
  timeoutIdRef: {
    current: -1
  },
  currentIdRef: {
    current: null
  },
  currentContextRef: {
    current: null
  }
});
var rafId = 0;
function enqueueFocus(el, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    preventScroll = false,
    cancelPrevious = true,
    sync = false
  } = options;
  cancelPrevious && cancelAnimationFrame(rafId);
  const exec = () => el == null ? void 0 : el.focus({
    preventScroll
  });
  if (sync) {
    exec();
  } else {
    rafId = requestAnimationFrame(exec);
  }
}
function getDocument2(node) {
  return (node == null ? void 0 : node.ownerDocument) || document;
}
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledElementsSet = /* @__PURE__ */ new WeakSet();
var markerMap = {};
var lockCount$1 = 0;
var supportsInert = () => typeof HTMLElement !== "undefined" && "inert" in HTMLElement.prototype;
var unwrapHost = (node) => node && (node.host || unwrapHost(node.parentNode));
var correctElements = (parent, targets) => targets.map((target) => {
  if (parent.contains(target)) {
    return target;
  }
  const correctedTarget = unwrapHost(target);
  if (parent.contains(correctedTarget)) {
    return correctedTarget;
  }
  return null;
}).filter((x) => x != null);
function applyAttributeToOthers(uncorrectedAvoidElements, body, ariaHidden, inert) {
  const markerName = "data-floating-ui-inert";
  const controlAttribute = inert ? "inert" : ariaHidden ? "aria-hidden" : null;
  const avoidElements = correctElements(body, uncorrectedAvoidElements);
  const elementsToKeep = /* @__PURE__ */ new Set();
  const elementsToStop = new Set(avoidElements);
  const hiddenElements = [];
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  const markerCounter = markerMap[markerName];
  avoidElements.forEach(keep);
  deep(body);
  elementsToKeep.clear();
  function keep(el) {
    if (!el || elementsToKeep.has(el)) {
      return;
    }
    elementsToKeep.add(el);
    el.parentNode && keep(el.parentNode);
  }
  function deep(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    [].forEach.call(parent.children, (node) => {
      if (getNodeName(node) === "script") return;
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        const attr2 = controlAttribute ? node.getAttribute(controlAttribute) : null;
        const alreadyHidden = attr2 !== null && attr2 !== "false";
        const currentCounterValue = counterMap.get(node) || 0;
        const counterValue = controlAttribute ? currentCounterValue + 1 : currentCounterValue;
        const markerValue = (markerCounter.get(node) || 0) + 1;
        counterMap.set(node, counterValue);
        markerCounter.set(node, markerValue);
        hiddenElements.push(node);
        if (counterValue === 1 && alreadyHidden) {
          uncontrolledElementsSet.add(node);
        }
        if (markerValue === 1) {
          node.setAttribute(markerName, "");
        }
        if (!alreadyHidden && controlAttribute) {
          node.setAttribute(controlAttribute, controlAttribute === "inert" ? "" : "true");
        }
      }
    });
  }
  lockCount$1++;
  return () => {
    hiddenElements.forEach((element) => {
      const currentCounterValue = counterMap.get(element) || 0;
      const counterValue = controlAttribute ? currentCounterValue - 1 : currentCounterValue;
      const markerValue = (markerCounter.get(element) || 0) - 1;
      counterMap.set(element, counterValue);
      markerCounter.set(element, markerValue);
      if (!counterValue) {
        if (!uncontrolledElementsSet.has(element) && controlAttribute) {
          element.removeAttribute(controlAttribute);
        }
        uncontrolledElementsSet.delete(element);
      }
      if (!markerValue) {
        element.removeAttribute(markerName);
      }
    });
    lockCount$1--;
    if (!lockCount$1) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledElementsSet = /* @__PURE__ */ new WeakSet();
      markerMap = {};
    }
  };
}
function markOthers(avoidElements, ariaHidden, inert) {
  if (ariaHidden === void 0) {
    ariaHidden = false;
  }
  if (inert === void 0) {
    inert = false;
  }
  const body = getDocument2(avoidElements[0]).body;
  return applyAttributeToOthers(avoidElements.concat(Array.from(body.querySelectorAll("[aria-live]"))), body, ariaHidden, inert);
}
var HIDDEN_STYLES = {
  border: 0,
  clip: "rect(0 0 0 0)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: 0,
  position: "fixed",
  whiteSpace: "nowrap",
  width: "1px",
  top: 0,
  left: 0
};
var FocusGuard = React3.forwardRef(function FocusGuard2(props, ref) {
  const [role2, setRole] = React3.useState();
  index(() => {
    if (isSafari2()) {
      setRole("button");
    }
  }, []);
  const restProps = {
    ref,
    tabIndex: 0,
    // Role is only for VoiceOver
    role: role2,
    "aria-hidden": role2 ? void 0 : true,
    [createAttribute("focus-guard")]: "",
    style: HIDDEN_STYLES
  };
  return (0, import_jsx_runtime2.jsx)("span", {
    ...props,
    ...restProps
  });
});
var PortalContext = React3.createContext(null);
var attr = createAttribute("portal");
function useFloatingPortalNode(props) {
  if (props === void 0) {
    props = {};
  }
  const {
    id,
    root
  } = props;
  const uniqueId = useId();
  const portalContext = usePortalContext();
  const [portalNode, setPortalNode] = React3.useState(null);
  const portalNodeRef = React3.useRef(null);
  index(() => {
    return () => {
      portalNode == null || portalNode.remove();
      queueMicrotask(() => {
        portalNodeRef.current = null;
      });
    };
  }, [portalNode]);
  index(() => {
    if (!uniqueId) return;
    if (portalNodeRef.current) return;
    const existingIdRoot = id ? document.getElementById(id) : null;
    if (!existingIdRoot) return;
    const subRoot = document.createElement("div");
    subRoot.id = uniqueId;
    subRoot.setAttribute(attr, "");
    existingIdRoot.appendChild(subRoot);
    portalNodeRef.current = subRoot;
    setPortalNode(subRoot);
  }, [id, uniqueId]);
  index(() => {
    if (root === null) return;
    if (!uniqueId) return;
    if (portalNodeRef.current) return;
    let container = root || (portalContext == null ? void 0 : portalContext.portalNode);
    if (container && !isElement(container)) container = container.current;
    container = container || document.body;
    let idWrapper = null;
    if (id) {
      idWrapper = document.createElement("div");
      idWrapper.id = id;
      container.appendChild(idWrapper);
    }
    const subRoot = document.createElement("div");
    subRoot.id = uniqueId;
    subRoot.setAttribute(attr, "");
    container = idWrapper || container;
    container.appendChild(subRoot);
    portalNodeRef.current = subRoot;
    setPortalNode(subRoot);
  }, [id, root, uniqueId, portalContext]);
  return portalNode;
}
function FloatingPortal(props) {
  const {
    children,
    id,
    root,
    preserveTabOrder = true
  } = props;
  const portalNode = useFloatingPortalNode({
    id,
    root
  });
  const [focusManagerState, setFocusManagerState] = React3.useState(null);
  const beforeOutsideRef = React3.useRef(null);
  const afterOutsideRef = React3.useRef(null);
  const beforeInsideRef = React3.useRef(null);
  const afterInsideRef = React3.useRef(null);
  const modal = focusManagerState == null ? void 0 : focusManagerState.modal;
  const open = focusManagerState == null ? void 0 : focusManagerState.open;
  const shouldRenderGuards = (
    // The FocusManager and therefore floating element are currently open/
    // rendered.
    !!focusManagerState && // Guards are only for non-modal focus management.
    !focusManagerState.modal && // Don't render if unmount is transitioning.
    focusManagerState.open && preserveTabOrder && !!(root || portalNode)
  );
  React3.useEffect(() => {
    if (!portalNode || !preserveTabOrder || modal) {
      return;
    }
    function onFocus(event) {
      if (portalNode && isOutsideEvent(event)) {
        const focusing = event.type === "focusin";
        const manageFocus = focusing ? enableFocusInside : disableFocusInside;
        manageFocus(portalNode);
      }
    }
    portalNode.addEventListener("focusin", onFocus, true);
    portalNode.addEventListener("focusout", onFocus, true);
    return () => {
      portalNode.removeEventListener("focusin", onFocus, true);
      portalNode.removeEventListener("focusout", onFocus, true);
    };
  }, [portalNode, preserveTabOrder, modal]);
  React3.useEffect(() => {
    if (!portalNode) return;
    if (open) return;
    enableFocusInside(portalNode);
  }, [open, portalNode]);
  return (0, import_jsx_runtime2.jsxs)(PortalContext.Provider, {
    value: React3.useMemo(() => ({
      preserveTabOrder,
      beforeOutsideRef,
      afterOutsideRef,
      beforeInsideRef,
      afterInsideRef,
      portalNode,
      setFocusManagerState
    }), [preserveTabOrder, portalNode]),
    children: [shouldRenderGuards && portalNode && (0, import_jsx_runtime2.jsx)(FocusGuard, {
      "data-type": "outside",
      ref: beforeOutsideRef,
      onFocus: (event) => {
        if (isOutsideEvent(event, portalNode)) {
          var _beforeInsideRef$curr;
          (_beforeInsideRef$curr = beforeInsideRef.current) == null || _beforeInsideRef$curr.focus();
        } else {
          const domReference = focusManagerState ? focusManagerState.domReference : null;
          const prevTabbable = getPreviousTabbable(domReference);
          prevTabbable == null || prevTabbable.focus();
        }
      }
    }), shouldRenderGuards && portalNode && (0, import_jsx_runtime2.jsx)("span", {
      "aria-owns": portalNode.id,
      style: HIDDEN_STYLES
    }), portalNode && ReactDOM2.createPortal(children, portalNode), shouldRenderGuards && portalNode && (0, import_jsx_runtime2.jsx)(FocusGuard, {
      "data-type": "outside",
      ref: afterOutsideRef,
      onFocus: (event) => {
        if (isOutsideEvent(event, portalNode)) {
          var _afterInsideRef$curre;
          (_afterInsideRef$curre = afterInsideRef.current) == null || _afterInsideRef$curre.focus();
        } else {
          const domReference = focusManagerState ? focusManagerState.domReference : null;
          const nextTabbable = getNextTabbable(domReference);
          nextTabbable == null || nextTabbable.focus();
          (focusManagerState == null ? void 0 : focusManagerState.closeOnFocusOut) && (focusManagerState == null ? void 0 : focusManagerState.onOpenChange(false, event.nativeEvent, "focus-out"));
        }
      }
    })]
  });
}
var usePortalContext = () => React3.useContext(PortalContext);
function useLiteMergeRefs(refs) {
  return React3.useMemo(() => {
    return (value) => {
      refs.forEach((ref) => {
        if (ref) {
          ref.current = value;
        }
      });
    };
  }, refs);
}
var LIST_LIMIT = 20;
var previouslyFocusedElements = [];
function addPreviouslyFocusedElement(element) {
  previouslyFocusedElements = previouslyFocusedElements.filter((el) => el.isConnected);
  if (element && getNodeName(element) !== "body") {
    previouslyFocusedElements.push(element);
    if (previouslyFocusedElements.length > LIST_LIMIT) {
      previouslyFocusedElements = previouslyFocusedElements.slice(-20);
    }
  }
}
function getPreviouslyFocusedElement() {
  return previouslyFocusedElements.slice().reverse().find((el) => el.isConnected);
}
function getFirstTabbableElement(container) {
  const tabbableOptions = getTabbableOptions();
  if (isTabbable(container, tabbableOptions)) {
    return container;
  }
  return tabbable(container, tabbableOptions)[0] || container;
}
function handleTabIndex(floatingFocusElement, orderRef) {
  var _floatingFocusElement;
  if (!orderRef.current.includes("floating") && !((_floatingFocusElement = floatingFocusElement.getAttribute("role")) != null && _floatingFocusElement.includes("dialog"))) {
    return;
  }
  const options = getTabbableOptions();
  const focusableElements = focusable(floatingFocusElement, options);
  const tabbableContent = focusableElements.filter((element) => {
    const dataTabIndex = element.getAttribute("data-tabindex") || "";
    return isTabbable(element, options) || element.hasAttribute("data-tabindex") && !dataTabIndex.startsWith("-");
  });
  const tabIndex = floatingFocusElement.getAttribute("tabindex");
  if (orderRef.current.includes("floating") || tabbableContent.length === 0) {
    if (tabIndex !== "0") {
      floatingFocusElement.setAttribute("tabindex", "0");
    }
  } else if (tabIndex !== "-1" || floatingFocusElement.hasAttribute("data-tabindex") && floatingFocusElement.getAttribute("data-tabindex") !== "-1") {
    floatingFocusElement.setAttribute("tabindex", "-1");
    floatingFocusElement.setAttribute("data-tabindex", "-1");
  }
}
var VisuallyHiddenDismiss = React3.forwardRef(function VisuallyHiddenDismiss2(props, ref) {
  return (0, import_jsx_runtime2.jsx)("button", {
    ...props,
    type: "button",
    ref,
    tabIndex: -1,
    style: HIDDEN_STYLES
  });
});
function FloatingFocusManager(props) {
  const {
    context: context2,
    children,
    disabled = false,
    order = ["content"],
    guards: _guards = true,
    initialFocus = 0,
    returnFocus = true,
    restoreFocus = false,
    modal = true,
    visuallyHiddenDismiss = false,
    closeOnFocusOut = true,
    outsideElementsInert = false,
    getInsideElements: _getInsideElements = () => []
  } = props;
  const {
    open,
    onOpenChange,
    events: events2,
    dataRef,
    elements: {
      domReference,
      floating
    }
  } = context2;
  const getNodeId = useEffectEvent(() => {
    var _dataRef$current$floa;
    return (_dataRef$current$floa = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa.nodeId;
  });
  const getInsideElements = useEffectEvent(_getInsideElements);
  const ignoreInitialFocus = typeof initialFocus === "number" && initialFocus < 0;
  const isUntrappedTypeableCombobox = isTypeableCombobox(domReference) && ignoreInitialFocus;
  const inertSupported = supportsInert();
  const guards = inertSupported ? _guards : true;
  const useInert = !guards || inertSupported && outsideElementsInert;
  const orderRef = useLatestRef(order);
  const initialFocusRef = useLatestRef(initialFocus);
  const returnFocusRef = useLatestRef(returnFocus);
  const tree = useFloatingTree();
  const portalContext = usePortalContext();
  const startDismissButtonRef = React3.useRef(null);
  const endDismissButtonRef = React3.useRef(null);
  const preventReturnFocusRef = React3.useRef(false);
  const isPointerDownRef = React3.useRef(false);
  const tabbableIndexRef = React3.useRef(-1);
  const isInsidePortal = portalContext != null;
  const floatingFocusElement = getFloatingFocusElement(floating);
  const getTabbableContent = useEffectEvent(function(container) {
    if (container === void 0) {
      container = floatingFocusElement;
    }
    return container ? tabbable(container, getTabbableOptions()) : [];
  });
  const getTabbableElements = useEffectEvent((container) => {
    const content = getTabbableContent(container);
    return orderRef.current.map((type) => {
      if (domReference && type === "reference") {
        return domReference;
      }
      if (floatingFocusElement && type === "floating") {
        return floatingFocusElement;
      }
      return content;
    }).filter(Boolean).flat();
  });
  React3.useEffect(() => {
    if (disabled) return;
    if (!modal) return;
    function onKeyDown(event) {
      if (event.key === "Tab") {
        if (contains(floatingFocusElement, activeElement(getDocument(floatingFocusElement))) && getTabbableContent().length === 0 && !isUntrappedTypeableCombobox) {
          stopEvent(event);
        }
        const els = getTabbableElements();
        const target = getTarget(event);
        if (orderRef.current[0] === "reference" && target === domReference) {
          stopEvent(event);
          if (event.shiftKey) {
            enqueueFocus(els[els.length - 1]);
          } else {
            enqueueFocus(els[1]);
          }
        }
        if (orderRef.current[1] === "floating" && target === floatingFocusElement && event.shiftKey) {
          stopEvent(event);
          enqueueFocus(els[0]);
        }
      }
    }
    const doc = getDocument(floatingFocusElement);
    doc.addEventListener("keydown", onKeyDown);
    return () => {
      doc.removeEventListener("keydown", onKeyDown);
    };
  }, [disabled, domReference, floatingFocusElement, modal, orderRef, isUntrappedTypeableCombobox, getTabbableContent, getTabbableElements]);
  React3.useEffect(() => {
    if (disabled) return;
    if (!floating) return;
    function handleFocusIn(event) {
      const target = getTarget(event);
      const tabbableContent = getTabbableContent();
      const tabbableIndex = tabbableContent.indexOf(target);
      if (tabbableIndex !== -1) {
        tabbableIndexRef.current = tabbableIndex;
      }
    }
    floating.addEventListener("focusin", handleFocusIn);
    return () => {
      floating.removeEventListener("focusin", handleFocusIn);
    };
  }, [disabled, floating, getTabbableContent]);
  React3.useEffect(() => {
    if (disabled) return;
    if (!closeOnFocusOut) return;
    function handlePointerDown() {
      isPointerDownRef.current = true;
      setTimeout(() => {
        isPointerDownRef.current = false;
      });
    }
    function handleFocusOutside(event) {
      const relatedTarget = event.relatedTarget;
      const currentTarget = event.currentTarget;
      queueMicrotask(() => {
        const nodeId = getNodeId();
        const movedToUnrelatedNode = !(contains(domReference, relatedTarget) || contains(floating, relatedTarget) || contains(relatedTarget, floating) || contains(portalContext == null ? void 0 : portalContext.portalNode, relatedTarget) || relatedTarget != null && relatedTarget.hasAttribute(createAttribute("focus-guard")) || tree && (getNodeChildren(tree.nodesRef.current, nodeId).find((node) => {
          var _node$context, _node$context2;
          return contains((_node$context = node.context) == null ? void 0 : _node$context.elements.floating, relatedTarget) || contains((_node$context2 = node.context) == null ? void 0 : _node$context2.elements.domReference, relatedTarget);
        }) || getNodeAncestors(tree.nodesRef.current, nodeId).find((node) => {
          var _node$context3, _node$context4, _node$context5;
          return [(_node$context3 = node.context) == null ? void 0 : _node$context3.elements.floating, getFloatingFocusElement((_node$context4 = node.context) == null ? void 0 : _node$context4.elements.floating)].includes(relatedTarget) || ((_node$context5 = node.context) == null ? void 0 : _node$context5.elements.domReference) === relatedTarget;
        })));
        if (currentTarget === domReference && floatingFocusElement) {
          handleTabIndex(floatingFocusElement, orderRef);
        }
        if (restoreFocus && movedToUnrelatedNode && activeElement(getDocument(floatingFocusElement)) === getDocument(floatingFocusElement).body) {
          if (isHTMLElement(floatingFocusElement)) {
            floatingFocusElement.focus();
          }
          const prevTabbableIndex = tabbableIndexRef.current;
          const tabbableContent = getTabbableContent();
          const nodeToFocus = tabbableContent[prevTabbableIndex] || tabbableContent[tabbableContent.length - 1] || floatingFocusElement;
          if (isHTMLElement(nodeToFocus)) {
            nodeToFocus.focus();
          }
        }
        if ((isUntrappedTypeableCombobox ? true : !modal) && relatedTarget && movedToUnrelatedNode && !isPointerDownRef.current && // Fix React 18 Strict Mode returnFocus due to double rendering.
        relatedTarget !== getPreviouslyFocusedElement()) {
          preventReturnFocusRef.current = true;
          onOpenChange(false, event, "focus-out");
        }
      });
    }
    if (floating && isHTMLElement(domReference)) {
      domReference.addEventListener("focusout", handleFocusOutside);
      domReference.addEventListener("pointerdown", handlePointerDown);
      floating.addEventListener("focusout", handleFocusOutside);
      return () => {
        domReference.removeEventListener("focusout", handleFocusOutside);
        domReference.removeEventListener("pointerdown", handlePointerDown);
        floating.removeEventListener("focusout", handleFocusOutside);
      };
    }
  }, [disabled, domReference, floating, floatingFocusElement, modal, tree, portalContext, onOpenChange, closeOnFocusOut, restoreFocus, getTabbableContent, isUntrappedTypeableCombobox, getNodeId, orderRef]);
  const beforeGuardRef = React3.useRef(null);
  const afterGuardRef = React3.useRef(null);
  const mergedBeforeGuardRef = useLiteMergeRefs([beforeGuardRef, portalContext == null ? void 0 : portalContext.beforeInsideRef]);
  const mergedAfterGuardRef = useLiteMergeRefs([afterGuardRef, portalContext == null ? void 0 : portalContext.afterInsideRef]);
  React3.useEffect(() => {
    var _portalContext$portal, _ancestors$find;
    if (disabled) return;
    if (!floating) return;
    const portalNodes = Array.from((portalContext == null || (_portalContext$portal = portalContext.portalNode) == null ? void 0 : _portalContext$portal.querySelectorAll("[" + createAttribute("portal") + "]")) || []);
    const ancestors = tree ? getNodeAncestors(tree.nodesRef.current, getNodeId()) : [];
    const ancestorFloatingNodes = tree && !modal ? ancestors.map((node) => {
      var _node$context6;
      return (_node$context6 = node.context) == null ? void 0 : _node$context6.elements.floating;
    }) : [];
    const rootAncestorComboboxDomReference = (_ancestors$find = ancestors.find((node) => {
      var _node$context7;
      return isTypeableCombobox(((_node$context7 = node.context) == null ? void 0 : _node$context7.elements.domReference) || null);
    })) == null || (_ancestors$find = _ancestors$find.context) == null ? void 0 : _ancestors$find.elements.domReference;
    const insideElements = [floating, rootAncestorComboboxDomReference, ...portalNodes, ...ancestorFloatingNodes, ...getInsideElements(), startDismissButtonRef.current, endDismissButtonRef.current, beforeGuardRef.current, afterGuardRef.current, portalContext == null ? void 0 : portalContext.beforeOutsideRef.current, portalContext == null ? void 0 : portalContext.afterOutsideRef.current, orderRef.current.includes("reference") || isUntrappedTypeableCombobox ? domReference : null].filter((x) => x != null);
    const cleanup2 = modal || isUntrappedTypeableCombobox ? markOthers(insideElements, !useInert, useInert) : markOthers(insideElements);
    return () => {
      cleanup2();
    };
  }, [disabled, domReference, floating, modal, orderRef, portalContext, isUntrappedTypeableCombobox, guards, useInert, tree, getNodeId, getInsideElements]);
  index(() => {
    if (disabled || !isHTMLElement(floatingFocusElement)) return;
    const doc = getDocument(floatingFocusElement);
    const previouslyFocusedElement = activeElement(doc);
    queueMicrotask(() => {
      const focusableElements = getTabbableElements(floatingFocusElement);
      const initialFocusValue = initialFocusRef.current;
      const elToFocus = (typeof initialFocusValue === "number" ? focusableElements[initialFocusValue] : initialFocusValue.current) || floatingFocusElement;
      const focusAlreadyInsideFloatingEl = contains(floatingFocusElement, previouslyFocusedElement);
      if (!ignoreInitialFocus && !focusAlreadyInsideFloatingEl && open) {
        enqueueFocus(elToFocus, {
          preventScroll: elToFocus === floatingFocusElement
        });
      }
    });
  }, [disabled, open, floatingFocusElement, ignoreInitialFocus, getTabbableElements, initialFocusRef]);
  index(() => {
    if (disabled || !floatingFocusElement) return;
    let preventReturnFocusScroll = false;
    const doc = getDocument(floatingFocusElement);
    const previouslyFocusedElement = activeElement(doc);
    addPreviouslyFocusedElement(previouslyFocusedElement);
    function onOpenChange2(_ref) {
      let {
        reason,
        event,
        nested
      } = _ref;
      if (["hover", "safe-polygon"].includes(reason) && event.type === "mouseleave") {
        preventReturnFocusRef.current = true;
      }
      if (reason !== "outside-press") return;
      if (nested) {
        preventReturnFocusRef.current = false;
        preventReturnFocusScroll = true;
      } else if (isVirtualClick(event) || isVirtualPointerEvent(event)) {
        preventReturnFocusRef.current = false;
      } else {
        let isPreventScrollSupported = false;
        document.createElement("div").focus({
          get preventScroll() {
            isPreventScrollSupported = true;
            return false;
          }
        });
        if (isPreventScrollSupported) {
          preventReturnFocusRef.current = false;
          preventReturnFocusScroll = true;
        } else {
          preventReturnFocusRef.current = true;
        }
      }
    }
    events2.on("openchange", onOpenChange2);
    const fallbackEl = doc.createElement("span");
    fallbackEl.setAttribute("tabindex", "-1");
    fallbackEl.setAttribute("aria-hidden", "true");
    Object.assign(fallbackEl.style, HIDDEN_STYLES);
    if (isInsidePortal && domReference) {
      domReference.insertAdjacentElement("afterend", fallbackEl);
    }
    function getReturnElement() {
      if (typeof returnFocusRef.current === "boolean") {
        const el = domReference || getPreviouslyFocusedElement();
        return el && el.isConnected ? el : fallbackEl;
      }
      return returnFocusRef.current.current || fallbackEl;
    }
    return () => {
      events2.off("openchange", onOpenChange2);
      const activeEl = activeElement(doc);
      const isFocusInsideFloatingTree = contains(floating, activeEl) || tree && getNodeChildren(tree.nodesRef.current, getNodeId()).some((node) => {
        var _node$context8;
        return contains((_node$context8 = node.context) == null ? void 0 : _node$context8.elements.floating, activeEl);
      });
      const returnElement = getReturnElement();
      queueMicrotask(() => {
        const tabbableReturnElement = getFirstTabbableElement(returnElement);
        if (
          // eslint-disable-next-line react-hooks/exhaustive-deps
          returnFocusRef.current && !preventReturnFocusRef.current && isHTMLElement(tabbableReturnElement) && // If the focus moved somewhere else after mount, avoid returning focus
          // since it likely entered a different element which should be
          // respected: https://github.com/floating-ui/floating-ui/issues/2607
          (tabbableReturnElement !== activeEl && activeEl !== doc.body ? isFocusInsideFloatingTree : true)
        ) {
          tabbableReturnElement.focus({
            preventScroll: preventReturnFocusScroll
          });
        }
        fallbackEl.remove();
      });
    };
  }, [disabled, floating, floatingFocusElement, returnFocusRef, dataRef, events2, tree, isInsidePortal, domReference, getNodeId]);
  React3.useEffect(() => {
    queueMicrotask(() => {
      preventReturnFocusRef.current = false;
    });
  }, [disabled]);
  index(() => {
    if (disabled) return;
    if (!portalContext) return;
    portalContext.setFocusManagerState({
      modal,
      closeOnFocusOut,
      open,
      onOpenChange,
      domReference
    });
    return () => {
      portalContext.setFocusManagerState(null);
    };
  }, [disabled, portalContext, modal, open, onOpenChange, closeOnFocusOut, domReference]);
  index(() => {
    if (disabled) return;
    if (!floatingFocusElement) return;
    handleTabIndex(floatingFocusElement, orderRef);
  }, [disabled, floatingFocusElement, orderRef]);
  function renderDismissButton(location) {
    if (disabled || !visuallyHiddenDismiss || !modal) {
      return null;
    }
    return (0, import_jsx_runtime2.jsx)(VisuallyHiddenDismiss, {
      ref: location === "start" ? startDismissButtonRef : endDismissButtonRef,
      onClick: (event) => onOpenChange(false, event.nativeEvent),
      children: typeof visuallyHiddenDismiss === "string" ? visuallyHiddenDismiss : "Dismiss"
    });
  }
  const shouldRenderGuards = !disabled && guards && (modal ? !isUntrappedTypeableCombobox : true) && (isInsidePortal || modal);
  return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, {
    children: [shouldRenderGuards && (0, import_jsx_runtime2.jsx)(FocusGuard, {
      "data-type": "inside",
      ref: mergedBeforeGuardRef,
      onFocus: (event) => {
        if (modal) {
          const els = getTabbableElements();
          enqueueFocus(order[0] === "reference" ? els[0] : els[els.length - 1]);
        } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {
          preventReturnFocusRef.current = false;
          if (isOutsideEvent(event, portalContext.portalNode)) {
            const nextTabbable = getNextTabbable(domReference);
            nextTabbable == null || nextTabbable.focus();
          } else {
            var _portalContext$before;
            (_portalContext$before = portalContext.beforeOutsideRef.current) == null || _portalContext$before.focus();
          }
        }
      }
    }), !isUntrappedTypeableCombobox && renderDismissButton("start"), children, renderDismissButton("end"), shouldRenderGuards && (0, import_jsx_runtime2.jsx)(FocusGuard, {
      "data-type": "inside",
      ref: mergedAfterGuardRef,
      onFocus: (event) => {
        if (modal) {
          enqueueFocus(getTabbableElements()[0]);
        } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {
          if (closeOnFocusOut) {
            preventReturnFocusRef.current = true;
          }
          if (isOutsideEvent(event, portalContext.portalNode)) {
            const prevTabbable = getPreviousTabbable(domReference);
            prevTabbable == null || prevTabbable.focus();
          } else {
            var _portalContext$afterO;
            (_portalContext$afterO = portalContext.afterOutsideRef.current) == null || _portalContext$afterO.focus();
          }
        }
      }
    })]
  });
}
var lockCount = 0;
function enableScrollLock() {
  const isIOS = /iP(hone|ad|od)|iOS/.test(getPlatform());
  const bodyStyle = document.body.style;
  const scrollbarX = Math.round(document.documentElement.getBoundingClientRect().left) + document.documentElement.scrollLeft;
  const paddingProp = scrollbarX ? "paddingLeft" : "paddingRight";
  const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
  const scrollX = bodyStyle.left ? parseFloat(bodyStyle.left) : window.scrollX;
  const scrollY = bodyStyle.top ? parseFloat(bodyStyle.top) : window.scrollY;
  bodyStyle.overflow = "hidden";
  if (scrollbarWidth) {
    bodyStyle[paddingProp] = scrollbarWidth + "px";
  }
  if (isIOS) {
    var _window$visualViewpor, _window$visualViewpor2;
    const offsetLeft = ((_window$visualViewpor = window.visualViewport) == null ? void 0 : _window$visualViewpor.offsetLeft) || 0;
    const offsetTop = ((_window$visualViewpor2 = window.visualViewport) == null ? void 0 : _window$visualViewpor2.offsetTop) || 0;
    Object.assign(bodyStyle, {
      position: "fixed",
      top: -(scrollY - Math.floor(offsetTop)) + "px",
      left: -(scrollX - Math.floor(offsetLeft)) + "px",
      right: "0"
    });
  }
  return () => {
    Object.assign(bodyStyle, {
      overflow: "",
      [paddingProp]: ""
    });
    if (isIOS) {
      Object.assign(bodyStyle, {
        position: "",
        top: "",
        left: "",
        right: ""
      });
      window.scrollTo(scrollX, scrollY);
    }
  };
}
var cleanup = () => {
};
var FloatingOverlay = React3.forwardRef(function FloatingOverlay2(props, ref) {
  const {
    lockScroll = false,
    ...rest
  } = props;
  index(() => {
    if (!lockScroll) return;
    lockCount++;
    if (lockCount === 1) {
      cleanup = enableScrollLock();
    }
    return () => {
      lockCount--;
      if (lockCount === 0) {
        cleanup();
      }
    };
  }, [lockScroll]);
  return (0, import_jsx_runtime2.jsx)("div", {
    ref,
    ...rest,
    style: {
      position: "fixed",
      overflow: "auto",
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...rest.style
    }
  });
});
function isButtonTarget(event) {
  return isHTMLElement(event.target) && event.target.tagName === "BUTTON";
}
function isAnchorTarget(event) {
  return isHTMLElement(event.target) && event.target.tagName === "A";
}
function isSpaceIgnored(element) {
  return isTypeableElement(element);
}
function useClick(context2, props) {
  if (props === void 0) {
    props = {};
  }
  const {
    open,
    onOpenChange,
    dataRef,
    elements: {
      domReference
    }
  } = context2;
  const {
    enabled = true,
    event: eventOption = "click",
    toggle = true,
    ignoreMouse = false,
    keyboardHandlers = true,
    stickIfOpen = true
  } = props;
  const pointerTypeRef = React3.useRef();
  const didKeyDownRef = React3.useRef(false);
  const reference = React3.useMemo(() => ({
    onPointerDown(event) {
      pointerTypeRef.current = event.pointerType;
    },
    onMouseDown(event) {
      const pointerType = pointerTypeRef.current;
      if (event.button !== 0) return;
      if (eventOption === "click") return;
      if (isMouseLikePointerType(pointerType, true) && ignoreMouse) return;
      if (open && toggle && (dataRef.current.openEvent && stickIfOpen ? dataRef.current.openEvent.type === "mousedown" : true)) {
        onOpenChange(false, event.nativeEvent, "click");
      } else {
        event.preventDefault();
        onOpenChange(true, event.nativeEvent, "click");
      }
    },
    onClick(event) {
      const pointerType = pointerTypeRef.current;
      if (eventOption === "mousedown" && pointerTypeRef.current) {
        pointerTypeRef.current = void 0;
        return;
      }
      if (isMouseLikePointerType(pointerType, true) && ignoreMouse) return;
      if (open && toggle && (dataRef.current.openEvent && stickIfOpen ? dataRef.current.openEvent.type === "click" : true)) {
        onOpenChange(false, event.nativeEvent, "click");
      } else {
        onOpenChange(true, event.nativeEvent, "click");
      }
    },
    onKeyDown(event) {
      pointerTypeRef.current = void 0;
      if (event.defaultPrevented || !keyboardHandlers || isButtonTarget(event)) {
        return;
      }
      if (event.key === " " && !isSpaceIgnored(domReference)) {
        event.preventDefault();
        didKeyDownRef.current = true;
      }
      if (isAnchorTarget(event)) {
        return;
      }
      if (event.key === "Enter") {
        if (open && toggle) {
          onOpenChange(false, event.nativeEvent, "click");
        } else {
          onOpenChange(true, event.nativeEvent, "click");
        }
      }
    },
    onKeyUp(event) {
      if (event.defaultPrevented || !keyboardHandlers || isButtonTarget(event) || isSpaceIgnored(domReference)) {
        return;
      }
      if (event.key === " " && didKeyDownRef.current) {
        didKeyDownRef.current = false;
        if (open && toggle) {
          onOpenChange(false, event.nativeEvent, "click");
        } else {
          onOpenChange(true, event.nativeEvent, "click");
        }
      }
    }
  }), [dataRef, domReference, eventOption, ignoreMouse, keyboardHandlers, onOpenChange, open, stickIfOpen, toggle]);
  return React3.useMemo(() => enabled ? {
    reference
  } : {}, [enabled, reference]);
}
var bubbleHandlerKeys = {
  pointerdown: "onPointerDown",
  mousedown: "onMouseDown",
  click: "onClick"
};
var captureHandlerKeys = {
  pointerdown: "onPointerDownCapture",
  mousedown: "onMouseDownCapture",
  click: "onClickCapture"
};
var normalizeProp = (normalizable) => {
  var _normalizable$escapeK, _normalizable$outside;
  return {
    escapeKey: typeof normalizable === "boolean" ? normalizable : (_normalizable$escapeK = normalizable == null ? void 0 : normalizable.escapeKey) != null ? _normalizable$escapeK : false,
    outsidePress: typeof normalizable === "boolean" ? normalizable : (_normalizable$outside = normalizable == null ? void 0 : normalizable.outsidePress) != null ? _normalizable$outside : true
  };
};
function useDismiss(context2, props) {
  if (props === void 0) {
    props = {};
  }
  const {
    open,
    onOpenChange,
    elements,
    dataRef
  } = context2;
  const {
    enabled = true,
    escapeKey = true,
    outsidePress: unstable_outsidePress = true,
    outsidePressEvent = "pointerdown",
    referencePress = false,
    referencePressEvent = "pointerdown",
    ancestorScroll = false,
    bubbles,
    capture
  } = props;
  const tree = useFloatingTree();
  const outsidePressFn = useEffectEvent(typeof unstable_outsidePress === "function" ? unstable_outsidePress : () => false);
  const outsidePress = typeof unstable_outsidePress === "function" ? outsidePressFn : unstable_outsidePress;
  const insideReactTreeRef = React3.useRef(false);
  const endedOrStartedInsideRef = React3.useRef(false);
  const {
    escapeKey: escapeKeyBubbles,
    outsidePress: outsidePressBubbles
  } = normalizeProp(bubbles);
  const {
    escapeKey: escapeKeyCapture,
    outsidePress: outsidePressCapture
  } = normalizeProp(capture);
  const isComposingRef = React3.useRef(false);
  const closeOnEscapeKeyDown = useEffectEvent((event) => {
    var _dataRef$current$floa;
    if (!open || !enabled || !escapeKey || event.key !== "Escape") {
      return;
    }
    if (isComposingRef.current) {
      return;
    }
    const nodeId = (_dataRef$current$floa = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa.nodeId;
    const children = tree ? getNodeChildren(tree.nodesRef.current, nodeId) : [];
    if (!escapeKeyBubbles) {
      event.stopPropagation();
      if (children.length > 0) {
        let shouldDismiss = true;
        children.forEach((child) => {
          var _child$context;
          if ((_child$context = child.context) != null && _child$context.open && !child.context.dataRef.current.__escapeKeyBubbles) {
            shouldDismiss = false;
            return;
          }
        });
        if (!shouldDismiss) {
          return;
        }
      }
    }
    onOpenChange(false, isReactEvent(event) ? event.nativeEvent : event, "escape-key");
  });
  const closeOnEscapeKeyDownCapture = useEffectEvent((event) => {
    var _getTarget2;
    const callback = () => {
      var _getTarget;
      closeOnEscapeKeyDown(event);
      (_getTarget = getTarget(event)) == null || _getTarget.removeEventListener("keydown", callback);
    };
    (_getTarget2 = getTarget(event)) == null || _getTarget2.addEventListener("keydown", callback);
  });
  const closeOnPressOutside = useEffectEvent((event) => {
    var _dataRef$current$floa2;
    const insideReactTree = insideReactTreeRef.current;
    insideReactTreeRef.current = false;
    const endedOrStartedInside = endedOrStartedInsideRef.current;
    endedOrStartedInsideRef.current = false;
    if (outsidePressEvent === "click" && endedOrStartedInside) {
      return;
    }
    if (insideReactTree) {
      return;
    }
    if (typeof outsidePress === "function" && !outsidePress(event)) {
      return;
    }
    const target = getTarget(event);
    const inertSelector = "[" + createAttribute("inert") + "]";
    const markers = getDocument(elements.floating).querySelectorAll(inertSelector);
    let targetRootAncestor = isElement(target) ? target : null;
    while (targetRootAncestor && !isLastTraversableNode(targetRootAncestor)) {
      const nextParent = getParentNode(targetRootAncestor);
      if (isLastTraversableNode(nextParent) || !isElement(nextParent)) {
        break;
      }
      targetRootAncestor = nextParent;
    }
    if (markers.length && isElement(target) && !isRootElement(target) && // Clicked on a direct ancestor (e.g. FloatingOverlay).
    !contains(target, elements.floating) && // If the target root element contains none of the markers, then the
    // element was injected after the floating element rendered.
    Array.from(markers).every((marker) => !contains(targetRootAncestor, marker))) {
      return;
    }
    if (isHTMLElement(target) && floating) {
      const lastTraversableNode = isLastTraversableNode(target);
      const style = getComputedStyle2(target);
      const scrollRe = /auto|scroll/;
      const isScrollableX = lastTraversableNode || scrollRe.test(style.overflowX);
      const isScrollableY = lastTraversableNode || scrollRe.test(style.overflowY);
      const canScrollX = isScrollableX && target.clientWidth > 0 && target.scrollWidth > target.clientWidth;
      const canScrollY = isScrollableY && target.clientHeight > 0 && target.scrollHeight > target.clientHeight;
      const isRTL2 = style.direction === "rtl";
      const pressedVerticalScrollbar = canScrollY && (isRTL2 ? event.offsetX <= target.offsetWidth - target.clientWidth : event.offsetX > target.clientWidth);
      const pressedHorizontalScrollbar = canScrollX && event.offsetY > target.clientHeight;
      if (pressedVerticalScrollbar || pressedHorizontalScrollbar) {
        return;
      }
    }
    const nodeId = (_dataRef$current$floa2 = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa2.nodeId;
    const targetIsInsideChildren = tree && getNodeChildren(tree.nodesRef.current, nodeId).some((node) => {
      var _node$context;
      return isEventTargetWithin(event, (_node$context = node.context) == null ? void 0 : _node$context.elements.floating);
    });
    if (isEventTargetWithin(event, elements.floating) || isEventTargetWithin(event, elements.domReference) || targetIsInsideChildren) {
      return;
    }
    const children = tree ? getNodeChildren(tree.nodesRef.current, nodeId) : [];
    if (children.length > 0) {
      let shouldDismiss = true;
      children.forEach((child) => {
        var _child$context2;
        if ((_child$context2 = child.context) != null && _child$context2.open && !child.context.dataRef.current.__outsidePressBubbles) {
          shouldDismiss = false;
          return;
        }
      });
      if (!shouldDismiss) {
        return;
      }
    }
    onOpenChange(false, event, "outside-press");
  });
  const closeOnPressOutsideCapture = useEffectEvent((event) => {
    var _getTarget4;
    const callback = () => {
      var _getTarget3;
      closeOnPressOutside(event);
      (_getTarget3 = getTarget(event)) == null || _getTarget3.removeEventListener(outsidePressEvent, callback);
    };
    (_getTarget4 = getTarget(event)) == null || _getTarget4.addEventListener(outsidePressEvent, callback);
  });
  React3.useEffect(() => {
    if (!open || !enabled) {
      return;
    }
    dataRef.current.__escapeKeyBubbles = escapeKeyBubbles;
    dataRef.current.__outsidePressBubbles = outsidePressBubbles;
    let compositionTimeout = -1;
    function onScroll(event) {
      onOpenChange(false, event, "ancestor-scroll");
    }
    function handleCompositionStart() {
      window.clearTimeout(compositionTimeout);
      isComposingRef.current = true;
    }
    function handleCompositionEnd() {
      compositionTimeout = window.setTimeout(
        () => {
          isComposingRef.current = false;
        },
        // 0ms or 1ms don't work in Safari. 5ms appears to consistently work.
        // Only apply to WebKit for the test to remain 0ms.
        isWebKit() ? 5 : 0
      );
    }
    const doc = getDocument(elements.floating);
    if (escapeKey) {
      doc.addEventListener("keydown", escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture);
      doc.addEventListener("compositionstart", handleCompositionStart);
      doc.addEventListener("compositionend", handleCompositionEnd);
    }
    outsidePress && doc.addEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);
    let ancestors = [];
    if (ancestorScroll) {
      if (isElement(elements.domReference)) {
        ancestors = getOverflowAncestors(elements.domReference);
      }
      if (isElement(elements.floating)) {
        ancestors = ancestors.concat(getOverflowAncestors(elements.floating));
      }
      if (!isElement(elements.reference) && elements.reference && elements.reference.contextElement) {
        ancestors = ancestors.concat(getOverflowAncestors(elements.reference.contextElement));
      }
    }
    ancestors = ancestors.filter((ancestor) => {
      var _doc$defaultView;
      return ancestor !== ((_doc$defaultView = doc.defaultView) == null ? void 0 : _doc$defaultView.visualViewport);
    });
    ancestors.forEach((ancestor) => {
      ancestor.addEventListener("scroll", onScroll, {
        passive: true
      });
    });
    return () => {
      if (escapeKey) {
        doc.removeEventListener("keydown", escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture);
        doc.removeEventListener("compositionstart", handleCompositionStart);
        doc.removeEventListener("compositionend", handleCompositionEnd);
      }
      outsidePress && doc.removeEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);
      ancestors.forEach((ancestor) => {
        ancestor.removeEventListener("scroll", onScroll);
      });
      window.clearTimeout(compositionTimeout);
    };
  }, [dataRef, elements, escapeKey, outsidePress, outsidePressEvent, open, onOpenChange, ancestorScroll, enabled, escapeKeyBubbles, outsidePressBubbles, closeOnEscapeKeyDown, escapeKeyCapture, closeOnEscapeKeyDownCapture, closeOnPressOutside, outsidePressCapture, closeOnPressOutsideCapture]);
  React3.useEffect(() => {
    insideReactTreeRef.current = false;
  }, [outsidePress, outsidePressEvent]);
  const reference = React3.useMemo(() => ({
    onKeyDown: closeOnEscapeKeyDown,
    ...referencePress && {
      [bubbleHandlerKeys[referencePressEvent]]: (event) => {
        onOpenChange(false, event.nativeEvent, "reference-press");
      },
      ...referencePressEvent !== "click" && {
        onClick(event) {
          onOpenChange(false, event.nativeEvent, "reference-press");
        }
      }
    }
  }), [closeOnEscapeKeyDown, onOpenChange, referencePress, referencePressEvent]);
  const floating = React3.useMemo(() => ({
    onKeyDown: closeOnEscapeKeyDown,
    onMouseDown() {
      endedOrStartedInsideRef.current = true;
    },
    onMouseUp() {
      endedOrStartedInsideRef.current = true;
    },
    [captureHandlerKeys[outsidePressEvent]]: () => {
      insideReactTreeRef.current = true;
    }
  }), [closeOnEscapeKeyDown, outsidePressEvent]);
  return React3.useMemo(() => enabled ? {
    reference,
    floating
  } : {}, [enabled, reference, floating]);
}
function useFloatingRootContext(options) {
  const {
    open = false,
    onOpenChange: onOpenChangeProp,
    elements: elementsProp
  } = options;
  const floatingId = useId();
  const dataRef = React3.useRef({});
  const [events2] = React3.useState(() => createEventEmitter());
  const nested = useFloatingParentNodeId() != null;
  if (true) {
    const optionDomReference = elementsProp.reference;
    if (optionDomReference && !isElement(optionDomReference)) {
      error("Cannot pass a virtual element to the `elements.reference` option,", "as it must be a real DOM element. Use `refs.setPositionReference()`", "instead.");
    }
  }
  const [positionReference, setPositionReference] = React3.useState(elementsProp.reference);
  const onOpenChange = useEffectEvent((open2, event, reason) => {
    dataRef.current.openEvent = open2 ? event : void 0;
    events2.emit("openchange", {
      open: open2,
      event,
      reason,
      nested
    });
    onOpenChangeProp == null || onOpenChangeProp(open2, event, reason);
  });
  const refs = React3.useMemo(() => ({
    setPositionReference
  }), []);
  const elements = React3.useMemo(() => ({
    reference: positionReference || elementsProp.reference || null,
    floating: elementsProp.floating || null,
    domReference: elementsProp.reference
  }), [positionReference, elementsProp.reference, elementsProp.floating]);
  return React3.useMemo(() => ({
    dataRef,
    open,
    onOpenChange,
    elements,
    events: events2,
    floatingId,
    refs
  }), [open, onOpenChange, elements, events2, floatingId, refs]);
}
function useFloating2(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    nodeId
  } = options;
  const internalRootContext = useFloatingRootContext({
    ...options,
    elements: {
      reference: null,
      floating: null,
      ...options.elements
    }
  });
  const rootContext = options.rootContext || internalRootContext;
  const computedElements = rootContext.elements;
  const [_domReference, setDomReference] = React3.useState(null);
  const [positionReference, _setPositionReference] = React3.useState(null);
  const optionDomReference = computedElements == null ? void 0 : computedElements.domReference;
  const domReference = optionDomReference || _domReference;
  const domReferenceRef = React3.useRef(null);
  const tree = useFloatingTree();
  index(() => {
    if (domReference) {
      domReferenceRef.current = domReference;
    }
  }, [domReference]);
  const position = useFloating({
    ...options,
    elements: {
      ...computedElements,
      ...positionReference && {
        reference: positionReference
      }
    }
  });
  const setPositionReference = React3.useCallback((node) => {
    const computedPositionReference = isElement(node) ? {
      getBoundingClientRect: () => node.getBoundingClientRect(),
      getClientRects: () => node.getClientRects(),
      contextElement: node
    } : node;
    _setPositionReference(computedPositionReference);
    position.refs.setReference(computedPositionReference);
  }, [position.refs]);
  const setReference = React3.useCallback((node) => {
    if (isElement(node) || node === null) {
      domReferenceRef.current = node;
      setDomReference(node);
    }
    if (isElement(position.refs.reference.current) || position.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to
    // `null` to support `positionReference` + an unstable `reference`
    // callback ref.
    node !== null && !isElement(node)) {
      position.refs.setReference(node);
    }
  }, [position.refs]);
  const refs = React3.useMemo(() => ({
    ...position.refs,
    setReference,
    setPositionReference,
    domReference: domReferenceRef
  }), [position.refs, setReference, setPositionReference]);
  const elements = React3.useMemo(() => ({
    ...position.elements,
    domReference
  }), [position.elements, domReference]);
  const context2 = React3.useMemo(() => ({
    ...position,
    ...rootContext,
    refs,
    elements,
    nodeId
  }), [position, refs, elements, nodeId, rootContext]);
  index(() => {
    rootContext.dataRef.current.floatingContext = context2;
    const node = tree == null ? void 0 : tree.nodesRef.current.find((node2) => node2.id === nodeId);
    if (node) {
      node.context = context2;
    }
  });
  return React3.useMemo(() => ({
    ...position,
    context: context2,
    refs,
    elements
  }), [position, refs, elements, context2]);
}
function mergeProps(userProps, propsList, elementKey) {
  const map2 = /* @__PURE__ */ new Map();
  const isItem = elementKey === "item";
  let domUserProps = userProps;
  if (isItem && userProps) {
    const {
      [ACTIVE_KEY]: _,
      [SELECTED_KEY]: __,
      ...validProps
    } = userProps;
    domUserProps = validProps;
  }
  return {
    ...elementKey === "floating" && {
      tabIndex: -1,
      [FOCUSABLE_ATTRIBUTE2]: ""
    },
    ...domUserProps,
    ...propsList.map((value) => {
      const propsOrGetProps = value ? value[elementKey] : null;
      if (typeof propsOrGetProps === "function") {
        return userProps ? propsOrGetProps(userProps) : null;
      }
      return propsOrGetProps;
    }).concat(userProps).reduce((acc, props) => {
      if (!props) {
        return acc;
      }
      Object.entries(props).forEach((_ref) => {
        let [key, value] = _ref;
        if (isItem && [ACTIVE_KEY, SELECTED_KEY].includes(key)) {
          return;
        }
        if (key.indexOf("on") === 0) {
          if (!map2.has(key)) {
            map2.set(key, []);
          }
          if (typeof value === "function") {
            var _map$get;
            (_map$get = map2.get(key)) == null || _map$get.push(value);
            acc[key] = function() {
              var _map$get2;
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              return (_map$get2 = map2.get(key)) == null ? void 0 : _map$get2.map((fn) => fn(...args)).find((val) => val !== void 0);
            };
          }
        } else {
          acc[key] = value;
        }
      });
      return acc;
    }, {})
  };
}
function useInteractions(propsList) {
  if (propsList === void 0) {
    propsList = [];
  }
  const referenceDeps = propsList.map((key) => key == null ? void 0 : key.reference);
  const floatingDeps = propsList.map((key) => key == null ? void 0 : key.floating);
  const itemDeps = propsList.map((key) => key == null ? void 0 : key.item);
  const getReferenceProps = React3.useCallback(
    (userProps) => mergeProps(userProps, propsList, "reference"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    referenceDeps
  );
  const getFloatingProps = React3.useCallback(
    (userProps) => mergeProps(userProps, propsList, "floating"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    floatingDeps
  );
  const getItemProps = React3.useCallback(
    (userProps) => mergeProps(userProps, propsList, "item"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    itemDeps
  );
  return React3.useMemo(() => ({
    getReferenceProps,
    getFloatingProps,
    getItemProps
  }), [getReferenceProps, getFloatingProps, getItemProps]);
}
var ESCAPE = "Escape";
function doSwitch(orientation, vertical, horizontal) {
  switch (orientation) {
    case "vertical":
      return vertical;
    case "horizontal":
      return horizontal;
    default:
      return vertical || horizontal;
  }
}
function isMainOrientationKey(key, orientation) {
  const vertical = key === ARROW_UP2 || key === ARROW_DOWN2;
  const horizontal = key === ARROW_LEFT2 || key === ARROW_RIGHT2;
  return doSwitch(orientation, vertical, horizontal);
}
function isMainOrientationToEndKey(key, orientation, rtl) {
  const vertical = key === ARROW_DOWN2;
  const horizontal = rtl ? key === ARROW_LEFT2 : key === ARROW_RIGHT2;
  return doSwitch(orientation, vertical, horizontal) || key === "Enter" || key === " " || key === "";
}
function isCrossOrientationOpenKey(key, orientation, rtl) {
  const vertical = rtl ? key === ARROW_LEFT2 : key === ARROW_RIGHT2;
  const horizontal = key === ARROW_DOWN2;
  return doSwitch(orientation, vertical, horizontal);
}
function isCrossOrientationCloseKey(key, orientation, rtl, cols) {
  const vertical = rtl ? key === ARROW_RIGHT2 : key === ARROW_LEFT2;
  const horizontal = key === ARROW_UP2;
  if (orientation === "both" || orientation === "horizontal" && cols && cols > 1) {
    return key === ESCAPE;
  }
  return doSwitch(orientation, vertical, horizontal);
}
function useListNavigation(context2, props) {
  const {
    open,
    onOpenChange,
    elements,
    floatingId
  } = context2;
  const {
    listRef,
    activeIndex,
    onNavigate: unstable_onNavigate = () => {
    },
    enabled = true,
    selectedIndex = null,
    allowEscape = false,
    loop = false,
    nested = false,
    rtl = false,
    virtual = false,
    focusItemOnOpen = "auto",
    focusItemOnHover = true,
    openOnArrowKeyDown = true,
    disabledIndices = void 0,
    orientation = "vertical",
    parentOrientation,
    cols = 1,
    scrollItemIntoView = true,
    virtualItemRef,
    itemSizes,
    dense = false
  } = props;
  if (true) {
    if (allowEscape) {
      if (!loop) {
        warn("`useListNavigation` looping must be enabled to allow escaping.");
      }
      if (!virtual) {
        warn("`useListNavigation` must be virtual to allow escaping.");
      }
    }
    if (orientation === "vertical" && cols > 1) {
      warn("In grid list navigation mode (`cols` > 1), the `orientation` should", 'be either "horizontal" or "both".');
    }
  }
  const floatingFocusElement = getFloatingFocusElement(elements.floating);
  const floatingFocusElementRef = useLatestRef(floatingFocusElement);
  const parentId = useFloatingParentNodeId();
  const tree = useFloatingTree();
  index(() => {
    context2.dataRef.current.orientation = orientation;
  }, [context2, orientation]);
  const onNavigate = useEffectEvent(() => {
    unstable_onNavigate(indexRef.current === -1 ? null : indexRef.current);
  });
  const typeableComboboxReference = isTypeableCombobox(elements.domReference);
  const focusItemOnOpenRef = React3.useRef(focusItemOnOpen);
  const indexRef = React3.useRef(selectedIndex != null ? selectedIndex : -1);
  const keyRef = React3.useRef(null);
  const isPointerModalityRef = React3.useRef(true);
  const previousOnNavigateRef = React3.useRef(onNavigate);
  const previousMountedRef = React3.useRef(!!elements.floating);
  const previousOpenRef = React3.useRef(open);
  const forceSyncFocusRef = React3.useRef(false);
  const forceScrollIntoViewRef = React3.useRef(false);
  const disabledIndicesRef = useLatestRef(disabledIndices);
  const latestOpenRef = useLatestRef(open);
  const scrollItemIntoViewRef = useLatestRef(scrollItemIntoView);
  const selectedIndexRef = useLatestRef(selectedIndex);
  const [activeId, setActiveId] = React3.useState();
  const [virtualId, setVirtualId] = React3.useState();
  const focusItem = useEffectEvent(() => {
    function runFocus(item2) {
      if (virtual) {
        var _item$id;
        if ((_item$id = item2.id) != null && _item$id.endsWith("-fui-option")) {
          item2.id = floatingId + "-" + Math.random().toString(16).slice(2, 10);
        }
        setActiveId(item2.id);
        tree == null || tree.events.emit("virtualfocus", item2);
        if (virtualItemRef) {
          virtualItemRef.current = item2;
        }
      } else {
        enqueueFocus(item2, {
          sync: forceSyncFocusRef.current,
          preventScroll: true
        });
      }
    }
    const initialItem = listRef.current[indexRef.current];
    const forceScrollIntoView = forceScrollIntoViewRef.current;
    if (initialItem) {
      runFocus(initialItem);
    }
    const scheduler = forceSyncFocusRef.current ? (v) => v() : requestAnimationFrame;
    scheduler(() => {
      const waitedItem = listRef.current[indexRef.current] || initialItem;
      if (!waitedItem) return;
      if (!initialItem) {
        runFocus(waitedItem);
      }
      const scrollIntoViewOptions = scrollItemIntoViewRef.current;
      const shouldScrollIntoView = scrollIntoViewOptions && item && (forceScrollIntoView || !isPointerModalityRef.current);
      if (shouldScrollIntoView) {
        waitedItem.scrollIntoView == null || waitedItem.scrollIntoView(typeof scrollIntoViewOptions === "boolean" ? {
          block: "nearest",
          inline: "nearest"
        } : scrollIntoViewOptions);
      }
    });
  });
  index(() => {
    if (!enabled) return;
    if (open && elements.floating) {
      if (focusItemOnOpenRef.current && selectedIndex != null) {
        forceScrollIntoViewRef.current = true;
        indexRef.current = selectedIndex;
        onNavigate();
      }
    } else if (previousMountedRef.current) {
      indexRef.current = -1;
      previousOnNavigateRef.current();
    }
  }, [enabled, open, elements.floating, selectedIndex, onNavigate]);
  index(() => {
    if (!enabled) return;
    if (!open) return;
    if (!elements.floating) return;
    if (activeIndex == null) {
      forceSyncFocusRef.current = false;
      if (selectedIndexRef.current != null) {
        return;
      }
      if (previousMountedRef.current) {
        indexRef.current = -1;
        focusItem();
      }
      if ((!previousOpenRef.current || !previousMountedRef.current) && focusItemOnOpenRef.current && (keyRef.current != null || focusItemOnOpenRef.current === true && keyRef.current == null)) {
        let runs = 0;
        const waitForListPopulated = () => {
          if (listRef.current[0] == null) {
            if (runs < 2) {
              const scheduler = runs ? requestAnimationFrame : queueMicrotask;
              scheduler(waitForListPopulated);
            }
            runs++;
          } else {
            indexRef.current = keyRef.current == null || isMainOrientationToEndKey(keyRef.current, orientation, rtl) || nested ? getMinListIndex(listRef, disabledIndicesRef.current) : getMaxListIndex(listRef, disabledIndicesRef.current);
            keyRef.current = null;
            onNavigate();
          }
        };
        waitForListPopulated();
      }
    } else if (!isIndexOutOfListBounds(listRef, activeIndex)) {
      indexRef.current = activeIndex;
      focusItem();
      forceScrollIntoViewRef.current = false;
    }
  }, [enabled, open, elements.floating, activeIndex, selectedIndexRef, nested, listRef, orientation, rtl, onNavigate, focusItem, disabledIndicesRef]);
  index(() => {
    var _nodes$find;
    if (!enabled || elements.floating || !tree || virtual || !previousMountedRef.current) {
      return;
    }
    const nodes = tree.nodesRef.current;
    const parent = (_nodes$find = nodes.find((node) => node.id === parentId)) == null || (_nodes$find = _nodes$find.context) == null ? void 0 : _nodes$find.elements.floating;
    const activeEl = activeElement(getDocument(elements.floating));
    const treeContainsActiveEl = nodes.some((node) => node.context && contains(node.context.elements.floating, activeEl));
    if (parent && !treeContainsActiveEl && isPointerModalityRef.current) {
      parent.focus({
        preventScroll: true
      });
    }
  }, [enabled, elements.floating, tree, parentId, virtual]);
  index(() => {
    if (!enabled) return;
    if (!tree) return;
    if (!virtual) return;
    if (parentId) return;
    function handleVirtualFocus(item2) {
      setVirtualId(item2.id);
      if (virtualItemRef) {
        virtualItemRef.current = item2;
      }
    }
    tree.events.on("virtualfocus", handleVirtualFocus);
    return () => {
      tree.events.off("virtualfocus", handleVirtualFocus);
    };
  }, [enabled, tree, virtual, parentId, virtualItemRef]);
  index(() => {
    previousOnNavigateRef.current = onNavigate;
    previousOpenRef.current = open;
    previousMountedRef.current = !!elements.floating;
  });
  index(() => {
    if (!open) {
      keyRef.current = null;
    }
  }, [open]);
  const hasActiveIndex = activeIndex != null;
  const item = React3.useMemo(() => {
    function syncCurrentTarget(currentTarget) {
      if (!open) return;
      const index3 = listRef.current.indexOf(currentTarget);
      if (index3 !== -1 && indexRef.current !== index3) {
        indexRef.current = index3;
        onNavigate();
      }
    }
    const props2 = {
      onFocus(_ref) {
        let {
          currentTarget
        } = _ref;
        forceSyncFocusRef.current = true;
        syncCurrentTarget(currentTarget);
      },
      onClick: (_ref2) => {
        let {
          currentTarget
        } = _ref2;
        return currentTarget.focus({
          preventScroll: true
        });
      },
      // Safari
      ...focusItemOnHover && {
        onMouseMove(_ref3) {
          let {
            currentTarget
          } = _ref3;
          forceSyncFocusRef.current = true;
          forceScrollIntoViewRef.current = false;
          syncCurrentTarget(currentTarget);
        },
        onPointerLeave(_ref4) {
          let {
            pointerType
          } = _ref4;
          if (!isPointerModalityRef.current || pointerType === "touch") {
            return;
          }
          forceSyncFocusRef.current = true;
          indexRef.current = -1;
          onNavigate();
          if (!virtual) {
            var _floatingFocusElement;
            (_floatingFocusElement = floatingFocusElementRef.current) == null || _floatingFocusElement.focus({
              preventScroll: true
            });
          }
        }
      }
    };
    return props2;
  }, [open, floatingFocusElementRef, focusItemOnHover, listRef, onNavigate, virtual]);
  const getParentOrientation = React3.useCallback(() => {
    var _tree$nodesRef$curren;
    return parentOrientation != null ? parentOrientation : tree == null || (_tree$nodesRef$curren = tree.nodesRef.current.find((node) => node.id === parentId)) == null || (_tree$nodesRef$curren = _tree$nodesRef$curren.context) == null || (_tree$nodesRef$curren = _tree$nodesRef$curren.dataRef) == null ? void 0 : _tree$nodesRef$curren.current.orientation;
  }, [parentId, tree, parentOrientation]);
  const commonOnKeyDown = useEffectEvent((event) => {
    isPointerModalityRef.current = false;
    forceSyncFocusRef.current = true;
    if (event.which === 229) {
      return;
    }
    if (!latestOpenRef.current && event.currentTarget === floatingFocusElementRef.current) {
      return;
    }
    if (nested && isCrossOrientationCloseKey(event.key, orientation, rtl, cols)) {
      if (!isMainOrientationKey(event.key, getParentOrientation())) {
        stopEvent(event);
      }
      onOpenChange(false, event.nativeEvent, "list-navigation");
      if (isHTMLElement(elements.domReference)) {
        if (virtual) {
          tree == null || tree.events.emit("virtualfocus", elements.domReference);
        } else {
          elements.domReference.focus();
        }
      }
      return;
    }
    const currentIndex = indexRef.current;
    const minIndex = getMinListIndex(listRef, disabledIndices);
    const maxIndex = getMaxListIndex(listRef, disabledIndices);
    if (!typeableComboboxReference) {
      if (event.key === "Home") {
        stopEvent(event);
        indexRef.current = minIndex;
        onNavigate();
      }
      if (event.key === "End") {
        stopEvent(event);
        indexRef.current = maxIndex;
        onNavigate();
      }
    }
    if (cols > 1) {
      const sizes = itemSizes || Array.from({
        length: listRef.current.length
      }, () => ({
        width: 1,
        height: 1
      }));
      const cellMap = createGridCellMap(sizes, cols, dense);
      const minGridIndex = cellMap.findIndex((index4) => index4 != null && !isListIndexDisabled(listRef, index4, disabledIndices));
      const maxGridIndex = cellMap.reduce((foundIndex, index4, cellIndex) => index4 != null && !isListIndexDisabled(listRef, index4, disabledIndices) ? cellIndex : foundIndex, -1);
      const index3 = cellMap[getGridNavigatedIndex({
        current: cellMap.map((itemIndex) => itemIndex != null ? listRef.current[itemIndex] : null)
      }, {
        event,
        orientation,
        loop,
        rtl,
        cols,
        // treat undefined (empty grid spaces) as disabled indices so we
        // don't end up in them
        disabledIndices: getGridCellIndices([...disabledIndices || listRef.current.map((_, index4) => isListIndexDisabled(listRef, index4) ? index4 : void 0), void 0], cellMap),
        minIndex: minGridIndex,
        maxIndex: maxGridIndex,
        prevIndex: getGridCellIndexOfCorner(
          indexRef.current > maxIndex ? minIndex : indexRef.current,
          sizes,
          cellMap,
          cols,
          // use a corner matching the edge closest to the direction
          // we're moving in so we don't end up in the same item. Prefer
          // top/left over bottom/right.
          event.key === ARROW_DOWN2 ? "bl" : event.key === (rtl ? ARROW_LEFT2 : ARROW_RIGHT2) ? "tr" : "tl"
        ),
        stopEvent: true
      })];
      if (index3 != null) {
        indexRef.current = index3;
        onNavigate();
      }
      if (orientation === "both") {
        return;
      }
    }
    if (isMainOrientationKey(event.key, orientation)) {
      stopEvent(event);
      if (open && !virtual && activeElement(event.currentTarget.ownerDocument) === event.currentTarget) {
        indexRef.current = isMainOrientationToEndKey(event.key, orientation, rtl) ? minIndex : maxIndex;
        onNavigate();
        return;
      }
      if (isMainOrientationToEndKey(event.key, orientation, rtl)) {
        if (loop) {
          indexRef.current = currentIndex >= maxIndex ? allowEscape && currentIndex !== listRef.current.length ? -1 : minIndex : findNonDisabledListIndex(listRef, {
            startingIndex: currentIndex,
            disabledIndices
          });
        } else {
          indexRef.current = Math.min(maxIndex, findNonDisabledListIndex(listRef, {
            startingIndex: currentIndex,
            disabledIndices
          }));
        }
      } else {
        if (loop) {
          indexRef.current = currentIndex <= minIndex ? allowEscape && currentIndex !== -1 ? listRef.current.length : maxIndex : findNonDisabledListIndex(listRef, {
            startingIndex: currentIndex,
            decrement: true,
            disabledIndices
          });
        } else {
          indexRef.current = Math.max(minIndex, findNonDisabledListIndex(listRef, {
            startingIndex: currentIndex,
            decrement: true,
            disabledIndices
          }));
        }
      }
      if (isIndexOutOfListBounds(listRef, indexRef.current)) {
        indexRef.current = -1;
      }
      onNavigate();
    }
  });
  const ariaActiveDescendantProp = React3.useMemo(() => {
    return virtual && open && hasActiveIndex && {
      "aria-activedescendant": virtualId || activeId
    };
  }, [virtual, open, hasActiveIndex, virtualId, activeId]);
  const floating = React3.useMemo(() => {
    return {
      "aria-orientation": orientation === "both" ? void 0 : orientation,
      ...!typeableComboboxReference ? ariaActiveDescendantProp : {},
      onKeyDown: commonOnKeyDown,
      onPointerMove() {
        isPointerModalityRef.current = true;
      }
    };
  }, [ariaActiveDescendantProp, commonOnKeyDown, orientation, typeableComboboxReference]);
  const reference = React3.useMemo(() => {
    function checkVirtualMouse(event) {
      if (focusItemOnOpen === "auto" && isVirtualClick(event.nativeEvent)) {
        focusItemOnOpenRef.current = true;
      }
    }
    function checkVirtualPointer(event) {
      focusItemOnOpenRef.current = focusItemOnOpen;
      if (focusItemOnOpen === "auto" && isVirtualPointerEvent(event.nativeEvent)) {
        focusItemOnOpenRef.current = true;
      }
    }
    return {
      ...ariaActiveDescendantProp,
      onKeyDown(event) {
        isPointerModalityRef.current = false;
        const isArrowKey = event.key.startsWith("Arrow");
        const isHomeOrEndKey = ["Home", "End"].includes(event.key);
        const isMoveKey = isArrowKey || isHomeOrEndKey;
        const isCrossOpenKey = isCrossOrientationOpenKey(event.key, orientation, rtl);
        const isCrossCloseKey = isCrossOrientationCloseKey(event.key, orientation, rtl, cols);
        const isParentCrossOpenKey = isCrossOrientationOpenKey(event.key, getParentOrientation(), rtl);
        const isMainKey = isMainOrientationKey(event.key, orientation);
        const isNavigationKey = (nested ? isParentCrossOpenKey : isMainKey) || event.key === "Enter" || event.key.trim() === "";
        if (virtual && open) {
          const rootNode = tree == null ? void 0 : tree.nodesRef.current.find((node) => node.parentId == null);
          const deepestNode = tree && rootNode ? getDeepestNode(tree.nodesRef.current, rootNode.id) : null;
          if (isMoveKey && deepestNode && virtualItemRef) {
            const eventObject = new KeyboardEvent("keydown", {
              key: event.key,
              bubbles: true
            });
            if (isCrossOpenKey || isCrossCloseKey) {
              var _deepestNode$context, _deepestNode$context2;
              const isCurrentTarget = ((_deepestNode$context = deepestNode.context) == null ? void 0 : _deepestNode$context.elements.domReference) === event.currentTarget;
              const dispatchItem = isCrossCloseKey && !isCurrentTarget ? (_deepestNode$context2 = deepestNode.context) == null ? void 0 : _deepestNode$context2.elements.domReference : isCrossOpenKey ? listRef.current.find((item2) => (item2 == null ? void 0 : item2.id) === activeId) : null;
              if (dispatchItem) {
                stopEvent(event);
                dispatchItem.dispatchEvent(eventObject);
                setVirtualId(void 0);
              }
            }
            if ((isMainKey || isHomeOrEndKey) && deepestNode.context) {
              if (deepestNode.context.open && deepestNode.parentId && event.currentTarget !== deepestNode.context.elements.domReference) {
                var _deepestNode$context$;
                stopEvent(event);
                (_deepestNode$context$ = deepestNode.context.elements.domReference) == null || _deepestNode$context$.dispatchEvent(eventObject);
                return;
              }
            }
          }
          return commonOnKeyDown(event);
        }
        if (!open && !openOnArrowKeyDown && isArrowKey) {
          return;
        }
        if (isNavigationKey) {
          const isParentMainKey = isMainOrientationKey(event.key, getParentOrientation());
          keyRef.current = nested && isParentMainKey ? null : event.key;
        }
        if (nested) {
          if (isParentCrossOpenKey) {
            stopEvent(event);
            if (open) {
              indexRef.current = getMinListIndex(listRef, disabledIndicesRef.current);
              onNavigate();
            } else {
              onOpenChange(true, event.nativeEvent, "list-navigation");
            }
          }
          return;
        }
        if (isMainKey) {
          if (selectedIndex != null) {
            indexRef.current = selectedIndex;
          }
          stopEvent(event);
          if (!open && openOnArrowKeyDown) {
            onOpenChange(true, event.nativeEvent, "list-navigation");
          } else {
            commonOnKeyDown(event);
          }
          if (open) {
            onNavigate();
          }
        }
      },
      onFocus() {
        if (open && !virtual) {
          indexRef.current = -1;
          onNavigate();
        }
      },
      onPointerDown: checkVirtualPointer,
      onPointerEnter: checkVirtualPointer,
      onMouseDown: checkVirtualMouse,
      onClick: checkVirtualMouse
    };
  }, [activeId, ariaActiveDescendantProp, cols, commonOnKeyDown, disabledIndicesRef, focusItemOnOpen, listRef, nested, onNavigate, onOpenChange, open, openOnArrowKeyDown, orientation, getParentOrientation, rtl, selectedIndex, tree, virtual, virtualItemRef]);
  return React3.useMemo(() => enabled ? {
    reference,
    floating,
    item
  } : {}, [enabled, reference, floating, item]);
}
var componentRoleToAriaRoleMap = /* @__PURE__ */ new Map([["select", "listbox"], ["combobox", "listbox"], ["label", false]]);
function useRole(context2, props) {
  var _elements$domReferenc, _componentRoleToAriaR;
  if (props === void 0) {
    props = {};
  }
  const {
    open,
    elements,
    floatingId: defaultFloatingId
  } = context2;
  const {
    enabled = true,
    role: role2 = "dialog"
  } = props;
  const defaultReferenceId = useId();
  const referenceId = ((_elements$domReferenc = elements.domReference) == null ? void 0 : _elements$domReferenc.id) || defaultReferenceId;
  const floatingId = React3.useMemo(() => {
    var _getFloatingFocusElem;
    return ((_getFloatingFocusElem = getFloatingFocusElement(elements.floating)) == null ? void 0 : _getFloatingFocusElem.id) || defaultFloatingId;
  }, [elements.floating, defaultFloatingId]);
  const ariaRole = (_componentRoleToAriaR = componentRoleToAriaRoleMap.get(role2)) != null ? _componentRoleToAriaR : role2;
  const parentId = useFloatingParentNodeId();
  const isNested = parentId != null;
  const reference = React3.useMemo(() => {
    if (ariaRole === "tooltip" || role2 === "label") {
      return {
        ["aria-" + (role2 === "label" ? "labelledby" : "describedby")]: open ? floatingId : void 0
      };
    }
    return {
      "aria-expanded": open ? "true" : "false",
      "aria-haspopup": ariaRole === "alertdialog" ? "dialog" : ariaRole,
      "aria-controls": open ? floatingId : void 0,
      ...ariaRole === "listbox" && {
        role: "combobox"
      },
      ...ariaRole === "menu" && {
        id: referenceId
      },
      ...ariaRole === "menu" && isNested && {
        role: "menuitem"
      },
      ...role2 === "select" && {
        "aria-autocomplete": "none"
      },
      ...role2 === "combobox" && {
        "aria-autocomplete": "list"
      }
    };
  }, [ariaRole, floatingId, isNested, open, referenceId, role2]);
  const floating = React3.useMemo(() => {
    const floatingProps = {
      id: floatingId,
      ...ariaRole && {
        role: ariaRole
      }
    };
    if (ariaRole === "tooltip" || role2 === "label") {
      return floatingProps;
    }
    return {
      ...floatingProps,
      ...ariaRole === "menu" && {
        "aria-labelledby": referenceId
      }
    };
  }, [ariaRole, floatingId, referenceId, role2]);
  const item = React3.useCallback((_ref) => {
    let {
      active,
      selected
    } = _ref;
    const commonProps = {
      role: "option",
      ...active && {
        id: floatingId + "-fui-option"
      }
    };
    switch (role2) {
      case "select":
        return {
          ...commonProps,
          "aria-selected": active && selected
        };
      case "combobox": {
        return {
          ...commonProps,
          "aria-selected": selected
        };
      }
    }
    return {};
  }, [floatingId, role2]);
  return React3.useMemo(() => enabled ? {
    reference,
    floating,
    item
  } : {}, [enabled, reference, floating, item]);
}
function useTypeahead(context2, props) {
  var _ref;
  const {
    open,
    dataRef
  } = context2;
  const {
    listRef,
    activeIndex,
    onMatch: unstable_onMatch,
    onTypingChange: unstable_onTypingChange,
    enabled = true,
    findMatch = null,
    resetMs = 750,
    ignoreKeys = [],
    selectedIndex = null
  } = props;
  const timeoutIdRef = React3.useRef(-1);
  const stringRef = React3.useRef("");
  const prevIndexRef = React3.useRef((_ref = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref : -1);
  const matchIndexRef = React3.useRef(null);
  const onMatch = useEffectEvent(unstable_onMatch);
  const onTypingChange = useEffectEvent(unstable_onTypingChange);
  const findMatchRef = useLatestRef(findMatch);
  const ignoreKeysRef = useLatestRef(ignoreKeys);
  index(() => {
    if (open) {
      clearTimeoutIfSet(timeoutIdRef);
      matchIndexRef.current = null;
      stringRef.current = "";
    }
  }, [open]);
  index(() => {
    if (open && stringRef.current === "") {
      var _ref2;
      prevIndexRef.current = (_ref2 = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref2 : -1;
    }
  }, [open, selectedIndex, activeIndex]);
  const setTypingChange = useEffectEvent((value) => {
    if (value) {
      if (!dataRef.current.typing) {
        dataRef.current.typing = value;
        onTypingChange(value);
      }
    } else {
      if (dataRef.current.typing) {
        dataRef.current.typing = value;
        onTypingChange(value);
      }
    }
  });
  const onKeyDown = useEffectEvent((event) => {
    function getMatchingIndex(list, orderedList, string) {
      const str = findMatchRef.current ? findMatchRef.current(orderedList, string) : orderedList.find((text) => (text == null ? void 0 : text.toLocaleLowerCase().indexOf(string.toLocaleLowerCase())) === 0);
      return str ? list.indexOf(str) : -1;
    }
    const listContent = listRef.current;
    if (stringRef.current.length > 0 && stringRef.current[0] !== " ") {
      if (getMatchingIndex(listContent, listContent, stringRef.current) === -1) {
        setTypingChange(false);
      } else if (event.key === " ") {
        stopEvent(event);
      }
    }
    if (listContent == null || ignoreKeysRef.current.includes(event.key) || // Character key.
    event.key.length !== 1 || // Modifier key.
    event.ctrlKey || event.metaKey || event.altKey) {
      return;
    }
    if (open && event.key !== " ") {
      stopEvent(event);
      setTypingChange(true);
    }
    const allowRapidSuccessionOfFirstLetter = listContent.every((text) => {
      var _text$, _text$2;
      return text ? ((_text$ = text[0]) == null ? void 0 : _text$.toLocaleLowerCase()) !== ((_text$2 = text[1]) == null ? void 0 : _text$2.toLocaleLowerCase()) : true;
    });
    if (allowRapidSuccessionOfFirstLetter && stringRef.current === event.key) {
      stringRef.current = "";
      prevIndexRef.current = matchIndexRef.current;
    }
    stringRef.current += event.key;
    clearTimeoutIfSet(timeoutIdRef);
    timeoutIdRef.current = window.setTimeout(() => {
      stringRef.current = "";
      prevIndexRef.current = matchIndexRef.current;
      setTypingChange(false);
    }, resetMs);
    const prevIndex = prevIndexRef.current;
    const index3 = getMatchingIndex(listContent, [...listContent.slice((prevIndex || 0) + 1), ...listContent.slice(0, (prevIndex || 0) + 1)], stringRef.current);
    if (index3 !== -1) {
      onMatch(index3);
      matchIndexRef.current = index3;
    } else if (event.key !== " ") {
      stringRef.current = "";
      setTypingChange(false);
    }
  });
  const reference = React3.useMemo(() => ({
    onKeyDown
  }), [onKeyDown]);
  const floating = React3.useMemo(() => {
    return {
      onKeyDown,
      onKeyUp(event) {
        if (event.key === " ") {
          setTypingChange(false);
        }
      }
    };
  }, [onKeyDown, setTypingChange]);
  return React3.useMemo(() => enabled ? {
    reference,
    floating
  } : {}, [enabled, reference, floating]);
}

// node_modules/@stream-io/video-react-sdk/dist/index.es.js
var import_react_dom3 = __toESM(require_react_dom());

// node_modules/wasm-feature-detect/dist/esm/index.js
var simd = async () => WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 123, 3, 2, 1, 0, 10, 10, 1, 8, 0, 65, 0, 253, 15, 253, 98, 11]));

// node_modules/@stream-io/video-filters-web/dist/index.es.js
var isMobile2 = () => /Mobi/i.test(navigator.userAgent);
var isPlatformSupported = async () => typeof document !== "undefined" && typeof window !== "undefined" && typeof navigator !== "undefined" && !isMobile2() && // we don't support mobile devices yet due to performance issues
typeof WebAssembly !== "undefined" && !!window.WebGL2RenderingContext && // WebGL2 is required for the video filters
!!document.createElement("canvas").getContext("webgl2") && await simd();
var glsl = String.raw;
function createPipelineStageProgram(gl, vertexShader, fragmentShader, positionBuffer, texCoordBuffer) {
  const program = createProgram(gl, vertexShader, fragmentShader);
  const positionAttributeLocation = gl.getAttribLocation(program, "a_position");
  gl.enableVertexAttribArray(positionAttributeLocation);
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);
  const texCoordAttributeLocation = gl.getAttribLocation(program, "a_texCoord");
  gl.enableVertexAttribArray(texCoordAttributeLocation);
  gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
  gl.vertexAttribPointer(texCoordAttributeLocation, 2, gl.FLOAT, false, 0, 0);
  return program;
}
function createProgram(gl, vertexShader, fragmentShader) {
  const program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    throw new Error(`Could not link WebGL program: ${gl.getProgramInfoLog(program)}`);
  }
  return program;
}
function compileShader(gl, shaderType, shaderSource) {
  const shader = gl.createShader(shaderType);
  gl.shaderSource(shader, shaderSource);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    throw new Error(`Could not compile shader: ${gl.getShaderInfoLog(shader)}`);
  }
  return shader;
}
function createTexture(gl, internalformat, width, height, minFilter = gl.NEAREST, magFilter = gl.NEAREST) {
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);
  gl.texStorage2D(gl.TEXTURE_2D, 1, internalformat, width, height);
  return texture;
}
async function readPixelsAsync(gl, x, y, width, height, format, type, dest) {
  const buf = gl.createBuffer();
  gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buf);
  gl.bufferData(gl.PIXEL_PACK_BUFFER, dest.byteLength, gl.STREAM_READ);
  gl.readPixels(x, y, width, height, format, type, 0);
  gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
  await getBufferSubDataAsync(gl, gl.PIXEL_PACK_BUFFER, buf, 0, dest);
  gl.deleteBuffer(buf);
  return dest;
}
async function getBufferSubDataAsync(gl, target, buffer2, srcByteOffset, dstBuffer, dstOffset, length) {
  const sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
  gl.flush();
  if (!sync)
    return;
  const res = await clientWaitAsync(gl, sync);
  gl.deleteSync(sync);
  if (res !== gl.WAIT_FAILED) {
    gl.bindBuffer(target, buffer2);
    gl.getBufferSubData(target, srcByteOffset, dstBuffer, dstOffset, length);
    gl.bindBuffer(target, null);
  }
}
function clientWaitAsync(gl, sync) {
  return new Promise((resolve) => {
    function test() {
      const res = gl.clientWaitSync(sync, 0, 0);
      if (res === gl.WAIT_FAILED) {
        resolve(res);
        return;
      }
      if (res === gl.TIMEOUT_EXPIRED) {
        setTimeout(test);
        return;
      }
      resolve(res);
    }
    setTimeout(test);
  });
}
function buildBackgroundBlurStage(gl, vertexShader, positionBuffer, texCoordBuffer, personMaskTexture, canvas, blurLevel) {
  const blurPass = buildBlurPass(gl, vertexShader, positionBuffer, texCoordBuffer, personMaskTexture, canvas, blurLevel);
  const blendPass = buildBlendPass(gl, positionBuffer, texCoordBuffer, canvas);
  function render() {
    blurPass.render();
    blendPass.render();
  }
  function updateCoverage(coverage) {
    blendPass.updateCoverage(coverage);
  }
  function cleanUp() {
    blendPass.cleanUp();
    blurPass.cleanUp();
  }
  return {
    render,
    updateCoverage,
    cleanUp
  };
}
function buildBlurPass(gl, vertexShader, positionBuffer, texCoordBuffer, personMaskTexture, canvas, blurLevel) {
  const sigma = typeof blurLevel === "number" ? blurLevel : blurLevel === "low" ? 2 : blurLevel === "medium" ? 4 : 6;
  const windowSize = Math.max(1, Math.floor(sigma * 3));
  const offset4 = new Array(windowSize).fill(0).map((v, index3) => index3);
  const variance = sigma ** 2;
  const weights = offset4.map((x) => {
    var m = sigma * Math.sqrt(2 * Math.PI);
    var e = Math.exp(-(x ** 2) / (2 * variance));
    return e / m;
  });
  const fragmentShaderSource = glsl`#version 300 es

    precision highp float;

    uniform sampler2D u_inputFrame;
    uniform sampler2D u_personMask;
    uniform vec2 u_texelSize;

    in vec2 v_texCoord;
    out vec4 outColor;

    const float offset[${windowSize}] = float[](${offset4.map((i) => i.toFixed(10)).join(", ")});
    const float weight[${windowSize}] = float[](${weights.map((i) => i.toFixed(10)).join(", ")});

    void main() {
      vec4 centerColor = texture(u_inputFrame, v_texCoord);
      float personMask = texture(u_personMask, v_texCoord).a;

      vec4 frameColor = centerColor * weight[0] * (1.0 - personMask);

      for (int i = 1; i < ${windowSize}; i++) {
        vec2 offset = vec2(offset[i]) * u_texelSize;

        vec2 texCoord = v_texCoord + offset;
        frameColor += texture(u_inputFrame, texCoord)
           * weight[i]
           * (1.0 - texture(u_personMask, texCoord).a);

        texCoord = v_texCoord - offset;
        frameColor += texture(u_inputFrame, texCoord)
          * weight[i]
          * (1.0 - texture(u_personMask, texCoord).a);
      }
      outColor = vec4(frameColor.rgb + (1.0 - frameColor.a) * centerColor.rgb, 1.0);
    }
  `;
  const scale = 0.5;
  const outputWidth = canvas.width * scale;
  const outputHeight = canvas.height * scale;
  const texelWidth = 1 / outputWidth;
  const texelHeight = 1 / outputHeight;
  const fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
  const program = createPipelineStageProgram(gl, vertexShader, fragmentShader, positionBuffer, texCoordBuffer);
  const inputFrameLocation = gl.getUniformLocation(program, "u_inputFrame");
  const personMaskLocation = gl.getUniformLocation(program, "u_personMask");
  const texelSizeLocation = gl.getUniformLocation(program, "u_texelSize");
  const texture1 = createTexture(
    gl,
    gl.RGBA8,
    outputWidth,
    outputHeight,
    gl.NEAREST,
    // @ts-expect-error types are incomplete
    gl.LINEAR
  );
  const texture2 = createTexture(
    gl,
    gl.RGBA8,
    outputWidth,
    outputHeight,
    gl.NEAREST,
    // @ts-expect-error types are incomplete
    gl.LINEAR
  );
  const frameBuffer1 = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer1);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture1, 0);
  const frameBuffer2 = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer2);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture2, 0);
  gl.useProgram(program);
  gl.uniform1i(personMaskLocation, 1);
  function render() {
    gl.viewport(0, 0, outputWidth, outputHeight);
    gl.useProgram(program);
    gl.uniform1i(inputFrameLocation, 0);
    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, personMaskTexture);
    for (let i = 0; i < 3; i++) {
      gl.uniform2f(texelSizeLocation, 0, texelHeight);
      gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer1);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      gl.activeTexture(gl.TEXTURE2);
      gl.bindTexture(gl.TEXTURE_2D, texture1);
      gl.uniform1i(inputFrameLocation, 2);
      gl.uniform2f(texelSizeLocation, texelWidth, 0);
      gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer2);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      gl.bindTexture(gl.TEXTURE_2D, texture2);
    }
  }
  function cleanUp() {
    gl.deleteFramebuffer(frameBuffer2);
    gl.deleteFramebuffer(frameBuffer1);
    gl.deleteTexture(texture2);
    gl.deleteTexture(texture1);
    gl.deleteProgram(program);
    gl.deleteShader(fragmentShader);
  }
  return {
    render,
    cleanUp
  };
}
function buildBlendPass(gl, positionBuffer, texCoordBuffer, canvas) {
  const vertexShaderSource = glsl`#version 300 es

    in vec2 a_position;
    in vec2 a_texCoord;

    out vec2 v_texCoord;

    void main() {
      // Flipping Y is required when rendering to canvas
      gl_Position = vec4(a_position * vec2(1.0, -1.0), 0.0, 1.0);
      v_texCoord = a_texCoord;
    }
  `;
  const fragmentShaderSource = glsl`#version 300 es

    precision highp float;

    uniform sampler2D u_inputFrame;
    uniform sampler2D u_personMask;
    uniform sampler2D u_blurredInputFrame;
    uniform vec2 u_coverage;

    in vec2 v_texCoord;

    out vec4 outColor;

    void main() {
      vec3 color = texture(u_inputFrame, v_texCoord).rgb;
      vec3 blurredColor = texture(u_blurredInputFrame, v_texCoord).rgb;
      float personMask = texture(u_personMask, v_texCoord).a;
      personMask = smoothstep(u_coverage.x, u_coverage.y, personMask);
      outColor = vec4(mix(blurredColor, color, personMask), 1.0);
    }
  `;
  const { width: outputWidth, height: outputHeight } = canvas;
  const vertexShader = compileShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
  const fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
  const program = createPipelineStageProgram(gl, vertexShader, fragmentShader, positionBuffer, texCoordBuffer);
  const inputFrameLocation = gl.getUniformLocation(program, "u_inputFrame");
  const personMaskLocation = gl.getUniformLocation(program, "u_personMask");
  const blurredInputFrame = gl.getUniformLocation(program, "u_blurredInputFrame");
  const coverageLocation = gl.getUniformLocation(program, "u_coverage");
  gl.useProgram(program);
  gl.uniform1i(inputFrameLocation, 0);
  gl.uniform1i(personMaskLocation, 1);
  gl.uniform1i(blurredInputFrame, 2);
  gl.uniform2f(coverageLocation, 0, 1);
  function render() {
    gl.viewport(0, 0, outputWidth, outputHeight);
    gl.useProgram(program);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  }
  function updateCoverage(coverage) {
    gl.useProgram(program);
    gl.uniform2f(coverageLocation, coverage[0], coverage[1]);
  }
  function cleanUp() {
    gl.deleteProgram(program);
    gl.deleteShader(fragmentShader);
    gl.deleteShader(vertexShader);
  }
  return {
    render,
    updateCoverage,
    cleanUp
  };
}
function buildBackgroundImageStage(gl, positionBuffer, texCoordBuffer, personMaskTexture, backgroundImage, canvas) {
  const vertexShaderSource = glsl`#version 300 es

    uniform vec2 u_backgroundScale;
    uniform vec2 u_backgroundOffset;

    in vec2 a_position;
    in vec2 a_texCoord;

    out vec2 v_texCoord;
    out vec2 v_backgroundCoord;

    void main() {
      // Flipping Y is required when rendering to canvas
      gl_Position = vec4(a_position * vec2(1.0, -1.0), 0.0, 1.0);
      v_texCoord = a_texCoord;
      v_backgroundCoord = a_texCoord * u_backgroundScale + u_backgroundOffset;
    }
  `;
  const fragmentShaderSource = glsl`#version 300 es

    precision highp float;

    uniform sampler2D u_inputFrame;
    uniform sampler2D u_personMask;
    uniform sampler2D u_background;
    uniform vec2 u_coverage;
    uniform float u_lightWrapping;
    uniform float u_blendMode;

    in vec2 v_texCoord;
    in vec2 v_backgroundCoord;

    out vec4 outColor;

    vec3 screen(vec3 a, vec3 b) {
      return 1.0 - (1.0 - a) * (1.0 - b);
    }

    vec3 linearDodge(vec3 a, vec3 b) {
      return a + b;
    }

    void main() {
      vec3 frameColor = texture(u_inputFrame, v_texCoord).rgb;
      vec3 backgroundColor = texture(u_background, v_backgroundCoord).rgb;
      float personMask = texture(u_personMask, v_texCoord).a;
      float lightWrapMask = 1.0 - max(0.0, personMask - u_coverage.y) / (1.0 - u_coverage.y);
      vec3 lightWrap = u_lightWrapping * lightWrapMask * backgroundColor;

      frameColor = u_blendMode * linearDodge(frameColor, lightWrap)
        + (1.0 - u_blendMode) * screen(frameColor, lightWrap);
      personMask = smoothstep(u_coverage.x, u_coverage.y, personMask);
      outColor = vec4(frameColor * personMask + backgroundColor * (1.0 - personMask), 1.0);
    }
  `;
  const { width: outputWidth, height: outputHeight } = canvas;
  const outputRatio = outputWidth / outputHeight;
  const vertexShader = compileShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
  const fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
  const program = createPipelineStageProgram(gl, vertexShader, fragmentShader, positionBuffer, texCoordBuffer);
  const backgroundScaleLocation = gl.getUniformLocation(program, "u_backgroundScale");
  const backgroundOffsetLocation = gl.getUniformLocation(program, "u_backgroundOffset");
  const inputFrameLocation = gl.getUniformLocation(program, "u_inputFrame");
  const personMaskLocation = gl.getUniformLocation(program, "u_personMask");
  const backgroundLocation = gl.getUniformLocation(program, "u_background");
  const coverageLocation = gl.getUniformLocation(program, "u_coverage");
  const lightWrappingLocation = gl.getUniformLocation(program, "u_lightWrapping");
  const blendModeLocation = gl.getUniformLocation(program, "u_blendMode");
  gl.useProgram(program);
  gl.uniform2f(backgroundScaleLocation, 1, 1);
  gl.uniform2f(backgroundOffsetLocation, 0, 0);
  gl.uniform1i(inputFrameLocation, 0);
  gl.uniform1i(personMaskLocation, 1);
  gl.uniform2f(coverageLocation, 0, 1);
  gl.uniform1f(lightWrappingLocation, 0);
  gl.uniform1f(blendModeLocation, 0);
  let backgroundTexture = null;
  if (backgroundImage == null ? void 0 : backgroundImage.complete) {
    updateBackgroundImage(backgroundImage);
  } else if (backgroundImage) {
    backgroundImage.onload = () => {
      updateBackgroundImage(backgroundImage);
    };
  }
  function render() {
    gl.viewport(0, 0, outputWidth, outputHeight);
    gl.useProgram(program);
    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, personMaskTexture);
    if (backgroundTexture !== null) {
      gl.activeTexture(gl.TEXTURE2);
      gl.bindTexture(gl.TEXTURE_2D, backgroundTexture);
      gl.uniform1i(backgroundLocation, 2);
    }
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  }
  function updateBackgroundImage(bgImage) {
    backgroundTexture = createTexture(
      gl,
      gl.RGBA8,
      bgImage.naturalWidth,
      bgImage.naturalHeight,
      // @ts-expect-error types are incomplete
      gl.LINEAR,
      gl.LINEAR
    );
    gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, bgImage.naturalWidth, bgImage.naturalHeight, gl.RGBA, gl.UNSIGNED_BYTE, bgImage);
    let xOffset = 0;
    let yOffset = 0;
    let backgroundWidth = bgImage.naturalWidth;
    let backgroundHeight = bgImage.naturalHeight;
    const backgroundRatio = backgroundWidth / backgroundHeight;
    if (backgroundRatio < outputRatio) {
      backgroundHeight = backgroundWidth / outputRatio;
      yOffset = (bgImage.naturalHeight - backgroundHeight) / 2;
    } else {
      backgroundWidth = backgroundHeight * outputRatio;
      xOffset = (bgImage.naturalWidth - backgroundWidth) / 2;
    }
    const xScale = backgroundWidth / bgImage.naturalWidth;
    const yScale = backgroundHeight / bgImage.naturalHeight;
    xOffset /= bgImage.naturalWidth;
    yOffset /= bgImage.naturalHeight;
    gl.uniform2f(backgroundScaleLocation, xScale, yScale);
    gl.uniform2f(backgroundOffsetLocation, xOffset, yOffset);
  }
  function updateCoverage(coverage) {
    gl.useProgram(program);
    gl.uniform2f(coverageLocation, coverage[0], coverage[1]);
  }
  function updateLightWrapping(lightWrapping) {
    gl.useProgram(program);
    gl.uniform1f(lightWrappingLocation, lightWrapping);
  }
  function updateBlendMode(blendMode) {
    gl.useProgram(program);
    gl.uniform1f(blendModeLocation, blendMode === "screen" ? 0 : 1);
  }
  function cleanUp() {
    gl.deleteTexture(backgroundTexture);
    gl.deleteProgram(program);
    gl.deleteShader(fragmentShader);
    gl.deleteShader(vertexShader);
  }
  return {
    render,
    updateCoverage,
    updateLightWrapping,
    updateBlendMode,
    cleanUp
  };
}
function buildJointBilateralFilterStage(gl, vertexShader, positionBuffer, texCoordBuffer, inputTexture, outputTexture, canvas, segmentationConfig) {
  const fragmentShaderSource = glsl`#version 300 es

    precision highp float;

    uniform sampler2D u_inputFrame;
    uniform sampler2D u_segmentationMask;
    uniform vec2 u_texelSize;
    uniform float u_step;
    uniform float u_radius;
    uniform float u_offset;
    uniform float u_sigmaTexel;
    uniform float u_sigmaColor;

    in vec2 v_texCoord;
    out vec4 outColor;

    float gaussian(float x, float sigma) {
      float coeff = -0.5 / (sigma * sigma * 4.0 + 1.0e-6);
      return exp((x * x) * coeff);
    }

    void main() {
      vec2 centerCoord = v_texCoord;
      vec3 centerColor = texture(u_inputFrame, centerCoord).rgb;
      float newVal = 0.0;

      float spaceWeight = 0.0;
      float colorWeight = 0.0;
      float totalWeight = 0.0;

      // Subsample kernel space.
      for (float i = -u_radius + u_offset; i <= u_radius; i += u_step) {
        for (float j = -u_radius + u_offset; j <= u_radius; j += u_step) {
          vec2 shift = vec2(j, i) * u_texelSize;
          vec2 coord = vec2(centerCoord + shift);
          vec3 frameColor = texture(u_inputFrame, coord).rgb;
          float outVal = texture(u_segmentationMask, coord).a;

          spaceWeight = gaussian(distance(centerCoord, coord), u_sigmaTexel);
          colorWeight = gaussian(distance(centerColor, frameColor), u_sigmaColor);
          totalWeight += spaceWeight * colorWeight;

          newVal += spaceWeight * colorWeight * outVal;
        }
      }
      newVal /= totalWeight;

      outColor = vec4(vec3(0.0), newVal);
    }
  `;
  const { width: segmentationWidth, height: segmentationHeight } = segmentationConfig;
  const { width: outputWidth, height: outputHeight } = canvas;
  const texelWidth = 1 / outputWidth;
  const texelHeight = 1 / outputHeight;
  const fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
  const program = createPipelineStageProgram(gl, vertexShader, fragmentShader, positionBuffer, texCoordBuffer);
  const inputFrameLocation = gl.getUniformLocation(program, "u_inputFrame");
  const segmentationMaskLocation = gl.getUniformLocation(program, "u_segmentationMask");
  const texelSizeLocation = gl.getUniformLocation(program, "u_texelSize");
  const stepLocation = gl.getUniformLocation(program, "u_step");
  const radiusLocation = gl.getUniformLocation(program, "u_radius");
  const offsetLocation = gl.getUniformLocation(program, "u_offset");
  const sigmaTexelLocation = gl.getUniformLocation(program, "u_sigmaTexel");
  const sigmaColorLocation = gl.getUniformLocation(program, "u_sigmaColor");
  const frameBuffer = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, outputTexture, 0);
  gl.useProgram(program);
  gl.uniform1i(inputFrameLocation, 0);
  gl.uniform1i(segmentationMaskLocation, 1);
  gl.uniform2f(texelSizeLocation, texelWidth, texelHeight);
  updateSigmaSpace(0);
  updateSigmaColor(0);
  function render() {
    gl.viewport(0, 0, outputWidth, outputHeight);
    gl.useProgram(program);
    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, inputTexture);
    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  }
  function updateSigmaSpace(sigmaSpace) {
    sigmaSpace *= Math.max(outputWidth / segmentationWidth, outputHeight / segmentationHeight);
    const kSparsityFactor = 0.66;
    const step = Math.max(1, Math.sqrt(sigmaSpace) * kSparsityFactor);
    const radius = sigmaSpace;
    const offset4 = step > 1 ? step * 0.5 : 0;
    const sigmaTexel = Math.max(texelWidth, texelHeight) * sigmaSpace;
    gl.useProgram(program);
    gl.uniform1f(stepLocation, step);
    gl.uniform1f(radiusLocation, radius);
    gl.uniform1f(offsetLocation, offset4);
    gl.uniform1f(sigmaTexelLocation, sigmaTexel);
  }
  function updateSigmaColor(sigmaColor) {
    gl.useProgram(program);
    gl.uniform1f(sigmaColorLocation, sigmaColor);
  }
  function cleanUp() {
    gl.deleteFramebuffer(frameBuffer);
    gl.deleteProgram(program);
    gl.deleteShader(fragmentShader);
  }
  return { render, updateSigmaSpace, updateSigmaColor, cleanUp };
}
function buildResizingStage(gl, vertexShader, positionBuffer, texCoordBuffer, tflite, segmentationConfig, onError) {
  const fragmentShaderSource = glsl`#version 300 es

    precision highp float;
    uniform sampler2D u_inputFrame;
    in vec2 v_texCoord;
    out vec4 outColor;

    void main() {
      outColor = texture(u_inputFrame, v_texCoord);
    }
  `;
  const tfliteInputMemoryOffset = tflite._getInputMemoryOffset() / 4;
  const { width: outputWidth, height: outputHeight } = segmentationConfig;
  const outputPixelCount = outputWidth * outputHeight;
  const fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
  const program = createPipelineStageProgram(gl, vertexShader, fragmentShader, positionBuffer, texCoordBuffer);
  const inputFrameLocation = gl.getUniformLocation(program, "u_inputFrame");
  const outputTexture = createTexture(gl, gl.RGBA8, outputWidth, outputHeight);
  const frameBuffer = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, outputTexture, 0);
  const outputPixels = new Uint8Array(outputPixelCount * 4);
  gl.useProgram(program);
  gl.uniform1i(inputFrameLocation, 0);
  function render() {
    gl.viewport(0, 0, outputWidth, outputHeight);
    gl.useProgram(program);
    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    readPixelsAsync(gl, 0, 0, outputWidth, outputHeight, gl.RGBA, gl.UNSIGNED_BYTE, outputPixels).catch((error2) => {
    });
    for (let i = 0; i < outputPixelCount; i++) {
      const tfliteIndex = tfliteInputMemoryOffset + i * 3;
      const outputIndex = i * 4;
      tflite.HEAPF32[tfliteIndex] = outputPixels[outputIndex] / 255;
      tflite.HEAPF32[tfliteIndex + 1] = outputPixels[outputIndex + 1] / 255;
      tflite.HEAPF32[tfliteIndex + 2] = outputPixels[outputIndex + 2] / 255;
    }
  }
  function cleanUp() {
    gl.deleteFramebuffer(frameBuffer);
    gl.deleteTexture(outputTexture);
    gl.deleteProgram(program);
    gl.deleteShader(fragmentShader);
  }
  return { render, cleanUp };
}
function buildSoftmaxStage(gl, vertexShader, positionBuffer, texCoordBuffer, tflite, outputTexture, segmentationConfig) {
  const fragmentShaderSource = glsl`#version 300 es

    precision highp float;

    uniform sampler2D u_inputSegmentation;
    in vec2 v_texCoord;
    out vec4 outColor;

    void main() {
      vec2 segmentation = texture(u_inputSegmentation, v_texCoord).rg;
      float shift = max(segmentation.r, segmentation.g);
      float backgroundExp = exp(segmentation.r - shift);
      float personExp = exp(segmentation.g - shift);
      outColor = vec4(vec3(0.0), personExp / (backgroundExp + personExp));
    }
  `;
  const tfliteOutputMemoryOffset = tflite._getOutputMemoryOffset() / 4;
  const { width: segmentationWidth, height: segmentationHeight } = segmentationConfig;
  const fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
  const program = createPipelineStageProgram(gl, vertexShader, fragmentShader, positionBuffer, texCoordBuffer);
  const inputLocation = gl.getUniformLocation(program, "u_inputSegmentation");
  const inputTexture = createTexture(gl, gl.RG32F, segmentationWidth, segmentationHeight);
  const frameBuffer = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, outputTexture, 0);
  gl.useProgram(program);
  gl.uniform1i(inputLocation, 1);
  function render() {
    gl.viewport(0, 0, segmentationWidth, segmentationHeight);
    gl.useProgram(program);
    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, inputTexture);
    gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, segmentationWidth, segmentationHeight, gl.RG, gl.FLOAT, tflite.HEAPF32, tfliteOutputMemoryOffset);
    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  }
  function cleanUp() {
    gl.deleteFramebuffer(frameBuffer);
    gl.deleteTexture(inputTexture);
    gl.deleteProgram(program);
    gl.deleteShader(fragmentShader);
  }
  return { render, cleanUp };
}
function buildWebGL2Pipeline(videoSource, backgroundImage, blurLevel, backgroundFilter, canvas, tflite, segmentationConfig, onError) {
  const gl = canvas.getContext("webgl2");
  if (!gl)
    throw new Error("WebGL2 is not supported");
  if (gl.isContextLost())
    throw new Error("WebGL2 context was lost");
  const { width: frameWidth, height: frameHeight } = videoSource;
  const { width: segmentationWidth, height: segmentationHeight } = segmentationConfig;
  const vertexShaderSource = glsl`#version 300 es

    in vec2 a_position;
    in vec2 a_texCoord;
    out vec2 v_texCoord;

    void main() {
      gl_Position = vec4(a_position, 0.0, 1.0);
      v_texCoord = a_texCoord;
    }
  `;
  const vertexShader = compileShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
  const vertexArray = gl.createVertexArray();
  gl.bindVertexArray(vertexArray);
  const positionBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]), gl.STATIC_DRAW);
  const texCoordBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), gl.STATIC_DRAW);
  const inputFrameTexture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, inputFrameTexture);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  const segmentationTexture = createTexture(gl, gl.RGBA8, segmentationWidth, segmentationHeight);
  const personMaskTexture = createTexture(gl, gl.RGBA8, frameWidth, frameHeight);
  const resizingStage = buildResizingStage(gl, vertexShader, positionBuffer, texCoordBuffer, tflite, segmentationConfig);
  const loadSegmentationStage = buildSoftmaxStage(gl, vertexShader, positionBuffer, texCoordBuffer, tflite, segmentationTexture, segmentationConfig);
  const jointBilateralFilterStage = buildJointBilateralFilterStage(gl, vertexShader, positionBuffer, texCoordBuffer, segmentationTexture, personMaskTexture, canvas, segmentationConfig);
  const backgroundStage = backgroundFilter === "blur" ? buildBackgroundBlurStage(gl, vertexShader, positionBuffer, texCoordBuffer, personMaskTexture, canvas, blurLevel || "high") : buildBackgroundImageStage(gl, positionBuffer, texCoordBuffer, personMaskTexture, backgroundImage, canvas);
  function render() {
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, inputFrameTexture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, videoSource);
    gl.bindVertexArray(vertexArray);
    resizingStage.render();
    tflite._runInference();
    loadSegmentationStage.render();
    jointBilateralFilterStage.render();
    backgroundStage.render();
  }
  function updatePostProcessingConfig() {
    jointBilateralFilterStage.updateSigmaSpace(1);
    jointBilateralFilterStage.updateSigmaColor(0.1);
    if (backgroundFilter === "image") {
      const backgroundImageStage = backgroundStage;
      backgroundImageStage.updateCoverage([0.5, 0.75]);
      backgroundImageStage.updateLightWrapping(0.3);
      backgroundImageStage.updateBlendMode("screen");
    } else if (backgroundFilter === "blur") {
      const backgroundBlurStage = backgroundStage;
      backgroundBlurStage.updateCoverage([0.5, 0.75]);
    } else {
      const backgroundImageStage = backgroundStage;
      backgroundImageStage.updateCoverage([0, 0.9999]);
      backgroundImageStage.updateLightWrapping(0);
    }
  }
  function cleanUp() {
    backgroundStage.cleanUp();
    jointBilateralFilterStage.cleanUp();
    loadSegmentationStage.cleanUp();
    resizingStage.cleanUp();
    gl.deleteTexture(personMaskTexture);
    gl.deleteTexture(segmentationTexture);
    gl.deleteTexture(inputFrameTexture);
    gl.deleteBuffer(texCoordBuffer);
    gl.deleteBuffer(positionBuffer);
    gl.deleteVertexArray(vertexArray);
    gl.deleteShader(vertexShader);
  }
  return { render, updatePostProcessingConfig, cleanUp };
}
var SegmentationLevel;
(function(SegmentationLevel2) {
  SegmentationLevel2["LOW"] = "low";
  SegmentationLevel2["HIGH"] = "high";
})(SegmentationLevel || (SegmentationLevel = {}));
var getSegmentationParams = (level2) => {
  if (level2 === SegmentationLevel.HIGH) {
    return { width: 256, height: 144 };
  }
  return { width: 160, height: 96 };
};
function createRenderer(tflite, videoSource, targetCanvas, options, onError) {
  const { backgroundFilter, backgroundImage, backgroundBlurLevel, segmentationLevel = SegmentationLevel.HIGH, fps = 30 } = options;
  if (backgroundFilter === "image" && !backgroundImage) {
    throw new Error(`backgroundImage element is required when backgroundFilter is image`);
  }
  const pipeline = buildWebGL2Pipeline(videoSource, backgroundImage, backgroundBlurLevel, backgroundFilter, targetCanvas, tflite, getSegmentationParams(segmentationLevel));
  const id = setInterval(() => {
    try {
      pipeline.render();
      if (backgroundFilter === "image") {
        pipeline.updatePostProcessingConfig();
      }
    } catch (error2) {
      onError == null ? void 0 : onError(error2);
    }
  }, 1e3 / (fps <= 0 ? 30 : fps));
  return {
    dispose: () => {
      pipeline.cleanUp();
      clearInterval(id);
    }
  };
}
var createTFLiteSIMDModule = (__Module) => {
  __Module = __Module || {};
  var _scriptDir = typeof document !== "undefined" && document.currentScript ? document.currentScript.src : void 0;
  var Module = typeof __Module != "undefined" ? __Module : {};
  var readyPromiseResolve, readyPromiseReject;
  Module["ready"] = new Promise(function(resolve, reject) {
    readyPromiseResolve = resolve;
    readyPromiseReject = reject;
  });
  var moduleOverrides = Object.assign({}, Module);
  var thisProgram = "./this.program";
  var quit_ = (status, toThrow) => {
    throw toThrow;
  };
  var ENVIRONMENT_IS_WEB = true;
  var scriptDirectory = "";
  function locateFile(path) {
    if (Module["locateFile"]) {
      return Module["locateFile"](path, scriptDirectory);
    }
    return scriptDirectory + path;
  }
  var readBinary;
  {
    if (typeof document != "undefined" && document.currentScript) {
      scriptDirectory = document.currentScript.src;
    }
    if (_scriptDir) {
      scriptDirectory = _scriptDir;
    }
    if (scriptDirectory.indexOf("blob:") !== 0) {
      scriptDirectory = scriptDirectory.substr(
        0,
        scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1
      );
    } else {
      scriptDirectory = "";
    }
  }
  var out = Module["print"] || console.log.bind(console);
  var err = Module["printErr"] || console.warn.bind(console);
  Object.assign(Module, moduleOverrides);
  moduleOverrides = null;
  if (Module["arguments"]) Module["arguments"];
  if (Module["thisProgram"]) thisProgram = Module["thisProgram"];
  if (Module["quit"]) quit_ = Module["quit"];
  var wasmBinary;
  if (Module["wasmBinary"]) wasmBinary = Module["wasmBinary"];
  Module["noExitRuntime"] || true;
  if (typeof WebAssembly != "object") {
    abort("no native wasm support detected");
  }
  var wasmMemory;
  var ABORT = false;
  var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0;
  function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead) {
    var endIdx = idx + maxBytesToRead;
    var endPtr = idx;
    while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;
    if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
      return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
    }
    var str = "";
    while (idx < endPtr) {
      var u0 = heapOrArray[idx++];
      if (!(u0 & 128)) {
        str += String.fromCharCode(u0);
        continue;
      }
      var u1 = heapOrArray[idx++] & 63;
      if ((u0 & 224) == 192) {
        str += String.fromCharCode((u0 & 31) << 6 | u1);
        continue;
      }
      var u2 = heapOrArray[idx++] & 63;
      if ((u0 & 240) == 224) {
        u0 = (u0 & 15) << 12 | u1 << 6 | u2;
      } else {
        u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
      }
      if (u0 < 65536) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 65536;
        str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
      }
    }
    return str;
  }
  var buffer2, HEAP8, HEAPU8, HEAPU32;
  function updateGlobalBufferAndViews(buf) {
    buffer2 = buf;
    Module["HEAP8"] = HEAP8 = new Int8Array(buf);
    Module["HEAP16"] = new Int16Array(buf);
    Module["HEAP32"] = new Int32Array(buf);
    Module["HEAPU8"] = HEAPU8 = new Uint8Array(buf);
    Module["HEAPU16"] = new Uint16Array(buf);
    Module["HEAPU32"] = HEAPU32 = new Uint32Array(buf);
    Module["HEAPF32"] = new Float32Array(buf);
    Module["HEAPF64"] = new Float64Array(buf);
  }
  Module["INITIAL_MEMORY"] || 16777216;
  var __ATPRERUN__ = [];
  var __ATINIT__ = [];
  var __ATPOSTRUN__ = [];
  function preRun() {
    if (Module["preRun"]) {
      if (typeof Module["preRun"] == "function")
        Module["preRun"] = [Module["preRun"]];
      while (Module["preRun"].length) {
        addOnPreRun(Module["preRun"].shift());
      }
    }
    callRuntimeCallbacks(__ATPRERUN__);
  }
  function initRuntime() {
    callRuntimeCallbacks(__ATINIT__);
  }
  function postRun() {
    if (Module["postRun"]) {
      if (typeof Module["postRun"] == "function")
        Module["postRun"] = [Module["postRun"]];
      while (Module["postRun"].length) {
        addOnPostRun(Module["postRun"].shift());
      }
    }
    callRuntimeCallbacks(__ATPOSTRUN__);
  }
  function addOnPreRun(cb) {
    __ATPRERUN__.unshift(cb);
  }
  function addOnInit(cb) {
    __ATINIT__.unshift(cb);
  }
  function addOnPostRun(cb) {
    __ATPOSTRUN__.unshift(cb);
  }
  var runDependencies = 0;
  var dependenciesFulfilled = null;
  function addRunDependency(id) {
    runDependencies++;
    if (Module["monitorRunDependencies"]) {
      Module["monitorRunDependencies"](runDependencies);
    }
  }
  function removeRunDependency(id) {
    runDependencies--;
    if (Module["monitorRunDependencies"]) {
      Module["monitorRunDependencies"](runDependencies);
    }
    if (runDependencies == 0) {
      if (dependenciesFulfilled) {
        var callback = dependenciesFulfilled;
        dependenciesFulfilled = null;
        callback();
      }
    }
  }
  function abort(what) {
    {
      if (Module["onAbort"]) {
        Module["onAbort"](what);
      }
    }
    what = "Aborted(" + what + ")";
    err(what);
    ABORT = true;
    what += ". Build with -sASSERTIONS for more info.";
    var e = new WebAssembly.RuntimeError(what);
    readyPromiseReject(e);
    throw e;
  }
  var dataURIPrefix = "data:application/octet-stream;base64,";
  function isDataURI(filename) {
    return filename.startsWith(dataURIPrefix);
  }
  var wasmBinaryFile;
  wasmBinaryFile = "tflite-simd.wasm";
  if (!isDataURI(wasmBinaryFile)) {
    wasmBinaryFile = locateFile(wasmBinaryFile);
  }
  function getBinary(file) {
    try {
      if (file == wasmBinaryFile && wasmBinary) {
        return new Uint8Array(wasmBinary);
      }
      if (readBinary) ;
      throw "both async and sync fetching of the wasm failed";
    } catch (err2) {
      abort(err2);
    }
  }
  function getBinaryPromise() {
    if (!wasmBinary && ENVIRONMENT_IS_WEB) {
      if (typeof fetch == "function") {
        return fetch(wasmBinaryFile, { credentials: "same-origin" }).then(function(response) {
          if (!response["ok"]) {
            throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
          }
          return response["arrayBuffer"]();
        }).catch(function() {
          return getBinary(wasmBinaryFile);
        });
      }
    }
    return Promise.resolve().then(function() {
      return getBinary(wasmBinaryFile);
    });
  }
  function createWasm() {
    var info = {
      env: asmLibraryArg,
      wasi_snapshot_preview1: asmLibraryArg
    };
    function receiveInstance(instance2, module) {
      var exports2 = instance2.exports;
      Module["asm"] = exports2;
      wasmMemory = Module["asm"]["memory"];
      updateGlobalBufferAndViews(wasmMemory.buffer);
      Module["asm"]["__indirect_function_table"];
      addOnInit(Module["asm"]["__wasm_call_ctors"]);
      removeRunDependency();
    }
    addRunDependency();
    function receiveInstantiationResult(result) {
      receiveInstance(result["instance"]);
    }
    function instantiateArrayBuffer(receiver) {
      return getBinaryPromise().then(function(binary) {
        return WebAssembly.instantiate(binary, info);
      }).then(function(instance2) {
        return instance2;
      }).then(receiver, function(reason) {
        err("failed to asynchronously prepare wasm: " + reason);
        abort(reason);
      });
    }
    function instantiateAsync() {
      if (!wasmBinary && typeof WebAssembly.instantiateStreaming == "function" && !isDataURI(wasmBinaryFile) && typeof fetch == "function") {
        return fetch(wasmBinaryFile, { credentials: "same-origin" }).then(
          function(response) {
            var result = WebAssembly.instantiateStreaming(response, info);
            return result.then(receiveInstantiationResult, function(reason) {
              err("wasm streaming compile failed: " + reason);
              err("falling back to ArrayBuffer instantiation");
              return instantiateArrayBuffer(receiveInstantiationResult);
            });
          }
        );
      } else {
        return instantiateArrayBuffer(receiveInstantiationResult);
      }
    }
    if (Module["instantiateWasm"]) {
      try {
        var exports = Module["instantiateWasm"](info, receiveInstance);
        return exports;
      } catch (e) {
        err("Module.instantiateWasm callback failed with error: " + e);
        readyPromiseReject(e);
      }
    }
    instantiateAsync().catch(readyPromiseReject);
    return {};
  }
  function ExitStatus(status) {
    this.name = "ExitStatus";
    this.message = "Program terminated with exit(" + status + ")";
    this.status = status;
  }
  function callRuntimeCallbacks(callbacks) {
    while (callbacks.length > 0) {
      callbacks.shift()(Module);
    }
  }
  function __dlinit(main_dso_handle) {
  }
  var dlopenMissingError = "To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking";
  function __dlopen_js(filename, flag) {
    abort(dlopenMissingError);
  }
  function __dlsym_js(handle, symbol) {
    abort(dlopenMissingError);
  }
  var nowIsMonotonic = true;
  function __emscripten_get_now_is_monotonic() {
    return nowIsMonotonic;
  }
  function __mmap_js(len, prot, flags, fd, off, allocated) {
    return -52;
  }
  function __munmap_js(addr, len, prot, flags, fd, offset4) {
  }
  function _abort() {
    abort("");
  }
  function _emscripten_date_now() {
    return Date.now();
  }
  function getHeapMax() {
    return 2147483648;
  }
  function _emscripten_get_heap_max() {
    return getHeapMax();
  }
  var _emscripten_get_now;
  _emscripten_get_now = () => performance.now();
  function _emscripten_memcpy_big(dest, src, num) {
    HEAPU8.copyWithin(dest, src, src + num);
  }
  function emscripten_realloc_buffer(size4) {
    try {
      wasmMemory.grow(size4 - buffer2.byteLength + 65535 >>> 16);
      updateGlobalBufferAndViews(wasmMemory.buffer);
      return 1;
    } catch (e) {
    }
  }
  function _emscripten_resize_heap(requestedSize) {
    var oldSize = HEAPU8.length;
    requestedSize = requestedSize >>> 0;
    var maxHeapSize = getHeapMax();
    if (requestedSize > maxHeapSize) {
      return false;
    }
    let alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;
    for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
      var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
      overGrownHeapSize = Math.min(
        overGrownHeapSize,
        requestedSize + 100663296
      );
      var newSize = Math.min(
        maxHeapSize,
        alignUp(Math.max(requestedSize, overGrownHeapSize), 65536)
      );
      var replacement = emscripten_realloc_buffer(newSize);
      if (replacement) {
        return true;
      }
    }
    return false;
  }
  var ENV = {};
  function getExecutableName() {
    return thisProgram || "./this.program";
  }
  function getEnvStrings() {
    if (!getEnvStrings.strings) {
      var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
      var env = {
        USER: "web_user",
        LOGNAME: "web_user",
        PATH: "/",
        PWD: "/",
        HOME: "/home/web_user",
        LANG: lang,
        _: getExecutableName()
      };
      for (var x in ENV) {
        if (ENV[x] === void 0) delete env[x];
        else env[x] = ENV[x];
      }
      var strings = [];
      for (var x in env) {
        strings.push(x + "=" + env[x]);
      }
      getEnvStrings.strings = strings;
    }
    return getEnvStrings.strings;
  }
  function writeAsciiToMemory(str, buffer3, dontAddNull) {
    for (var i = 0; i < str.length; ++i) {
      HEAP8[buffer3++ >> 0] = str.charCodeAt(i);
    }
    HEAP8[buffer3 >> 0] = 0;
  }
  function _environ_get(__environ, environ_buf) {
    var bufSize = 0;
    getEnvStrings().forEach(function(string, i) {
      var ptr = environ_buf + bufSize;
      HEAPU32[__environ + i * 4 >> 2] = ptr;
      writeAsciiToMemory(string, ptr);
      bufSize += string.length + 1;
    });
    return 0;
  }
  function _environ_sizes_get(penviron_count, penviron_buf_size) {
    var strings = getEnvStrings();
    HEAPU32[penviron_count >> 2] = strings.length;
    var bufSize = 0;
    strings.forEach(function(string) {
      bufSize += string.length + 1;
    });
    HEAPU32[penviron_buf_size >> 2] = bufSize;
    return 0;
  }
  function _proc_exit(code) {
    quit_(code, new ExitStatus(code));
  }
  function exitJS(status, implicit) {
    _proc_exit(status);
  }
  var _exit = exitJS;
  function _fd_close(fd) {
    return 52;
  }
  function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
    return 70;
  }
  var printCharBuffers = [null, [], []];
  function printChar(stream, curr) {
    var buffer3 = printCharBuffers[stream];
    if (curr === 0 || curr === 10) {
      (stream === 1 ? out : err)(UTF8ArrayToString(buffer3, 0));
      buffer3.length = 0;
    } else {
      buffer3.push(curr);
    }
  }
  function _fd_write(fd, iov, iovcnt, pnum) {
    var num = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      for (var j = 0; j < len; j++) {
        printChar(fd, HEAPU8[ptr + j]);
      }
      num += len;
    }
    HEAPU32[pnum >> 2] = num;
    return 0;
  }
  function getRandomDevice() {
    if (typeof crypto == "object" && typeof crypto["getRandomValues"] == "function") {
      var randomBuffer = new Uint8Array(1);
      return () => {
        crypto.getRandomValues(randomBuffer);
        return randomBuffer[0];
      };
    } else return () => abort("randomDevice");
  }
  function _getentropy(buffer3, size4) {
    if (!_getentropy.randomDevice) {
      _getentropy.randomDevice = getRandomDevice();
    }
    for (var i = 0; i < size4; i++) {
      HEAP8[buffer3 + i >> 0] = _getentropy.randomDevice();
    }
    return 0;
  }
  var asmLibraryArg = {
    _dlinit: __dlinit,
    _dlopen_js: __dlopen_js,
    _dlsym_js: __dlsym_js,
    _emscripten_get_now_is_monotonic: __emscripten_get_now_is_monotonic,
    _mmap_js: __mmap_js,
    _munmap_js: __munmap_js,
    abort: _abort,
    emscripten_date_now: _emscripten_date_now,
    emscripten_get_heap_max: _emscripten_get_heap_max,
    emscripten_get_now: _emscripten_get_now,
    emscripten_memcpy_big: _emscripten_memcpy_big,
    emscripten_resize_heap: _emscripten_resize_heap,
    environ_get: _environ_get,
    environ_sizes_get: _environ_sizes_get,
    exit: _exit,
    fd_close: _fd_close,
    fd_seek: _fd_seek,
    fd_write: _fd_write,
    getentropy: _getentropy
  };
  createWasm();
  Module["___wasm_call_ctors"] = function() {
    return (Module["___wasm_call_ctors"] = Module["asm"]["__wasm_call_ctors"]).apply(null, arguments);
  };
  Module["_getModelBufferMemoryOffset"] = function() {
    return (Module["_getModelBufferMemoryOffset"] = Module["asm"]["getModelBufferMemoryOffset"]).apply(null, arguments);
  };
  Module["_getInputMemoryOffset"] = function() {
    return (Module["_getInputMemoryOffset"] = Module["asm"]["getInputMemoryOffset"]).apply(null, arguments);
  };
  Module["_getInputHeight"] = function() {
    return (Module["_getInputHeight"] = Module["asm"]["getInputHeight"]).apply(null, arguments);
  };
  Module["_getInputWidth"] = function() {
    return (Module["_getInputWidth"] = Module["asm"]["getInputWidth"]).apply(null, arguments);
  };
  Module["_getInputChannelCount"] = function() {
    return (Module["_getInputChannelCount"] = Module["asm"]["getInputChannelCount"]).apply(null, arguments);
  };
  Module["_getOutputMemoryOffset"] = function() {
    return (Module["_getOutputMemoryOffset"] = Module["asm"]["getOutputMemoryOffset"]).apply(null, arguments);
  };
  Module["_getOutputHeight"] = function() {
    return (Module["_getOutputHeight"] = Module["asm"]["getOutputHeight"]).apply(null, arguments);
  };
  Module["_getOutputWidth"] = function() {
    return (Module["_getOutputWidth"] = Module["asm"]["getOutputWidth"]).apply(null, arguments);
  };
  Module["_getOutputChannelCount"] = function() {
    return (Module["_getOutputChannelCount"] = Module["asm"]["getOutputChannelCount"]).apply(null, arguments);
  };
  Module["_loadModel"] = function() {
    return (Module["_loadModel"] = Module["asm"]["loadModel"]).apply(null, arguments);
  };
  Module["_runInference"] = function() {
    return (Module["_runInference"] = Module["asm"]["runInference"]).apply(null, arguments);
  };
  Module["_malloc"] = function() {
    return (Module["_malloc"] = Module["asm"]["malloc"]).apply(
      null,
      arguments
    );
  };
  Module["___errno_location"] = function() {
    return (Module["___errno_location"] = Module["asm"]["__errno_location"]).apply(null, arguments);
  };
  Module["___dl_seterr"] = function() {
    return (Module["___dl_seterr"] = Module["asm"]["__dl_seterr"]).apply(null, arguments);
  };
  Module["stackSave"] = function() {
    return (Module["stackSave"] = Module["asm"]["stackSave"]).apply(
      null,
      arguments
    );
  };
  Module["stackRestore"] = function() {
    return (Module["stackRestore"] = Module["asm"]["stackRestore"]).apply(null, arguments);
  };
  Module["stackAlloc"] = function() {
    return (Module["stackAlloc"] = Module["asm"]["stackAlloc"]).apply(null, arguments);
  };
  Module["dynCall_jjj"] = function() {
    return (Module["dynCall_jjj"] = Module["asm"]["dynCall_jjj"]).apply(null, arguments);
  };
  Module["dynCall_jiii"] = function() {
    return (Module["dynCall_jiii"] = Module["asm"]["dynCall_jiii"]).apply(null, arguments);
  };
  Module["dynCall_iiiijj"] = function() {
    return (Module["dynCall_iiiijj"] = Module["asm"]["dynCall_iiiijj"]).apply(null, arguments);
  };
  Module["dynCall_viijj"] = function() {
    return (Module["dynCall_viijj"] = Module["asm"]["dynCall_viijj"]).apply(null, arguments);
  };
  Module["dynCall_viiijjj"] = function() {
    return (Module["dynCall_viiijjj"] = Module["asm"]["dynCall_viiijjj"]).apply(null, arguments);
  };
  Module["dynCall_iijjiiii"] = function() {
    return (Module["dynCall_iijjiiii"] = Module["asm"]["dynCall_iijjiiii"]).apply(null, arguments);
  };
  Module["dynCall_jiji"] = function() {
    return (Module["dynCall_jiji"] = Module["asm"]["dynCall_jiji"]).apply(null, arguments);
  };
  var calledRun;
  dependenciesFulfilled = function runCaller() {
    if (!calledRun) run();
    if (!calledRun) dependenciesFulfilled = runCaller;
  };
  function run(args) {
    if (runDependencies > 0) {
      return;
    }
    preRun();
    if (runDependencies > 0) {
      return;
    }
    function doRun() {
      if (calledRun) return;
      calledRun = true;
      Module["calledRun"] = true;
      if (ABORT) return;
      initRuntime();
      readyPromiseResolve(Module);
      if (Module["onRuntimeInitialized"]) Module["onRuntimeInitialized"]();
      postRun();
    }
    if (Module["setStatus"]) {
      Module["setStatus"]("Running...");
      setTimeout(function() {
        setTimeout(function() {
          Module["setStatus"]("");
        }, 1);
        doRun();
      }, 1);
    } else {
      doRun();
    }
  }
  if (Module["preInit"]) {
    if (typeof Module["preInit"] == "function")
      Module["preInit"] = [Module["preInit"]];
    while (Module["preInit"].length > 0) {
      Module["preInit"].pop()();
    }
  }
  run();
  return __Module.ready;
};
var version2 = "0.1.7";
var packageName = "@stream-io/video-filters-web";
var createTFLite = createTFLiteSIMDModule;
var loadTFLite = async (options = {}) => {
  const { basePath = `https://unpkg.com/${packageName}@${version2}/tf`, tfFilePath = `${basePath}/tflite/tflite-simd.wasm`, modelFilePath = `${basePath}/models/segm_full_v679.tflite` } = options;
  const [tfLite, model] = await Promise.all([
    createTFLite({ locateFile: () => tfFilePath }),
    fetchModel(modelFilePath)
  ]);
  const modelBufferOffset = tfLite._getModelBufferMemoryOffset();
  tfLite.HEAPU8.set(new Uint8Array(model), modelBufferOffset);
  tfLite._loadModel(model.byteLength);
  return tfLite;
};
var lastModelFilePath = "";
var modelFileCache;
var fetchModel = async (modelFilePath) => {
  const model = modelFilePath === lastModelFilePath && modelFileCache ? modelFileCache : await fetch(modelFilePath).then((r) => r.arrayBuffer());
  modelFileCache = model;
  lastModelFilePath = modelFilePath;
  return model;
};

// node_modules/@stream-io/video-react-sdk/dist/index.es.js
var Audio = ({ participant, trackType = "audioTrack", ...rest }) => {
  const call = useCall();
  const [audioElement, setAudioElement] = (0, import_react4.useState)(null);
  const { userId, sessionId } = participant;
  (0, import_react4.useEffect)(() => {
    if (!call || !audioElement)
      return;
    const cleanup2 = call.bindAudioElement(audioElement, sessionId, trackType);
    return () => {
      cleanup2 == null ? void 0 : cleanup2();
    };
  }, [call, sessionId, audioElement, trackType]);
  return (0, import_jsx_runtime3.jsx)("audio", { autoPlay: true, ...rest, ref: setAudioElement, "data-user-id": userId, "data-session-id": sessionId, "data-track-type": trackType });
};
Audio.displayName = "Audio";
var ParticipantsAudio = (props) => {
  const { participants, audioProps } = props;
  return (0, import_jsx_runtime3.jsx)(import_jsx_runtime3.Fragment, { children: participants.map((participant) => {
    if (participant.isLocalParticipant)
      return null;
    const { audioStream, screenShareAudioStream, sessionId } = participant;
    const hasAudioTrack = hasAudio(participant);
    const audioTrackElement = hasAudioTrack && audioStream && (0, import_jsx_runtime3.jsx)(Audio, { ...audioProps, trackType: "audioTrack", participant });
    const hasScreenShareAudioTrack = hasScreenShareAudio(participant);
    const screenShareAudioTrackElement = hasScreenShareAudioTrack && screenShareAudioStream && (0, import_jsx_runtime3.jsx)(Audio, { ...audioProps, trackType: "screenShareAudioTrack", participant });
    return (0, import_jsx_runtime3.jsxs)(import_react4.Fragment, { children: [audioTrackElement, screenShareAudioTrackElement] }, sessionId);
  }) });
};
ParticipantsAudio.displayName = "ParticipantsAudio";
var ParticipantViewContext = (0, import_react4.createContext)(void 0);
var useParticipantViewContext = () => (0, import_react4.useContext)(ParticipantViewContext);
var useFloatingUIPreset = ({ middleware = [], placement, strategy, offset: offsetInPx = 10 }) => {
  const { refs, x, y, update, elements: { domReference, floating }, context: context2 } = useFloating2({
    placement,
    strategy,
    middleware: [
      offset3(offsetInPx),
      shift3(),
      flip3(),
      size3({
        padding: 10,
        apply: ({ availableHeight, elements }) => {
          Object.assign(elements.floating.style, {
            maxHeight: `${availableHeight}px`
          });
        }
      }),
      ...middleware
    ]
  });
  (0, import_react4.useEffect)(() => {
    if (!domReference || !floating)
      return;
    const cleanup2 = autoUpdate(domReference, floating, update);
    return () => cleanup2();
  }, [domReference, floating, update]);
  return { refs, x, y, domReference, floating, strategy, context: context2 };
};
var defaultDevice = "default";
var usePersistedDevicePreferences = (key = "@stream-io/device-preferences") => {
  const { useCallSettings: useCallSettings2, useCameraState: useCameraState2, useMicrophoneState: useMicrophoneState2, useSpeakerState: useSpeakerState2 } = useCallStateHooks();
  const settings = useCallSettings2();
  usePersistedDevicePreference(key, "camera", useCameraState2(), settings ? !settings.video.camera_default_on : void 0);
  usePersistedDevicePreference(key, "microphone", useMicrophoneState2(), settings ? !settings.audio.mic_default_on : void 0);
  usePersistedDevicePreference(key, "speaker", useSpeakerState2(), false);
};
var usePersistedDevicePreference = (key, deviceKey, state, defaultMuted) => {
  const { useCallCallingState: useCallCallingState2 } = useCallStateHooks();
  const callingState = useCallCallingState2();
  const [applyingState, setApplyingState] = (0, import_react4.useState)("idle");
  const manager = state[deviceKey];
  (0, import_react4.useEffect)(function apply() {
    var _a;
    if (callingState === CallingState.LEFT || !((_a = state.devices) == null ? void 0 : _a.length) || typeof defaultMuted !== "boolean" || applyingState !== "idle") {
      return;
    }
    const preferences = parseLocalDevicePreferences(key);
    const preference = preferences[deviceKey];
    setApplyingState("applying");
    if (!manager.state.selectedDevice) {
      const applyPromise = preference ? applyLocalDevicePreference(manager, [preference].flat(), state.devices) : applyMutedState(manager, defaultMuted);
      applyPromise.catch((err) => {
        console.warn(`Failed to apply ${deviceKey} device preferences`, err);
      }).finally(() => setApplyingState("applied"));
    } else {
      setApplyingState("applied");
    }
  }, [
    applyingState,
    callingState,
    defaultMuted,
    deviceKey,
    key,
    manager,
    state.devices
  ]);
  (0, import_react4.useEffect)(function persist() {
    var _a;
    if (callingState === CallingState.LEFT || !((_a = state.devices) == null ? void 0 : _a.length) || applyingState !== "applied") {
      return;
    }
    try {
      patchLocalDevicePreference(key, deviceKey, {
        devices: state.devices,
        selectedDevice: state.selectedDevice,
        isMute: state.isMute
      });
    } catch (err) {
      console.warn(`Failed to save ${deviceKey} device preferences`, err);
    }
  }, [
    applyingState,
    callingState,
    deviceKey,
    key,
    state.devices,
    state.isMute,
    state.selectedDevice
  ]);
};
var parseLocalDevicePreferences = (key) => {
  const preferencesStr = window.localStorage.getItem(key);
  let preferences = {};
  if (preferencesStr) {
    try {
      preferences = JSON.parse(preferencesStr);
      if (Object.hasOwn(preferences, "mic")) {
        preferences.microphone = preferences.mic;
      }
    } catch {
    }
  }
  return preferences;
};
var patchLocalDevicePreference = (key, deviceKey, state) => {
  const preferences = parseLocalDevicePreferences(key);
  const nextPreference = getSelectedDevicePreference(state.devices, state.selectedDevice);
  const preferenceHistory = [preferences[deviceKey] ?? []].flat().filter((p) => p.selectedDeviceId !== nextPreference.selectedDeviceId && (p.selectedDeviceLabel === "" || p.selectedDeviceLabel !== nextPreference.selectedDeviceLabel));
  window.localStorage.setItem(key, JSON.stringify({
    ...preferences,
    mic: void 0,
    // for backwards compatibility
    [deviceKey]: [
      {
        ...nextPreference,
        muted: state.isMute
      },
      ...preferenceHistory
    ].slice(0, 3)
  }));
};
var applyLocalDevicePreference = async (manager, preference, devices) => {
  let muted;
  for (const p of preference) {
    muted ?? (muted = p.muted);
    if (p.selectedDeviceId === defaultDevice) {
      break;
    }
    const device = devices.find((d) => d.deviceId === p.selectedDeviceId) ?? devices.find((d) => d.label === p.selectedDeviceLabel);
    if (device) {
      await manager.select(device.deviceId);
      muted = p.muted;
      break;
    }
  }
  if (typeof muted === "boolean") {
    await applyMutedState(manager, muted);
  }
};
var applyMutedState = async (manager, muted) => {
  var _a;
  await ((_a = manager[muted ? "disable" : "enable"]) == null ? void 0 : _a.call(manager));
};
var getSelectedDevicePreference = (devices, selectedDevice) => {
  var _a;
  return {
    selectedDeviceId: selectedDevice || defaultDevice,
    selectedDeviceLabel: ((_a = devices == null ? void 0 : devices.find((d) => d.deviceId === selectedDevice)) == null ? void 0 : _a.label) ?? ""
  };
};
var SCROLL_THRESHOLD = 10;
var useVerticalScrollPosition = (scrollElement, threshold = SCROLL_THRESHOLD) => {
  const [scrollPosition, setScrollPosition] = (0, import_react4.useState)(null);
  (0, import_react4.useEffect)(() => {
    if (!scrollElement)
      return;
    const scrollHandler = () => {
      const element = scrollElement;
      const hasVerticalScrollbar = element.scrollHeight > element.clientHeight;
      if (!hasVerticalScrollbar)
        return setScrollPosition(null);
      const isAtTheTop = element.scrollTop <= threshold;
      if (isAtTheTop)
        return setScrollPosition("top");
      const isAtTheBottom = Math.abs(element.scrollHeight - element.scrollTop - element.clientHeight) <= threshold;
      if (isAtTheBottom)
        return setScrollPosition("bottom");
      setScrollPosition("between");
    };
    const resizeObserver = new ResizeObserver(scrollHandler);
    resizeObserver.observe(scrollElement);
    scrollElement.addEventListener("scroll", scrollHandler);
    return () => {
      scrollElement.removeEventListener("scroll", scrollHandler);
      resizeObserver.disconnect();
    };
  }, [scrollElement, threshold]);
  return scrollPosition;
};
var useHorizontalScrollPosition = (scrollElement, threshold = SCROLL_THRESHOLD) => {
  const [scrollPosition, setScrollPosition] = (0, import_react4.useState)(null);
  (0, import_react4.useEffect)(() => {
    if (!scrollElement)
      return;
    const scrollHandler = () => {
      const element = scrollElement;
      const hasHorizontalScrollbar = element.scrollWidth > element.clientWidth;
      if (!hasHorizontalScrollbar)
        return setScrollPosition(null);
      const isAtTheStart = element.scrollLeft <= threshold;
      if (isAtTheStart)
        return setScrollPosition("start");
      const isAtTheEnd = Math.abs(element.scrollWidth - element.scrollLeft - element.clientWidth) <= threshold;
      if (isAtTheEnd)
        return setScrollPosition("end");
      setScrollPosition("between");
    };
    const resizeObserver = new ResizeObserver(scrollHandler);
    resizeObserver.observe(scrollElement);
    scrollElement.addEventListener("scroll", scrollHandler);
    return () => {
      scrollElement.removeEventListener("scroll", scrollHandler);
      resizeObserver.disconnect();
    };
  }, [scrollElement, threshold]);
  return scrollPosition;
};
var useRequestPermission = (permission) => {
  const call = useCall();
  const { useHasPermissions: useHasPermissions2 } = useCallStateHooks();
  const hasPermission = useHasPermissions2(permission);
  const [isAwaitingPermission, setIsAwaitingPermission] = (0, import_react4.useState)(false);
  (0, import_react4.useEffect)(() => {
    const reset = () => setIsAwaitingPermission(false);
    if (hasPermission)
      reset();
  }, [hasPermission]);
  const requestPermission = (0, import_react4.useCallback)(async () => {
    if (hasPermission)
      return true;
    const canRequestPermission = !!(call == null ? void 0 : call.permissionsContext.canRequest(permission));
    if (isAwaitingPermission || !canRequestPermission)
      return false;
    setIsAwaitingPermission(true);
    try {
      await (call == null ? void 0 : call.requestPermissions({
        permissions: [permission]
      }));
    } catch (error2) {
      setIsAwaitingPermission(false);
      throw new Error(`requestPermission failed: ${error2}`);
    }
    return false;
  }, [call, hasPermission, isAwaitingPermission, permission]);
  return {
    requestPermission,
    hasPermission,
    canRequestPermission: !!(call == null ? void 0 : call.permissionsContext.canRequest(permission)),
    isAwaitingPermission
  };
};
function useDeviceList(devices, selectedDeviceId) {
  const { t: t2 } = useI18n();
  return (0, import_react4.useMemo)(() => {
    let selectedDeviceInfo = null;
    let selectedIndex = null;
    const deviceList = devices.map((d, i) => {
      const isSelected = d.deviceId === selectedDeviceId;
      const device = { deviceId: d.deviceId, label: d.label, isSelected };
      if (isSelected) {
        selectedDeviceInfo = device;
        selectedIndex = i;
      }
      return device;
    });
    if (selectedDeviceInfo === null || selectedIndex === null) {
      const defaultDevice2 = {
        deviceId: "default",
        label: t2("Default"),
        isSelected: true
      };
      selectedDeviceInfo = defaultDevice2;
      selectedIndex = 0;
      deviceList.unshift(defaultDevice2);
    }
    return { deviceList, selectedDeviceInfo, selectedIndex };
  }, [devices, selectedDeviceId, t2]);
}
var MenuVisualType;
(function(MenuVisualType2) {
  MenuVisualType2["PORTAL"] = "portal";
  MenuVisualType2["MENU"] = "menu";
})(MenuVisualType || (MenuVisualType = {}));
var MenuContext = (0, import_react4.createContext)({});
var useMenuContext = () => {
  return (0, import_react4.useContext)(MenuContext);
};
var MenuPortal = ({ children, refs }) => {
  const portalId = (0, import_react4.useMemo)(() => `str-video-portal-${Math.random().toString(36).substring(2, 9)}`, []);
  return (0, import_jsx_runtime3.jsxs)(import_jsx_runtime3.Fragment, { children: [(0, import_jsx_runtime3.jsx)("div", { id: portalId, className: "str-video__portal" }), (0, import_jsx_runtime3.jsx)(FloatingOverlay, { children: (0, import_jsx_runtime3.jsx)(FloatingPortal, { id: portalId, children: (0, import_jsx_runtime3.jsx)("div", { className: "str-video__portal-content", ref: refs.setFloating, children }) }) })] });
};
var MenuToggle = ({ ToggleButton: ToggleButton5, placement = "top-start", strategy = "absolute", offset: offset4, visualType = MenuVisualType.MENU, children, onToggle }) => {
  const [menuShown, setMenuShown] = (0, import_react4.useState)(false);
  const toggleHandler = (0, import_react4.useRef)(onToggle);
  toggleHandler.current = onToggle;
  const { floating, domReference, refs, x, y } = useFloatingUIPreset({
    placement,
    strategy,
    offset: offset4
  });
  (0, import_react4.useEffect)(() => {
    const parentDocument = domReference == null ? void 0 : domReference.ownerDocument;
    const handleClick = (event) => {
      var _a, _b;
      if (!floating && (domReference == null ? void 0 : domReference.contains(event.target))) {
        setMenuShown(true);
        (_a = toggleHandler.current) == null ? void 0 : _a.call(toggleHandler, true);
      } else if (floating && !(floating == null ? void 0 : floating.contains(event.target))) {
        setMenuShown(false);
        (_b = toggleHandler.current) == null ? void 0 : _b.call(toggleHandler, false);
      }
    };
    const handleKeyDown = (event) => {
      var _a;
      if (event.key && // key can be undefined in some browsers
      event.key.toLowerCase() === "escape" && !event.altKey && !event.ctrlKey) {
        setMenuShown(false);
        (_a = toggleHandler.current) == null ? void 0 : _a.call(toggleHandler, false);
      }
    };
    parentDocument == null ? void 0 : parentDocument.addEventListener("click", handleClick, { capture: true });
    parentDocument == null ? void 0 : parentDocument.addEventListener("keydown", handleKeyDown);
    return () => {
      parentDocument == null ? void 0 : parentDocument.removeEventListener("click", handleClick, {
        capture: true
      });
      parentDocument == null ? void 0 : parentDocument.removeEventListener("keydown", handleKeyDown);
    };
  }, [floating, domReference]);
  return (0, import_jsx_runtime3.jsxs)(import_jsx_runtime3.Fragment, { children: [menuShown && (0, import_jsx_runtime3.jsx)(MenuContext.Provider, { value: { close: () => setMenuShown(false) }, children: visualType === MenuVisualType.PORTAL ? (0, import_jsx_runtime3.jsx)(MenuPortal, { refs, children }) : visualType === MenuVisualType.MENU ? (0, import_jsx_runtime3.jsx)("div", { className: "str-video__menu-container", ref: refs.setFloating, style: {
    position: strategy,
    top: y ?? 0,
    left: x ?? 0,
    overflowY: "auto"
  }, role: "menu", children }) : null }), (0, import_jsx_runtime3.jsx)(ToggleButton5, { menuShown, ref: refs.setReference })] });
};
var GenericMenu = ({ children, onItemClick }) => {
  const ref = (0, import_react4.useRef)(null);
  return (0, import_jsx_runtime3.jsx)("ul", { className: "str-video__generic-menu", ref, onClick: (e) => {
    var _a;
    if (onItemClick && e.target !== ref.current && ((_a = ref.current) == null ? void 0 : _a.contains(e.target))) {
      onItemClick(e);
    }
  }, children });
};
var GenericMenuButtonItem = ({ children, ...rest }) => {
  return (0, import_jsx_runtime3.jsx)("li", { className: "str-video__generic-menu--item", children: (0, import_jsx_runtime3.jsx)("button", { ...rest, children }) });
};
var Icon = ({ className, icon }) => (0, import_jsx_runtime3.jsx)("span", { className: clsx_default("str-video__icon", icon && `str-video__icon--${icon}`, className) });
function usePictureInPictureState(videoElement) {
  const [isPiP, setIsPiP] = (0, import_react4.useState)(document.pictureInPictureElement === videoElement);
  if (!videoElement && isPiP)
    setIsPiP(false);
  (0, import_react4.useEffect)(() => {
    if (!videoElement)
      return;
    const handlePiP = () => {
      setIsPiP(document.pictureInPictureElement === videoElement);
    };
    videoElement.addEventListener("enterpictureinpicture", handlePiP);
    videoElement.addEventListener("leavepictureinpicture", handlePiP);
    return () => {
      videoElement.removeEventListener("enterpictureinpicture", handlePiP);
      videoElement.removeEventListener("leavepictureinpicture", handlePiP);
    };
  }, [videoElement]);
  return isPiP;
}
var ParticipantActionsContextMenu = () => {
  const { participant, participantViewElement, videoElement } = useParticipantViewContext();
  const [fullscreenModeOn, setFullscreenModeOn] = (0, import_react4.useState)(!!document.fullscreenElement);
  const call = useCall();
  const isPiP = usePictureInPictureState(videoElement ?? void 0);
  const { t: t2 } = useI18n();
  const { pin, sessionId, userId } = participant;
  const hasAudioTrack = hasAudio(participant);
  const hasVideoTrack = hasVideo(participant);
  const hasScreenShareTrack = hasScreenShare(participant);
  const hasScreenShareAudioTrack = hasScreenShareAudio(participant);
  const blockUser = () => call == null ? void 0 : call.blockUser(userId);
  const muteAudio = () => call == null ? void 0 : call.muteUser(userId, "audio");
  const muteVideo = () => call == null ? void 0 : call.muteUser(userId, "video");
  const muteScreenShare = () => call == null ? void 0 : call.muteUser(userId, "screenshare");
  const muteScreenShareAudio = () => call == null ? void 0 : call.muteUser(userId, "screenshare_audio");
  const grantPermission = (permission) => () => {
    call == null ? void 0 : call.updateUserPermissions({
      user_id: userId,
      grant_permissions: [permission]
    });
  };
  const revokePermission = (permission) => () => {
    call == null ? void 0 : call.updateUserPermissions({
      user_id: userId,
      revoke_permissions: [permission]
    });
  };
  const toggleParticipantPin = () => {
    if (pin) {
      call == null ? void 0 : call.unpin(sessionId);
    } else {
      call == null ? void 0 : call.pin(sessionId);
    }
  };
  const pinForEveryone = () => {
    call == null ? void 0 : call.pinForEveryone({
      user_id: userId,
      session_id: sessionId
    }).catch((err) => {
      console.error(`Failed to pin participant ${userId}`, err);
    });
  };
  const unpinForEveryone = () => {
    call == null ? void 0 : call.unpinForEveryone({
      user_id: userId,
      session_id: sessionId
    }).catch((err) => {
      console.error(`Failed to unpin participant ${userId}`, err);
    });
  };
  const toggleFullscreenMode = () => {
    if (!fullscreenModeOn) {
      return participantViewElement == null ? void 0 : participantViewElement.requestFullscreen().catch(console.error);
    }
    return document.exitFullscreen().catch(console.error);
  };
  (0, import_react4.useEffect)(() => {
    const handleFullscreenChange = () => {
      setFullscreenModeOn(!!document.fullscreenElement);
    };
    document.addEventListener("fullscreenchange", handleFullscreenChange);
    return () => {
      document.removeEventListener("fullscreenchange", handleFullscreenChange);
    };
  }, []);
  const togglePictureInPicture = () => {
    if (videoElement && !isPiP) {
      return videoElement.requestPictureInPicture().catch(console.error);
    }
    return document.exitPictureInPicture().catch(console.error);
  };
  const { close } = useMenuContext() || {};
  return (0, import_jsx_runtime3.jsxs)(GenericMenu, { onItemClick: close, children: [(0, import_jsx_runtime3.jsxs)(GenericMenuButtonItem, { onClick: toggleParticipantPin, disabled: pin && !pin.isLocalPin, children: [(0, import_jsx_runtime3.jsx)(Icon, { icon: "pin" }), pin ? t2("Unpin") : t2("Pin")] }), (0, import_jsx_runtime3.jsxs)(Restricted, { requiredGrants: [OwnCapability.PIN_FOR_EVERYONE], children: [(0, import_jsx_runtime3.jsxs)(GenericMenuButtonItem, { onClick: pinForEveryone, disabled: pin && !pin.isLocalPin, children: [(0, import_jsx_runtime3.jsx)(Icon, { icon: "pin" }), t2("Pin for everyone")] }), (0, import_jsx_runtime3.jsxs)(GenericMenuButtonItem, { onClick: unpinForEveryone, disabled: !pin || pin.isLocalPin, children: [(0, import_jsx_runtime3.jsx)(Icon, { icon: "pin" }), t2("Unpin for everyone")] })] }), (0, import_jsx_runtime3.jsx)(Restricted, { requiredGrants: [OwnCapability.BLOCK_USERS], children: (0, import_jsx_runtime3.jsxs)(GenericMenuButtonItem, { onClick: blockUser, children: [(0, import_jsx_runtime3.jsx)(Icon, { icon: "not-allowed" }), t2("Block")] }) }), (0, import_jsx_runtime3.jsxs)(Restricted, { requiredGrants: [OwnCapability.MUTE_USERS], children: [hasVideoTrack && (0, import_jsx_runtime3.jsxs)(GenericMenuButtonItem, { onClick: muteVideo, children: [(0, import_jsx_runtime3.jsx)(Icon, { icon: "camera-off-outline" }), t2("Turn off video")] }), hasScreenShareTrack && (0, import_jsx_runtime3.jsxs)(GenericMenuButtonItem, { onClick: muteScreenShare, children: [(0, import_jsx_runtime3.jsx)(Icon, { icon: "screen-share-off" }), t2("Turn off screen share")] }), hasAudioTrack && (0, import_jsx_runtime3.jsxs)(GenericMenuButtonItem, { onClick: muteAudio, children: [(0, import_jsx_runtime3.jsx)(Icon, { icon: "no-audio" }), t2("Mute audio")] }), hasScreenShareAudioTrack && (0, import_jsx_runtime3.jsxs)(GenericMenuButtonItem, { onClick: muteScreenShareAudio, children: [(0, import_jsx_runtime3.jsx)(Icon, { icon: "no-audio" }), t2("Mute screen share audio")] })] }), participantViewElement && typeof participantViewElement.requestFullscreen !== "undefined" && (0, import_jsx_runtime3.jsx)(GenericMenuButtonItem, { onClick: toggleFullscreenMode, children: t2("{{ direction }} fullscreen", {
    direction: fullscreenModeOn ? t2("Leave") : t2("Enter")
  }) }), videoElement && document.pictureInPictureEnabled && (0, import_jsx_runtime3.jsx)(GenericMenuButtonItem, { onClick: togglePictureInPicture, children: t2("{{ direction }} picture-in-picture", {
    direction: isPiP ? t2("Leave") : t2("Enter")
  }) }), (0, import_jsx_runtime3.jsxs)(Restricted, { requiredGrants: [OwnCapability.UPDATE_CALL_PERMISSIONS], children: [(0, import_jsx_runtime3.jsx)(GenericMenuButtonItem, { onClick: grantPermission(OwnCapability.SEND_AUDIO), children: t2("Allow audio") }), (0, import_jsx_runtime3.jsx)(GenericMenuButtonItem, { onClick: grantPermission(OwnCapability.SEND_VIDEO), children: t2("Allow video") }), (0, import_jsx_runtime3.jsx)(GenericMenuButtonItem, { onClick: grantPermission(OwnCapability.SCREENSHARE), children: t2("Allow screen sharing") }), (0, import_jsx_runtime3.jsx)(GenericMenuButtonItem, { onClick: revokePermission(OwnCapability.SEND_AUDIO), children: t2("Disable audio") }), (0, import_jsx_runtime3.jsx)(GenericMenuButtonItem, { onClick: revokePermission(OwnCapability.SEND_VIDEO), children: t2("Disable video") }), (0, import_jsx_runtime3.jsx)(GenericMenuButtonItem, { onClick: revokePermission(OwnCapability.SCREENSHARE), children: t2("Disable screen sharing") })] })] });
};
var isComponentType = (elementOrComponent) => {
  return elementOrComponent === null ? false : !(0, import_react4.isValidElement)(elementOrComponent);
};
var chunk = (array, size4) => {
  const chunkCount = Math.ceil(array.length / size4);
  return Array.from({ length: chunkCount }, (_, index3) => array.slice(size4 * index3, size4 * index3 + size4));
};
var applyElementToRef = (ref, element) => {
  if (!ref)
    return;
  if (typeof ref === "function")
    return ref(element);
  ref.current = element;
};
var BaseVideo = (0, import_react4.forwardRef)(function BaseVideo2({ stream, ...rest }, ref) {
  const [videoElement, setVideoElement] = (0, import_react4.useState)(null);
  (0, import_react4.useEffect)(() => {
    if (!videoElement || !stream)
      return;
    if (stream === videoElement.srcObject)
      return;
    videoElement.srcObject = stream;
    if (browsers.isSafari() || browsers.isFirefox()) {
      setTimeout(() => {
        videoElement.srcObject = stream;
        videoElement.play().catch((e) => {
          console.error(`Failed to play stream`, e);
        });
      }, 0);
    }
    return () => {
      videoElement.pause();
      videoElement.srcObject = null;
    };
  }, [stream, videoElement]);
  return (0, import_jsx_runtime3.jsx)("video", { autoPlay: true, playsInline: true, ...rest, ref: (element) => {
    applyElementToRef(ref, element);
    setVideoElement(element);
  } });
});
var BaseVideoPlaceholder = (0, import_react4.forwardRef)(function DefaultVideoPlaceholder({ participant, style, children }, ref) {
  const [error2, setError] = (0, import_react4.useState)(false);
  const name2 = participant.name || participant.userId;
  return (0, import_jsx_runtime3.jsxs)("div", { className: "str-video__video-placeholder", style, ref, children: [(!participant.image || error2) && (name2 ? (0, import_jsx_runtime3.jsx)(InitialsFallback, { name: name2 }) : (0, import_jsx_runtime3.jsx)("div", { className: "str-video__video-placeholder__no-video-label", children })), participant.image && !error2 && (0, import_jsx_runtime3.jsx)("img", { onError: () => setError(true), alt: name2, className: "str-video__video-placeholder__avatar", src: participant.image })] });
});
var InitialsFallback = (props) => {
  const { name: name2 } = props;
  const initials = name2.split(" ").slice(0, 2).map((n) => n[0]).join("");
  return (0, import_jsx_runtime3.jsx)("div", { className: "str-video__video-placeholder__initials-fallback", children: initials });
};
var DefaultVideoPlaceholder2 = (0, import_react4.forwardRef)(function DefaultVideoPlaceholder3(props, ref) {
  const { t: t2 } = useI18n();
  return (0, import_jsx_runtime3.jsx)(BaseVideoPlaceholder, { ref, ...props, children: t2("Video is disabled") });
});
var DefaultPictureInPicturePlaceholder = (0, import_react4.forwardRef)(function DefaultPictureInPicturePlaceholder2(props, ref) {
  const { t: t2 } = useI18n();
  return (0, import_jsx_runtime3.jsx)(BaseVideoPlaceholder, { ref, ...props, children: t2("Video is playing in a popup") });
});
var Video$1 = ({ enabled = true, mirror, trackType, participant, className, VideoPlaceholder = DefaultVideoPlaceholder2, PictureInPicturePlaceholder = DefaultPictureInPicturePlaceholder, refs, ...rest }) => {
  const { sessionId, videoStream, screenShareStream, viewportVisibilityState, isLocalParticipant, userId } = participant;
  const call = useCall();
  const [videoElement, setVideoElement] = (0, import_react4.useState)(null);
  const [isVideoPaused, setIsVideoPaused] = (0, import_react4.useState)(true);
  const [isWideMode, setIsWideMode] = (0, import_react4.useState)(true);
  const isPiP = usePictureInPictureState(videoElement ?? void 0);
  const stream = trackType === "videoTrack" ? videoStream : trackType === "screenShareTrack" ? screenShareStream : void 0;
  (0, import_react4.useLayoutEffect)(() => {
    if (!call || !videoElement || trackType === "none")
      return;
    const cleanup2 = call.bindVideoElement(videoElement, sessionId, trackType);
    return () => {
      cleanup2 == null ? void 0 : cleanup2();
    };
  }, [call, trackType, sessionId, videoElement]);
  (0, import_react4.useEffect)(() => {
    if (!stream || !videoElement)
      return;
    const [track] = stream.getVideoTracks();
    if (!track)
      return;
    const handlePlayPause = () => {
      setIsVideoPaused(videoElement.paused);
      const { width = 0, height = 0 } = track.getSettings();
      setIsWideMode(width >= height);
    };
    setIsVideoPaused(videoElement.paused);
    videoElement.addEventListener("play", handlePlayPause);
    videoElement.addEventListener("pause", handlePlayPause);
    track.addEventListener("unmute", handlePlayPause);
    return () => {
      videoElement.removeEventListener("play", handlePlayPause);
      videoElement.removeEventListener("pause", handlePlayPause);
      track.removeEventListener("unmute", handlePlayPause);
      setIsVideoPaused(true);
    };
  }, [stream, videoElement]);
  if (!call)
    return null;
  const isPublishingTrack = trackType === "videoTrack" ? hasVideo(participant) : trackType === "screenShareTrack" ? hasScreenShare(participant) : false;
  const isInvisible = trackType === "none" || (viewportVisibilityState == null ? void 0 : viewportVisibilityState[trackType]) === VisibilityState.INVISIBLE;
  const hasNoVideoOrInvisible = !enabled || !isPublishingTrack || isInvisible;
  const mirrorVideo = mirror === void 0 ? isLocalParticipant && trackType === "videoTrack" : mirror;
  const isScreenShareTrack = trackType === "screenShareTrack";
  return (0, import_jsx_runtime3.jsxs)(import_jsx_runtime3.Fragment, { children: [!hasNoVideoOrInvisible && (0, import_jsx_runtime3.jsx)("video", { ...rest, className: clsx_default("str-video__video", className, {
    "str-video__video--not-playing": isVideoPaused,
    "str-video__video--tall": !isWideMode,
    "str-video__video--mirror": mirrorVideo,
    "str-video__video--screen-share": isScreenShareTrack
  }), "data-user-id": userId, "data-session-id": sessionId, ref: (element) => {
    var _a;
    setVideoElement(element);
    (_a = refs == null ? void 0 : refs.setVideoElement) == null ? void 0 : _a.call(refs, element);
  } }), isPiP && PictureInPicturePlaceholder && (0, import_jsx_runtime3.jsx)(PictureInPicturePlaceholder, { style: { position: "absolute" }, participant }), (hasNoVideoOrInvisible || isVideoPaused) && VideoPlaceholder && (0, import_jsx_runtime3.jsx)(VideoPlaceholder, { style: { position: "absolute" }, participant, ref: refs == null ? void 0 : refs.setVideoPlaceholderElement })] });
};
Video$1.displayName = "Video";
var useTrackElementVisibility = ({ trackedElement, dynascaleManager: propsDynascaleManager, sessionId, trackType }) => {
  const call = useCall();
  const manager = propsDynascaleManager ?? (call == null ? void 0 : call.dynascaleManager);
  (0, import_react4.useEffect)(() => {
    if (!trackedElement || !manager || !call || trackType === "none")
      return;
    const unobserve = manager.trackElementVisibility(trackedElement, sessionId, trackType);
    return () => {
      unobserve();
    };
  }, [trackedElement, manager, call, sessionId, trackType]);
};
var Avatar = ({ imageSrc, name: name2, style, className, ...rest }) => {
  const [error2, setError] = (0, import_react4.useState)(false);
  return (0, import_jsx_runtime3.jsxs)(import_jsx_runtime3.Fragment, { children: [(!imageSrc || error2) && name2 && (0, import_jsx_runtime3.jsx)(AvatarFallback, { className, style, names: [name2] }), imageSrc && !error2 && (0, import_jsx_runtime3.jsx)("img", { onError: () => setError(true), alt: "avatar", className: clsx_default("str-video__avatar", className), src: imageSrc, style, ...rest })] });
};
var AvatarFallback = ({ className, names, style }) => {
  var _a;
  return (0, import_jsx_runtime3.jsx)("div", { className: clsx_default("str-video__avatar--initials-fallback", className), style, children: (0, import_jsx_runtime3.jsxs)("div", { children: [names[0][0], (_a = names[1]) == null ? void 0 : _a[0]] }) });
};
var BackgroundFiltersContext = (0, import_react4.createContext)(void 0);
var useBackgroundFilters = () => {
  const context2 = (0, import_react4.useContext)(BackgroundFiltersContext);
  if (!context2) {
    throw new Error("useBackgroundFilters must be used within a BackgroundFiltersProvider");
  }
  return context2;
};
var BackgroundFiltersProvider = (props) => {
  const { children, backgroundImages = [], backgroundFilter: bgFilterFromProps = void 0, backgroundImage: bgImageFromProps = void 0, backgroundBlurLevel: bgBlurLevelFromProps = void 0, tfFilePath, modelFilePath, basePath, onError } = props;
  const [backgroundFilter, setBackgroundFilter] = (0, import_react4.useState)(bgFilterFromProps);
  const [backgroundImage, setBackgroundImage] = (0, import_react4.useState)(bgImageFromProps);
  const [backgroundBlurLevel, setBackgroundBlurLevel] = (0, import_react4.useState)(bgBlurLevelFromProps);
  const applyBackgroundImageFilter = (0, import_react4.useCallback)((imageUrl) => {
    setBackgroundFilter("image");
    setBackgroundImage(imageUrl);
  }, []);
  const applyBackgroundBlurFilter = (0, import_react4.useCallback)((blurLevel = "high") => {
    setBackgroundFilter("blur");
    setBackgroundBlurLevel(blurLevel);
  }, []);
  const disableBackgroundFilter = (0, import_react4.useCallback)(() => {
    setBackgroundFilter(void 0);
    setBackgroundImage(void 0);
    setBackgroundBlurLevel(void 0);
  }, []);
  const [isSupported, setIsSupported] = (0, import_react4.useState)(false);
  (0, import_react4.useEffect)(() => {
    isPlatformSupported().then(setIsSupported);
  }, []);
  const [tfLite, setTfLite] = (0, import_react4.useState)();
  (0, import_react4.useEffect)(() => {
    if (!isSupported)
      return;
    loadTFLite({ basePath, modelFilePath, tfFilePath }).then(setTfLite).catch((err) => console.error("Failed to load TFLite", err));
  }, [basePath, isSupported, modelFilePath, tfFilePath]);
  const handleError = (0, import_react4.useCallback)((error2) => {
    getLogger(["filters"])("warn", "Filter encountered an error and will be disabled");
    disableBackgroundFilter();
    onError == null ? void 0 : onError(error2);
  }, [disableBackgroundFilter, onError]);
  return (0, import_jsx_runtime3.jsxs)(BackgroundFiltersContext.Provider, { value: {
    isSupported,
    isReady: !!tfLite,
    backgroundImage,
    backgroundBlurLevel,
    backgroundFilter,
    disableBackgroundFilter,
    applyBackgroundBlurFilter,
    applyBackgroundImageFilter,
    backgroundImages,
    tfFilePath,
    modelFilePath,
    basePath,
    onError: handleError
  }, children: [children, tfLite && (0, import_jsx_runtime3.jsx)(BackgroundFilters, { tfLite })] });
};
var BackgroundFilters = (props) => {
  const call = useCall();
  const { children, start } = useRenderer(props.tfLite);
  const { backgroundFilter, onError } = useBackgroundFilters();
  const handleErrorRef = (0, import_react4.useRef)(void 0);
  handleErrorRef.current = onError;
  (0, import_react4.useEffect)(() => {
    if (!call || !backgroundFilter)
      return;
    const { unregister } = call.camera.registerFilter((ms) => start(ms, (error2) => {
      var _a;
      return (_a = handleErrorRef.current) == null ? void 0 : _a.call(handleErrorRef, error2);
    }));
    return () => {
      unregister();
    };
  }, [backgroundFilter, call, start]);
  return children;
};
var useRenderer = (tfLite) => {
  const { backgroundFilter, backgroundBlurLevel, backgroundImage } = useBackgroundFilters();
  const videoRef = (0, import_react4.useRef)(null);
  const canvasRef = (0, import_react4.useRef)(null);
  const bgImageRef = (0, import_react4.useRef)(null);
  const [videoSize, setVideoSize] = (0, import_react4.useState)({
    width: 1920,
    height: 1080
  });
  const start = (0, import_react4.useCallback)((ms, onError) => {
    let outputStream;
    let renderer;
    const output = new Promise((resolve, reject) => {
      if (!backgroundFilter) {
        reject(new Error("No filter specified"));
        return;
      }
      const videoEl = videoRef.current;
      const canvasEl = canvasRef.current;
      const bgImageEl = bgImageRef.current;
      if (!videoEl || !canvasEl || backgroundImage && !bgImageEl) {
        reject(new Error("Renderer started before elements are ready"));
        return;
      }
      videoEl.srcObject = ms;
      videoEl.play().then(() => {
        const [track] = ms.getVideoTracks();
        if (!track) {
          reject(new Error("No video tracks in input media stream"));
          return;
        }
        const trackSettings = track.getSettings();
        (0, import_react_dom3.flushSync)(() => setVideoSize({
          width: trackSettings.width ?? 0,
          height: trackSettings.height ?? 0
        }));
        renderer = createRenderer(tfLite, videoEl, canvasEl, {
          backgroundFilter,
          backgroundBlurLevel,
          backgroundImage: bgImageEl ?? void 0
        }, onError);
        outputStream = canvasEl.captureStream();
        resolve(outputStream);
      }, () => {
        reject(new Error("Could not play the source video stream"));
      });
    });
    return {
      output,
      stop: () => {
        renderer == null ? void 0 : renderer.dispose();
        if (videoRef.current)
          videoRef.current.srcObject = null;
        if (outputStream)
          disposeOfMediaStream(outputStream);
      }
    };
  }, [backgroundBlurLevel, backgroundFilter, backgroundImage, tfLite]);
  const children = (0, import_jsx_runtime3.jsxs)("div", { className: "str-video__background-filters", children: [(0, import_jsx_runtime3.jsx)("video", { className: clsx_default("str-video__background-filters__video", videoSize.height > videoSize.width && "str-video__background-filters__video--tall"), ref: videoRef, playsInline: true, muted: true, controls: false, ...videoSize }), backgroundImage && (0, import_jsx_runtime3.jsx)("img", { className: "str-video__background-filters__background-image", alt: "Background", ref: bgImageRef, src: backgroundImage, ...videoSize }), (0, import_jsx_runtime3.jsx)("canvas", { className: "str-video__background-filters__target-canvas", ...videoSize, ref: canvasRef })] });
  return {
    start,
    children
  };
};
var IconButton = (0, import_react4.forwardRef)(function IconButton2(props, ref) {
  const { icon, enabled, variant, onClick, className, ...rest } = props;
  return (0, import_jsx_runtime3.jsx)("button", { className: clsx_default("str-video__call-controls__button", className, {
    [`str-video__call-controls__button--variant-${variant}`]: variant,
    "str-video__call-controls__button--enabled": enabled
  }), onClick: (e) => {
    e.preventDefault();
    onClick == null ? void 0 : onClick(e);
  }, ref, ...rest, children: (0, import_jsx_runtime3.jsx)(Icon, { icon }) });
});
var CompositeButton = (0, import_react4.forwardRef)(function CompositeButton2({ disabled, caption, children, className, active, Menu: Menu2, menuPlacement, menuOffset, title, ToggleMenuButton: ToggleMenuButton3 = DefaultToggleMenuButton, variant, onClick, onMenuToggle, ...restButtonProps }, ref) {
  return (0, import_jsx_runtime3.jsxs)("div", { className: clsx_default("str-video__composite-button", className, {
    "str-video__composite-button--caption": caption,
    "str-video__composite-button--menu": Menu2
  }), title, ref, children: [(0, import_jsx_runtime3.jsxs)("div", { className: clsx_default("str-video__composite-button__button-group", {
    "str-video__composite-button__button-group--active": active,
    "str-video__composite-button__button-group--active-primary": active && variant === "primary",
    "str-video__composite-button__button-group--active-secondary": active && variant === "secondary",
    "str-video__composite-button__button-group--disabled": disabled
  }), children: [(0, import_jsx_runtime3.jsx)("button", { type: "button", className: "str-video__composite-button__button", onClick: (e) => {
    e.preventDefault();
    onClick == null ? void 0 : onClick(e);
  }, disabled, ...restButtonProps, children }), Menu2 && (0, import_jsx_runtime3.jsx)(MenuToggle, { offset: menuOffset, placement: menuPlacement, ToggleButton: ToggleMenuButton3, onToggle: onMenuToggle, children: isComponentType(Menu2) ? (0, import_jsx_runtime3.jsx)(Menu2, {}) : Menu2 })] }), caption && (0, import_jsx_runtime3.jsx)("div", { className: "str-video__composite-button__caption", children: caption })] });
});
var DefaultToggleMenuButton = (0, import_react4.forwardRef)(function DefaultToggleMenuButton2({ menuShown }, ref) {
  return (0, import_jsx_runtime3.jsx)(IconButton, { className: clsx_default("str-video__menu-toggle-button", {
    "str-video__menu-toggle-button--active": menuShown
  }), icon: menuShown ? "caret-down" : "caret-up", ref });
});
var TextButton = ({ children, ...rest }) => {
  return (0, import_jsx_runtime3.jsx)("button", { ...rest, className: "str-video__text-button", children });
};
var AcceptCallButton = ({ disabled, onAccept, onClick }) => {
  const call = useCall();
  const handleClick = (0, import_react4.useCallback)(async (e) => {
    if (onClick) {
      onClick(e);
    } else if (call) {
      await call.join();
      onAccept == null ? void 0 : onAccept();
    }
  }, [onClick, onAccept, call]);
  return (0, import_jsx_runtime3.jsx)(IconButton, { disabled, icon: "call-accept", variant: "success", "data-testid": "accept-call-button", onClick: handleClick });
};
var Notification2 = (props) => {
  const { isVisible, message, children, visibilityTimeout, resetIsVisible, placement = "top", iconClassName = "str-video__notification__icon", close } = props;
  const { refs, x, y, strategy } = useFloatingUIPreset({
    placement,
    strategy: "absolute"
  });
  (0, import_react4.useEffect)(() => {
    if (!isVisible || !visibilityTimeout || !resetIsVisible)
      return;
    const timeout2 = setTimeout(() => {
      resetIsVisible();
    }, visibilityTimeout);
    return () => clearTimeout(timeout2);
  }, [isVisible, resetIsVisible, visibilityTimeout]);
  return (0, import_jsx_runtime3.jsxs)("div", { ref: refs.setReference, children: [isVisible && (0, import_jsx_runtime3.jsxs)("div", { className: "str-video__notification", ref: refs.setFloating, style: {
    position: strategy,
    top: y ?? 0,
    left: x ?? 0,
    overflowY: "auto"
  }, children: [iconClassName && (0, import_jsx_runtime3.jsx)("i", { className: iconClassName }), (0, import_jsx_runtime3.jsx)("span", { className: "str-video__notification__message", children: message }), close ? (0, import_jsx_runtime3.jsx)("i", { className: "str-video__icon str-video__icon--close str-video__notification__close", onClick: close }) : null] }), children] });
};
var PermissionNotification = (props) => {
  const { permission, isAwaitingApproval, messageApproved, messageAwaitingApproval, messageRevoked, visibilityTimeout = 3500, children } = props;
  const { useHasPermissions: useHasPermissions2 } = useCallStateHooks();
  const hasPermission = useHasPermissions2(permission);
  const prevHasPermission = (0, import_react4.useRef)(hasPermission);
  const [showNotification, setShowNotification] = (0, import_react4.useState)();
  (0, import_react4.useEffect)(() => {
    if (hasPermission && !prevHasPermission.current) {
      setShowNotification("granted");
      prevHasPermission.current = true;
    } else if (!hasPermission && prevHasPermission.current) {
      setShowNotification("revoked");
      prevHasPermission.current = false;
    }
  }, [hasPermission]);
  const resetIsVisible = (0, import_react4.useCallback)(() => setShowNotification(void 0), []);
  if (isAwaitingApproval) {
    return (0, import_jsx_runtime3.jsx)(Notification2, { isVisible: isAwaitingApproval && !hasPermission, message: messageAwaitingApproval, children });
  }
  return (0, import_jsx_runtime3.jsx)(Notification2, { isVisible: !!showNotification, visibilityTimeout, resetIsVisible, message: showNotification === "granted" ? messageApproved : messageRevoked, children });
};
var SpeakingWhileMutedNotification = ({ children, text, placement }) => {
  const { useMicrophoneState: useMicrophoneState2 } = useCallStateHooks();
  const { isSpeakingWhileMuted } = useMicrophoneState2();
  const { t: t2 } = useI18n();
  const message = text ?? t2("You are muted. Unmute to speak.");
  return (0, import_jsx_runtime3.jsx)(Notification2, { message, isVisible: isSpeakingWhileMuted, placement: placement || "top-start", children });
};
var RecordingInProgressNotification = ({ children, text }) => {
  const { t: t2 } = useI18n();
  const { isCallRecordingInProgress } = useToggleCallRecording();
  const [isVisible, setVisible] = (0, import_react4.useState)(false);
  const message = text ?? t2("Recording in progress...");
  (0, import_react4.useEffect)(() => {
    if (isCallRecordingInProgress) {
      setVisible(true);
    } else {
      setVisible(false);
    }
  }, [isCallRecordingInProgress]);
  return (0, import_jsx_runtime3.jsx)(Notification2, { message, iconClassName: "str-video__icon str-video__icon--recording-on", isVisible, placement: "top-start", close: () => setVisible(false), children });
};
var LoadingIndicator = ({ className, type = "spinner", text, tooltip }) => {
  return (0, import_jsx_runtime3.jsxs)("div", { className: clsx_default("str-video__loading-indicator", className), title: tooltip, children: [(0, import_jsx_runtime3.jsx)("div", { className: clsx_default("str-video__loading-indicator__icon", type) }), text && (0, import_jsx_runtime3.jsx)("p", { className: "str-video__loading-indicator-text", children: text })] });
};
var Tooltip = ({ children, referenceElement, tooltipClassName, tooltipPlacement = "top", visible = false }) => {
  const arrowRef = (0, import_react4.useRef)(null);
  const { refs, x, y, strategy, context: context2 } = useFloatingUIPreset({
    placement: tooltipPlacement,
    strategy: "absolute",
    middleware: [arrow3({ element: arrowRef })]
  });
  (0, import_react4.useEffect)(() => {
    refs.setReference(referenceElement);
  }, [referenceElement, refs]);
  if (!visible)
    return null;
  return (0, import_jsx_runtime3.jsxs)("div", { className: clsx_default("str-video__tooltip", tooltipClassName), ref: refs.setFloating, style: {
    position: strategy,
    top: y ?? 0,
    left: x ?? 0
  }, children: [(0, import_jsx_runtime3.jsx)(FloatingArrow, { ref: arrowRef, context: context2, fill: "var(--str-video__tooltip--background-color)" }), children] });
};
var useEnterLeaveHandlers = ({ onMouseEnter, onMouseLeave } = {}) => {
  const [tooltipVisible, setTooltipVisible] = (0, import_react4.useState)(false);
  const handleMouseEnter = (0, import_react4.useCallback)((e) => {
    setTooltipVisible(true);
    onMouseEnter == null ? void 0 : onMouseEnter(e);
  }, [onMouseEnter]);
  const handleMouseLeave = (0, import_react4.useCallback)((e) => {
    setTooltipVisible(false);
    onMouseLeave == null ? void 0 : onMouseLeave(e);
  }, [onMouseLeave]);
  return { handleMouseEnter, handleMouseLeave, tooltipVisible };
};
var WithTooltip = ({ title, tooltipClassName, tooltipPlacement, tooltipDisabled, ...props }) => {
  const { handleMouseEnter, handleMouseLeave, tooltipVisible } = useEnterLeaveHandlers();
  const [tooltipAnchor, setTooltipAnchor] = (0, import_react4.useState)(null);
  const tooltipActuallyVisible = !tooltipDisabled && Boolean(title) && tooltipVisible;
  return (0, import_jsx_runtime3.jsxs)(import_jsx_runtime3.Fragment, { children: [(0, import_jsx_runtime3.jsx)(Tooltip, { referenceElement: tooltipAnchor, visible: tooltipActuallyVisible, tooltipClassName, tooltipPlacement, children: title || "" }), (0, import_jsx_runtime3.jsx)("div", { ref: setTooltipAnchor, onMouseEnter: handleMouseEnter, onMouseLeave: handleMouseLeave, ...props })] });
};
var RecordEndConfirmation = () => {
  const { t: t2 } = useI18n();
  const { toggleCallRecording, isAwaitingResponse } = useToggleCallRecording();
  const { close } = useMenuContext();
  return (0, import_jsx_runtime3.jsxs)("div", { className: "str-video__end-recording__confirmation", children: [(0, import_jsx_runtime3.jsxs)("div", { className: "str-video__end-recording__header", children: [(0, import_jsx_runtime3.jsx)(Icon, { icon: "recording-on" }), (0, import_jsx_runtime3.jsx)("h2", { className: "str-video__end-recording__heading", children: t2("End recording") })] }), (0, import_jsx_runtime3.jsx)("p", { className: "str-video__end-recording__description", children: t2("Are you sure you want end the recording?") }), (0, import_jsx_runtime3.jsxs)("div", { className: "str-video__end-recording__actions", children: [(0, import_jsx_runtime3.jsx)(CompositeButton, { variant: "secondary", onClick: close, children: t2("Cancel") }), (0, import_jsx_runtime3.jsx)(CompositeButton, { variant: "primary", onClick: toggleCallRecording, children: isAwaitingResponse ? (0, import_jsx_runtime3.jsx)(LoadingIndicator, {}) : t2("End recording") })] })] });
};
var ToggleEndRecordingMenuButton = (0, import_react4.forwardRef)(function ToggleEndRecordingMenuButton2(props, ref) {
  return (0, import_jsx_runtime3.jsx)(CompositeButton, { ref, active: true, variant: "secondary", "data-testid": "recording-stop-button", children: (0, import_jsx_runtime3.jsx)(Icon, { icon: "recording-off" }) });
});
var RecordCallConfirmationButton = ({ caption }) => {
  const { t: t2 } = useI18n();
  const { toggleCallRecording, isAwaitingResponse, isCallRecordingInProgress } = useToggleCallRecording();
  if (isCallRecordingInProgress) {
    return (0, import_jsx_runtime3.jsx)(Restricted, { requiredGrants: [
      OwnCapability.START_RECORD_CALL,
      OwnCapability.STOP_RECORD_CALL
    ], children: (0, import_jsx_runtime3.jsx)(MenuToggle, { ToggleButton: ToggleEndRecordingMenuButton, visualType: MenuVisualType.PORTAL, children: (0, import_jsx_runtime3.jsx)(RecordEndConfirmation, {}) }) });
  }
  const title = isAwaitingResponse ? t2("Waiting for recording to start...") : caption ?? t2("Record call");
  return (0, import_jsx_runtime3.jsx)(Restricted, { requiredGrants: [
    OwnCapability.START_RECORD_CALL,
    OwnCapability.STOP_RECORD_CALL
  ], children: (0, import_jsx_runtime3.jsx)(WithTooltip, { title, children: (0, import_jsx_runtime3.jsx)(CompositeButton, { active: isCallRecordingInProgress, caption, variant: "secondary", "data-testid": "recording-start-button", onClick: isAwaitingResponse ? void 0 : toggleCallRecording, children: isAwaitingResponse ? (0, import_jsx_runtime3.jsx)(LoadingIndicator, {}) : (0, import_jsx_runtime3.jsx)(Icon, { icon: "recording-off" }) }) }) });
};
var RecordCallButton = ({ caption }) => {
  const { t: t2 } = useI18n();
  const { toggleCallRecording, isAwaitingResponse, isCallRecordingInProgress } = useToggleCallRecording();
  let title = caption ?? t2("Record call");
  if (isAwaitingResponse) {
    title = isCallRecordingInProgress ? t2("Waiting for recording to stop...") : t2("Waiting for recording to start...");
  }
  return (0, import_jsx_runtime3.jsx)(Restricted, { requiredGrants: [
    OwnCapability.START_RECORD_CALL,
    OwnCapability.STOP_RECORD_CALL
  ], children: (0, import_jsx_runtime3.jsx)(CompositeButton, { active: isCallRecordingInProgress, caption, variant: "secondary", "data-testid": isCallRecordingInProgress ? "recording-stop-button" : "recording-start-button", title, onClick: isAwaitingResponse ? void 0 : toggleCallRecording, children: isAwaitingResponse ? (0, import_jsx_runtime3.jsx)(LoadingIndicator, {}) : (0, import_jsx_runtime3.jsx)(Icon, { icon: isCallRecordingInProgress ? "recording-on" : "recording-off" }) }) });
};
var defaultEmojiReactionMap = {
  ":like:": "👍",
  ":raise-hand:": "✋",
  ":fireworks:": "🎉",
  ":dislike:": "👎",
  ":heart:": "❤️",
  ":smile:": "😀"
};
var Reaction = ({ participant: { reaction, sessionId }, hideAfterTimeoutInMs = 5500, emojiReactionMap = defaultEmojiReactionMap }) => {
  const call = useCall();
  (0, import_react4.useEffect)(() => {
    if (!call || !reaction)
      return;
    const timeoutId = setTimeout(() => {
      call.resetReaction(sessionId);
    }, hideAfterTimeoutInMs);
    return () => {
      clearTimeout(timeoutId);
    };
  }, [call, hideAfterTimeoutInMs, reaction, sessionId]);
  if (!reaction)
    return null;
  const { emoji_code: emojiCode } = reaction;
  return (0, import_jsx_runtime3.jsx)("div", { className: "str-video__reaction", children: (0, import_jsx_runtime3.jsx)("span", { className: "str-video__reaction__emoji", children: emojiCode && emojiReactionMap[emojiCode] }) });
};
var defaultReactions = [
  {
    type: "reaction",
    emoji_code: ":like:"
  },
  {
    // TODO OL: use `prompt` type?
    type: "raised-hand",
    emoji_code: ":raise-hand:"
  },
  {
    type: "reaction",
    emoji_code: ":fireworks:"
  },
  {
    type: "reaction",
    emoji_code: ":dislike:"
  },
  {
    type: "reaction",
    emoji_code: ":heart:"
  },
  {
    type: "reaction",
    emoji_code: ":smile:"
  }
];
var ReactionsButton = ({ reactions = defaultReactions }) => {
  return (0, import_jsx_runtime3.jsx)(Restricted, { requiredGrants: [OwnCapability.CREATE_REACTION], children: (0, import_jsx_runtime3.jsx)(MenuToggle, { placement: "top", ToggleButton: ToggleReactionsMenuButton, visualType: MenuVisualType.MENU, children: (0, import_jsx_runtime3.jsx)(DefaultReactionsMenu, { reactions }) }) });
};
var ToggleReactionsMenuButton = (0, import_react4.forwardRef)(function ToggleReactionsMenuButton2({ menuShown }, ref) {
  const { t: t2 } = useI18n();
  return (0, import_jsx_runtime3.jsx)(WithTooltip, { title: t2("Reactions"), tooltipDisabled: menuShown, children: (0, import_jsx_runtime3.jsx)(CompositeButton, { ref, active: menuShown, variant: "primary", children: (0, import_jsx_runtime3.jsx)(Icon, { icon: "reactions" }) }) });
});
var DefaultReactionsMenu = ({ reactions, layout = "horizontal" }) => {
  const call = useCall();
  const { close } = useMenuContext();
  return (0, import_jsx_runtime3.jsx)("div", { className: clsx_default("str-video__reactions-menu", {
    "str-video__reactions-menu--horizontal": layout === "horizontal",
    "str-video__reactions-menu--vertical": layout === "vertical"
  }), children: reactions.map((reaction) => (0, import_jsx_runtime3.jsx)("button", { type: "button", className: "str-video__reactions-menu__button", onClick: () => {
    call == null ? void 0 : call.sendReaction(reaction);
    close == null ? void 0 : close();
  }, children: reaction.emoji_code && defaultEmojiReactionMap[reaction.emoji_code] }, reaction.emoji_code)) });
};
var createCallControlHandler = (props, handler) => {
  const logger2 = getLogger(["react-sdk"]);
  return async () => {
    try {
      await handler();
    } catch (error2) {
      if (props.onError) {
        props.onError(error2);
        return;
      }
      if (!isNotAllowedError(error2)) {
        logger2("error", "Call control handler failed", error2);
      }
    }
  };
};
function isNotAllowedError(error2) {
  return error2 instanceof DOMException && error2.name === "NotAllowedError";
}
var ScreenShareButton = (props) => {
  const { t: t2 } = useI18n();
  const { caption } = props;
  const { useHasOngoingScreenShare: useHasOngoingScreenShare2, useScreenShareState: useScreenShareState2, useCallSettings: useCallSettings2 } = useCallStateHooks();
  const isSomeoneScreenSharing = useHasOngoingScreenShare2();
  const { hasPermission, requestPermission, isAwaitingPermission } = useRequestPermission(OwnCapability.SCREENSHARE);
  const callSettings = useCallSettings2();
  const isScreenSharingAllowed = callSettings == null ? void 0 : callSettings.screensharing.enabled;
  const { screenShare, optimisticIsMute } = useScreenShareState2();
  const amIScreenSharing = !optimisticIsMute;
  const disableScreenShareButton = !amIScreenSharing && (isSomeoneScreenSharing || isScreenSharingAllowed === false);
  const handleClick = createCallControlHandler(props, async () => {
    if (!hasPermission) {
      await requestPermission();
    } else {
      await screenShare.toggle();
    }
  });
  return (0, import_jsx_runtime3.jsx)(Restricted, { requiredGrants: [OwnCapability.SCREENSHARE], children: (0, import_jsx_runtime3.jsx)(PermissionNotification, { permission: OwnCapability.SCREENSHARE, isAwaitingApproval: isAwaitingPermission, messageApproved: t2("You can now share your screen."), messageAwaitingApproval: t2("Awaiting for an approval to share screen."), messageRevoked: t2("You can no longer share your screen."), children: (0, import_jsx_runtime3.jsx)(WithTooltip, { title: caption ?? t2("Share screen"), children: (0, import_jsx_runtime3.jsx)(CompositeButton, { active: isSomeoneScreenSharing || amIScreenSharing, caption, variant: "primary", "data-testid": isSomeoneScreenSharing ? "screen-share-stop-button" : "screen-share-start-button", disabled: disableScreenShareButton, onClick: handleClick, children: (0, import_jsx_runtime3.jsx)(Icon, { icon: isSomeoneScreenSharing ? "screen-share-on" : "screen-share-off" }) }) }) }) });
};
var SelectContext = (0, import_react4.createContext)({});
var Select = (props) => {
  const { children, icon, defaultSelectedLabel, defaultSelectedIndex, handleSelect: handleSelectProp } = props;
  const [isOpen, setIsOpen] = (0, import_react4.useState)(false);
  const [activeIndex, setActiveIndex] = (0, import_react4.useState)(null);
  const [selectedIndex, setSelectedIndex] = (0, import_react4.useState)(defaultSelectedIndex);
  const [selectedLabel, setSelectedLabel] = (0, import_react4.useState)(defaultSelectedLabel);
  const { refs, context: context2 } = useFloating2({
    placement: "bottom-start",
    open: isOpen,
    onOpenChange: setIsOpen,
    whileElementsMounted: autoUpdate,
    middleware: [flip3()]
  });
  const elementsRef = (0, import_react4.useRef)([]);
  const labelsRef = (0, import_react4.useRef)([]);
  const handleSelect = (0, import_react4.useCallback)((index3) => {
    setSelectedIndex(index3);
    handleSelectProp(index3 || 0);
    setIsOpen(false);
    if (index3 !== null) {
      setSelectedLabel(labelsRef.current[index3]);
    }
  }, [handleSelectProp]);
  const handleTypeaheadMatch = (index3) => {
    if (isOpen) {
      setActiveIndex(index3);
    } else {
      handleSelect(index3);
    }
  };
  const listNav = useListNavigation(context2, {
    listRef: elementsRef,
    activeIndex,
    selectedIndex,
    onNavigate: setActiveIndex
  });
  const typeahead = useTypeahead(context2, {
    listRef: labelsRef,
    activeIndex,
    selectedIndex,
    onMatch: handleTypeaheadMatch
  });
  const click = useClick(context2);
  const dismiss = useDismiss(context2);
  const role2 = useRole(context2, { role: "listbox" });
  const { getReferenceProps, getFloatingProps, getItemProps } = useInteractions([listNav, typeahead, click, dismiss, role2]);
  const selectContext = (0, import_react4.useMemo)(() => ({
    activeIndex,
    selectedIndex,
    getItemProps,
    handleSelect
  }), [activeIndex, selectedIndex, getItemProps, handleSelect]);
  return (0, import_jsx_runtime3.jsxs)("div", { className: "str-video__dropdown", children: [(0, import_jsx_runtime3.jsxs)("div", { className: "str-video__dropdown-selected", ref: refs.setReference, tabIndex: 0, ...getReferenceProps(), children: [(0, import_jsx_runtime3.jsxs)("label", { className: "str-video__dropdown-selected__label", children: [icon && (0, import_jsx_runtime3.jsx)(Icon, { className: "str-video__dropdown-selected__icon", icon }), selectedLabel] }), (0, import_jsx_runtime3.jsx)(Icon, { className: "str-video__dropdown-selected__chevron", icon: isOpen ? "chevron-up" : "chevron-down" })] }), (0, import_jsx_runtime3.jsx)(SelectContext.Provider, { value: selectContext, children: isOpen && (0, import_jsx_runtime3.jsx)(FloatingFocusManager, { context: context2, modal: false, children: (0, import_jsx_runtime3.jsx)("div", { className: "str-video__dropdown-list", ref: refs.setFloating, ...getFloatingProps(), children: (0, import_jsx_runtime3.jsx)(FloatingList, { elementsRef, labelsRef, children }) }) }) })] });
};
var DropDownSelectOption = (props) => {
  const { selected, label, icon } = props;
  const { getItemProps, handleSelect } = (0, import_react4.useContext)(SelectContext);
  const { ref, index: index3 } = useListItem();
  return (0, import_jsx_runtime3.jsxs)("div", { className: clsx_default("str-video__dropdown-option", {
    "str-video__dropdown-option--selected": selected
  }), ref, ...getItemProps({
    onClick: () => handleSelect(index3)
  }), children: [icon && (0, import_jsx_runtime3.jsx)(Icon, { className: "str-video__dropdown-icon", icon }), (0, import_jsx_runtime3.jsx)("span", { className: "str-video__dropdown-label", children: label })] });
};
var DropDownSelect = (props) => {
  const { children, icon, handleSelect, defaultSelectedLabel, defaultSelectedIndex } = props;
  return (0, import_jsx_runtime3.jsx)(Select, { icon, handleSelect, defaultSelectedIndex, defaultSelectedLabel, children });
};
var DeviceSelectorOption = ({ disabled, id, label, onChange, name: name2, selected, defaultChecked, value }) => {
  return (0, import_jsx_runtime3.jsxs)("label", { className: clsx_default("str-video__device-settings__option", {
    "str-video__device-settings__option--selected": selected,
    "str-video__device-settings__option--disabled": disabled
  }), htmlFor: id, children: [(0, import_jsx_runtime3.jsx)("input", { type: "radio", name: name2, onChange, value, id, checked: selected, defaultChecked, disabled }), label] });
};
var DeviceSelectorList = (props) => {
  const { devices = [], selectedDeviceId, title, type, onChange } = props;
  const { close } = useMenuContext();
  const { deviceList } = useDeviceList(devices, selectedDeviceId);
  return (0, import_jsx_runtime3.jsxs)("div", { className: "str-video__device-settings__device-kind", children: [title && (0, import_jsx_runtime3.jsx)("div", { className: "str-video__device-settings__device-selector-title", children: title }), deviceList.map((device) => {
    return (0, import_jsx_runtime3.jsx)(DeviceSelectorOption, { id: `${type}--${device.deviceId}`, value: device.deviceId, label: device.label, onChange: (e) => {
      const deviceId = e.target.value;
      if (deviceId !== "default") {
        onChange == null ? void 0 : onChange(deviceId);
      }
      close == null ? void 0 : close();
    }, name: type, selected: device.isSelected }, device.deviceId);
  })] });
};
var DeviceSelectorDropdown = (props) => {
  const { devices = [], selectedDeviceId, title, onChange, icon } = props;
  const { deviceList, selectedDeviceInfo, selectedIndex } = useDeviceList(devices, selectedDeviceId);
  const handleSelect = (0, import_react4.useCallback)((index3) => {
    const deviceId = deviceList[index3].deviceId;
    if (deviceId !== "default") {
      onChange == null ? void 0 : onChange(deviceId);
    }
  }, [deviceList, onChange]);
  return (0, import_jsx_runtime3.jsxs)("div", { className: "str-video__device-settings__device-kind", children: [(0, import_jsx_runtime3.jsx)("div", { className: "str-video__device-settings__device-selector-title", children: title }), (0, import_jsx_runtime3.jsx)(DropDownSelect, { icon, defaultSelectedIndex: selectedIndex, defaultSelectedLabel: selectedDeviceInfo.label, handleSelect, children: deviceList.map((device) => (0, import_jsx_runtime3.jsx)(DropDownSelectOption, { icon, label: device.label, selected: device.isSelected }, device.deviceId)) })] });
};
var DeviceSelector = (props) => {
  const { visualType = "list", icon, ...rest } = props;
  if (visualType === "list") {
    return (0, import_jsx_runtime3.jsx)(DeviceSelectorList, { ...rest });
  }
  return (0, import_jsx_runtime3.jsx)(DeviceSelectorDropdown, { ...rest, icon });
};
var DeviceSelectorAudioInput = ({ title, visualType }) => {
  const { useMicrophoneState: useMicrophoneState2 } = useCallStateHooks();
  const { microphone, selectedDevice, devices } = useMicrophoneState2();
  return (0, import_jsx_runtime3.jsx)(DeviceSelector, { devices: devices || [], selectedDeviceId: selectedDevice, type: "audioinput", onChange: async (deviceId) => {
    await microphone.select(deviceId);
  }, title, visualType, icon: "mic" });
};
var DeviceSelectorAudioOutput = ({ title, visualType }) => {
  const { useSpeakerState: useSpeakerState2 } = useCallStateHooks();
  const { speaker, selectedDevice, devices, isDeviceSelectionSupported } = useSpeakerState2();
  if (!isDeviceSelectionSupported)
    return null;
  return (0, import_jsx_runtime3.jsx)(DeviceSelector, { devices, type: "audiooutput", selectedDeviceId: selectedDevice, onChange: (deviceId) => {
    speaker.select(deviceId);
  }, title, visualType, icon: "speaker" });
};
var DeviceSelectorVideo = ({ title, visualType }) => {
  const { useCameraState: useCameraState2 } = useCallStateHooks();
  const { camera, devices, selectedDevice } = useCameraState2();
  return (0, import_jsx_runtime3.jsx)(DeviceSelector, { devices: devices || [], type: "videoinput", selectedDeviceId: selectedDevice, onChange: async (deviceId) => {
    await camera.select(deviceId);
  }, title, visualType, icon: "camera" });
};
var DeviceSettings = ({ visualType = MenuVisualType.MENU }) => {
  return (0, import_jsx_runtime3.jsx)(MenuToggle, { placement: "bottom-end", ToggleButton: ToggleDeviceSettingsMenuButton, visualType, children: (0, import_jsx_runtime3.jsx)(Menu, {}) });
};
var Menu = () => {
  const { t: t2 } = useI18n();
  return (0, import_jsx_runtime3.jsxs)("div", { className: "str-video__device-settings", children: [(0, import_jsx_runtime3.jsx)(DeviceSelectorVideo, { title: t2("Select a Camera") }), (0, import_jsx_runtime3.jsx)(DeviceSelectorAudioInput, { title: t2("Select a Mic") }), (0, import_jsx_runtime3.jsx)(DeviceSelectorAudioOutput, { title: t2("Select Speakers") })] });
};
var ToggleDeviceSettingsMenuButton = (0, import_react4.forwardRef)(function ToggleDeviceSettingsMenuButton2({ menuShown }, ref) {
  const { t: t2 } = useI18n();
  return (0, import_jsx_runtime3.jsx)(IconButton, { className: clsx_default("str-video__device-settings__button", {
    "str-video__device-settings__button--active": menuShown
  }), title: t2("Toggle device menu"), icon: "device-settings", ref });
});
var ToggleAudioPreviewButton = (props) => {
  const { caption, onMenuToggle, ...restCompositeButtonProps } = props;
  const { t: t2 } = useI18n();
  const { useMicrophoneState: useMicrophoneState2 } = useCallStateHooks();
  const { microphone, optimisticIsMute, hasBrowserPermission, isPromptingPermission } = useMicrophoneState2();
  const [tooltipDisabled, setTooltipDisabled] = (0, import_react4.useState)(false);
  const handleClick = createCallControlHandler(props, () => microphone.toggle());
  return (0, import_jsx_runtime3.jsx)(WithTooltip, { title: !hasBrowserPermission ? t2("Check your browser audio permissions") : caption ?? t2("Mic"), tooltipDisabled, children: (0, import_jsx_runtime3.jsxs)(CompositeButton, { active: optimisticIsMute, caption, className: clsx_default(!hasBrowserPermission && "str-video__device-unavailable"), variant: "secondary", disabled: !hasBrowserPermission, "data-testid": optimisticIsMute ? "preview-audio-unmute-button" : "preview-audio-mute-button", onClick: handleClick, ...restCompositeButtonProps, onMenuToggle: (shown) => {
    setTooltipDisabled(shown);
    onMenuToggle == null ? void 0 : onMenuToggle(shown);
  }, children: [(0, import_jsx_runtime3.jsx)(Icon, { icon: !optimisticIsMute ? "mic" : "mic-off" }), !hasBrowserPermission && (0, import_jsx_runtime3.jsx)("span", { className: "str-video__no-media-permission", title: t2("Check your browser audio permissions"), children: "!" }), isPromptingPermission && (0, import_jsx_runtime3.jsx)("span", { className: "str-video__pending-permission", title: t2("Waiting for permission"), children: "?" })] }) });
};
var ToggleAudioPublishingButton = (props) => {
  const { t: t2 } = useI18n();
  const { caption, Menu: Menu2 = (0, import_jsx_runtime3.jsx)(DeviceSelectorAudioInput, { visualType: "list" }), menuPlacement = "top", onMenuToggle, ...restCompositeButtonProps } = props;
  const { hasPermission, requestPermission, isAwaitingPermission } = useRequestPermission(OwnCapability.SEND_AUDIO);
  const { useMicrophoneState: useMicrophoneState2 } = useCallStateHooks();
  const { microphone, optimisticIsMute, hasBrowserPermission, isPromptingPermission } = useMicrophoneState2();
  const [tooltipDisabled, setTooltipDisabled] = (0, import_react4.useState)(false);
  const handleClick = createCallControlHandler(props, async () => {
    if (!hasPermission) {
      await requestPermission();
    } else {
      await microphone.toggle();
    }
  });
  return (0, import_jsx_runtime3.jsx)(Restricted, { requiredGrants: [OwnCapability.SEND_AUDIO], children: (0, import_jsx_runtime3.jsx)(PermissionNotification, { permission: OwnCapability.SEND_AUDIO, isAwaitingApproval: isAwaitingPermission, messageApproved: t2("You can now speak."), messageAwaitingApproval: t2("Awaiting for an approval to speak."), messageRevoked: t2("You can no longer speak."), children: (0, import_jsx_runtime3.jsx)(WithTooltip, { title: !hasPermission ? t2("You have no permission to share your audio") : !hasBrowserPermission ? t2("Check your browser mic permissions") : caption ?? t2("Mic"), tooltipDisabled, children: (0, import_jsx_runtime3.jsxs)(CompositeButton, { active: optimisticIsMute, caption, variant: "secondary", disabled: !hasBrowserPermission || !hasPermission, "data-testid": optimisticIsMute ? "audio-unmute-button" : "audio-mute-button", onClick: handleClick, Menu: Menu2, menuPlacement, menuOffset: 16, ...restCompositeButtonProps, onMenuToggle: (shown) => {
    setTooltipDisabled(shown);
    onMenuToggle == null ? void 0 : onMenuToggle(shown);
  }, children: [(0, import_jsx_runtime3.jsx)(Icon, { icon: optimisticIsMute ? "mic-off" : "mic" }), (!hasBrowserPermission || !hasPermission) && (0, import_jsx_runtime3.jsx)("span", { className: "str-video__no-media-permission", children: "!" }), isPromptingPermission && (0, import_jsx_runtime3.jsx)("span", { className: "str-video__pending-permission", title: t2("Waiting for permission"), children: "?" })] }) }) }) });
};
var ToggleVideoPreviewButton = (props) => {
  const { caption, Menu: Menu2 = DeviceSelectorVideo, menuPlacement = "top", onMenuToggle, ...restCompositeButtonProps } = props;
  const { t: t2 } = useI18n();
  const { useCameraState: useCameraState2 } = useCallStateHooks();
  const { camera, optimisticIsMute, hasBrowserPermission, isPromptingPermission } = useCameraState2();
  const [tooltipDisabled, setTooltipDisabled] = (0, import_react4.useState)(false);
  const handleClick = createCallControlHandler(props, () => camera.toggle());
  return (0, import_jsx_runtime3.jsx)(WithTooltip, { title: !hasBrowserPermission ? t2("Check your browser video permissions") : caption ?? t2("Video"), tooltipDisabled, children: (0, import_jsx_runtime3.jsxs)(CompositeButton, { active: optimisticIsMute, caption, className: clsx_default(!hasBrowserPermission && "str-video__device-unavailable"), variant: "secondary", "data-testid": optimisticIsMute ? "preview-video-unmute-button" : "preview-video-mute-button", onClick: handleClick, disabled: !hasBrowserPermission, Menu: Menu2, menuPlacement, ...restCompositeButtonProps, onMenuToggle: (shown) => {
    setTooltipDisabled(shown);
    onMenuToggle == null ? void 0 : onMenuToggle(shown);
  }, children: [(0, import_jsx_runtime3.jsx)(Icon, { icon: !optimisticIsMute ? "camera" : "camera-off" }), !hasBrowserPermission && (0, import_jsx_runtime3.jsx)("span", { className: "str-video__no-media-permission", title: t2("Check your browser video permissions"), children: "!" }), isPromptingPermission && (0, import_jsx_runtime3.jsx)("span", { className: "str-video__pending-permission", title: t2("Waiting for permission"), children: "?" })] }) });
};
var ToggleVideoPublishingButton = (props) => {
  const { t: t2 } = useI18n();
  const { caption, Menu: Menu2 = (0, import_jsx_runtime3.jsx)(DeviceSelectorVideo, { visualType: "list" }), menuPlacement = "top", onMenuToggle, ...restCompositeButtonProps } = props;
  const { hasPermission, requestPermission, isAwaitingPermission } = useRequestPermission(OwnCapability.SEND_VIDEO);
  const { useCameraState: useCameraState2, useCallSettings: useCallSettings2 } = useCallStateHooks();
  const { camera, optimisticIsMute, hasBrowserPermission, isPromptingPermission } = useCameraState2();
  const callSettings = useCallSettings2();
  const isPublishingVideoAllowed = callSettings == null ? void 0 : callSettings.video.enabled;
  const [tooltipDisabled, setTooltipDisabled] = (0, import_react4.useState)(false);
  const handleClick = createCallControlHandler(props, async () => {
    if (!hasPermission) {
      await requestPermission();
    } else {
      await camera.toggle();
    }
  });
  return (0, import_jsx_runtime3.jsx)(Restricted, { requiredGrants: [OwnCapability.SEND_VIDEO], children: (0, import_jsx_runtime3.jsx)(PermissionNotification, { permission: OwnCapability.SEND_VIDEO, isAwaitingApproval: isAwaitingPermission, messageApproved: t2("You can now share your video."), messageAwaitingApproval: t2("Awaiting for an approval to share your video."), messageRevoked: t2("You can no longer share your video."), children: (0, import_jsx_runtime3.jsx)(WithTooltip, { title: !hasPermission ? t2("You have no permission to share your video") : !hasBrowserPermission ? t2("Check your browser video permissions") : !isPublishingVideoAllowed ? t2("Video publishing is disabled by the system") : caption || t2("Video"), tooltipDisabled, children: (0, import_jsx_runtime3.jsxs)(CompositeButton, { active: optimisticIsMute, caption, variant: "secondary", disabled: !hasBrowserPermission || !hasPermission || !isPublishingVideoAllowed, "data-testid": optimisticIsMute ? "video-unmute-button" : "video-mute-button", onClick: handleClick, Menu: Menu2, menuPlacement, menuOffset: 16, ...restCompositeButtonProps, onMenuToggle: (shown) => {
    setTooltipDisabled(shown);
    onMenuToggle == null ? void 0 : onMenuToggle(shown);
  }, children: [(0, import_jsx_runtime3.jsx)(Icon, { icon: optimisticIsMute ? "camera-off" : "camera" }), (!hasBrowserPermission || !hasPermission || !isPublishingVideoAllowed) && (0, import_jsx_runtime3.jsx)("span", { className: "str-video__no-media-permission", children: "!" }), isPromptingPermission && (0, import_jsx_runtime3.jsx)("span", { className: "str-video__pending-permission", title: t2("Waiting for permission"), children: "?" })] }) }) }) });
};
var EndCallMenu = (props) => {
  const { onLeave, onEnd } = props;
  const { t: t2 } = useI18n();
  return (0, import_jsx_runtime3.jsxs)("div", { className: "str-video__end-call__confirmation", children: [(0, import_jsx_runtime3.jsxs)("button", { className: "str-video__button str-video__end-call__leave", type: "button", "data-testid": "leave-call-button", onClick: onLeave, children: [(0, import_jsx_runtime3.jsx)(Icon, { className: "str-video__button__icon str-video__end-call__leave-icon", icon: "logout" }), t2("Leave call")] }), (0, import_jsx_runtime3.jsx)(Restricted, { requiredGrants: [OwnCapability.END_CALL], children: (0, import_jsx_runtime3.jsxs)("button", { className: "str-video__button str-video__end-call__end", type: "button", "data-testid": "end-call-for-all-button", onClick: onEnd, children: [(0, import_jsx_runtime3.jsx)(Icon, { className: "str-video__button__icon str-video__end-call__end-icon", icon: "call-end" }), t2("End call for all")] }) })] });
};
var CancelCallToggleMenuButton = (0, import_react4.forwardRef)(function CancelCallToggleMenuButton2({ menuShown }, ref) {
  const { t: t2 } = useI18n();
  return (0, import_jsx_runtime3.jsx)(WithTooltip, { title: t2("Leave call"), tooltipDisabled: menuShown, children: (0, import_jsx_runtime3.jsx)(IconButton, { icon: menuShown ? "close" : "call-end", variant: menuShown ? "active" : "danger", "data-testid": "leave-call-button", ref }) });
});
var CancelCallConfirmButton = ({ onClick, onLeave }) => {
  const call = useCall();
  const handleLeave = (0, import_react4.useCallback)(async (e) => {
    if (onClick) {
      onClick(e);
    } else if (call) {
      await call.leave();
      onLeave == null ? void 0 : onLeave();
    }
  }, [onClick, onLeave, call]);
  const handleEndCall = (0, import_react4.useCallback)(async (e) => {
    if (onClick) {
      onClick(e);
    } else if (call) {
      await call.endCall();
      onLeave == null ? void 0 : onLeave();
    }
  }, [onClick, onLeave, call]);
  return (0, import_jsx_runtime3.jsx)(MenuToggle, { placement: "top-start", ToggleButton: CancelCallToggleMenuButton, children: (0, import_jsx_runtime3.jsx)(EndCallMenu, { onEnd: handleEndCall, onLeave: handleLeave }) });
};
var CancelCallButton = ({ disabled, caption, onClick, onLeave }) => {
  const call = useCall();
  const { t: t2 } = useI18n();
  const handleClick = (0, import_react4.useCallback)(async (e) => {
    if (onClick) {
      onClick(e);
    } else if (call) {
      await call.leave();
      onLeave == null ? void 0 : onLeave();
    }
  }, [onClick, onLeave, call]);
  return (0, import_jsx_runtime3.jsx)(IconButton, { disabled, icon: "call-end", variant: "danger", title: caption ?? t2("Leave call"), "data-testid": "cancel-call-button", onClick: handleClick });
};
var CallControls = ({ onLeave }) => (0, import_jsx_runtime3.jsxs)("div", { className: "str-video__call-controls", children: [(0, import_jsx_runtime3.jsx)(Restricted, { requiredGrants: [OwnCapability.SEND_AUDIO], children: (0, import_jsx_runtime3.jsx)(SpeakingWhileMutedNotification, { children: (0, import_jsx_runtime3.jsx)(ToggleAudioPublishingButton, {}) }) }), (0, import_jsx_runtime3.jsx)(Restricted, { requiredGrants: [OwnCapability.SEND_VIDEO], children: (0, import_jsx_runtime3.jsx)(ToggleVideoPublishingButton, {}) }), (0, import_jsx_runtime3.jsx)(Restricted, { requiredGrants: [OwnCapability.CREATE_REACTION], children: (0, import_jsx_runtime3.jsx)(ReactionsButton, {}) }), (0, import_jsx_runtime3.jsx)(Restricted, { requiredGrants: [OwnCapability.SCREENSHARE], children: (0, import_jsx_runtime3.jsx)(ScreenShareButton, {}) }), (0, import_jsx_runtime3.jsx)(Restricted, { requiredGrants: [
  OwnCapability.START_RECORD_CALL,
  OwnCapability.STOP_RECORD_CALL
], children: (0, import_jsx_runtime3.jsx)(RecordCallButton, {}) }), (0, import_jsx_runtime3.jsx)(CancelCallButton, { onLeave })] });
var CallStatsLatencyChart = (0, import_react4.lazy)(() => import("./latency-chart-Bj5OSYzg.es-7MKSASM4.js"));
var Status;
(function(Status2) {
  Status2["GOOD"] = "Good";
  Status2["OK"] = "Ok";
  Status2["BAD"] = "Bad";
})(Status || (Status = {}));
var CallStats = (props) => {
  const { latencyLowBound = 75, latencyHighBound = 400, showCodecInfo = false, LatencyChartSuspenseFallback = null } = props;
  const [latencyBuffer, setLatencyBuffer] = (0, import_react4.useState)(() => {
    const now = Date.now();
    return Array.from({ length: 20 }, (_, i) => ({ x: now + i, y: 0 }));
  });
  const { t: t2 } = useI18n();
  const [publishBitrate, setPublishBitrate] = (0, import_react4.useState)("-");
  const [subscribeBitrate, setSubscribeBitrate] = (0, import_react4.useState)("-");
  const previousStats = (0, import_react4.useRef)();
  const { useCallStatsReport: useCallStatsReport2 } = useCallStateHooks();
  const callStatsReport = useCallStatsReport2();
  (0, import_react4.useEffect)(() => {
    if (!callStatsReport)
      return;
    if (!previousStats.current) {
      previousStats.current = callStatsReport;
      return;
    }
    const previousCallStatsReport = previousStats.current;
    setPublishBitrate(() => {
      return calculatePublishBitrate(previousCallStatsReport, callStatsReport);
    });
    setSubscribeBitrate(() => {
      return calculateSubscribeBitrate(previousCallStatsReport, callStatsReport);
    });
    setLatencyBuffer((latencyBuf) => {
      const newLatencyBuffer = latencyBuf.slice(-19);
      newLatencyBuffer.push({
        x: callStatsReport.timestamp,
        y: callStatsReport.publisherStats.averageRoundTripTimeInMs
      });
      return newLatencyBuffer;
    });
    previousStats.current = callStatsReport;
  }, [callStatsReport]);
  const latencyComparison = {
    lowBound: latencyLowBound,
    highBound: latencyHighBound,
    value: (callStatsReport == null ? void 0 : callStatsReport.publisherStats.averageRoundTripTimeInMs) || 0
  };
  return (0, import_jsx_runtime3.jsx)("div", { className: "str-video__call-stats", children: callStatsReport && (0, import_jsx_runtime3.jsxs)(import_jsx_runtime3.Fragment, { children: [(0, import_jsx_runtime3.jsxs)("div", { className: "str-video__call-stats__header", children: [(0, import_jsx_runtime3.jsxs)("h3", { className: "str-video__call-stats__heading", children: [(0, import_jsx_runtime3.jsx)(Icon, { className: "str-video__call-stats__icon", icon: "call-latency" }), t2("Call Latency")] }), (0, import_jsx_runtime3.jsx)("p", { className: "str-video__call-stats__description", children: t2("Very high latency values may reduce call quality, cause lag, and make the call less enjoyable.") })] }), (0, import_jsx_runtime3.jsx)("div", { className: "str-video__call-stats__latencychart", children: (0, import_jsx_runtime3.jsx)(import_react4.Suspense, { fallback: LatencyChartSuspenseFallback, children: (0, import_jsx_runtime3.jsx)(CallStatsLatencyChart, { values: latencyBuffer }) }) }), (0, import_jsx_runtime3.jsxs)("div", { className: "str-video__call-stats__header", children: [(0, import_jsx_runtime3.jsxs)("h3", { className: "str-video__call-stats__heading", children: [(0, import_jsx_runtime3.jsx)(Icon, { className: "str-video__call-stats__icon", icon: "network-quality" }), t2("Call performance")] }), (0, import_jsx_runtime3.jsx)("p", { className: "str-video__call-stats__description", children: t2("Review the key data points below to assess call performance") })] }), (0, import_jsx_runtime3.jsxs)("div", { className: "str-video__call-stats__card-container", children: [(0, import_jsx_runtime3.jsx)(StatCard, { label: t2("Region"), value: callStatsReport.datacenter }), (0, import_jsx_runtime3.jsx)(StatCard, { label: t2("Latency"), value: `${callStatsReport.publisherStats.averageRoundTripTimeInMs} ms.`, comparison: latencyComparison }), (0, import_jsx_runtime3.jsx)(StatCard, { label: t2("Receive jitter"), value: `${callStatsReport.subscriberStats.averageJitterInMs} ms.`, comparison: {
    ...latencyComparison,
    value: callStatsReport.subscriberStats.averageJitterInMs
  } }), (0, import_jsx_runtime3.jsx)(StatCard, { label: t2("Publish jitter"), value: `${callStatsReport.publisherStats.averageJitterInMs} ms.`, comparison: {
    ...latencyComparison,
    value: callStatsReport.publisherStats.averageJitterInMs
  } }), (0, import_jsx_runtime3.jsx)(StatCard, { label: `${t2("Publish resolution")}${showCodecInfo ? formatCodec(callStatsReport) : ""}`, value: toFrameSize(callStatsReport.publisherStats) }), (0, import_jsx_runtime3.jsx)(StatCard, { label: t2("Publish quality drop reason"), value: callStatsReport.publisherStats.qualityLimitationReasons }), (0, import_jsx_runtime3.jsx)(StatCard, { label: t2("Receiving resolution"), value: toFrameSize(callStatsReport.subscriberStats) }), (0, import_jsx_runtime3.jsx)(StatCard, { label: t2("Receive quality drop reason"), value: callStatsReport.subscriberStats.qualityLimitationReasons }), (0, import_jsx_runtime3.jsx)(StatCard, { label: t2("Publish bitrate"), value: publishBitrate }), (0, import_jsx_runtime3.jsx)(StatCard, { label: t2("Receiving bitrate"), value: subscribeBitrate })] })] }) });
};
var StatCardExplanation = (props) => {
  const { description } = props;
  const [isOpen, setIsOpen] = (0, import_react4.useState)(false);
  const { refs, floatingStyles, context: context2 } = useFloating2({
    open: isOpen,
    onOpenChange: setIsOpen
  });
  const hover = useHover(context2);
  const { getReferenceProps, getFloatingProps } = useInteractions([hover]);
  return (0, import_jsx_runtime3.jsxs)(import_jsx_runtime3.Fragment, { children: [(0, import_jsx_runtime3.jsx)("div", { className: "str-video__call-explanation", ref: refs.setReference, ...getReferenceProps(), children: (0, import_jsx_runtime3.jsx)(Icon, { className: "str-video__call-explanation__icon", icon: "info" }) }), isOpen && (0, import_jsx_runtime3.jsx)("div", { className: "str-video__call-explanation__description", ref: refs.setFloating, style: floatingStyles, ...getFloatingProps(), children: description })] });
};
var StatsTag = (props) => {
  const { children, status } = props;
  return (0, import_jsx_runtime3.jsx)("div", { className: clsx_default("str-video__call-stats__tag", {
    "str-video__call-stats__tag--good": status === Status.GOOD,
    "str-video__call-stats__tag--ok": status === Status.OK,
    "str-video__call-stats__tag--bad": status === Status.BAD
  }), children: (0, import_jsx_runtime3.jsx)("div", { className: "str-video__call-stats__tag__text", children }) });
};
var StatCard = (props) => {
  const { label, value, description, comparison } = props;
  const { t: t2 } = useI18n();
  const status = comparison ? toStatus(comparison) : void 0;
  return (0, import_jsx_runtime3.jsxs)("div", { className: "str-video__call-stats__card", children: [(0, import_jsx_runtime3.jsxs)("div", { className: "str-video__call-stats__card-content", children: [(0, import_jsx_runtime3.jsxs)("div", { className: "str-video__call-stats__card-label", children: [label, description && (0, import_jsx_runtime3.jsx)(StatCardExplanation, { description })] }), (0, import_jsx_runtime3.jsx)("div", { className: "str-video__call-stats__card-value", children: value })] }), status && (0, import_jsx_runtime3.jsx)(StatsTag, { status, children: t2(status) })] });
};
var toStatus = (config2) => {
  const { value, lowBound, highBound } = config2;
  if (value <= lowBound)
    return Status.GOOD;
  if (value >= lowBound && value <= highBound)
    return Status.OK;
  if (value >= highBound)
    return Status.BAD;
  return Status.GOOD;
};
var toFrameSize = (stats) => {
  const { highestFrameWidth: w, highestFrameHeight: h, highestFramesPerSecond: fps } = stats;
  let size4 = `-`;
  if (w && h) {
    size4 = `${w}x${h}`;
    if (fps) {
      size4 += `@${fps}fps.`;
    }
  }
  return size4;
};
var formatCodec = (callStatsReport) => {
  const { codecPerTrackType } = callStatsReport.publisherStats;
  if (!codecPerTrackType || !codecPerTrackType[models.TrackType.VIDEO]) {
    return "";
  }
  const [, name2] = codecPerTrackType[models.TrackType.VIDEO].split("/");
  return name2 ? ` (${name2})` : "";
};
var calculatePublishBitrate = (previousCallStatsReport, callStatsReport) => {
  const { publisherStats: { totalBytesSent: previousTotalBytesSent, timestamp: previousTimestamp } } = previousCallStatsReport;
  const { publisherStats: { totalBytesSent, timestamp: timestamp2 } } = callStatsReport;
  const bytesSent = totalBytesSent - previousTotalBytesSent;
  const timeElapsed = timestamp2 - previousTimestamp;
  return `${(bytesSent * 8 / timeElapsed).toFixed(2)} kbps`;
};
var calculateSubscribeBitrate = (previousCallStatsReport, callStatsReport) => {
  const { subscriberStats: { totalBytesReceived: previousTotalBytesReceived, timestamp: previousTimestamp } } = previousCallStatsReport;
  const { subscriberStats: { totalBytesReceived, timestamp: timestamp2 } } = callStatsReport;
  const bytesReceived = totalBytesReceived - previousTotalBytesReceived;
  const timeElapsed = timestamp2 - previousTimestamp;
  return `${(bytesReceived * 8 / timeElapsed).toFixed(2)} kbps`;
};
var CallStatsButton = () => (0, import_jsx_runtime3.jsx)(MenuToggle, { placement: "top-end", ToggleButton: ToggleMenuButton, children: (0, import_jsx_runtime3.jsx)(CallStats, {}) });
var ToggleMenuButton = (0, import_react4.forwardRef)(function ToggleMenuButton2(props, ref) {
  const { t: t2 } = useI18n();
  const { caption, menuShown } = props;
  return (0, import_jsx_runtime3.jsx)(CompositeButton, { ref, active: menuShown, caption, title: caption || t2("Statistics"), "data-testid": "stats-button", children: (0, import_jsx_runtime3.jsx)(Icon, { icon: "stats" }) });
});
var ToggleAudioOutputButton = (props) => {
  const { t: t2 } = useI18n();
  const { caption, Menu: Menu2 = DeviceSelectorAudioOutput, menuPlacement = "top", onMenuToggle } = props;
  const [tooltipDisabled, setTooltipDisabled] = (0, import_react4.useState)(false);
  return (0, import_jsx_runtime3.jsx)(WithTooltip, { title: caption || t2("Speakers"), tooltipDisabled, children: (0, import_jsx_runtime3.jsx)(CompositeButton, { Menu: Menu2, menuPlacement, caption, "data-testid": "audio-output-button", onMenuToggle: (shown) => {
    setTooltipDisabled(shown);
    onMenuToggle == null ? void 0 : onMenuToggle(shown);
  }, children: (0, import_jsx_runtime3.jsx)(Icon, { icon: "speaker" }) }) });
};
var BlockedUserListing = ({ data }) => {
  if (!data.length)
    return null;
  return (0, import_jsx_runtime3.jsx)(import_jsx_runtime3.Fragment, { children: (0, import_jsx_runtime3.jsx)("div", { className: "str-video__participant-listing", children: data.map((userId) => (0, import_jsx_runtime3.jsx)(BlockedUserListingItem, { userId }, userId)) }) });
};
var BlockedUserListingItem = ({ userId }) => {
  const call = useCall();
  const unblockUserClickHandler = () => {
    if (userId)
      call == null ? void 0 : call.unblockUser(userId);
  };
  return (0, import_jsx_runtime3.jsxs)("div", { className: "str-video__participant-listing-item", children: [(0, import_jsx_runtime3.jsx)("div", { className: "str-video__participant-listing-item__display-name", children: userId }), (0, import_jsx_runtime3.jsx)(Restricted, { requiredGrants: [OwnCapability.BLOCK_USERS], children: (0, import_jsx_runtime3.jsx)(TextButton, { onClick: unblockUserClickHandler, children: "Unblock" }) })] });
};
var CallParticipantListHeader = ({ onClose }) => {
  const { useParticipants: useParticipants2, useAnonymousParticipantCount: useAnonymousParticipantCount2 } = useCallStateHooks();
  const participants = useParticipants2();
  const anonymousParticipantCount = useAnonymousParticipantCount2();
  const { t: t2 } = useI18n();
  return (0, import_jsx_runtime3.jsxs)("div", { className: "str-video__participant-list-header", children: [(0, import_jsx_runtime3.jsxs)("div", { className: "str-video__participant-list-header__title", children: [t2("Participants"), " ", (0, import_jsx_runtime3.jsxs)("span", { className: "str-video__participant-list-header__title-count", children: ["[", participants.length, "]"] }), anonymousParticipantCount > 0 && (0, import_jsx_runtime3.jsx)("span", { className: "str-video__participant-list-header__title-anonymous", children: t2("Anonymous", { count: anonymousParticipantCount }) })] }), (0, import_jsx_runtime3.jsx)(IconButton, { onClick: onClose, className: "str-video__participant-list-header__close-button", icon: "close" })] });
};
var CallParticipantListingItem = ({ participant, DisplayName = DefaultDisplayName }) => {
  const isAudioOn = hasAudio(participant);
  const isVideoOn = hasVideo(participant);
  const isPinnedOn = isPinned(participant);
  const { t: t2 } = useI18n();
  return (0, import_jsx_runtime3.jsxs)("div", { className: "str-video__participant-listing-item", children: [(0, import_jsx_runtime3.jsx)(Avatar, { name: participant.name, imageSrc: participant.image }), (0, import_jsx_runtime3.jsx)(DisplayName, { participant }), (0, import_jsx_runtime3.jsxs)("div", { className: "str-video__participant-listing-item__media-indicator-group", children: [(0, import_jsx_runtime3.jsx)(MediaIndicator, { title: isAudioOn ? t2("Microphone on") : t2("Microphone off"), className: clsx_default("str-video__participant-listing-item__icon", `str-video__participant-listing-item__icon-${isAudioOn ? "mic" : "mic-off"}`) }), (0, import_jsx_runtime3.jsx)(MediaIndicator, { title: isVideoOn ? t2("Camera on") : t2("Camera off"), className: clsx_default("str-video__participant-listing-item__icon", `str-video__participant-listing-item__icon-${isVideoOn ? "camera" : "camera-off"}`) }), isPinnedOn && (0, import_jsx_runtime3.jsx)(MediaIndicator, { title: t2("Pinned"), className: clsx_default("str-video__participant-listing-item__icon", "str-video__participant-listing-item__icon-pinned") }), (0, import_jsx_runtime3.jsx)(MenuToggle, { placement: "bottom-end", ToggleButton: ToggleButton$2, children: (0, import_jsx_runtime3.jsx)(ParticipantViewContext.Provider, { value: { participant, trackType: "none" }, children: (0, import_jsx_runtime3.jsx)(ParticipantActionsContextMenu, {}) }) })] })] });
};
var MediaIndicator = (props) => (0, import_jsx_runtime3.jsx)(WithTooltip, { ...props });
var DefaultDisplayName = ({ participant }) => {
  const connectedUser = useConnectedUser();
  const { t: t2 } = useI18n();
  const meFlag = participant.userId === (connectedUser == null ? void 0 : connectedUser.id) ? t2("Me") : "";
  const nameOrId = participant.name || participant.userId || t2("Unknown");
  let displayName;
  if (!participant.name) {
    displayName = meFlag || nameOrId || t2("Unknown");
  } else if (meFlag) {
    displayName = `${nameOrId} (${meFlag})`;
  } else {
    displayName = nameOrId;
  }
  return (0, import_jsx_runtime3.jsx)(WithTooltip, { className: "str-video__participant-listing-item__display-name", title: displayName, children: displayName });
};
var ToggleButton$2 = (0, import_react4.forwardRef)(function ToggleButton(props, ref) {
  return (0, import_jsx_runtime3.jsx)(IconButton, { enabled: props.menuShown, icon: "ellipsis", ref });
});
var CallParticipantListing = ({ data }) => (0, import_jsx_runtime3.jsx)("div", { className: "str-video__participant-listing", children: data.map((participant) => (0, import_jsx_runtime3.jsx)(CallParticipantListingItem, { participant }, participant.sessionId)) });
var EmptyParticipantSearchList = () => {
  const { t: t2 } = useI18n();
  return (0, import_jsx_runtime3.jsx)("div", { className: "str-video__participant-list--empty", children: t2("No participants found") });
};
var SearchInput = ({ exitSearch, isActive, ...rest }) => {
  const [inputElement, setInputElement] = (0, import_react4.useState)(null);
  (0, import_react4.useEffect)(() => {
    if (!inputElement)
      return;
    const handleKeyDown = (e) => {
      if (e.key.toLowerCase() === "escape")
        exitSearch();
    };
    inputElement.addEventListener("keydown", handleKeyDown);
    return () => {
      inputElement.removeEventListener("keydown", handleKeyDown);
    };
  }, [exitSearch, inputElement]);
  return (0, import_jsx_runtime3.jsxs)("div", { className: clsx_default("str-video__search-input__container", {
    "str-video__search-input__container--active": isActive
  }), children: [(0, import_jsx_runtime3.jsx)("input", { placeholder: "Search", ...rest, ref: setInputElement }), isActive ? (0, import_jsx_runtime3.jsx)("button", { className: "str-video__search-input__clear-btn", onClick: exitSearch, children: (0, import_jsx_runtime3.jsx)("span", { className: "str-video__search-input__icon--active" }) }) : (0, import_jsx_runtime3.jsx)("span", { className: "str-video__search-input__icon" })] });
};
function SearchResults({ EmptySearchResultComponent, LoadingIndicator: LoadingIndicator$1 = LoadingIndicator, searchQueryInProgress, searchResults, SearchResultList }) {
  if (searchQueryInProgress) {
    return (0, import_jsx_runtime3.jsx)("div", { className: "str-video__search-results--loading", children: (0, import_jsx_runtime3.jsx)(LoadingIndicator$1, {}) });
  }
  if (!searchResults.length) {
    return (0, import_jsx_runtime3.jsx)(EmptySearchResultComponent, {});
  }
  return (0, import_jsx_runtime3.jsx)(SearchResultList, { data: searchResults });
}
var useSearch = ({ debounceInterval, searchFn, searchQuery = "" }) => {
  const [searchResults, setSearchResults] = (0, import_react4.useState)([]);
  const [searchQueryInProgress, setSearchQueryInProgress] = (0, import_react4.useState)(false);
  (0, import_react4.useEffect)(() => {
    if (!searchQuery.length) {
      setSearchQueryInProgress(false);
      setSearchResults([]);
      return;
    }
    setSearchQueryInProgress(true);
    const timeout2 = setTimeout(async () => {
      try {
        const results = await searchFn(searchQuery);
        setSearchResults(results);
      } catch (error2) {
        console.error(error2);
      } finally {
        setSearchQueryInProgress(false);
      }
    }, debounceInterval);
    return () => {
      clearTimeout(timeout2);
    };
  }, [debounceInterval, searchFn, searchQuery]);
  return {
    searchQueryInProgress,
    searchResults
  };
};
var UserListTypes = {
  active: "Active users",
  blocked: "Blocked users"
};
var DEFAULT_DEBOUNCE_SEARCH_INTERVAL = 200;
var CallParticipantsList = ({ onClose, activeUsersSearchFn, blockedUsersSearchFn, debounceSearchInterval }) => {
  const [searchQuery, setSearchQuery] = (0, import_react4.useState)("");
  const [userListType, setUserListType] = (0, import_react4.useState)("active");
  const exitSearch = (0, import_react4.useCallback)(() => setSearchQuery(""), []);
  return (0, import_jsx_runtime3.jsxs)("div", { className: "str-video__participant-list", children: [(0, import_jsx_runtime3.jsx)(CallParticipantListHeader, { onClose }), (0, import_jsx_runtime3.jsx)(SearchInput, { value: searchQuery, onChange: ({ currentTarget }) => setSearchQuery(currentTarget.value), exitSearch, isActive: !!searchQuery }), (0, import_jsx_runtime3.jsx)(CallParticipantListContentHeader, { userListType, setUserListType }), (0, import_jsx_runtime3.jsxs)("div", { className: "str-video__participant-list__content", children: [userListType === "active" && (0, import_jsx_runtime3.jsx)(ActiveUsersSearchResults, { searchQuery, activeUsersSearchFn, debounceSearchInterval }), userListType === "blocked" && (0, import_jsx_runtime3.jsx)(BlockedUsersSearchResults, { searchQuery, blockedUsersSearchFn, debounceSearchInterval })] })] });
};
var CallParticipantListContentHeader = ({ userListType, setUserListType }) => {
  const call = useCall();
  const muteAll = () => {
    call == null ? void 0 : call.muteAllUsers("audio");
  };
  return (0, import_jsx_runtime3.jsxs)("div", { className: "str-video__participant-list__content-header", children: [(0, import_jsx_runtime3.jsx)("div", { className: "str-video__participant-list__content-header-title", children: userListType === "active" && (0, import_jsx_runtime3.jsx)(Restricted, { requiredGrants: [OwnCapability.MUTE_USERS], hasPermissionsOnly: true, children: (0, import_jsx_runtime3.jsx)(TextButton, { onClick: muteAll, children: "Mute all" }) }) }), (0, import_jsx_runtime3.jsx)(MenuToggle, { placement: "bottom-end", ToggleButton: ToggleButton$1, children: (0, import_jsx_runtime3.jsx)(GenericMenu, { children: Object.keys(UserListTypes).map((lt) => (0, import_jsx_runtime3.jsx)(GenericMenuButtonItem, { "aria-selected": lt === userListType, onClick: () => setUserListType(lt), children: UserListTypes[lt] }, lt)) }) })] });
};
var ActiveUsersSearchResults = ({ searchQuery, activeUsersSearchFn: activeUsersSearchFnFromProps, debounceSearchInterval = DEFAULT_DEBOUNCE_SEARCH_INTERVAL }) => {
  const { useParticipants: useParticipants2 } = useCallStateHooks();
  const participants = useParticipants2({ sortBy: name });
  const activeUsersSearchFn = (0, import_react4.useCallback)((queryString) => {
    const queryRegExp = new RegExp(queryString, "i");
    return Promise.resolve(participants.filter((participant) => {
      return participant.name.match(queryRegExp);
    }));
  }, [participants]);
  const { searchQueryInProgress, searchResults } = useSearch({
    searchFn: activeUsersSearchFnFromProps ?? activeUsersSearchFn,
    debounceInterval: debounceSearchInterval,
    searchQuery
  });
  return (0, import_jsx_runtime3.jsx)(SearchResults, { EmptySearchResultComponent: EmptyParticipantSearchList, LoadingIndicator, searchQueryInProgress, searchResults: searchQuery ? searchResults : participants, SearchResultList: CallParticipantListing });
};
var BlockedUsersSearchResults = ({ blockedUsersSearchFn: blockedUsersSearchFnFromProps, debounceSearchInterval = DEFAULT_DEBOUNCE_SEARCH_INTERVAL, searchQuery }) => {
  const { useCallBlockedUserIds: useCallBlockedUserIds2 } = useCallStateHooks();
  const blockedUsers = useCallBlockedUserIds2();
  const blockedUsersSearchFn = (0, import_react4.useCallback)((queryString) => {
    const queryRegExp = new RegExp(queryString, "i");
    return Promise.resolve(blockedUsers.filter((blockedUser) => {
      return blockedUser.match(queryRegExp);
    }));
  }, [blockedUsers]);
  const { searchQueryInProgress, searchResults } = useSearch({
    searchFn: blockedUsersSearchFnFromProps ?? blockedUsersSearchFn,
    debounceInterval: debounceSearchInterval,
    searchQuery
  });
  return (0, import_jsx_runtime3.jsx)(SearchResults, { EmptySearchResultComponent: EmptyParticipantSearchList, LoadingIndicator, searchQueryInProgress, searchResults: searchQuery ? searchResults : blockedUsers, SearchResultList: BlockedUserListing });
};
var ToggleButton$1 = (0, import_react4.forwardRef)(function ToggleButton2(props, ref) {
  return (0, import_jsx_runtime3.jsx)(IconButton, { enabled: props.menuShown, icon: "filter", ref });
});
var CallPreview = (props) => {
  const { className, style } = props;
  const call = useCall();
  const { useCallThumbnail: useCallThumbnail2 } = useCallStateHooks();
  const thumbnail = useCallThumbnail2();
  const [imageRef, setImageRef] = (0, import_react4.useState)(null);
  (0, import_react4.useEffect)(() => {
    if (!imageRef || !call)
      return;
    const cleanup2 = call.bindCallThumbnailElement(imageRef);
    return () => cleanup2();
  }, [imageRef, call]);
  if (!thumbnail)
    return null;
  return (0, import_jsx_runtime3.jsx)("img", { className: clsx_default("str-video__call-preview", className), style, alt: "Call Preview Thumbnail", ref: setImageRef });
};
var CallRecordingListHeader = ({ callRecordings, onRefresh }) => {
  const { t: t2 } = useI18n();
  return (0, import_jsx_runtime3.jsxs)("div", { className: "str-video__call-recording-list__header", children: [(0, import_jsx_runtime3.jsxs)("div", { className: "str-video__call-recording-list__title", children: [(0, import_jsx_runtime3.jsx)("span", { children: t2("Call Recordings") }), callRecordings.length ? (0, import_jsx_runtime3.jsxs)("span", { children: ["(", callRecordings.length, ")"] }) : null] }), onRefresh && (0, import_jsx_runtime3.jsx)(IconButton, { icon: "refresh", title: t2("Refresh"), onClick: onRefresh })] });
};
var dateFormat = (date) => {
  const format = new Date(date);
  return format.toTimeString().split(" ")[0];
};
var CallRecordingListItem = ({ recording }) => {
  return (0, import_jsx_runtime3.jsxs)("li", { className: "str-video__call-recording-list__item", children: [(0, import_jsx_runtime3.jsx)("div", { className: "str-video__call-recording-list__table-cell str-video__call-recording-list__filename", children: recording.filename }), (0, import_jsx_runtime3.jsx)("div", { className: "str-video__call-recording-list__table-cell str-video__call-recording-list__time", children: dateFormat(recording.start_time) }), (0, import_jsx_runtime3.jsx)("div", { className: "str-video__call-recording-list__table-cell str-video__call-recording-list__time", children: dateFormat(recording.end_time) }), (0, import_jsx_runtime3.jsx)("div", { className: "str-video__call-recording-list__table-cell str-video__call-recording-list__download", children: (0, import_jsx_runtime3.jsx)("a", { className: clsx_default("str-video__call-recording-list-item__action-button", "str-video__call-recording-list-item__action-button--download"), role: "button", href: recording.url, download: recording.filename, title: "Download the recording", children: (0, import_jsx_runtime3.jsx)(Icon, { icon: "download" }) }) })] });
};
var EmptyCallRecordingListing = () => {
  return (0, import_jsx_runtime3.jsxs)("div", { className: "str-video__call-recording-list__listing str-video__call-recording-list__listing--empty", children: [(0, import_jsx_runtime3.jsx)("div", { className: "str-video__call-recording-list__listing--icon-empty" }), (0, import_jsx_runtime3.jsx)("p", { className: "str-video__call-recording-list__listing--text-empty", children: "No recordings available" })] });
};
var LoadingCallRecordingListing = ({ callRecordings }) => {
  return (0, import_jsx_runtime3.jsxs)(import_jsx_runtime3.Fragment, { children: [callRecordings.map((recording) => (0, import_jsx_runtime3.jsx)(CallRecordingListItem, { recording }, recording.filename)), (0, import_jsx_runtime3.jsx)(LoadingIndicator, { text: "Recording getting ready" })] });
};
var CallRecordingList = ({ callRecordings, CallRecordingListHeader: CallRecordingListHeader$1 = CallRecordingListHeader, CallRecordingListItem: CallRecordingListItem$1 = CallRecordingListItem, EmptyCallRecordingList = EmptyCallRecordingListing, loading, LoadingCallRecordingList = LoadingCallRecordingListing, onRefresh }) => {
  return (0, import_jsx_runtime3.jsxs)("div", { className: "str-video__call-recording-list", children: [(0, import_jsx_runtime3.jsx)(CallRecordingListHeader$1, { callRecordings, onRefresh }), (0, import_jsx_runtime3.jsx)("div", { className: "str-video__call-recording-list__listing", children: loading ? (0, import_jsx_runtime3.jsx)(LoadingCallRecordingList, { callRecordings }) : callRecordings.length ? (0, import_jsx_runtime3.jsxs)(import_jsx_runtime3.Fragment, { children: [(0, import_jsx_runtime3.jsx)("ul", { className: "str-video__call-recording-list__list", children: (0, import_jsx_runtime3.jsxs)("li", { className: "str-video__call-recording-list__item", children: [(0, import_jsx_runtime3.jsx)("div", { className: "str-video__call-recording-list__filename", children: "Name" }), (0, import_jsx_runtime3.jsx)("div", { className: "str-video__call-recording-list__time", children: "Start time" }), (0, import_jsx_runtime3.jsx)("div", { className: "str-video__call-recording-list__time", children: "End time" }), (0, import_jsx_runtime3.jsx)("div", { className: "str-video__call-recording-list__download" })] }) }), (0, import_jsx_runtime3.jsx)("ul", { className: "str-video__call-recording-list__list", children: callRecordings.map((recording) => (0, import_jsx_runtime3.jsx)(CallRecordingListItem$1, { recording }, recording.filename)) })] }) : (0, import_jsx_runtime3.jsx)(EmptyCallRecordingList, {}) })] });
};
var NoiseCancellationContext = (0, import_react4.createContext)(null);
var useNoiseCancellation = () => {
  const context2 = (0, import_react4.useContext)(NoiseCancellationContext);
  if (!context2) {
    throw new Error("useNoiseCancellation must be used within a NoiseCancellationProvider");
  }
  return context2;
};
var NoiseCancellationProvider = (props) => {
  const { children, noiseCancellation } = props;
  const call = useCall();
  const { useCallSettings: useCallSettings2, useHasPermissions: useHasPermissions2 } = useCallStateHooks();
  const settings = useCallSettings2();
  const noiseCancellationAllowed = !!(settings && settings.audio.noise_cancellation && settings.audio.noise_cancellation.mode !== NoiseCancellationSettingsModeEnum.DISABLED);
  const hasCapability = useHasPermissions2(OwnCapability.ENABLE_NOISE_CANCELLATION);
  const [isSupportedByBrowser, setIsSupportedByBrowser] = (0, import_react4.useState)(void 0);
  (0, import_react4.useEffect)(() => {
    const result = noiseCancellation.isSupported();
    if (typeof result === "boolean") {
      setIsSupportedByBrowser(result);
    } else {
      result.then((_isSupportedByBrowser) => setIsSupportedByBrowser(_isSupportedByBrowser)).catch((err) => console.error(`Can't determine if noise cancellation is supported`, err));
    }
  }, [noiseCancellation]);
  const isSupported = isSupportedByBrowser && hasCapability && noiseCancellationAllowed;
  const [isEnabled, setIsEnabled] = (0, import_react4.useState)(false);
  const deinit = (0, import_react4.useRef)();
  (0, import_react4.useEffect)(() => {
    if (!call || !isSupported)
      return;
    const unsubscribe = noiseCancellation.on("change", (v) => setIsEnabled(v));
    const init2 = (deinit.current || Promise.resolve()).then(() => noiseCancellation.init()).then(() => call.microphone.enableNoiseCancellation(noiseCancellation)).catch((err) => console.error(`Can't initialize noise suppression`, err));
    return () => {
      deinit.current = init2.then(() => call.microphone.disableNoiseCancellation()).then(() => noiseCancellation.dispose()).then(() => unsubscribe());
    };
  }, [call, isSupported, noiseCancellation]);
  return (0, import_jsx_runtime3.jsx)(NoiseCancellationContext.Provider, { value: {
    isSupported,
    isEnabled,
    setEnabled: (enabledOrSetter) => {
      if (!noiseCancellation)
        return;
      const enable = typeof enabledOrSetter === "function" ? enabledOrSetter(isEnabled) : enabledOrSetter;
      if (enable) {
        noiseCancellation.enable();
      } else {
        noiseCancellation.disable();
      }
    }
  }, children });
};
var RingingCallControls = () => {
  const call = useCall();
  const { useCallCallingState: useCallCallingState2 } = useCallStateHooks();
  const callCallingState = useCallCallingState2();
  if (!call)
    return null;
  const buttonsDisabled = callCallingState !== CallingState.RINGING;
  return (0, import_jsx_runtime3.jsx)("div", { className: "str-video__pending-call-controls", children: call.isCreatedByMe ? (0, import_jsx_runtime3.jsx)(CancelCallButton, { disabled: buttonsDisabled }) : (0, import_jsx_runtime3.jsxs)(import_jsx_runtime3.Fragment, { children: [(0, import_jsx_runtime3.jsx)(AcceptCallButton, { disabled: buttonsDisabled }), (0, import_jsx_runtime3.jsx)(CancelCallButton, { onClick: () => {
    const reason = call.isCreatedByMe ? "cancel" : "decline";
    call.leave({ reject: true, reason });
  }, disabled: buttonsDisabled })] }) });
};
var CALLING_STATE_TO_LABEL = {
  [CallingState.JOINING]: "Joining",
  [CallingState.RINGING]: "Ringing",
  [CallingState.MIGRATING]: "Migrating",
  [CallingState.RECONNECTING]: "Re-connecting",
  [CallingState.RECONNECTING_FAILED]: "Failed",
  [CallingState.OFFLINE]: "No internet connection",
  [CallingState.IDLE]: "",
  [CallingState.UNKNOWN]: "",
  [CallingState.JOINED]: "Joined",
  [CallingState.LEFT]: "Left call"
};
var RingingCall = (props) => {
  const { includeSelf = false, totalMembersToShow = 3 } = props;
  const call = useCall();
  const { t: t2 } = useI18n();
  const { useCallCallingState: useCallCallingState2, useCallMembers: useCallMembers2 } = useCallStateHooks();
  const callingState = useCallCallingState2();
  const members = useCallMembers2();
  const connectedUser = useConnectedUser();
  if (!call)
    return null;
  const membersToShow = (members || []).slice(0, totalMembersToShow).map(({ user }) => user).filter((user) => user.id !== (connectedUser == null ? void 0 : connectedUser.id) || includeSelf);
  if (includeSelf && !membersToShow.find((user) => user.id === (connectedUser == null ? void 0 : connectedUser.id))) {
    const self = members.find(({ user }) => user.id === (connectedUser == null ? void 0 : connectedUser.id));
    if (self) {
      membersToShow.splice(0, 1, self.user);
    }
  }
  const callingStateLabel = CALLING_STATE_TO_LABEL[callingState];
  return (0, import_jsx_runtime3.jsxs)("div", { className: "str-video__call-panel str-video__call-panel--ringing", children: [(0, import_jsx_runtime3.jsx)("div", { className: "str-video__call-panel__members-list", children: membersToShow.map((user) => (0, import_jsx_runtime3.jsxs)("div", { className: "str-video__call-panel__member-box", children: [(0, import_jsx_runtime3.jsx)(Avatar, { name: user.name, imageSrc: user.image }), user.name && (0, import_jsx_runtime3.jsx)("div", { className: "str-video__member_details", children: (0, import_jsx_runtime3.jsx)("span", { className: "str-video__member_name", children: user.name }) })] }, user.id)) }), callingStateLabel && (0, import_jsx_runtime3.jsx)("div", { className: "str-video__call-panel__calling-state-label", children: t2(callingStateLabel) }), [CallingState.RINGING, CallingState.JOINING].includes(callingState) && (0, import_jsx_runtime3.jsx)(RingingCallControls, {})] });
};
var byNameOrId = (a, b) => {
  if (a.name && b.name && a.name < b.name)
    return -1;
  if (a.name && b.name && a.name > b.name)
    return 1;
  if (a.id < b.id)
    return -1;
  if (a.id > b.id)
    return 1;
  return 0;
};
var PermissionRequests = () => {
  const call = useCall();
  const { useLocalParticipant: useLocalParticipant2, useHasPermissions: useHasPermissions2 } = useCallStateHooks();
  const localParticipant = useLocalParticipant2();
  const [expanded, setExpanded] = (0, import_react4.useState)(false);
  const [permissionRequests, setPermissionRequests] = (0, import_react4.useState)([]);
  const canUpdateCallPermissions = useHasPermissions2(OwnCapability.UPDATE_CALL_PERMISSIONS);
  const localUserId = localParticipant == null ? void 0 : localParticipant.userId;
  (0, import_react4.useEffect)(() => {
    if (!call || !canUpdateCallPermissions)
      return;
    return call.on("call.permission_request", (event) => {
      if (event.user.id !== localUserId) {
        setPermissionRequests((requests) => [...requests, event].sort((a, b) => byNameOrId(a.user, b.user)));
      }
    });
  }, [call, canUpdateCallPermissions, localUserId]);
  const handleUpdatePermission = (request, type) => {
    return async () => {
      const { user, permissions } = request;
      switch (type) {
        case "grant":
          await (call == null ? void 0 : call.grantPermissions(user.id, permissions));
          break;
        case "revoke":
          await (call == null ? void 0 : call.revokePermissions(user.id, permissions));
          break;
      }
      setPermissionRequests((requests) => requests.filter((r) => r !== request));
    };
  };
  const { refs, x, y, strategy } = useFloatingUIPreset({
    placement: "bottom",
    strategy: "absolute"
  });
  if (permissionRequests.length === 0)
    return null;
  return (0, import_jsx_runtime3.jsxs)("div", { className: "str-video__permission-requests", ref: refs.setReference, children: [(0, import_jsx_runtime3.jsxs)("div", { className: "str-video__permission-requests__notification", children: [(0, import_jsx_runtime3.jsxs)("span", { className: "str-video__permission-requests__notification__message", children: [permissionRequests.length, " pending permission requests"] }), (0, import_jsx_runtime3.jsx)(Button, { type: "button", onClick: () => {
    setExpanded((e) => !e);
  }, children: expanded ? "Hide requests" : "Show requests" })] }), expanded && (0, import_jsx_runtime3.jsx)(PermissionRequestList, { ref: refs.setFloating, style: {
    position: strategy,
    top: y ?? 0,
    left: x ?? 0,
    overflowY: "auto"
  }, permissionRequests, handleUpdatePermission })] });
};
var PermissionRequestList = (0, import_react4.forwardRef)(function PermissionRequestList2(props, ref) {
  const { permissionRequests, handleUpdatePermission, ...rest } = props;
  const { t: t2 } = useI18n();
  return (0, import_jsx_runtime3.jsx)("div", { className: "str-video__permission-requests-list", ref, ...rest, children: permissionRequests.map((request, reqIndex) => {
    const { user, permissions } = request;
    return (0, import_jsx_runtime3.jsx)(import_react4.Fragment, { children: permissions.map((permission) => (0, import_jsx_runtime3.jsxs)("div", { className: "str-video__permission-request", children: [(0, import_jsx_runtime3.jsx)("div", { className: "str-video__permission-request__message", children: messageForPermission(user.name || user.id, permission, t2) }), (0, import_jsx_runtime3.jsx)(Button, { className: "str-video__permission-request__button--allow", type: "button", onClick: handleUpdatePermission(request, "grant"), children: t2("Allow") }), (0, import_jsx_runtime3.jsx)(Button, { className: "str-video__permission-request__button--reject", type: "button", onClick: handleUpdatePermission(request, "revoke"), children: t2("Revoke") }), (0, import_jsx_runtime3.jsx)(Button, { className: "str-video__permission-request__button--reject", type: "button", onClick: handleUpdatePermission(request, "dismiss"), children: t2("Dismiss") })] }, permission)) }, `${user.id}/${reqIndex}`);
  }) });
});
var Button = (props) => {
  const { className, ...rest } = props;
  return (0, import_jsx_runtime3.jsx)("button", { className: clsx_default("str-video__permission-request__button", className), ...rest });
};
var messageForPermission = (userName, permission, t2) => {
  switch (permission) {
    case OwnCapability.SEND_AUDIO:
      return t2("{{ userName }} is requesting to speak", { userName });
    case OwnCapability.SEND_VIDEO:
      return t2("{{ userName }} is requesting to share their camera", {
        userName
      });
    case OwnCapability.SCREENSHARE:
      return t2("{{ userName }} is requesting to present their screen", {
        userName
      });
    default:
      return t2("{{ userName }} is requesting permission: {{ permission }}", {
        userName,
        permission
      });
  }
};
var StreamTheme = ({ as: Component = "div", className, children, ...props }) => {
  return (0, import_jsx_runtime3.jsx)(Component, { ...props, className: clsx_default("str-video", className), children });
};
var DefaultDisabledVideoPreview = () => {
  const { t: t2 } = useI18n();
  return (0, import_jsx_runtime3.jsx)("div", { className: "str_video__video-preview__disabled-video-preview", children: t2("Video is disabled") });
};
var DefaultNoCameraPreview = () => {
  const { t: t2 } = useI18n();
  return (0, import_jsx_runtime3.jsx)("div", { className: "str_video__video-preview__no-camera-preview", children: t2("No camera found") });
};
var VideoPreview = ({ className, mirror = true, DisabledVideoPreview = DefaultDisabledVideoPreview, NoCameraPreview = DefaultNoCameraPreview, StartingCameraPreview = LoadingIndicator }) => {
  const { useCameraState: useCameraState2 } = useCallStateHooks();
  const { devices, status, isMute, mediaStream } = useCameraState2();
  let contents;
  if (isMute && (devices == null ? void 0 : devices.length) === 0) {
    contents = (0, import_jsx_runtime3.jsx)(NoCameraPreview, {});
  } else if (status === "enabled") {
    const loading = !mediaStream;
    contents = (0, import_jsx_runtime3.jsxs)(import_jsx_runtime3.Fragment, { children: [mediaStream && (0, import_jsx_runtime3.jsx)(BaseVideo, { stream: mediaStream, className: clsx_default("str-video__video-preview", {
      "str-video__video-preview--mirror": mirror,
      "str-video__video-preview--loading": loading
    }) }), loading && (0, import_jsx_runtime3.jsx)(StartingCameraPreview, {})] });
  } else {
    contents = (0, import_jsx_runtime3.jsx)(DisabledVideoPreview, {});
  }
  return (0, import_jsx_runtime3.jsx)("div", { className: clsx_default("str-video__video-preview-container", className), children: contents });
};
var ToggleButton3 = (0, import_react4.forwardRef)(function ToggleButton4(props, ref) {
  return (0, import_jsx_runtime3.jsx)(IconButton, { enabled: props.menuShown, icon: "ellipsis", ref });
});
var DefaultScreenShareOverlay = () => {
  const call = useCall();
  const { t: t2 } = useI18n();
  const stopScreenShare = () => {
    call == null ? void 0 : call.screenShare.disable();
  };
  return (0, import_jsx_runtime3.jsxs)("div", { className: "str-video__screen-share-overlay", children: [(0, import_jsx_runtime3.jsx)(Icon, { icon: "screen-share-off" }), (0, import_jsx_runtime3.jsx)("span", { className: "str-video__screen-share-overlay__title", children: t2("You are presenting your screen") }), (0, import_jsx_runtime3.jsxs)("button", { onClick: stopScreenShare, className: "str-video__screen-share-overlay__button", children: [(0, import_jsx_runtime3.jsx)(Icon, { icon: "close" }), " ", t2("Stop Screen Sharing")] })] });
};
var DefaultParticipantViewUI = ({ indicatorsVisible = true, menuPlacement = "bottom-start", showMenuButton = true, ParticipantActionsContextMenu: ParticipantActionsContextMenu$1 = ParticipantActionsContextMenu }) => {
  const { participant, trackType } = useParticipantViewContext();
  const isScreenSharing = hasScreenShare(participant);
  if (participant.isLocalParticipant && isScreenSharing && trackType === "screenShareTrack") {
    return (0, import_jsx_runtime3.jsxs)(import_jsx_runtime3.Fragment, { children: [(0, import_jsx_runtime3.jsx)(DefaultScreenShareOverlay, {}), (0, import_jsx_runtime3.jsx)(ParticipantDetails, { indicatorsVisible })] });
  }
  return (0, import_jsx_runtime3.jsxs)(import_jsx_runtime3.Fragment, { children: [showMenuButton && (0, import_jsx_runtime3.jsx)(MenuToggle, { strategy: "fixed", placement: menuPlacement, ToggleButton: ToggleButton3, children: (0, import_jsx_runtime3.jsx)(ParticipantActionsContextMenu$1, {}) }), (0, import_jsx_runtime3.jsx)(Reaction, { participant }), (0, import_jsx_runtime3.jsx)(ParticipantDetails, { indicatorsVisible })] });
};
var ParticipantDetails = ({ indicatorsVisible = true }) => {
  const { participant } = useParticipantViewContext();
  const { isLocalParticipant, connectionQuality, pin, sessionId, name: name2, userId } = participant;
  const call = useCall();
  const { t: t2 } = useI18n();
  const connectionQualityAsString = !!connectionQuality && models.ConnectionQuality[connectionQuality].toLowerCase();
  const hasAudioTrack = hasAudio(participant);
  const hasVideoTrack = hasVideo(participant);
  const canUnpin = !!pin && pin.isLocalPin;
  return (0, import_jsx_runtime3.jsxs)(import_jsx_runtime3.Fragment, { children: [(0, import_jsx_runtime3.jsx)("div", { className: "str-video__participant-details", children: (0, import_jsx_runtime3.jsxs)("span", { className: "str-video__participant-details__name", children: [name2 || userId, indicatorsVisible && !hasAudioTrack && (0, import_jsx_runtime3.jsx)("span", { className: "str-video__participant-details__name--audio-muted" }), indicatorsVisible && !hasVideoTrack && (0, import_jsx_runtime3.jsx)("span", { className: "str-video__participant-details__name--video-muted" }), indicatorsVisible && canUnpin && // TODO: remove this monstrosity once we have a proper design
  (0, import_jsx_runtime3.jsx)("span", { title: t2("Unpin"), onClick: () => call == null ? void 0 : call.unpin(sessionId), className: "str-video__participant-details__name--pinned" }), indicatorsVisible && (0, import_jsx_runtime3.jsx)(SpeechIndicator, {})] }) }), indicatorsVisible && (0, import_jsx_runtime3.jsx)(Notification2, { isVisible: isLocalParticipant && connectionQuality === models.ConnectionQuality.POOR, message: t2("Poor connection quality"), children: connectionQualityAsString && (0, import_jsx_runtime3.jsx)("span", { className: clsx_default("str-video__participant-details__connection-quality", `str-video__participant-details__connection-quality--${connectionQualityAsString}`), title: connectionQualityAsString }) })] });
};
var SpeechIndicator = () => {
  const { participant } = useParticipantViewContext();
  const { isSpeaking, isDominantSpeaker } = participant;
  return (0, import_jsx_runtime3.jsxs)("span", { className: clsx_default("str-video__speech-indicator", isSpeaking && "str-video__speech-indicator--speaking", isDominantSpeaker && "str-video__speech-indicator--dominant"), children: [(0, import_jsx_runtime3.jsx)("span", { className: "str-video__speech-indicator__bar" }), (0, import_jsx_runtime3.jsx)("span", { className: "str-video__speech-indicator__bar" }), (0, import_jsx_runtime3.jsx)("span", { className: "str-video__speech-indicator__bar" })] });
};
var ParticipantView = (0, import_react4.forwardRef)(function ParticipantView2({ participant, trackType = "videoTrack", mirror, muteAudio, refs: { setVideoElement, setVideoPlaceholderElement } = {}, className, VideoPlaceholder, PictureInPicturePlaceholder, ParticipantViewUI = DefaultParticipantViewUI }, ref) {
  const { isLocalParticipant, isSpeaking, isDominantSpeaker, sessionId } = participant;
  const hasAudioTrack = hasAudio(participant);
  const hasVideoTrack = hasVideo(participant);
  const hasScreenShareAudioTrack = hasScreenShareAudio(participant);
  const [trackedElement, setTrackedElement] = (0, import_react4.useState)(null);
  const [contextVideoElement, setContextVideoElement] = (0, import_react4.useState)(null);
  const [contextVideoPlaceholderElement, setContextVideoPlaceholderElement] = (0, import_react4.useState)(null);
  useTrackElementVisibility({
    sessionId,
    trackedElement,
    trackType
  });
  const { useIncomingVideoSettings: useIncomingVideoSettings2 } = useCallStateHooks();
  const { isParticipantVideoEnabled } = useIncomingVideoSettings2();
  const participantViewContextValue = (0, import_react4.useMemo)(() => ({
    participant,
    participantViewElement: trackedElement,
    videoElement: contextVideoElement,
    videoPlaceholderElement: contextVideoPlaceholderElement,
    trackType
  }), [
    contextVideoElement,
    contextVideoPlaceholderElement,
    participant,
    trackedElement,
    trackType
  ]);
  const videoRefs = (0, import_react4.useMemo)(() => ({
    setVideoElement: (element) => {
      setVideoElement == null ? void 0 : setVideoElement(element);
      setContextVideoElement(element);
    },
    setVideoPlaceholderElement: (element) => {
      setVideoPlaceholderElement == null ? void 0 : setVideoPlaceholderElement(element);
      setContextVideoPlaceholderElement(element);
    }
  }), [setVideoElement, setVideoPlaceholderElement]);
  return (0, import_jsx_runtime3.jsx)("div", { "data-testid": "participant-view", ref: (element) => {
    applyElementToRef(ref, element);
    setTrackedElement(element);
  }, className: clsx_default("str-video__participant-view", isDominantSpeaker && "str-video__participant-view--dominant-speaker", isSpeaking && "str-video__participant-view--speaking", !hasVideoTrack && "str-video__participant-view--no-video", !hasAudioTrack && "str-video__participant-view--no-audio", className), children: (0, import_jsx_runtime3.jsxs)(ParticipantViewContext.Provider, { value: participantViewContextValue, children: [!isLocalParticipant && !muteAudio && (0, import_jsx_runtime3.jsxs)(import_jsx_runtime3.Fragment, { children: [hasAudioTrack && (0, import_jsx_runtime3.jsx)(Audio, { participant, trackType: "audioTrack" }), hasScreenShareAudioTrack && (0, import_jsx_runtime3.jsx)(Audio, { participant, trackType: "screenShareAudioTrack" })] }), (0, import_jsx_runtime3.jsx)(Video$1, { VideoPlaceholder, PictureInPicturePlaceholder, participant, trackType, refs: videoRefs, enabled: isLocalParticipant || trackType !== "videoTrack" || isParticipantVideoEnabled(participant.sessionId), mirror, autoPlay: true }), isComponentType(ParticipantViewUI) ? (0, import_jsx_runtime3.jsx)(ParticipantViewUI, {}) : ParticipantViewUI] }) });
});
ParticipantView.displayName = "ParticipantView";
var StreamCall = StreamCallProvider;
StreamCall.displayName = "StreamCall";
var Joining = "Joining";
var Mic = "Mic";
var Ringing = "Ringing";
var Speakers = "Speakers";
var Video = "Video";
var Live = "Live";
var Reactions = "Reactions";
var Statistics = "Statistics";
var Invite = "Invite";
var Join = "Join";
var You = "You";
var Me = "Me";
var Unknown = "Unknown";
var Default = "Default";
var Refresh = "Refresh";
var Allow = "Allow";
var Revoke = "Revoke";
var Dismiss = "Dismiss";
var Pinned = "Pinned";
var Unpin = "Unpin";
var Pin2 = "Pin";
var Block = "Block";
var Enter = "Enter";
var Leave = "Leave";
var Participants = "Participants";
var Anonymous = ", and ({{ count }}) anonymous";
var en = {
  Joining,
  Mic,
  "No internet connection": "No internet connection",
  "Re-connecting": "Re-connecting",
  Ringing,
  "Screen Share": "Screen Share",
  "Select a Camera": "Select a Camera",
  "Select a Mic": "Select a Mic",
  "Select Speakers": "Select Speakers",
  Speakers,
  Video,
  "You are muted. Unmute to speak.": "You are muted. Unmute to speak.",
  Live,
  "You can now speak.": "You can now speak.",
  "Awaiting for an approval to speak.": "Awaiting for an approval to speak.",
  "You can no longer speak.": "You can no longer speak.",
  "You can now share your video.": "You can now share your video.",
  "Awaiting for an approval to share your video.": "Awaiting for an approval to share your video.",
  "You can no longer share your video.": "You can no longer share your video.",
  "Waiting for recording to stop...": "Waiting for recording to stop...",
  "Waiting for recording to start...": "Waiting for recording to start...",
  "Record call": "Record call",
  Reactions,
  Statistics,
  "You can now share your screen.": "You can now share your screen.",
  "Awaiting for an approval to share screen.": "Awaiting for an approval to share screen.",
  "You can no longer share your screen.": "You can no longer share your screen.",
  "Share screen": "Share screen",
  "Incoming Call...": "Incoming Call...",
  "Calling...": "Calling...",
  "Mute All": "Mute All",
  Invite,
  Join,
  You,
  Me,
  Unknown,
  "Toggle device menu": "Toggle device menu",
  Default,
  "Call Recordings": "Call Recordings",
  Refresh,
  "Check your browser video permissions": "Check your browser video permissions",
  "Video publishing is disabled by the system": "Video publishing is disabled by the system",
  "You have no permission to share your video": "You have no permission to share your video",
  "You have no permission to share your audio": "You have no permission to share your audio",
  "You are presenting your screen": "You are presenting your screen",
  "Stop Screen Sharing": "Stop Screen Sharing",
  Allow,
  Revoke,
  Dismiss,
  "Microphone on": "Microphone on",
  "Microphone off": "Microphone off",
  "Camera on": "Camera on",
  "Camera off": "Camera off",
  "No camera found": "No camera found",
  "Video is disabled": "Video is disabled",
  Pinned,
  Unpin,
  Pin: Pin2,
  "Pin for everyone": "Pin for everyone",
  "Unpin for everyone": "Unpin for everyone",
  Block,
  "Turn off video": "Turn off video",
  "Turn off screen share": "Turn off screen share",
  "Mute audio": "Mute audio",
  "Mute screen share audio": "Mute screen share audio",
  "Allow audio": "Allow audio",
  "Allow video": "Allow video",
  "Allow screen sharing": "Allow screen sharing",
  "Disable audio": "Disable audio",
  "Disable video": "Disable video",
  "Disable screen sharing": "Disable screen sharing",
  Enter,
  Leave,
  "Leave call": "Leave call",
  "End call for all": "End call for all",
  "{{ direction }} fullscreen": "{{ direction }} fullscreen",
  "{{ direction }} picture-in-picture": "{{ direction }} picture-in-picture",
  "Dominant Speaker": "Dominant Speaker",
  "Poor connection quality": "Poor connection quality. Please check your internet connection.",
  Participants,
  Anonymous,
  "No participants found": "No participants found",
  "Participants ({{ numberOfParticipants }})": "Participants ({{ numberOfParticipants }})",
  "{{ userName }} is sharing their screen": "{{ userName }} is sharing their screen",
  "{{ userName }} is requesting to speak": "{{ userName }} is requesting to speak",
  "{{ userName }} is requesting to share their camera": "{{ userName }} is requesting to share their camera",
  "{{ userName }} is requesting to present their screen": "{{ userName }} is requesting to present their screen",
  "{{ userName }} is requesting permission: {{ permission }}": "{{ userName }} is requesting permission: {{ permission }}"
};
var translations = { en };
var StreamVideo = (props) => {
  return (0, import_jsx_runtime3.jsx)(StreamVideoProvider, { translationsOverrides: translations, ...props });
};
StreamVideo.displayName = "StreamVideo";
function applyFilter(obj, filter2) {
  if ("$and" in filter2) {
    return filter2.$and.every((f) => applyFilter(obj, f));
  }
  if ("$or" in filter2) {
    return filter2.$or.some((f) => applyFilter(obj, f));
  }
  if ("$not" in filter2) {
    return !applyFilter(obj, filter2.$not);
  }
  return checkConditions(obj, filter2);
}
function checkConditions(obj, conditions) {
  let match = true;
  for (const key of Object.keys(conditions)) {
    const operator = conditions[key];
    const maybeOperator = operator && typeof operator === "object";
    const value = obj[key];
    if (maybeOperator && "$eq" in operator) {
      const eqOperator = operator;
      match && (match = eqOperator.$eq === value);
    } else if (maybeOperator && "$neq" in operator) {
      const neqOperator = operator;
      match && (match = neqOperator.$neq !== value);
    } else if (maybeOperator && "$in" in operator) {
      const inOperator = operator;
      match && (match = inOperator.$in.includes(value));
    } else if (maybeOperator && "$contains" in operator) {
      if (Array.isArray(value)) {
        const containsOperator = operator;
        match && (match = value.includes(containsOperator.$contains));
      } else {
        match = false;
      }
    } else {
      const eqValue = operator;
      match && (match = eqValue === value);
    }
    if (!match) {
      return false;
    }
  }
  return true;
}
var useFilteredParticipants = ({ excludeLocalParticipant = false, filterParticipants }) => {
  const { useParticipants: useParticipants2, useRemoteParticipants: useRemoteParticipants2 } = useCallStateHooks();
  const allParticipants = useParticipants2();
  const remoteParticipants = useRemoteParticipants2();
  return (0, import_react4.useMemo)(() => {
    const unfilteredParticipants = excludeLocalParticipant ? remoteParticipants : allParticipants;
    return filterParticipants ? applyParticipantsFilter(unfilteredParticipants, filterParticipants) : unfilteredParticipants;
  }, [
    allParticipants,
    remoteParticipants,
    excludeLocalParticipant,
    filterParticipants
  ]);
};
var applyParticipantsFilter = (participants, filter2) => {
  const filterCallback = typeof filter2 === "function" ? filter2 : (participant) => applyFilter({
    userId: participant.userId,
    isSpeaking: participant.isSpeaking,
    isDominantSpeaker: participant.isDominantSpeaker,
    name: participant.name,
    roles: participant.roles,
    isPinned: isPinned(participant),
    hasVideo: hasVideo(participant),
    hasAudio: hasAudio(participant)
  }, filter2);
  return participants.filter(filterCallback);
};
var usePaginatedLayoutSortPreset = (call) => {
  (0, import_react4.useEffect)(() => {
    if (!call)
      return;
    call.setSortParticipantsBy(paginatedLayoutSortPreset);
    return () => {
      resetSortPreset(call);
    };
  }, [call]);
};
var useSpeakerLayoutSortPreset = (call, isOneOnOneCall) => {
  (0, import_react4.useEffect)(() => {
    if (!call)
      return;
    if (isOneOnOneCall) {
      call.setSortParticipantsBy(combineComparators(screenSharing, loggedIn));
    } else {
      call.setSortParticipantsBy(speakerLayoutSortPreset);
    }
    return () => {
      resetSortPreset(call);
    };
  }, [call, isOneOnOneCall]);
};
var resetSortPreset = (call) => {
  const callConfig = CallTypes.get(call.type);
  call.setSortParticipantsBy(callConfig.options.sortParticipantsBy || defaultSortPreset);
};
var loggedIn = (a, b) => {
  if (a.isLocalParticipant)
    return 1;
  if (b.isLocalParticipant)
    return -1;
  return 0;
};
var LivestreamLayout = (props) => {
  const { useParticipants: useParticipants2, useRemoteParticipants: useRemoteParticipants2, useHasOngoingScreenShare: useHasOngoingScreenShare2 } = useCallStateHooks();
  const call = useCall();
  const participants = useParticipants2();
  const [currentSpeaker] = participants;
  const remoteParticipants = useRemoteParticipants2();
  const hasOngoingScreenShare = useHasOngoingScreenShare2();
  const presenter = hasOngoingScreenShare ? participants.find(hasScreenShare) : void 0;
  usePaginatedLayoutSortPreset(call);
  const Overlay = (0, import_jsx_runtime3.jsx)(ParticipantOverlay, { showParticipantCount: props.showParticipantCount, showDuration: props.showDuration, showLiveBadge: props.showLiveBadge, showSpeakerName: props.showSpeakerName });
  const { floatingParticipantProps, muted } = props;
  const FloatingParticipantOverlay = hasOngoingScreenShare && (0, import_jsx_runtime3.jsx)(
    ParticipantOverlay,
    {
      // these elements aren't needed for the video feed
      showParticipantCount: (floatingParticipantProps == null ? void 0 : floatingParticipantProps.showParticipantCount) ?? false,
      showDuration: (floatingParticipantProps == null ? void 0 : floatingParticipantProps.showDuration) ?? false,
      showLiveBadge: (floatingParticipantProps == null ? void 0 : floatingParticipantProps.showLiveBadge) ?? false,
      showSpeakerName: (floatingParticipantProps == null ? void 0 : floatingParticipantProps.showSpeakerName) ?? true
    }
  );
  return (0, import_jsx_runtime3.jsxs)("div", { className: "str-video__livestream-layout__wrapper", children: [!muted && (0, import_jsx_runtime3.jsx)(ParticipantsAudio, { participants: remoteParticipants }), hasOngoingScreenShare && presenter && (0, import_jsx_runtime3.jsx)(ParticipantView, { className: "str-video__livestream-layout__screen-share", participant: presenter, ParticipantViewUI: Overlay, trackType: "screenShareTrack", muteAudio: true }), currentSpeaker && (0, import_jsx_runtime3.jsx)(ParticipantView, { className: clsx_default(hasOngoingScreenShare && clsx_default("str-video__livestream-layout__floating-participant", `str-video__livestream-layout__floating-participant--${(floatingParticipantProps == null ? void 0 : floatingParticipantProps.position) ?? "top-right"}`)), participant: currentSpeaker, ParticipantViewUI: FloatingParticipantOverlay || Overlay, mirror: props.mirrorLocalParticipantVideo !== false ? void 0 : false, muteAudio: true })] });
};
var ParticipantOverlay = (props) => {
  const { enableFullScreen = true, showParticipantCount = true, showDuration = true, showLiveBadge = true, showSpeakerName = false } = props;
  const { participant } = useParticipantViewContext();
  const { useParticipantCount: useParticipantCount2 } = useCallStateHooks();
  const participantCount = useParticipantCount2();
  const duration = useUpdateCallDuration();
  const toggleFullScreen = useToggleFullScreen();
  const { t: t2 } = useI18n();
  return (0, import_jsx_runtime3.jsx)("div", { className: "str-video__livestream-layout__overlay", children: (0, import_jsx_runtime3.jsxs)("div", { className: "str-video__livestream-layout__overlay__bar", children: [showLiveBadge && (0, import_jsx_runtime3.jsx)("span", { className: "str-video__livestream-layout__live-badge", children: t2("Live") }), showParticipantCount && (0, import_jsx_runtime3.jsx)("span", { className: "str-video__livestream-layout__viewers-count", children: participantCount }), showSpeakerName && (0, import_jsx_runtime3.jsx)("span", { className: "str-video__livestream-layout__speaker-name", title: participant.name || participant.userId || "", children: participant.name || participant.userId || "" }), showDuration && (0, import_jsx_runtime3.jsx)("span", { className: "str-video__livestream-layout__duration", children: formatDuration(duration) }), enableFullScreen && (0, import_jsx_runtime3.jsx)("span", { className: "str-video__livestream-layout__go-fullscreen", onClick: toggleFullScreen })] }) });
};
LivestreamLayout.displayName = "LivestreamLayout";
var useUpdateCallDuration = () => {
  const { useIsCallLive: useIsCallLive2, useCallSession: useCallSession2 } = useCallStateHooks();
  const isCallLive = useIsCallLive2();
  const session = useCallSession2();
  const [duration, setDuration] = (0, import_react4.useState)(() => {
    if (!session || !session.live_started_at)
      return 0;
    const liveStartTime = new Date(session.live_started_at);
    const now = /* @__PURE__ */ new Date();
    return Math.floor((now.getTime() - liveStartTime.getTime()) / 1e3);
  });
  (0, import_react4.useEffect)(() => {
    if (!isCallLive)
      return;
    const interval2 = setInterval(() => {
      setDuration((d) => d + 1);
    }, 1e3);
    return () => {
      clearInterval(interval2);
    };
  }, [isCallLive]);
  return duration;
};
var useToggleFullScreen = () => {
  const { participantViewElement } = useParticipantViewContext();
  const [isFullscreen, setIsFullscreen] = (0, import_react4.useState)(false);
  return (0, import_react4.useCallback)(() => {
    if (isFullscreen) {
      document.exitFullscreen().then(() => {
        setIsFullscreen(false);
      });
    } else {
      participantViewElement == null ? void 0 : participantViewElement.requestFullscreen().then(() => {
        setIsFullscreen(true);
      });
    }
  }, [isFullscreen, participantViewElement]);
};
var formatDuration = (durationInMs) => {
  const days = Math.floor(durationInMs / 86400);
  const hours = Math.floor(durationInMs / 3600);
  const minutes = Math.floor(durationInMs % 3600 / 60);
  const seconds = durationInMs % 60;
  return `${days ? days + " " : ""}${hours ? hours + ":" : ""}${minutes < 10 ? "0" : ""}${minutes}:${seconds < 10 ? "0" : ""}${seconds}`;
};
var GROUP_SIZE = 16;
var PaginatedGridLayoutGroup = ({ group, mirror, VideoPlaceholder, PictureInPicturePlaceholder, ParticipantViewUI }) => {
  return (0, import_jsx_runtime3.jsx)("div", { className: clsx_default("str-video__paginated-grid-layout__group", {
    "str-video__paginated-grid-layout--one": group.length === 1,
    "str-video__paginated-grid-layout--two-four": group.length >= 2 && group.length <= 4,
    "str-video__paginated-grid-layout--five-nine": group.length >= 5 && group.length <= 9
  }), children: group.map((participant) => (0, import_jsx_runtime3.jsx)(ParticipantView, { participant, muteAudio: true, mirror, VideoPlaceholder, PictureInPicturePlaceholder, ParticipantViewUI }, participant.sessionId)) });
};
var PaginatedGridLayout = (props) => {
  const { groupSize = (props.groupSize || 0) > 0 ? props.groupSize || GROUP_SIZE : GROUP_SIZE, excludeLocalParticipant = false, filterParticipants, mirrorLocalParticipantVideo = true, pageArrowsVisible = true, VideoPlaceholder, ParticipantViewUI = DefaultParticipantViewUI, PictureInPicturePlaceholder, muted } = props;
  const [page, setPage] = (0, import_react4.useState)(0);
  const [paginatedGridLayoutWrapperElement, setPaginatedGridLayoutWrapperElement] = (0, import_react4.useState)(null);
  const call = useCall();
  const { useRemoteParticipants: useRemoteParticipants2 } = useCallStateHooks();
  const remoteParticipants = useRemoteParticipants2();
  const participants = useFilteredParticipants({
    excludeLocalParticipant,
    filterParticipants
  });
  usePaginatedLayoutSortPreset(call);
  (0, import_react4.useEffect)(() => {
    if (!paginatedGridLayoutWrapperElement || !call)
      return;
    const cleanup2 = call.setViewport(paginatedGridLayoutWrapperElement);
    return () => cleanup2();
  }, [paginatedGridLayoutWrapperElement, call]);
  const participantGroups = (0, import_react4.useMemo)(() => chunk(participants, groupSize), [participants, groupSize]);
  const pageCount = participantGroups.length;
  (0, import_react4.useEffect)(() => {
    if (page > pageCount - 1) {
      setPage(Math.max(0, pageCount - 1));
    }
  }, [page, pageCount]);
  const selectedGroup = participantGroups[page];
  const mirror = mirrorLocalParticipantVideo ? void 0 : false;
  if (!call)
    return null;
  return (0, import_jsx_runtime3.jsxs)("div", { className: "str-video__paginated-grid-layout__wrapper", ref: setPaginatedGridLayoutWrapperElement, children: [!muted && (0, import_jsx_runtime3.jsx)(ParticipantsAudio, { participants: remoteParticipants }), (0, import_jsx_runtime3.jsxs)("div", { className: "str-video__paginated-grid-layout", children: [pageArrowsVisible && pageCount > 1 && (0, import_jsx_runtime3.jsx)(IconButton, { icon: "caret-left", disabled: page === 0, onClick: () => setPage((currentPage) => Math.max(0, currentPage - 1)) }), selectedGroup && (0, import_jsx_runtime3.jsx)(PaginatedGridLayoutGroup, { group: selectedGroup, mirror, VideoPlaceholder, ParticipantViewUI, PictureInPicturePlaceholder }), pageArrowsVisible && pageCount > 1 && (0, import_jsx_runtime3.jsx)(IconButton, { disabled: page === pageCount - 1, icon: "caret-right", onClick: () => setPage((currentPage) => Math.min(pageCount - 1, currentPage + 1)) })] })] });
};
PaginatedGridLayout.displayName = "PaginatedGridLayout";
var useCalculateHardLimit = (wrapperElement, hostElement, limit) => {
  const [calculatedLimit, setCalculatedLimit] = (0, import_react4.useState)({
    vertical: typeof limit === "number" ? limit : null,
    horizontal: typeof limit === "number" ? limit : null
  });
  (0, import_react4.useEffect)(() => {
    if (!hostElement || !wrapperElement || typeof limit === "number" || typeof limit === "undefined")
      return;
    let childWidth = null;
    let childHeight = null;
    const resizeObserver = new ResizeObserver((entries, observer) => {
      if (entries.length > 1) {
        const child = hostElement.firstChild;
        if (child) {
          childHeight = child.clientHeight;
          childWidth = child.clientWidth;
          observer.unobserve(hostElement);
        }
      }
      if (childHeight === null || childWidth === null)
        return;
      const vertical = Math.floor(wrapperElement.clientHeight / childHeight);
      const horizontal = Math.floor(wrapperElement.clientWidth / childWidth);
      setCalculatedLimit((pv) => {
        if (pv.vertical !== vertical || pv.horizontal !== horizontal)
          return { vertical, horizontal };
        return pv;
      });
    });
    resizeObserver.observe(wrapperElement);
    resizeObserver.observe(hostElement);
    return () => {
      resizeObserver.disconnect();
    };
  }, [hostElement, limit, wrapperElement]);
  return calculatedLimit;
};
var DefaultParticipantViewUIBar = () => (0, import_jsx_runtime3.jsx)(DefaultParticipantViewUI, { menuPlacement: "top-end" });
var SpeakerLayout = ({ ParticipantViewUIBar = DefaultParticipantViewUIBar, ParticipantViewUISpotlight = DefaultParticipantViewUI, VideoPlaceholder, PictureInPicturePlaceholder, participantsBarPosition = "bottom", participantsBarLimit, mirrorLocalParticipantVideo = true, excludeLocalParticipant = false, filterParticipants, pageArrowsVisible = true, muted }) => {
  const call = useCall();
  const { useParticipants: useParticipants2, useRemoteParticipants: useRemoteParticipants2 } = useCallStateHooks();
  const allParticipants = useParticipants2();
  const remoteParticipants = useRemoteParticipants2();
  const [participantInSpotlight, ...otherParticipants] = useFilteredParticipants({ excludeLocalParticipant, filterParticipants });
  const [participantsBarWrapperElement, setParticipantsBarWrapperElement] = (0, import_react4.useState)(null);
  const [participantsBarElement, setParticipantsBarElement] = (0, import_react4.useState)(null);
  const [buttonsWrapperElement, setButtonsWrapperElement] = (0, import_react4.useState)(null);
  const isSpeakerScreenSharing = participantInSpotlight && hasScreenShare(participantInSpotlight);
  const hardLimit = useCalculateHardLimit(buttonsWrapperElement, participantsBarElement, participantsBarLimit);
  const isVertical = participantsBarPosition === "left" || participantsBarPosition === "right";
  const isHorizontal = participantsBarPosition === "top" || participantsBarPosition === "bottom";
  (0, import_react4.useEffect)(() => {
    if (!participantsBarWrapperElement || !call)
      return;
    const cleanup2 = call.setViewport(participantsBarWrapperElement);
    return () => cleanup2();
  }, [participantsBarWrapperElement, call]);
  const isOneOnOneCall = allParticipants.length === 2;
  useSpeakerLayoutSortPreset(call, isOneOnOneCall);
  let participantsWithAppliedLimit = otherParticipants;
  const hardLimitToApply = isVertical ? hardLimit.vertical : hardLimit.horizontal;
  if (typeof participantsBarLimit !== "undefined" && hardLimitToApply !== null) {
    participantsWithAppliedLimit = otherParticipants.slice(
      0,
      // subtract 1 if speaker is sharing screen as
      // that one is rendered independently from otherParticipants array
      hardLimitToApply - (isSpeakerScreenSharing ? 1 : 0)
    );
  }
  const mirror = mirrorLocalParticipantVideo ? void 0 : false;
  if (!call)
    return null;
  const renderParticipantsBar = participantsBarPosition && (participantsWithAppliedLimit.length > 0 || isSpeakerScreenSharing);
  return (0, import_jsx_runtime3.jsxs)("div", { className: "str-video__speaker-layout__wrapper", children: [!muted && (0, import_jsx_runtime3.jsx)(ParticipantsAudio, { participants: remoteParticipants }), (0, import_jsx_runtime3.jsxs)("div", { className: clsx_default("str-video__speaker-layout", participantsBarPosition && `str-video__speaker-layout--variant-${participantsBarPosition}`), children: [(0, import_jsx_runtime3.jsx)("div", { className: "str-video__speaker-layout__spotlight", children: participantInSpotlight && (0, import_jsx_runtime3.jsx)(ParticipantView, { participant: participantInSpotlight, muteAudio: true, mirror, trackType: isSpeakerScreenSharing ? "screenShareTrack" : "videoTrack", ParticipantViewUI: ParticipantViewUISpotlight, VideoPlaceholder, PictureInPicturePlaceholder }) }), renderParticipantsBar && (0, import_jsx_runtime3.jsxs)("div", { ref: setButtonsWrapperElement, className: "str-video__speaker-layout__participants-bar-buttons-wrapper", children: [(0, import_jsx_runtime3.jsx)("div", { className: "str-video__speaker-layout__participants-bar-wrapper", ref: setParticipantsBarWrapperElement, children: (0, import_jsx_runtime3.jsxs)("div", { ref: setParticipantsBarElement, className: "str-video__speaker-layout__participants-bar", children: [isSpeakerScreenSharing && (0, import_jsx_runtime3.jsx)("div", { className: "str-video__speaker-layout__participant-tile", children: (0, import_jsx_runtime3.jsx)(ParticipantView, { participant: participantInSpotlight, ParticipantViewUI: ParticipantViewUIBar, VideoPlaceholder, PictureInPicturePlaceholder, mirror, muteAudio: true }) }, participantInSpotlight.sessionId), participantsWithAppliedLimit.map((participant) => (0, import_jsx_runtime3.jsx)("div", { className: "str-video__speaker-layout__participant-tile", children: (0, import_jsx_runtime3.jsx)(ParticipantView, { participant, ParticipantViewUI: ParticipantViewUIBar, VideoPlaceholder, PictureInPicturePlaceholder, mirror, muteAudio: true }) }, participant.sessionId))] }) }), pageArrowsVisible && isVertical && (0, import_jsx_runtime3.jsx)(VerticalScrollButtons, { scrollWrapper: participantsBarWrapperElement }), pageArrowsVisible && isHorizontal && (0, import_jsx_runtime3.jsx)(HorizontalScrollButtons, { scrollWrapper: participantsBarWrapperElement })] })] })] });
};
SpeakerLayout.displayName = "SpeakerLayout";
var HorizontalScrollButtons = ({ scrollWrapper }) => {
  const scrollPosition = useHorizontalScrollPosition(scrollWrapper);
  const scrollStartClickHandler = () => {
    scrollWrapper == null ? void 0 : scrollWrapper.scrollBy({ left: -150, behavior: "smooth" });
  };
  const scrollEndClickHandler = () => {
    scrollWrapper == null ? void 0 : scrollWrapper.scrollBy({ left: 150, behavior: "smooth" });
  };
  return (0, import_jsx_runtime3.jsxs)(import_jsx_runtime3.Fragment, { children: [scrollPosition && scrollPosition !== "start" && (0, import_jsx_runtime3.jsx)(IconButton, { onClick: scrollStartClickHandler, icon: "caret-left", className: "str-video__speaker-layout__participants-bar--button-left" }), scrollPosition && scrollPosition !== "end" && (0, import_jsx_runtime3.jsx)(IconButton, { onClick: scrollEndClickHandler, icon: "caret-right", className: "str-video__speaker-layout__participants-bar--button-right" })] });
};
var VerticalScrollButtons = ({ scrollWrapper }) => {
  const scrollPosition = useVerticalScrollPosition(scrollWrapper);
  const scrollTopClickHandler = () => {
    scrollWrapper == null ? void 0 : scrollWrapper.scrollBy({ top: -150, behavior: "smooth" });
  };
  const scrollBottomClickHandler = () => {
    scrollWrapper == null ? void 0 : scrollWrapper.scrollBy({ top: 150, behavior: "smooth" });
  };
  return (0, import_jsx_runtime3.jsxs)(import_jsx_runtime3.Fragment, { children: [scrollPosition && scrollPosition !== "top" && (0, import_jsx_runtime3.jsx)(IconButton, { onClick: scrollTopClickHandler, icon: "caret-up", className: "str-video__speaker-layout__participants-bar--button-top" }), scrollPosition && scrollPosition !== "bottom" && (0, import_jsx_runtime3.jsx)(IconButton, { onClick: scrollBottomClickHandler, icon: "caret-down", className: "str-video__speaker-layout__participants-bar--button-bottom" })] });
};
var Pip = (props) => {
  const { t: t2 } = useI18n();
  const { excludeLocalParticipant = false, filterParticipants, mirrorLocalParticipantVideo = true, VideoPlaceholder, ParticipantViewUI = DefaultParticipantViewUI } = props;
  const [layoutWrapperElement, setLayoutWrapperElement] = (0, import_react4.useState)(null);
  const call = useCall();
  const participants = useFilteredParticipants({
    excludeLocalParticipant,
    filterParticipants
  });
  const screenSharingParticipant = participants.find((p) => hasScreenShare(p));
  usePaginatedLayoutSortPreset(call);
  (0, import_react4.useEffect)(() => {
    if (!layoutWrapperElement || !call)
      return;
    return call.setViewport(layoutWrapperElement);
  }, [layoutWrapperElement, call]);
  const mirror = mirrorLocalParticipantVideo ? void 0 : false;
  if (!call)
    return null;
  return (0, import_jsx_runtime3.jsxs)("div", { className: "str-video__pip-layout", ref: setLayoutWrapperElement, children: [screenSharingParticipant && (screenSharingParticipant.isLocalParticipant ? (0, import_jsx_runtime3.jsxs)("div", { className: "str-video__pip-screen-share-local", children: [(0, import_jsx_runtime3.jsx)(Icon, { icon: "screen-share-off" }), (0, import_jsx_runtime3.jsx)("span", { className: "str-video__pip-screen-share-local__title", children: t2("You are presenting your screen") })] }) : (0, import_jsx_runtime3.jsx)(ParticipantView, { participant: screenSharingParticipant, trackType: "screenShareTrack", muteAudio: true, mirror: false, VideoPlaceholder, ParticipantViewUI })), participants.map((participant) => (0, import_jsx_runtime3.jsx)(ParticipantView, { participant, muteAudio: true, mirror, VideoPlaceholder, ParticipantViewUI }, participant.sessionId))] });
};
Pip.displayName = "PipLayout.Pip";
var Host = () => {
  const { useRemoteParticipants: useRemoteParticipants2 } = useCallStateHooks();
  const remoteParticipants = useRemoteParticipants2();
  return (0, import_jsx_runtime3.jsx)(ParticipantsAudio, { participants: remoteParticipants });
};
Host.displayName = "PipLayout.Host";
var PipLayout = { Pip, Host };
var LivestreamPlayer = (props) => {
  const { callType, callId, layoutProps } = props;
  const client = useStreamVideoClient();
  const [call, setCall] = (0, import_react4.useState)();
  (0, import_react4.useEffect)(() => {
    if (!client)
      return;
    const myCall = client.call(callType, callId);
    setCall(myCall);
    myCall.join().catch((e) => {
      console.error("Failed to join call", e);
    });
    return () => {
      myCall.leave().catch((e) => {
        console.error("Failed to leave call", e);
      });
      setCall(void 0);
    };
  }, [callId, callType, client]);
  if (!call)
    return null;
  return (0, import_jsx_runtime3.jsx)(StreamCall, { call, children: (0, import_jsx_runtime3.jsx)(LivestreamLayout, { ...layoutProps }) });
};
var [major2, minor2, patch2] = "1.14.4".split(".");
setSdkInfo({
  type: models.SdkType.REACT,
  major: major2,
  minor: minor2,
  patch: patch2
});
export {
  AcceptCallButton,
  Audio,
  AudioSettingsRequestDefaultDeviceEnum,
  AudioSettingsResponseDefaultDeviceEnum,
  Avatar,
  AvatarFallback,
  AxiosError,
  BackgroundFiltersProvider,
  BaseVideo,
  browsers as Browsers,
  Call,
  CallControls,
  CallParticipantListing,
  CallParticipantListingItem,
  CallParticipantsList,
  CallPreview,
  CallRecordingList,
  CallRecordingListHeader,
  CallRecordingListItem,
  CallState,
  CallStats,
  CallStatsButton,
  CallType,
  CallTypes,
  CallingState,
  CameraManager,
  CameraManagerState,
  CancelCallButton,
  CancelCallConfirmButton,
  CompositeButton,
  CreateDeviceRequestPushProviderEnum,
  DebounceType,
  DefaultParticipantViewUI,
  DefaultReactionsMenu,
  DefaultScreenShareOverlay,
  DefaultVideoPlaceholder2 as DefaultVideoPlaceholder,
  DeviceSelector,
  DeviceSelectorAudioInput,
  DeviceSelectorAudioOutput,
  DeviceSelectorVideo,
  DeviceSettings,
  DropDownSelect,
  DropDownSelectOption,
  DynascaleManager,
  EmptyCallRecordingListing,
  ErrorFromResponse,
  FrameRecordingSettingsRequestModeEnum,
  FrameRecordingSettingsRequestQualityEnum,
  FrameRecordingSettingsResponseModeEnum,
  GenericMenu,
  GenericMenuButtonItem,
  Icon,
  IconButton,
  InputMediaDeviceManager,
  InputMediaDeviceManagerState,
  LayoutSettingsRequestNameEnum,
  LivestreamLayout,
  LivestreamPlayer,
  LoadingCallRecordingListing,
  LoadingIndicator,
  MenuToggle,
  MenuVisualType,
  MicrophoneManager,
  MicrophoneManagerState,
  NoiseCancellationProvider,
  NoiseCancellationSettingsModeEnum,
  Notification2 as Notification,
  OwnCapability,
  PaginatedGridLayout,
  ParticipantActionsContextMenu,
  ParticipantDetails,
  ParticipantView,
  ParticipantViewContext,
  ParticipantsAudio,
  PermissionNotification,
  PermissionRequestList,
  PermissionRequests,
  PipLayout,
  RTMPBroadcastRequestQualityEnum,
  RTMPSettingsRequestQualityEnum,
  ReactionsButton,
  RecordCallButton,
  RecordCallConfirmationButton,
  RecordSettingsRequestModeEnum,
  RecordSettingsRequestQualityEnum,
  RecordingInProgressNotification,
  Restricted,
  RingingCall,
  RingingCallControls,
  rxUtils as RxUtils,
  ScreenShareButton,
  ScreenShareManager,
  ScreenShareState,
  SearchInput,
  SearchResults,
  events as SfuEvents,
  models as SfuModels,
  SpeakerLayout,
  SpeakerManager,
  SpeakerState,
  SpeakingWhileMutedNotification,
  SpeechIndicator,
  StatCard,
  StreamCall,
  StreamCallProvider,
  StreamI18n,
  StreamI18nProvider,
  StreamSfuClient,
  StreamTheme,
  StreamVideo,
  StreamVideoClient,
  StreamVideoProvider,
  StreamVideoReadOnlyStateStore,
  StreamVideoWriteableStateStore,
  TextButton,
  ToggleAudioOutputButton,
  ToggleAudioPreviewButton,
  ToggleAudioPublishingButton,
  ToggleVideoPreviewButton,
  ToggleVideoPublishingButton,
  Tooltip,
  TranscriptionSettingsRequestClosedCaptionModeEnum,
  TranscriptionSettingsRequestLanguageEnum,
  TranscriptionSettingsRequestModeEnum,
  TranscriptionSettingsResponseClosedCaptionModeEnum,
  TranscriptionSettingsResponseLanguageEnum,
  TranscriptionSettingsResponseModeEnum,
  Video$1 as Video,
  VideoPreview,
  VideoSettingsRequestCameraFacingEnum,
  VideoSettingsResponseCameraFacingEnum,
  ViewportTracker,
  VisibilityState,
  WithTooltip,
  checkIfAudioOutputChangeSupported,
  combineComparators,
  conditional,
  createSoundDetector,
  defaultReactions,
  defaultSortPreset,
  defaultTranslationFunction,
  descending,
  deviceIds$,
  disposeOfMediaStream,
  dominantSpeaker,
  getAudioBrowserPermission,
  getAudioDevices,
  getAudioOutputDevices,
  getAudioStream,
  getClientDetails,
  getDeviceState,
  getLogLevel,
  getLogger,
  getScreenShareStream,
  getSdkInfo,
  getVideoBrowserPermission,
  getVideoDevices,
  getVideoStream,
  getWebRTCInfo,
  hasAudio,
  hasScreenShare,
  hasScreenShareAudio,
  hasVideo,
  isPinned,
  livestreamOrAudioRoomSortPreset,
  logLevels,
  logToConsole,
  name,
  noopComparator,
  paginatedLayoutSortPreset,
  pinned,
  publishingAudio,
  publishingVideo,
  reactionType,
  role,
  screenSharing,
  setDeviceInfo,
  setLogLevel,
  setLogger,
  setOSInfo,
  setPowerState,
  setSdkInfo,
  setThermalState,
  setWebRTCInfo,
  speakerLayoutSortPreset,
  speaking,
  translations,
  useBackgroundFilters,
  useCall,
  useCallStateHooks,
  useCalls,
  useConnectedUser,
  useCreateI18n,
  useDeviceList,
  useFilteredParticipants,
  useHorizontalScrollPosition,
  useI18n,
  useMenuContext,
  useNoiseCancellation,
  useObservableValue,
  useParticipantViewContext,
  usePersistedDevicePreferences,
  useRequestPermission,
  useStore,
  useStreamVideoClient,
  useToggleCallRecording,
  useTrackElementVisibility,
  useVerticalScrollPosition
};
/*! Bundled license information:

tabbable/dist/index.esm.js:
  (*!
  * tabbable 6.2.0
  * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
  *)
*/
//# sourceMappingURL=@stream-io_video-react-sdk.js.map
