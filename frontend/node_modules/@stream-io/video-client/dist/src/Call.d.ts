import { Publisher, Subscriber } from './rtc';
import { CallState } from './store';
import type { AcceptCallResponse, BlockUserResponse, CallRingEvent, CallSettingsResponse, CollectUserFeedbackRequest, CollectUserFeedbackResponse, DeleteCallRequest, DeleteCallResponse, EndCallResponse, GetCallReportResponse, GetCallResponse, GetOrCreateCallRequest, GetOrCreateCallResponse, GoLiveRequest, GoLiveResponse, JoinCallResponse, ListRecordingsResponse, ListTranscriptionsResponse, MuteUsersResponse, PinRequest, PinResponse, QueryCallMembersRequest, QueryCallMembersResponse, RejectCallResponse, RequestPermissionRequest, RequestPermissionResponse, SendCallEventResponse, SendReactionRequest, SendReactionResponse, StartClosedCaptionsRequest, StartClosedCaptionsResponse, StartFrameRecordingRequest, StartFrameRecordingResponse, StartHLSBroadcastingResponse, StartRecordingRequest, StartRecordingResponse, StartRTMPBroadcastsRequest, StartRTMPBroadcastsResponse, StartTranscriptionRequest, StartTranscriptionResponse, StopAllRTMPBroadcastsResponse, StopClosedCaptionsRequest, StopClosedCaptionsResponse, StopFrameRecordingResponse, StopHLSBroadcastingResponse, StopLiveRequest, StopLiveResponse, StopRecordingResponse, StopRTMPBroadcastsResponse, StopTranscriptionResponse, UnblockUserResponse, UnpinRequest, UnpinResponse, UpdateCallMembersRequest, UpdateCallMembersResponse, UpdateCallRequest, UpdateCallResponse, UpdateUserPermissionsRequest, UpdateUserPermissionsResponse, VideoDimension } from './gen/coordinator';
import { AudioTrackType, CallConstructor, CallLeaveOptions, ClientPublishOptions, ClosedCaptionsSettings, JoinCallData, TrackMuteType, VideoTrackType } from './types';
import { TrackType } from './gen/video/sfu/models/models';
import { DynascaleManager } from './helpers/DynascaleManager';
import { PermissionsContext } from './permissions';
import { StreamClient } from './coordinator/connection/client';
import { AllCallEvents, CallEventListener, Logger, RejectReason } from './coordinator/connection/types';
import { CameraManager, MicrophoneManager, ScreenShareManager, SpeakerManager } from './devices';
import { GetCallStatsResponse } from './gen/shims';
/**
 * An object representation of a `Call`.
 */
export declare class Call {
    /**
     * The type of the call.
     */
    readonly type: string;
    /**
     * The ID of the call.
     */
    readonly id: string;
    /**
     * The call CID.
     */
    readonly cid: string;
    /**
     * The state of this call.
     */
    readonly state: CallState;
    /**
     * Flag indicating whether this call is "watched" and receives
     * updates from the backend.
     */
    watching: boolean;
    /**
     * Device manager for the camera
     */
    readonly camera: CameraManager;
    /**
     * Device manager for the microphone.
     */
    readonly microphone: MicrophoneManager;
    /**
     * Device manager for the speaker.
     */
    readonly speaker: SpeakerManager;
    /**
     * Device manager for the screen.
     */
    readonly screenShare: ScreenShareManager;
    /**
     * The DynascaleManager instance.
     */
    readonly dynascaleManager: DynascaleManager;
    subscriber?: Subscriber;
    publisher?: Publisher;
    /**
     * Flag telling whether this call is a "ringing" call.
     */
    private readonly ringingSubject;
    /**
     * The permissions context of this call.
     */
    readonly permissionsContext: PermissionsContext;
    readonly logger: Logger;
    /**
     * The event dispatcher instance dedicated to this Call instance.
     * @private
     */
    private readonly dispatcher;
    private clientPublishOptions?;
    private currentPublishOptions?;
    private statsReporter?;
    private sfuStatsReporter?;
    private dropTimeout;
    private readonly clientStore;
    readonly streamClient: StreamClient;
    private sfuClient?;
    private sfuClientTag;
    private readonly reconnectConcurrencyTag;
    private reconnectAttempts;
    private reconnectStrategy;
    private reconnectReason;
    private fastReconnectDeadlineSeconds;
    private disconnectionTimeoutSeconds;
    private lastOfflineTimestamp;
    private networkAvailableTask;
    private trackPublishOrder;
    private joinCallData?;
    private hasJoinedOnce;
    private deviceSettingsAppliedOnce;
    private credentials?;
    private initialized;
    private readonly joinLeaveConcurrencyTag;
    /**
     * A list hooks/functions to invoke when the call is left.
     * A typical use case is to clean up some global event handlers.
     * @private
     */
    private readonly leaveCallHooks;
    private readonly streamClientBasePath;
    private streamClientEventHandlers;
    /**
     * Constructs a new `Call` instance.
     *
     * NOTE: Don't call the constructor directly, instead
     * Use the [`StreamVideoClient.call`](./StreamVideoClient.md/#call)
     * method to construct a `Call` instance.
     */
    constructor({ type, id, streamClient, members, ownCapabilities, sortParticipantsBy, clientStore, ringing, watching, }: CallConstructor);
    /**
     * Sets up the call instance.
     *
     * @internal an internal method and should not be used outside the SDK.
     */
    setup: () => Promise<void>;
    private registerEffects;
    private handleOwnCapabilitiesUpdated;
    /**
     * You can subscribe to WebSocket events provided by the API. To remove a subscription, call the `off` method.
     * Please note that subscribing to WebSocket events is an advanced use-case.
     * For most use-cases, it should be enough to watch for state changes.
     *
     * @param eventName the event name.
     * @param fn the event handler.
     */
    on: <E extends keyof AllCallEvents>(eventName: E, fn: CallEventListener<E>) => () => void;
    /**
     * Remove subscription for WebSocket events that were created by the `on` method.
     *
     * @param eventName the event name.
     * @param fn the event handler.
     */
    off: <E extends keyof AllCallEvents>(eventName: E, fn: CallEventListener<E>) => void;
    /**
     * Leave the call and stop the media streams that were published by the call.
     */
    leave: ({ reject, reason, }?: CallLeaveOptions) => Promise<void>;
    /**
     * A flag indicating whether the call is "ringing" type of call.
     */
    get ringing(): boolean;
    /**
     * Retrieves the current user ID.
     */
    get currentUserId(): string | undefined;
    /**
     * A flag indicating whether the call was created by the current user.
     */
    get isCreatedByMe(): boolean;
    /**
     * Update from the call response from the "call.ring" event
     * @internal
     */
    updateFromRingingEvent: (event: CallRingEvent) => Promise<void>;
    /**
     * Loads the information about the call.
     *
     * @param params.ring if set to true, a `call.ring` event will be sent to the call members.
     * @param params.notify if set to true, a `call.notification` event will be sent to the call members.
     * @param params.members_limit the total number of members to return as part of the response.
     */
    get: (params?: {
        ring?: boolean;
        notify?: boolean;
        members_limit?: number;
    }) => Promise<GetCallResponse>;
    /**
     * Loads the information about the call and creates it if it doesn't exist.
     *
     * @param data the data to create the call with.
     */
    getOrCreate: (data?: GetOrCreateCallRequest) => Promise<GetOrCreateCallResponse>;
    /**
     * Creates a call
     *
     * @param data the data to create the call with.
     */
    create: (data?: GetOrCreateCallRequest) => Promise<GetOrCreateCallResponse>;
    /**
     * Deletes the call.
     */
    delete: (data?: DeleteCallRequest) => Promise<DeleteCallResponse>;
    /**
     * A shortcut for {@link Call.get} with `ring` parameter set to `true`.
     * Will send a `call.ring` event to the call members.
     */
    ring: () => Promise<GetCallResponse>;
    /**
     * A shortcut for {@link Call.get} with `notify` parameter set to `true`.
     * Will send a `call.notification` event to the call members.
     */
    notify: () => Promise<GetCallResponse>;
    /**
     * Marks the incoming call as accepted.
     *
     * This method should be used only for "ringing" call flows.
     * {@link Call.join} invokes this method automatically for you when joining a call.
     * Unless you are implementing a custom "ringing" flow, you should not use this method.
     */
    accept: () => Promise<AcceptCallResponse>;
    /**
     * Marks the incoming call as rejected.
     *
     * This method should be used only for "ringing" call flows.
     * {@link Call.leave} invokes this method automatically for you when you leave or reject this call.
     * Unless you are implementing a custom "ringing" flow, you should not use this method.
     *
     * @param reason the reason for rejecting the call.
     */
    reject: (reason?: RejectReason) => Promise<RejectCallResponse>;
    /**
     * Will start to watch for call related WebSocket events and initiate a call session with the server.
     *
     * @returns a promise which resolves once the call join-flow has finished.
     */
    join: ({ maxJoinRetries, ...data }?: JoinCallData & {
        maxJoinRetries?: number;
    }) => Promise<void>;
    /**
     * Will make a single attempt to watch for call related WebSocket events
     * and initiate a call session with the server.
     *
     * @returns a promise which resolves once the call join-flow has finished.
     */
    doJoin: (data?: JoinCallData) => Promise<void>;
    /**
     * Prepares Reconnect Details object.
     * @internal
     */
    private getReconnectDetails;
    /**
     * Prepares the preferred codec for the call.
     * This is an experimental client feature and subject to change.
     * @internal
     */
    private getPreferredPublishOptions;
    /**
     * Prepares the preferred options for subscribing to tracks.
     * This is an experimental client feature and subject to change.
     * @internal
     */
    private getPreferredSubscribeOptions;
    /**
     * Performs an ICE restart on both the Publisher and Subscriber Peer Connections.
     * Uses the provided SFU client to restore the ICE connection.
     *
     * This method can throw an error if the ICE restart fails.
     * This error should be handled by the reconnect loop,
     * and a new reconnection shall be attempted.
     *
     * @internal
     */
    private restoreICE;
    /**
     * Initializes the Publisher and Subscriber Peer Connections.
     * @internal
     */
    private initPublisherAndSubscriber;
    /**
     * Retrieves credentials for joining the call.
     *
     * @internal
     *
     * @param data the join call data.
     */
    doJoinRequest: (data?: JoinCallData) => Promise<JoinCallResponse>;
    /**
     * Handles the closing of the SFU signal connection.
     *
     * @internal
     * @param sfuClient the SFU client instance that was closed.
     * @param reason the reason for the closure.
     */
    private handleSfuSignalClose;
    /**
     * Handles the reconnection flow.
     *
     * @internal
     *
     * @param strategy the reconnection strategy to use.
     * @param reason the reason for the reconnection.
     */
    private reconnect;
    /**
     * Initiates the reconnection flow with the "fast" strategy.
     * @internal
     */
    private reconnectFast;
    /**
     * Initiates the reconnection flow with the "rejoin" strategy.
     * @internal
     */
    private reconnectRejoin;
    /**
     * Initiates the reconnection flow with the "migrate" strategy.
     * @internal
     */
    private reconnectMigrate;
    /**
     * Registers the various event handlers for reconnection.
     *
     * @internal
     */
    private registerReconnectHandlers;
    /**
     * Restores the published tracks after a reconnection.
     * @internal
     */
    private restorePublishedTracks;
    /**
     * Restores the subscribed tracks after a reconnection.
     * @internal
     */
    private restoreSubscribedTracks;
    /**
     * Starts publishing the given video stream to the call.
     * @deprecated use `call.publish()`.
     */
    publishVideoStream: (videoStream: MediaStream) => Promise<void>;
    /**
     * Starts publishing the given audio stream to the call.
     * @deprecated use `call.publish()`
     */
    publishAudioStream: (audioStream: MediaStream) => Promise<void>;
    /**
     * Starts publishing the given screen-share stream to the call.
     * @deprecated use `call.publish()`
     */
    publishScreenShareStream: (screenShareStream: MediaStream) => Promise<void>;
    /**
     * Publishes the given media stream.
     *
     * @param mediaStream the media stream to publish.
     * @param trackType the type of the track to announce.
     */
    publish: (mediaStream: MediaStream, trackType: TrackType) => Promise<void>;
    /**
     * Stops publishing the given track type to the call, if it is currently being published.
     *
     * @param trackTypes the track types to stop publishing.
     */
    stopPublish: (...trackTypes: TrackType[]) => Promise<void>;
    /**
     * Updates the call state with the new stream.
     *
     * @param mediaStream the new stream to update the call state with.
     * If undefined, the stream will be removed from the call state.
     * @param trackTypes the track types to update the call state with.
     */
    private updateLocalStreamState;
    /**
     * Updates the preferred publishing options
     *
     * @internal
     * @param options the options to use.
     */
    updatePublishOptions: (options: ClientPublishOptions) => void;
    /**
     * Notifies the SFU that a noise cancellation process has started.
     *
     * @internal
     */
    notifyNoiseCancellationStarting: () => Promise<void | import("@protobuf-ts/runtime-rpc").FinishedUnaryCall<import("./gen/video/sfu/signal_rpc/signal").StartNoiseCancellationRequest, import("./gen/video/sfu/signal_rpc/signal").StartNoiseCancellationResponse> | undefined>;
    /**
     * Notifies the SFU that a noise cancellation process has stopped.
     *
     * @internal
     */
    notifyNoiseCancellationStopped: () => Promise<void | import("@protobuf-ts/runtime-rpc").FinishedUnaryCall<import("./gen/video/sfu/signal_rpc/signal").StopNoiseCancellationRequest, import("./gen/video/sfu/signal_rpc/signal").StopNoiseCancellationResponse> | undefined>;
    /**
     * Notifies the SFU about the mute state of the given track types.
     * @internal
     */
    notifyTrackMuteState: (muted: boolean, ...trackTypes: TrackType[]) => Promise<void>;
    /**
     * Will enhance the reported stats with additional participant-specific information (`callStatsReport$` state [store variable](./StreamVideoClient.md/#readonlystatestore)).
     * This is usually helpful when detailed stats for a specific participant are needed.
     *
     * @param sessionId the sessionId to start reporting for.
     */
    startReportingStatsFor: (sessionId: string) => void | undefined;
    /**
     * Opposite of `startReportingStatsFor`.
     * Will turn off stats reporting for a specific participant.
     *
     * @param sessionId the sessionId to stop reporting for.
     */
    stopReportingStatsFor: (sessionId: string) => void | undefined;
    /**
     * Resets the last sent reaction for the user holding the given `sessionId`. This is a local action, it won't reset the reaction on the backend.
     *
     * @param sessionId the session id.
     */
    resetReaction: (sessionId: string) => void;
    /**
     * Sets the list of criteria to sort the participants by.
     *
     * @param criteria the list of criteria to sort the participants by.
     */
    setSortParticipantsBy: CallState['setSortParticipantsBy'];
    /**
     * Sends a reaction to the other call participants.
     *
     * @param reaction the reaction to send.
     */
    sendReaction: (reaction: SendReactionRequest) => Promise<SendReactionResponse>;
    /**
     * Blocks the user with the given `userId`.
     *
     * @param userId the id of the user to block.
     */
    blockUser: (userId: string) => Promise<BlockUserResponse>;
    /**
     * Unblocks the user with the given `userId`.
     *
     * @param userId the id of the user to unblock.
     */
    unblockUser: (userId: string) => Promise<UnblockUserResponse>;
    /**
     * Mutes the current user.
     *
     * @param type the type of the mute operation.
     */
    muteSelf: (type: TrackMuteType) => Promise<MuteUsersResponse> | undefined;
    /**
     * Mutes all the other participants.
     *
     * @param type the type of the mute operation.
     */
    muteOthers: (type: TrackMuteType) => Promise<MuteUsersResponse> | undefined;
    /**
     * Mutes the user with the given `userId`.
     *
     * @param userId the id of the user to mute.
     * @param type the type of the mute operation.
     */
    muteUser: (userId: string | string[], type: TrackMuteType) => Promise<MuteUsersResponse>;
    /**
     * Will mute all users in the call.
     *
     * @param type the type of the mute operation.
     */
    muteAllUsers: (type: TrackMuteType) => Promise<MuteUsersResponse>;
    /**
     * Starts recording the call
     */
    startRecording: (request?: StartRecordingRequest) => Promise<StartRecordingResponse>;
    /**
     * Stops recording the call
     */
    stopRecording: () => Promise<StopRecordingResponse>;
    /**
     * Starts the transcription of the call.
     *
     * @param request the request data.
     */
    startTranscription: (request?: StartTranscriptionRequest) => Promise<StartTranscriptionResponse>;
    /**
     * Stops the transcription of the call.
     */
    stopTranscription: () => Promise<StopTranscriptionResponse>;
    /**
     * Starts the closed captions of the call.
     */
    startClosedCaptions: (options?: StartClosedCaptionsRequest) => Promise<StartClosedCaptionsResponse>;
    /**
     * Stops the closed captions of the call.
     */
    stopClosedCaptions: (options?: StopClosedCaptionsRequest) => Promise<StopClosedCaptionsResponse>;
    /**
     * Updates the closed caption settings.
     *
     * @param config the closed caption settings to apply
     */
    updateClosedCaptionSettings: (config: Partial<ClosedCaptionsSettings>) => void;
    /**
     * Sends a `call.permission_request` event to all users connected to the call.
     * The call settings object contains information about which permissions can be requested during a call
     * (for example, a user might be allowed to request permission to publish audio, but not video).
     */
    requestPermissions: (data: RequestPermissionRequest) => Promise<RequestPermissionResponse>;
    /**
     * Allows you to grant certain permissions to a user in a call.
     * The permissions are specific to the call experience and do not survive the call itself.
     *
     * Supported permissions that can be granted are:
     * - `send-audio`
     * - `send-video`
     * - `screenshare`
     *
     * @param userId the id of the user to grant permissions to.
     * @param permissions the permissions to grant.
     */
    grantPermissions: (userId: string, permissions: string[]) => Promise<UpdateUserPermissionsResponse>;
    /**
     * Allows you to revoke certain permissions from a user in a call.
     * The permissions are specific to the call experience and do not survive the call itself.
     *
     * Supported permissions that can be revoked are:
     * - `send-audio`
     * - `send-video`
     * - `screenshare`
     *
     * @param userId the id of the user to revoke permissions from.
     * @param permissions the permissions to revoke.
     */
    revokePermissions: (userId: string, permissions: string[]) => Promise<UpdateUserPermissionsResponse>;
    /**
     * Allows you to grant or revoke a specific permission to a user in a call. The permissions are specific to the call experience and do not survive the call itself.
     *
     * When revoking a permission, this endpoint will also mute the relevant track from the user. This is similar to muting a user with the difference that the user will not be able to unmute afterwards.
     *
     * Supported permissions that can be granted or revoked: `send-audio`, `send-video` and `screenshare`.
     *
     * `call.permissions_updated` event is sent to all members of the call.
     *
     */
    updateUserPermissions: (data: UpdateUserPermissionsRequest) => Promise<UpdateUserPermissionsResponse>;
    /**
     * Starts the livestreaming of the call.
     *
     * @param data the request data.
     * @param params the request params.
     */
    goLive: (data?: GoLiveRequest, params?: {
        notify?: boolean;
    }) => Promise<GoLiveResponse>;
    /**
     * Stops the livestreaming of the call.
     */
    stopLive: (data?: StopLiveRequest) => Promise<StopLiveResponse>;
    /**
     * Starts the broadcasting of the call.
     */
    startHLS: () => Promise<StartHLSBroadcastingResponse>;
    /**
     * Stops the broadcasting of the call.
     */
    stopHLS: () => Promise<StopHLSBroadcastingResponse>;
    /**
     * Starts the RTMP-out broadcasting of the call.
     */
    startRTMPBroadcasts: (data: StartRTMPBroadcastsRequest) => Promise<StartRTMPBroadcastsResponse>;
    /**
     * Stops all RTMP-out broadcasting of the call.
     */
    stopAllRTMPBroadcasts: () => Promise<StopAllRTMPBroadcastsResponse>;
    /**
     * Stops the RTMP-out broadcasting of the call specified by it's name.
     */
    stopRTMPBroadcast: (name: string) => Promise<StopRTMPBroadcastsResponse>;
    /**
     * Starts frame by frame recording.
     * Sends call.frame_recording_started events
     */
    startFrameRecording: (data: StartFrameRecordingRequest) => Promise<StartFrameRecordingResponse>;
    /**
     * Stops frame recording.
     */
    stopFrameRecording: () => Promise<StopFrameRecordingResponse>;
    /**
     * Updates the call settings or custom data.
     *
     * @param updates the updates to apply to the call.
     */
    update: (updates: UpdateCallRequest) => Promise<UpdateCallResponse>;
    /**
     * Ends the call. Once the call is ended, it cannot be re-joined.
     */
    endCall: () => Promise<EndCallResponse>;
    /**
     * Pins the given session to the top of the participants list.
     *
     * @param sessionId the sessionId to pin.
     */
    pin: (sessionId: string) => void;
    /**
     * Unpins the given session from the top of the participants list.
     *
     * @param sessionId the sessionId to unpin.
     */
    unpin: (sessionId: string) => void;
    /**
     * Pins the given session to the top of the participants list for everyone
     * in the call.
     * You can execute this method only if you have the `pin-for-everyone` capability.
     *
     * @param request the request object.
     */
    pinForEveryone: (request: PinRequest) => Promise<PinResponse>;
    /**
     * Unpins the given session from the top of the participants list for everyone
     * in the call.
     * You can execute this method only if you have the `pin-for-everyone` capability.
     *
     * @param request the request object.
     */
    unpinForEveryone: (request: UnpinRequest) => Promise<UnpinResponse>;
    /**
     * Query call members with filter query. The result won't be stored in call state.
     * @param request
     * @returns
     */
    queryMembers: (request?: Omit<QueryCallMembersRequest, "type" | "id">) => Promise<QueryCallMembersResponse>;
    /**
     * Will update the call members.
     *
     * @param data the request data.
     */
    updateCallMembers: (data: UpdateCallMembersRequest) => Promise<UpdateCallMembersResponse>;
    /**
     * Schedules an auto-drop timeout based on the call settings.
     * Applicable only for ringing calls.
     */
    private scheduleAutoDrop;
    /**
     * Cancels a scheduled auto-drop timeout.
     */
    private cancelAutoDrop;
    /**
     * Retrieves the list of recordings for the current call or call session.
     *
     * If `callSessionId` is provided, it will return the recordings for that call session.
     * Otherwise, all recordings for the current call will be returned.
     *
     * @param callSessionId the call session id to retrieve recordings for.
     */
    queryRecordings: (callSessionId?: string) => Promise<ListRecordingsResponse>;
    /**
     * Retrieves the list of transcriptions for the current call.
     *
     * @returns the list of transcriptions.
     */
    queryTranscriptions: () => Promise<ListTranscriptionsResponse>;
    /**
     * Retrieve call statistics for a particular call session (historical).
     * Here `callSessionID` is mandatory.
     *
     * @param callSessionID the call session ID to retrieve statistics for.
     * @returns The call stats.
     * @deprecated use `call.getCallReport` instead.
     * @internal
     */
    getCallStats: (callSessionID: string) => Promise<GetCallStatsResponse>;
    /**
     * Retrieve call report. If the `callSessionID` is not specified, then the
     * report for the latest call session is retrieved. If it is specified, then
     * the report for that particular session is retrieved if it exists.
     *
     * @param callSessionID the optional call session ID to retrieve statistics for
     * @returns the call report
     */
    getCallReport: (callSessionID?: string) => Promise<GetCallReportResponse>;
    /**
     * Submit user feedback for the call
     *
     * @param rating Rating between 1 and 5 denoting the experience of the user in the call
     * @param reason The reason/description for the rating
     * @param custom Custom data
     */
    submitFeedback: (rating: number, { reason, custom, }?: Pick<CollectUserFeedbackRequest, "reason" | "custom">) => Promise<CollectUserFeedbackResponse>;
    /**
     * Sends a custom event to all call participants.
     *
     * @param payload the payload to send.
     */
    sendCustomEvent: (payload: {
        [key: string]: any;
    }) => Promise<SendCallEventResponse>;
    /**
     * Applies the device configuration from the backend.
     *
     * @internal
     */
    applyDeviceConfig: (settings: CallSettingsResponse, publish: boolean) => Promise<void>;
    /**
     * Will begin tracking the given element for visibility changes within the
     * configured viewport element (`call.setViewport`).
     *
     * @param element the element to track.
     * @param sessionId the session id.
     * @param trackType the video mode.
     */
    trackElementVisibility: <T extends HTMLElement>(element: T, sessionId: string, trackType: VideoTrackType) => () => void;
    /**
     * Sets the viewport element to track bound video elements for visibility.
     *
     * @param element the viewport element.
     */
    setViewport: <T extends HTMLElement>(element: T) => () => void;
    /**
     * Binds a DOM <video> element to the given session id.
     * This method will make sure that the video element will play
     * the correct video stream for the given session id.
     *
     * Under the hood, it would also keep track of the video element dimensions
     * and update the subscription accordingly in order to optimize the bandwidth.
     *
     * If a "viewport" is configured, the video element will be automatically
     * tracked for visibility and the subscription will be updated accordingly.
     *
     * @param videoElement the video element to bind to.
     * @param sessionId the session id.
     * @param trackType the kind of video.
     */
    bindVideoElement: (videoElement: HTMLVideoElement, sessionId: string, trackType: VideoTrackType) => (() => void) | undefined;
    /**
     * Binds a DOM <audio> element to the given session id.
     *
     * This method will make sure that the audio element will
     * play the correct audio stream for the given session id.
     *
     * @param audioElement the audio element to bind to.
     * @param sessionId the session id.
     * @param trackType the kind of audio.
     */
    bindAudioElement: (audioElement: HTMLAudioElement, sessionId: string, trackType?: AudioTrackType) => (() => void) | undefined;
    /**
     * Binds a DOM <img> element to this call's thumbnail (if enabled in settings).
     *
     * @param imageElement the image element to bind to.
     * @param opts options for the binding.
     */
    bindCallThumbnailElement: (imageElement: HTMLImageElement, opts?: {
        fallbackImageSource?: string;
    }) => () => void;
    /**
     * Specify preference for incoming video resolution. The preference will
     * be matched as close as possible, but actual resolution will depend
     * on the video source quality and client network conditions. Will enable
     * incoming video, if previously disabled.
     *
     * @param resolution preferred resolution, or `undefined` to clear preference
     * @param sessionIds optionally specify session ids of the participants this
     * preference has effect on. Affects all participants by default.
     */
    setPreferredIncomingVideoResolution: (resolution: VideoDimension | undefined, sessionIds?: string[]) => void;
    /**
     * Enables or disables incoming video from all remote call participants,
     * and removes any preference for preferred resolution.
     */
    setIncomingVideoEnabled: (enabled: boolean) => void;
    /**
     * Sets the maximum amount of time a user can remain waiting for a reconnect
     * after a network disruption
     * @param timeoutSeconds Timeout in seconds, or 0 to keep reconnecting indefinetely
     */
    setDisconnectionTimeout: (timeoutSeconds: number) => void;
}
