import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios';
import { StableWSConnection } from './connection';
import { TokenManager } from './token_manager';
import { AllClientEvents, AllClientEventTypes, APIErrorResponse, ClientEventListener, ConnectAPIResponse, ErrorFromResponse, Logger, StreamClientOptions, StreamVideoEvent, TokenOrProvider, User, UserWithId } from './types';
import { ConnectedEvent, CreateGuestResponse } from '../../gen/coordinator';
export declare class StreamClient {
    _user?: UserWithId;
    anonymous: boolean;
    persistUserOnConnectionFailure?: boolean;
    axiosInstance: AxiosInstance;
    baseURL?: string;
    browser: boolean;
    clientID?: string;
    key: string;
    listeners: Partial<Record<AllClientEventTypes, ClientEventListener<any>[] | undefined>>;
    logger: Logger;
    private locationHint;
    node: boolean;
    options: StreamClientOptions;
    secret?: string;
    connectUserTask: ConnectAPIResponse | null;
    tokenManager: TokenManager;
    user?: UserWithId;
    private cachedUserAgent?;
    userID?: string;
    wsBaseURL?: string;
    wsConnection: StableWSConnection | null;
    private wsPromiseSafe;
    consecutiveFailures: number;
    defaultWSTimeout: number;
    resolveConnectionId?: Function;
    rejectConnectionId?: Function;
    private connectionIdPromiseSafe?;
    guestUserCreatePromise?: Promise<CreateGuestResponse>;
    /**
     * Initialize a client.
     *
     * @param {string} key - the api key
     * @param {StreamClientOptions} [options] - additional options, here you can pass custom options to axios instance
     * @param {string} [options.secret] - the api secret
     * @param {boolean} [options.browser] - enforce the client to be in browser mode
     * @param {boolean} [options.warmUp] - default to false, if true, client will open a connection as soon as possible to speed up following requests
     * @param {Logger} [options.Logger] - custom logger
     * @param {number} [options.timeout] - default to 3000
     * @param {httpsAgent} [options.httpsAgent] - custom httpsAgent, in node it's default to https.agent()
     */
    constructor(key: string, options?: StreamClientOptions);
    getAuthType: () => "anonymous" | "jwt";
    setBaseURL: (baseURL: string) => void;
    getLocationHint: (hintUrl?: string, timeout?: number) => Promise<string>;
    _getConnectionID: () => string | undefined;
    _hasConnectionID: () => boolean;
    /**
     * connectUser - Set the current user and open a WebSocket connection
     *
     * @param user Data about this user. IE {name: "john"}
     * @param {TokenOrProvider} tokenOrProvider Token or provider
     *
     * @return {ConnectAPIResponse} Returns a promise that resolves when the connection is setup
     */
    connectUser: (user: UserWithId, tokenOrProvider: TokenOrProvider) => ConnectAPIResponse;
    _setUser: (user: UserWithId) => void;
    /**
     * Disconnects the websocket connection, without removing the user set on client.
     * client.closeConnection will not trigger default auto-retry mechanism for reconnection. You need
     * to call client.openConnection to reconnect to websocket.
     *
     * This is mainly useful on mobile side. You can only receive push notifications
     * if you don't have active websocket connection.
     * So when your app goes to background, you can call `client.closeConnection`.
     * And when app comes back to foreground, call `client.openConnection`.
     *
     * @param timeout Max number of ms, to wait for close event of websocket, before forcefully assuming succesful disconnection.
     *                https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent
     */
    closeConnection: (timeout?: number) => Promise<void>;
    /**
     * Creates a new WebSocket connection with the current user. Returns empty promise, if there is an active connection
     */
    openConnection: () => Promise<ConnectedEvent | undefined>;
    /**
     * Disconnects the websocket and removes the user from client.
     *
     * @param timeout Max number of ms, to wait for close event of websocket, before forcefully assuming successful disconnection.
     *                https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent
     */
    disconnectUser: (timeout?: number) => Promise<void>;
    connectGuestUser: (user: User & {
        type: "guest";
    }) => Promise<void | ConnectedEvent>;
    /**
     * connectAnonymousUser - Set an anonymous user and open a WebSocket connection
     */
    connectAnonymousUser: (user: UserWithId, tokenOrProvider: TokenOrProvider) => Promise<void>;
    /**
     * on - Listen to events on all channels and users your watching
     *
     * client.on('message.new', event => {console.log("my new message", event, channel.state.messages)})
     *
     * @param eventName The event type to listen for (optional)
     * @param callback The callback to call
     *
     * @return  Returns a function which, when called, unsubscribes the event handler.
     */
    on: <E extends keyof AllClientEvents>(eventName: E, callback: ClientEventListener<E>) => () => void;
    /**
     * off - Remove the event handler
     */
    off: <E extends keyof AllClientEvents>(eventName: E, callback: ClientEventListener<E>) => void;
    /**
     * sets up the this.connectionIdPromise
     */
    _setupConnectionIdPromise: () => void;
    get connectionIdPromise(): Promise<string | undefined> | undefined;
    get isConnectionIsPromisePending(): boolean;
    get wsPromise(): Promise<ConnectedEvent | undefined> | undefined;
    _logApiRequest: (type: string, url: string, data: unknown, config: AxiosRequestConfig & {
        config?: AxiosRequestConfig & {
            maxBodyLength?: number;
        };
    }) => void;
    _logApiResponse: <T>(type: string, url: string, response: AxiosResponse<T>) => void;
    _logApiError: (type: string, url: string, error: unknown) => void;
    doAxiosRequest: <T, D = unknown>(type: string, url: string, data?: D, options?: AxiosRequestConfig & {
        config?: AxiosRequestConfig & {
            maxBodyLength?: number;
        };
    } & {
        publicEndpoint?: boolean;
    }) => Promise<T>;
    get: <T>(url: string, params?: AxiosRequestConfig["params"]) => Promise<T>;
    put: <T, D = unknown>(url: string, data?: D, params?: AxiosRequestConfig["params"]) => Promise<T>;
    post: <T, D = unknown>(url: string, data?: D, params?: AxiosRequestConfig["params"]) => Promise<T>;
    patch: <T, D = unknown>(url: string, data?: D, params?: AxiosRequestConfig["params"]) => Promise<T>;
    delete: <T>(url: string, params?: AxiosRequestConfig["params"]) => Promise<T>;
    errorFromResponse: (response: AxiosResponse<APIErrorResponse>) => ErrorFromResponse<APIErrorResponse>;
    handleResponse: <T>(response: AxiosResponse<T>) => T;
    dispatchEvent: (event: StreamVideoEvent) => void;
    /**
     * @private
     */
    connect: () => Promise<ConnectedEvent | undefined>;
    getUserAgent: () => string;
    _enrichAxiosOptions: (options?: AxiosRequestConfig & {
        config?: AxiosRequestConfig;
    } & {
        publicEndpoint?: boolean;
    }) => AxiosRequestConfig;
    _getToken: () => string | null | undefined;
    updateNetworkConnectionStatus: (event: {
        type: "online" | "offline";
    } | Event) => void;
}
