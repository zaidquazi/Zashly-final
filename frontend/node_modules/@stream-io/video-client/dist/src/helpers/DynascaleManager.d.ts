import { AudioTrackType, DebounceType, VideoTrackType } from '../types';
import { VideoDimension } from '../gen/video/sfu/models/models';
import { ViewportTracker } from './ViewportTracker';
import type { TrackSubscriptionDetails } from '../gen/video/sfu/signal_rpc/signal';
import type { CallState } from '../store';
import type { StreamSfuClient } from '../StreamSfuClient';
import { SpeakerManager } from '../devices';
type VideoTrackSubscriptionOverride = {
    enabled: true;
    dimension: VideoDimension;
} | {
    enabled: false;
};
declare const globalOverrideKey: unique symbol;
interface VideoTrackSubscriptionOverrides {
    [sessionId: string]: VideoTrackSubscriptionOverride | undefined;
    [globalOverrideKey]?: VideoTrackSubscriptionOverride;
}
/**
 * A manager class that handles dynascale related tasks like:
 *
 * - binding video elements to session ids
 * - binding audio elements to session ids
 * - tracking element visibility
 * - updating subscriptions based on viewport visibility
 * - updating subscriptions based on video element dimensions
 * - updating subscriptions based on published tracks
 */
export declare class DynascaleManager {
    /**
     * The viewport tracker instance.
     */
    readonly viewportTracker: ViewportTracker;
    private logger;
    private callState;
    private speaker;
    private sfuClient;
    private pendingSubscriptionsUpdate;
    private videoTrackSubscriptionOverridesSubject;
    videoTrackSubscriptionOverrides$: import("rxjs").Observable<VideoTrackSubscriptionOverrides>;
    incomingVideoSettings$: import("rxjs").Observable<{
        enabled: boolean;
        preferredResolution: VideoDimension | undefined;
        participants: {
            [k: string]: {
                enabled: boolean;
                preferredResolution: VideoDimension | undefined;
            };
        };
        isParticipantVideoEnabled: (sessionId: string) => boolean;
    }>;
    /**
     * Creates a new DynascaleManager instance.
     */
    constructor(callState: CallState, speaker: SpeakerManager);
    setSfuClient(sfuClient: StreamSfuClient | undefined): void;
    get trackSubscriptions(): TrackSubscriptionDetails[];
    get videoTrackSubscriptionOverrides(): VideoTrackSubscriptionOverrides;
    setVideoTrackSubscriptionOverrides: (override: VideoTrackSubscriptionOverride | undefined, sessionIds?: string[]) => VideoTrackSubscriptionOverrides;
    applyTrackSubscriptions: (debounceType?: DebounceType) => void;
    /**
     * Will begin tracking the given element for visibility changes within the
     * configured viewport element (`call.setViewport`).
     *
     * @param element the element to track.
     * @param sessionId the session id.
     * @param trackType the kind of video.
     * @returns Untrack.
     */
    trackElementVisibility: <T extends HTMLElement>(element: T, sessionId: string, trackType: VideoTrackType) => () => void;
    /**
     * Sets the viewport element to track bound video elements for visibility.
     *
     * @param element the viewport element.
     */
    setViewport: <T extends HTMLElement>(element: T) => () => void;
    /**
     * Binds a DOM <video> element to the given session id.
     * This method will make sure that the video element will play
     * the correct video stream for the given session id.
     *
     * Under the hood, it would also keep track of the video element dimensions
     * and update the subscription accordingly in order to optimize the bandwidth.
     *
     * If a "viewport" is configured, the video element will be automatically
     * tracked for visibility and the subscription will be updated accordingly.
     *
     * @param videoElement the video element to bind to.
     * @param sessionId the session id.
     * @param trackType the kind of video.
     */
    bindVideoElement: (videoElement: HTMLVideoElement, sessionId: string, trackType: VideoTrackType) => (() => void) | undefined;
    /**
     * Binds a DOM <audio> element to the given session id.
     *
     * This method will make sure that the audio element will
     * play the correct audio stream for the given session id.
     *
     * @param audioElement the audio element to bind to.
     * @param sessionId the session id.
     * @param trackType the kind of audio.
     * @returns a cleanup function that will unbind the audio element.
     */
    bindAudioElement: (audioElement: HTMLAudioElement, sessionId: string, trackType: AudioTrackType) => (() => void) | undefined;
}
export {};
