import { Call } from './Call';
import { StreamClient } from './coordinator/connection/client';
import { StreamVideoReadOnlyStateStore, StreamVideoWriteableStateStore } from './store';
import type { ConnectedEvent, CreateDeviceRequest, CreateGuestRequest, CreateGuestResponse, GetEdgesResponse, ListDevicesResponse, QueryAggregateCallStatsRequest, QueryAggregateCallStatsResponse, QueryCallsRequest, QueryCallStatsRequest, QueryCallStatsResponse } from './gen/coordinator';
import { AllClientEvents, ClientEventListener, Logger, StreamClientOptions, TokenOrProvider, TokenProvider, User } from './coordinator/connection/types';
export type StreamVideoClientOptions = {
    apiKey: string;
    options?: StreamClientOptions;
    user?: User;
    token?: string;
    tokenProvider?: TokenProvider;
};
/**
 * A `StreamVideoClient` instance lets you communicate with our API, and authenticate users.
 */
export declare class StreamVideoClient {
    /**
     * A reactive store that exposes all the state variables reactively.
     * You can subscribe to changes of the different state variables.
     * Our library is built in a way that all state changes are exposed in this store,
     * o all UI changes in your application should be handled by subscribing to these variables.
     *
     * @deprecated use the `client.state` getter.
     */
    readonly readOnlyStateStore: StreamVideoReadOnlyStateStore;
    readonly logger: Logger;
    protected readonly writeableStateStore: StreamVideoWriteableStateStore;
    streamClient: StreamClient;
    private effectsRegistered;
    private eventHandlersToUnregister;
    private readonly connectionConcurrencyTag;
    private static _instances;
    /**
     * You should create only one instance of `StreamVideoClient`.
     */
    constructor(apiKey: string, opts?: StreamClientOptions);
    constructor(args: StreamVideoClientOptions);
    /**
     * Gets or creates a StreamVideoClient instance based on the given options.
     */
    static getOrCreateInstance(args: StreamVideoClientOptions & {
        user: User;
    }): StreamVideoClient;
    private registerClientInstance;
    /**
     * Return the reactive state store, use this if you want to be notified about changes to the client state
     */
    get state(): StreamVideoReadOnlyStateStore;
    private registerEffects;
    /**
     * Connects the given user to the client.
     * Only one user can connect at a time, if you want to change users, call `disconnectUser` before connecting a new user.
     * If the connection is successful, the connected user [state variable](#readonlystatestore) will be updated accordingly.
     *
     * @param user the user to connect.
     * @param tokenOrProvider a token or a function that returns a token.
     */
    connectUser: (user: User, tokenOrProvider?: TokenOrProvider) => Promise<void | ConnectedEvent>;
    /**
     * Disconnects the currently connected user from the client.
     *
     * If the connection is successfully disconnected, the connected user [state variable](#readonlystatestore) will be updated accordingly
     *
     * @param timeout Max number of ms, to wait for close event of websocket, before forcefully assuming successful disconnection.
     *                https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent
     */
    disconnectUser: (timeout?: number) => Promise<void>;
    /**
     * You can subscribe to WebSocket events provided by the API.
     * To remove a subscription, call the `off` method or, execute the returned unsubscribe function.
     * Please note that subscribing to WebSocket events is an advanced use-case, for most use-cases it should be enough to watch for changes in the reactive [state store](#readonlystatestore).
     *
     * @param eventName the event name or 'all'.
     * @param callback the callback which will be called when the event is emitted.
     * @returns an unsubscribe function.
     */
    on: <E extends keyof AllClientEvents>(eventName: E, callback: ClientEventListener<E>) => () => void;
    /**
     * Remove subscription for WebSocket events that were created by the `on` method.
     *
     * @param eventName the event name.
     * @param callback the callback which was passed to the `on` method.
     */
    off: <E extends keyof AllClientEvents>(eventName: E, callback: ClientEventListener<E>) => void;
    /**
     * Creates a new call.
     *
     * @param type the type of the call.
     * @param id the id of the call.
     */
    call: (type: string, id: string) => Call;
    /**
     * Creates a new guest user with the given data.
     *
     * @param data the data for the guest user.
     */
    createGuestUser: (data: CreateGuestRequest) => Promise<CreateGuestResponse>;
    /**
     * Will query the API for calls matching the given filters.
     *
     * @param data the query data.
     */
    queryCalls: (data?: QueryCallsRequest) => Promise<{
        calls: Call[];
        duration: string;
        next?: string;
        prev?: string;
    }>;
    /**
     * Retrieve the list of available call statistics reports matching a particular condition.
     *
     * @param data Filter and sort conditions for retrieving available call report summaries.
     * @returns List with summary of available call reports matching the condition.
     */
    queryCallStats: (data?: QueryCallStatsRequest) => Promise<QueryCallStatsResponse>;
    /**
     * Retrieve the list of available reports aggregated from the call stats.
     *
     * @param data Specify filter conditions like from and to (within last 30 days) and the report types
     * @returns Requested reports with (mostly) raw daily data for each report type requested
     */
    queryAggregateCallStats: (data?: QueryAggregateCallStatsRequest) => Promise<QueryAggregateCallStatsResponse>;
    /**
     * Returns a list of available data centers available for hosting calls.
     */
    edges: () => Promise<GetEdgesResponse>;
    /**
     * addDevice - Adds a push device for a user.
     *
     * @param {string} id the device id
     * @param {string} push_provider the push provider name (eg. apn, firebase)
     * @param {string} push_provider_name user provided push provider name
     * @param {string} [userID] the user id (defaults to current user)
     * @param {boolean} [voip_token] enables use of VoIP token for push notifications on iOS platform
     */
    addDevice: (id: string, push_provider: string, push_provider_name?: string, userID?: string, voip_token?: boolean) => Promise<CreateDeviceRequest>;
    /**
     * addDevice - Adds a push device for a user.
     *
     * @param {string} id the device id
     * @param {string} push_provider the push provider name (eg. apn, firebase)
     * @param {string} push_provider_name user provided push provider name
     * @param {string} [userID] the user id (defaults to current user)
     */
    addVoipDevice: (id: string, push_provider: string, push_provider_name: string, userID?: string) => Promise<CreateDeviceRequest>;
    /**
     * getDevices - Returns the devices associated with a current user
     * @param {string} [userID] User ID. Only works on serverside
     */
    getDevices: (userID?: string) => Promise<ListDevicesResponse>;
    /**
     * removeDevice - Removes the device with the given id.
     *
     * @param {string} id The device id
     * @param {string} [userID] The user id. Only specify this for serverside requests
     */
    removeDevice: (id: string, userID?: string) => Promise<unknown>;
    /**
     * A callback that can be used to create ringing calls from push notifications. If the call already exists, it will do nothing.
     * @param call_cid
     * @returns
     */
    onRingingCall: (call_cid: string) => Promise<Call>;
    /**
     * Connects the given anonymous user to the client.
     *
     * @param user the user to connect.
     * @param tokenOrProvider a token or a function that returns a token.
     */
    private connectAnonymousUser;
}
