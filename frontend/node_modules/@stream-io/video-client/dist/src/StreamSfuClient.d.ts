import { Dispatcher, IceTrickleBuffer } from './rtc';
import { JoinRequest, JoinResponse } from './gen/video/sfu/event/events';
import { ICERestartRequest, SendAnswerRequest, SendStatsRequest, SetPublisherRequest, TrackMuteState, TrackSubscriptionDetails } from './gen/video/sfu/signal_rpc/signal';
import { ICETrickle } from './gen/video/sfu/models/models';
import { StreamClient } from './coordinator/connection/client';
import { Credentials } from './gen/coordinator';
import { TraceSlice } from './stats';
export type StreamSfuClientConstructor = {
    /**
     * The event dispatcher instance to use.
     */
    dispatcher: Dispatcher;
    /**
     * The credentials to use for the connection.
     */
    credentials: Credentials;
    /**
     * `sessionId` to use for the connection.
     */
    sessionId?: string;
    /**
     * A log tag to use for logging. Useful for debugging multiple instances.
     */
    logTag: string;
    /**
     * The timeout in milliseconds for waiting for the `joinResponse`.
     * Defaults to 5000ms.
     */
    joinResponseTimeout?: number;
    /**
     * Callback for when the WebSocket connection is closed.
     */
    onSignalClose?: (reason: string) => void;
    /**
     * The StreamClient instance to use for the connection.
     */
    streamClient: StreamClient;
    /**
     * Flag to enable tracing.
     */
    enableTracing: boolean;
};
/**
 * The client used for exchanging information with the SFU.
 */
export declare class StreamSfuClient {
    /**
     * A buffer for ICE Candidates that are received before
     * the Publisher and Subscriber Peer Connections are ready to handle them.
     */
    readonly iceTrickleBuffer: IceTrickleBuffer;
    /**
     * The `sessionId` of the currently connected participant.
     */
    readonly sessionId: string;
    /**
     * The `edgeName` representing the edge the client is connected to.
     */
    readonly edgeName: string;
    /**
     * Holds the current WebSocket connection to the SFU.
     */
    private signalWs;
    /**
     * Promise that resolves when the WebSocket connection is ready (open).
     */
    private signalReady;
    /**
     * Flag to indicate if the client is in the process of leaving the call.
     * This is set to `true` when the user initiates the leave process.
     */
    isLeaving: boolean;
    /**
     * Flag to indicate if the client is in the process of closing the connection.
     */
    isClosing: boolean;
    private readonly rpc;
    private keepAliveInterval?;
    private connectionCheckTimeout?;
    private migrateAwayTimeout?;
    private pingIntervalInMs;
    private unhealthyTimeoutInMs;
    private lastMessageTimestamp?;
    private readonly tracer?;
    private readonly unsubscribeIceTrickle;
    private readonly unsubscribeNetworkChanged;
    private readonly onSignalClose;
    private readonly logger;
    private readonly logTag;
    private readonly credentials;
    private readonly dispatcher;
    private readonly joinResponseTimeout;
    private networkAvailableTask;
    /**
     * Promise that resolves when the JoinResponse is received.
     * Rejects after a certain threshold if the response is not received.
     */
    private joinResponseTask;
    /**
     * Promise that resolves when the migration is complete.
     * Rejects after a certain threshold if the migration is not complete.
     */
    private migrationTask?;
    /**
     * A controller to abort the current requests.
     */
    private readonly abortController;
    /**
     * The normal closure code. Used for controlled shutdowns.
     */
    static NORMAL_CLOSURE: number;
    /**
     * The error code used when the SFU connection is unhealthy.
     * Usually, this means that no message has been received from the SFU for
     * a certain amount of time (`connectionCheckTimeout`).
     */
    static ERROR_CONNECTION_UNHEALTHY: number;
    /**
     * The error code used when the SFU connection is disposed because a new
     * connection is established or is about to be established.
     * Here, we don't use 1000 (normal closure) because we don't want the
     * SFU to clean up the resources associated with the current participant.
     */
    static DISPOSE_OLD_SOCKET: number;
    /**
     * Constructs a new SFU client.
     */
    constructor({ dispatcher, credentials, sessionId, logTag, joinResponseTimeout, onSignalClose, streamClient, enableTracing, }: StreamSfuClientConstructor);
    private createWebSocket;
    private cleanUpWebSocket;
    get isHealthy(): boolean;
    get joinTask(): Promise<JoinResponse>;
    private handleWebSocketClose;
    close: (code?: number, reason?: string) => void;
    private dispose;
    getTrace: () => TraceSlice | undefined;
    leaveAndClose: (reason: string) => Promise<void>;
    updateSubscriptions: (tracks: TrackSubscriptionDetails[]) => Promise<import("@protobuf-ts/runtime-rpc").FinishedUnaryCall<import("./gen/video/sfu/signal_rpc/signal").UpdateSubscriptionsRequest, import("./gen/video/sfu/signal_rpc/signal").UpdateSubscriptionsResponse>>;
    setPublisher: (data: Omit<SetPublisherRequest, "sessionId">) => Promise<import("@protobuf-ts/runtime-rpc").FinishedUnaryCall<SetPublisherRequest, import("./gen/video/sfu/signal_rpc/signal").SetPublisherResponse>>;
    sendAnswer: (data: Omit<SendAnswerRequest, "sessionId">) => Promise<import("@protobuf-ts/runtime-rpc").FinishedUnaryCall<SendAnswerRequest, import("./gen/video/sfu/signal_rpc/signal").SendAnswerResponse>>;
    iceTrickle: (data: Omit<ICETrickle, "sessionId">) => Promise<import("@protobuf-ts/runtime-rpc").FinishedUnaryCall<ICETrickle, import("./gen/video/sfu/signal_rpc/signal").ICETrickleResponse>>;
    iceRestart: (data: Omit<ICERestartRequest, "sessionId">) => Promise<import("@protobuf-ts/runtime-rpc").FinishedUnaryCall<ICERestartRequest, import("./gen/video/sfu/signal_rpc/signal").ICERestartResponse>>;
    updateMuteStates: (muteStates: TrackMuteState[]) => Promise<import("@protobuf-ts/runtime-rpc").FinishedUnaryCall<import("./gen/video/sfu/signal_rpc/signal").UpdateMuteStatesRequest, import("./gen/video/sfu/signal_rpc/signal").UpdateMuteStatesResponse>>;
    sendStats: (stats: Omit<SendStatsRequest, "sessionId">) => Promise<import("@protobuf-ts/runtime-rpc").FinishedUnaryCall<SendStatsRequest, import("./gen/video/sfu/signal_rpc/signal").SendStatsResponse>>;
    startNoiseCancellation: () => Promise<import("@protobuf-ts/runtime-rpc").FinishedUnaryCall<import("./gen/video/sfu/signal_rpc/signal").StartNoiseCancellationRequest, import("./gen/video/sfu/signal_rpc/signal").StartNoiseCancellationResponse>>;
    stopNoiseCancellation: () => Promise<import("@protobuf-ts/runtime-rpc").FinishedUnaryCall<import("./gen/video/sfu/signal_rpc/signal").StopNoiseCancellationRequest, import("./gen/video/sfu/signal_rpc/signal").StopNoiseCancellationResponse>>;
    enterMigration: (opts?: {
        timeout?: number;
    }) => Promise<void>;
    join: (data: Omit<JoinRequest, "sessionId" | "token">) => Promise<JoinResponse>;
    ping: () => Promise<void>;
    private notifyLeave;
    private send;
    private keepAlive;
    private scheduleConnectionCheck;
}
