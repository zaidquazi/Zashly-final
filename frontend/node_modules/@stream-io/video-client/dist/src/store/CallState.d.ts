import { Observable } from 'rxjs';
import type { Patch } from './rxUtils';
import { CallingState } from './CallingState';
import { type ClosedCaptionsSettings, type StreamVideoParticipant, type StreamVideoParticipantPatch, type StreamVideoParticipantPatches, type SubscriptionChanges, VideoTrackType } from '../types';
import { CallStatsReport } from '../stats';
import { CallClosedCaption, CallIngressResponse, CallResponse, CallSessionResponse, CallSettingsResponse, EgressResponse, MemberResponse, OwnCapability, ThumbnailResponse, UserResponse, VideoEvent } from '../gen/coordinator';
import { ReconnectDetails } from '../gen/video/sfu/event/events';
import { CallState as SfuCallState, Pin, TrackType } from '../gen/video/sfu/models/models';
import { Comparator } from '../sorting';
type OrphanedTrack = {
    id: string;
    trackLookupPrefix: string;
    trackType: TrackType;
    track: MediaStream;
};
/**
 * Holds the state of the current call.
 * @react You don't have to use this class directly, as we are exposing the state through Hooks.
 */
export declare class CallState {
    private backstageSubject;
    private blockedUserIdsSubject;
    private createdAtSubject;
    private endedAtSubject;
    private startsAtSubject;
    private updatedAtSubject;
    private createdBySubject;
    private customSubject;
    private egressSubject;
    private ingressSubject;
    private recordingSubject;
    private sessionSubject;
    private settingsSubject;
    private transcribingSubject;
    private captioningSubject;
    private endedBySubject;
    private thumbnailsSubject;
    private membersSubject;
    private ownCapabilitiesSubject;
    private callingStateSubject;
    private startedAtSubject;
    private participantCountSubject;
    private anonymousParticipantCountSubject;
    private participantsSubject;
    private callStatsReportSubject;
    private closedCaptionsSubject;
    private orphanedTracks;
    /**
     * The time the call session actually started.
     * Useful for displaying the call duration.
     */
    startedAt$: Observable<Date | undefined>;
    /**
     * The server-side counted number of participants connected to the current call.
     * This number includes the anonymous participants as well.
     */
    participantCount$: Observable<number>;
    /**
     * The server-side counted number of anonymous participants connected to the current call.
     * This number excludes the regular participants.
     */
    anonymousParticipantCount$: Observable<number>;
    /**
     * All participants of the current call (this includes the current user and other participants as well).
     */
    participants$: Observable<StreamVideoParticipant[]>;
    /**
     * Remote participants of the current call (this includes every participant except the logged-in user).
     */
    remoteParticipants$: Observable<StreamVideoParticipant[]>;
    /**
     * The local participant of the current call (the logged-in user).
     */
    localParticipant$: Observable<StreamVideoParticipant | undefined>;
    /**
     * Pinned participants of the current call.
     */
    pinnedParticipants$: Observable<StreamVideoParticipant[]>;
    /**
     * The currently elected dominant speaker in the current call.
     */
    dominantSpeaker$: Observable<StreamVideoParticipant | undefined>;
    /**
     * Emits true whenever there is an active screen sharing session within
     * the current call. Useful for displaying a "screen sharing" indicator and
     * switching the layout to a screen sharing layout.
     *
     * The actual screen sharing track isn't exposed here, but can be retrieved
     * from the list of call participants. We also don't want to be limiting
     * to the number of share screen tracks are displayed in a call.
     */
    hasOngoingScreenShare$: Observable<boolean>;
    /**
     * The latest stats report of the current call.
     * When stats gathering is enabled, this observable will emit a new value
     * at a regular (configurable) interval.
     *
     * Consumers of this observable can implement their own batching logic
     * in case they want to show historical stats data.
     */
    callStatsReport$: Observable<CallStatsReport | undefined>;
    /**
     * The list of members in the current call.
     */
    members$: Observable<MemberResponse[]>;
    /**
     * The list of capabilities of the current user.
     */
    ownCapabilities$: Observable<OwnCapability[]>;
    /**
     * The calling state.
     */
    callingState$: Observable<CallingState>;
    /**
     * The backstage state.
     */
    backstage$: Observable<boolean>;
    /**
     * Will provide the list of blocked user IDs.
     */
    blockedUserIds$: Observable<string[]>;
    /**
     * Will provide the time when this call has been created.
     */
    createdAt$: Observable<Date>;
    /**
     * Will provide the time when this call has been ended.
     */
    endedAt$: Observable<Date | undefined>;
    /**
     * Will provide the time when this call has been scheduled to start.
     */
    startsAt$: Observable<Date | undefined>;
    /**
     * Will provide the time when this call has been updated.
     */
    updatedAt$: Observable<Date>;
    /**
     * Will provide the user who created this call.
     */
    createdBy$: Observable<UserResponse | undefined>;
    /**
     * Will provide the custom data of this call.
     */
    custom$: Observable<Record<string, any>>;
    /**
     * Will provide the egress data of this call.
     */
    egress$: Observable<EgressResponse | undefined>;
    /**
     * Will provide the ingress data of this call.
     */
    ingress$: Observable<CallIngressResponse | undefined>;
    /**
     * Will provide the recording state of this call.
     */
    recording$: Observable<boolean>;
    /**
     * Will provide the session data of this call.
     */
    session$: Observable<CallSessionResponse | undefined>;
    /**
     * Will provide the settings of this call.
     */
    settings$: Observable<CallSettingsResponse | undefined>;
    /**
     * Will provide the transcribing state of this call.
     */
    transcribing$: Observable<boolean>;
    /**
     * Will provide the closed captioning state of this call.
     */
    captioning$: Observable<boolean>;
    /**
     * Will provide the user who ended this call.
     */
    endedBy$: Observable<UserResponse | undefined>;
    /**
     * Will provide the thumbnails of this call.
     */
    thumbnails$: Observable<ThumbnailResponse | undefined>;
    /**
     * The queue of closed captions.
     */
    closedCaptions$: Observable<CallClosedCaption[]>;
    readonly logger: import("../..").Logger;
    /**
     * A list of comparators that are used to sort the participants.
     */
    private sortParticipantsBy;
    /**
     * The closed captions configuration.
     */
    private closedCaptionsSettings;
    private closedCaptionsTasks;
    private readonly eventHandlers;
    /**
     * Creates a new instance of the CallState class.
     *
     */
    constructor();
    /**
     * Runs the cleanup tasks.
     */
    dispose: () => void;
    /**
     * Sets the list of criteria that are used to sort the participants.
     * To disable sorting, you can pass `noopComparator()`.
     *
     * @param comparator the comparator to use to sort the participants.
     */
    setSortParticipantsBy: (comparator: Comparator<StreamVideoParticipant>) => void;
    /**
     * Gets the current value of an observable, or undefined if the observable has
     * not emitted a value yet.
     *
     * @param observable$ the observable to get the value from.
     */
    getCurrentValue: <T>(observable$: Observable<T>) => T;
    /**
     * Updates the value of the provided Subject.
     * An `update` can either be a new value or a function which takes
     * the current value and returns a new value.
     *
     * @internal
     *
     * @param subject the subject to update.
     * @param update the update to apply to the subject.
     * @return the updated value.
     */
    setCurrentValue: <T>(subject: import("rxjs").Subject<T>, update: Patch<T>) => T;
    /**
     * The server-side counted number of participants connected to the current call.
     * This number includes the anonymous participants as well.
     */
    get participantCount(): number;
    /**
     * Sets the number of participants in the current call.
     *
     * @internal
     * @param count the number of participants.
     */
    setParticipantCount: (count: Patch<number>) => number;
    /**
     * The time the call session actually started.
     * Useful for displaying the call duration.
     */
    get startedAt(): Date | undefined;
    /**
     * Sets the time the call session actually started.
     *
     * @internal
     * @param startedAt the time the call session actually started.
     */
    setStartedAt: (startedAt: Patch<Date | undefined>) => Date | undefined;
    /**
     * Returns whether closed captions are enabled in the current call.
     */
    get captioning(): boolean;
    /**
     * Sets the closed captioning state of the current call.
     *
     * @internal
     * @param captioning the closed captioning state.
     */
    setCaptioning: (captioning: boolean) => {
        lastValue: boolean;
        value: boolean;
        rollback: () => boolean;
    };
    /**
     * The server-side counted number of anonymous participants connected to the current call.
     * This number includes the anonymous participants as well.
     */
    get anonymousParticipantCount(): number;
    /**
     * Sets the number of anonymous participants in the current call.
     *
     * @internal
     * @param count the number of anonymous participants.
     */
    setAnonymousParticipantCount: (count: Patch<number>) => number;
    /**
     * The list of participants in the current call.
     */
    get participants(): StreamVideoParticipant[];
    /**
     * Sets the list of participants in the current call.
     *
     * @internal
     *
     * @param participants the list of participants.
     */
    setParticipants: (participants: Patch<StreamVideoParticipant[]>) => StreamVideoParticipant[];
    /**
     * The local participant in the current call.
     */
    get localParticipant(): StreamVideoParticipant | undefined;
    /**
     * The list of remote participants in the current call.
     */
    get remoteParticipants(): StreamVideoParticipant[];
    /**
     * The dominant speaker in the current call.
     */
    get dominantSpeaker(): StreamVideoParticipant | undefined;
    /**
     * The list of pinned participants in the current call.
     */
    get pinnedParticipants(): StreamVideoParticipant[];
    /**
     * Tell if there is an ongoing screen share in this call.
     */
    get hasOngoingScreenShare(): boolean;
    /**
     * The calling state.
     */
    get callingState(): CallingState;
    /**
     * Sets the calling state.
     *
     * @internal
     * @param state the new calling state.
     */
    setCallingState: (state: Patch<CallingState>) => CallingState;
    /**
     * The call stats report.
     */
    get callStatsReport(): CallStatsReport | undefined;
    /**
     * Sets the call stats report.
     *
     * @internal
     * @param report the report to set.
     */
    setCallStatsReport: (report: Patch<CallStatsReport | undefined>) => CallStatsReport | undefined;
    /**
     * The members of the current call.
     */
    get members(): MemberResponse[];
    /**
     * Sets the members of the current call.
     *
     * @internal
     * @param members the members to set.
     */
    setMembers: (members: Patch<MemberResponse[]>) => void;
    /**
     * The capabilities of the current user for the current call.
     */
    get ownCapabilities(): OwnCapability[];
    /**
     * Sets the own capabilities.
     *
     * @internal
     * @param capabilities the capabilities to set.
     */
    setOwnCapabilities: (capabilities: Patch<OwnCapability[]>) => OwnCapability[];
    /**
     * The backstage state.
     */
    get backstage(): boolean;
    /**
     * Sets the backstage state.
     * @param backstage the backstage state.
     */
    setBackstage: (backstage: Patch<boolean>) => boolean;
    /**
     * Will provide the list of blocked user IDs.
     */
    get blockedUserIds(): string[];
    /**
     * Will provide the time when this call has been created.
     */
    get createdAt(): Date;
    /**
     * Will provide the time when this call has been ended.
     */
    get endedAt(): Date | undefined;
    /**
     * Sets the time when this call has been ended.
     * @param endedAt the time when this call has been ended.
     */
    setEndedAt: (endedAt: Patch<Date | undefined>) => Date | undefined;
    /**
     * Will provide the time when this call has been scheduled to start.
     */
    get startsAt(): Date | undefined;
    /**
     * Will provide the time when this call has been updated.
     */
    get updatedAt(): Date;
    /**
     * Will provide the user who created this call.
     */
    get createdBy(): UserResponse | undefined;
    /**
     * Will provide the custom data of this call.
     */
    get custom(): Record<string, any>;
    /**
     * Will provide the egress data of this call.
     */
    get egress(): EgressResponse | undefined;
    /**
     * Will provide the ingress data of this call.
     */
    get ingress(): CallIngressResponse | undefined;
    /**
     * Will provide the recording state of this call.
     */
    get recording(): boolean;
    /**
     * Will provide the session data of this call.
     */
    get session(): CallSessionResponse | undefined;
    /**
     * Will provide the settings of this call.
     */
    get settings(): CallSettingsResponse | undefined;
    /**
     * Will provide the transcribing state of this call.
     */
    get transcribing(): boolean;
    /**
     * Will provide the user who ended this call.
     */
    get endedBy(): UserResponse | undefined;
    /**
     * Will provide the thumbnails of this call, if enabled in the call settings.
     */
    get thumbnails(): ThumbnailResponse | undefined;
    /**
     * Returns the current queue of closed captions.
     */
    get closedCaptions(): CallClosedCaption[];
    /**
     * Will try to find the participant with the given sessionId in the current call.
     *
     * @param sessionId the sessionId of the participant to find.
     * @returns the participant with the given sessionId or undefined if not found.
     */
    findParticipantBySessionId: (sessionId: string) => StreamVideoParticipant | undefined;
    /**
     * Returns a new lookup table of participants indexed by their session ID.
     */
    getParticipantLookupBySessionId: () => {
        [sessionId: string]: StreamVideoParticipant | undefined;
    };
    /**
     * Updates a participant in the current call identified by the given `sessionId`.
     * If the participant can't be found, this operation is no-op.
     *
     * @internal
     *
     * @param sessionId the session ID of the participant to update.
     * @param patch the patch to apply to the participant.
     * @returns the updated participant or `undefined` if the participant couldn't be found.
     */
    updateParticipant: (sessionId: string, patch: StreamVideoParticipantPatch | ((p: StreamVideoParticipant) => StreamVideoParticipantPatch)) => StreamVideoParticipant[] | undefined;
    /**
     * Updates a participant in the current call identified by the given `sessionId`.
     * If a participant with matching `sessionId` can't be found, the provided
     * `participant` is added to the list of participants.
     *
     * @param sessionId the session ID of the participant to update.
     * @param participant the participant to update or add.
     */
    updateOrAddParticipant: (sessionId: string, participant: StreamVideoParticipant) => StreamVideoParticipant[];
    /**
     * Updates all participants in the current call whose session ID is in the given `sessionIds`.
     * If no patches are provided, this operation is no-op.
     *
     * @internal
     *
     * @param patch the patch to apply to the participants.
     * @returns all participants, with all patch applied.
     */
    updateParticipants: (patch: StreamVideoParticipantPatches) => StreamVideoParticipant[];
    /**
     * Update track subscription configuration for one or more participants.
     * You have to create a subscription for each participant for all the different kinds of tracks you want to receive.
     * You can only subscribe for tracks after the participant started publishing the given kind of track.
     *
     * @param trackType the kind of subscription to update.
     * @param changes the list of subscription changes to do.
     */
    updateParticipantTracks: (trackType: VideoTrackType, changes: SubscriptionChanges) => StreamVideoParticipant[];
    /**
     * Updates the call state with the data received from the server.
     *
     * @internal
     *
     * @param event the video event that our backend sent us.
     */
    updateFromEvent: (event: VideoEvent) => void;
    /**
     * Updates the participant pinned state with server side pinning data.
     *
     * @param pins the latest pins from the server.
     */
    setServerSidePins: (pins: Pin[]) => StreamVideoParticipant[];
    /**
     * Adds an orphaned track to the call state.
     *
     * @internal
     *
     * @param orphanedTrack the orphaned track to add.
     */
    registerOrphanedTrack: (orphanedTrack: OrphanedTrack) => void;
    /**
     * Removes an orphaned track from the call state.
     *
     * @internal
     *
     * @param id the ID of the orphaned track to remove.
     */
    removeOrphanedTrack: (id: string) => void;
    /**
     * Takes all orphaned tracks with the given track lookup prefix.
     * All orphaned tracks with the given track lookup prefix are removed from the call state.
     *
     * @internal
     *
     * @param trackLookupPrefix the track lookup prefix to match the orphaned tracks by.
     */
    takeOrphanedTracks: (trackLookupPrefix: string) => OrphanedTrack[];
    /**
     * Updates the closed captions settings.
     *
     * @param config the new closed captions settings.
     */
    updateClosedCaptionSettings: (config: Partial<ClosedCaptionsSettings>) => void;
    /**
     * Updates the call state with the data received from the server.
     *
     * @internal
     *
     * @param call the call response from the server.
     */
    updateFromCallResponse: (call: CallResponse) => void;
    /**
     * Updates the call state with the data received from the SFU server.
     *
     * @internal
     *
     * @param callState the call state from the SFU server.
     * @param currentSessionId the session ID of the current user.
     * @param reconnectDetails optional reconnect details.
     */
    updateFromSfuCallState: (callState: SfuCallState, currentSessionId: string, reconnectDetails?: ReconnectDetails) => void;
    private updateFromMemberRemoved;
    private updateFromMemberAdded;
    private updateFromHLSBroadcastStopped;
    private updateFromHLSBroadcastingFailed;
    private updateParticipantCountFromSession;
    private updateFromSessionParticipantCountUpdate;
    private updateFromSessionParticipantLeft;
    private updateFromSessionParticipantJoined;
    private updateMembers;
    private updateParticipantReaction;
    private unblockUser;
    private blockUser;
    private updateOwnCapabilities;
    private updateFromClosedCaptions;
}
export {};
