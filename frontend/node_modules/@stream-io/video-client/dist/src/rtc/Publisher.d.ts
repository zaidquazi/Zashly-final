import { BasePeerConnection, BasePeerConnectionOpts } from './BasePeerConnection';
import { PublishOption, TrackInfo, TrackType } from '../gen/video/sfu/models/models';
export type PublisherConstructorOpts = BasePeerConnectionOpts & {
    publishOptions: PublishOption[];
};
/**
 * The `Publisher` is responsible for publishing/unpublishing media streams to/from the SFU
 *
 * @internal
 */
export declare class Publisher extends BasePeerConnection {
    private readonly transceiverCache;
    private readonly clonedTracks;
    private publishOptions;
    /**
     * Constructs a new `Publisher` instance.
     */
    constructor({ publishOptions, ...baseOptions }: PublisherConstructorOpts);
    /**
     * Disposes this Publisher instance.
     */
    dispose(): void;
    /**
     * Starts publishing the given track of the given media stream.
     *
     * Consecutive calls to this method will replace the stream.
     * The previous stream will be stopped.
     *
     * @param track the track to publish.
     * @param trackType the track type to publish.
     */
    publish: (track: MediaStreamTrack, trackType: TrackType) => Promise<void>;
    /**
     * Adds a new transceiver carrying the given track to the peer connection.
     */
    private addTransceiver;
    /**
     * Synchronizes the current Publisher state with the provided publish options.
     */
    private syncPublishOptions;
    /**
     * Returns true if the given track type is currently being published to the SFU.
     *
     * @param trackType the track type to check.
     */
    isPublishing: (trackType: TrackType) => boolean;
    /**
     * Maps the given track ID to the corresponding track type.
     */
    getTrackType: (trackId: string) => TrackType | undefined;
    /**
     * Stops the cloned track that is being published to the SFU.
     */
    stopTracks: (...trackTypes: TrackType[]) => void;
    /**
     * Stops all the cloned tracks that are being published to the SFU.
     */
    stopAllTracks: () => void;
    private changePublishQuality;
    /**
     * Restarts the ICE connection and renegotiates with the SFU.
     */
    restartIce: () => Promise<void>;
    /**
     * Initiates a new offer/answer exchange with the currently connected SFU.
     *
     * @param options the optional offer options to use.
     */
    private negotiate;
    /**
     * Returns a list of tracks that are currently being published.
     */
    getPublishedTracks: () => MediaStreamTrack[];
    /**
     * Returns a list of tracks that are currently being published.
     * @param sdp an optional SDP to extract the `mid` from.
     */
    getAnnouncedTracks: (sdp: string | undefined) => TrackInfo[];
    /**
     * Returns a list of tracks that are currently being published.
     * This method shall be used for the reconnection flow.
     * There we shouldn't announce the tracks that have been stopped due to a codec switch.
     */
    getAnnouncedTracksForReconnect: () => TrackInfo[];
    /**
     * Converts the given transceiver to a `TrackInfo` object.
     */
    private toTrackInfo;
    private cloneTrack;
    private stopTrack;
}
