import { PublishOption, VideoDimension, VideoLayer, VideoQuality } from '../gen/video/sfu/models/models';
export type OptimalVideoLayer = RTCRtpEncodingParameters & {
    width: number;
    height: number;
    scalabilityMode?: string;
};
/**
 * In SVC, we need to send only one video encoding (layer).
 * this layer will have the additional spatial and temporal layers
 * defined via the scalabilityMode property.
 *
 * @param layers the layers to process.
 */
export declare const toSvcEncodings: (layers: OptimalVideoLayer[] | undefined) => RTCRtpEncodingParameters[] | undefined;
/**
 * Converts the rid to a video quality.
 */
export declare const ridToVideoQuality: (rid: string) => VideoQuality;
/**
 * Converts the given video layers to SFU video layers.
 */
export declare const toVideoLayers: (layers?: OptimalVideoLayer[] | undefined) => VideoLayer[];
/**
 * Determines the most optimal video layers for the given track.
 *
 * @param videoTrack the video track to find optimal layers for.
 * @param publishOption the publish options for the track.
 */
export declare const computeVideoLayers: (videoTrack: MediaStreamTrack, publishOption: PublishOption) => OptimalVideoLayer[] | undefined;
/**
 * Computes the maximum bitrate for a given resolution.
 * If the current resolution is lower than the target resolution,
 * we want to proportionally reduce the target bitrate.
 * If the current resolution is higher than the target resolution,
 * we want to use the target bitrate.
 *
 * @param targetResolution the target resolution.
 * @param currentWidth the current width of the track.
 * @param currentHeight the current height of the track.
 * @param bitrate the target bitrate.
 */
export declare const getComputedMaxBitrate: (targetResolution: VideoDimension, currentWidth: number, currentHeight: number, bitrate: number) => number;
