import { hasAudio, hasScreenShareAudio, CallingState, hasVideo, hasScreenShare, OwnCapability, Browsers, VisibilityState, getLogger, disposeOfMediaStream, SfuModels, isPinned, name, NoiseCancellationSettingsModeEnum, paginatedLayoutSortPreset, combineComparators, screenSharing, speakerLayoutSortPreset, CallTypes, defaultSortPreset, setSdkInfo } from '@stream-io/video-client';
export * from '@stream-io/video-client';
import { useCall, useCallStateHooks, useI18n, Restricted, useToggleCallRecording, useConnectedUser, StreamCallProvider, StreamVideoProvider, useStreamVideoClient } from '@stream-io/video-react-bindings';
export * from '@stream-io/video-react-bindings';
import { jsx, Fragment, jsxs } from 'react/jsx-runtime';
import { useState, useEffect, Fragment as Fragment$1, createContext, useContext, useCallback, useMemo, useRef, isValidElement, forwardRef, useLayoutEffect, lazy, Suspense } from 'react';
import { useFloating, offset, shift, flip, size, autoUpdate, FloatingOverlay, FloatingPortal, arrow, FloatingArrow, useListItem, useListNavigation, useTypeahead, useClick, useDismiss, useRole, useInteractions, FloatingFocusManager, FloatingList, useHover } from '@floating-ui/react';
import clsx from 'clsx';
import { flushSync } from 'react-dom';
import { isPlatformSupported, loadTFLite, createRenderer } from '@stream-io/video-filters-web';

const Audio = ({ participant, trackType = 'audioTrack', ...rest }) => {
    const call = useCall();
    const [audioElement, setAudioElement] = useState(null);
    const { userId, sessionId } = participant;
    useEffect(() => {
        if (!call || !audioElement)
            return;
        const cleanup = call.bindAudioElement(audioElement, sessionId, trackType);
        return () => {
            cleanup?.();
        };
    }, [call, sessionId, audioElement, trackType]);
    return (jsx("audio", { autoPlay: true, ...rest, ref: setAudioElement, "data-user-id": userId, "data-session-id": sessionId, "data-track-type": trackType }));
};
Audio.displayName = 'Audio';

const ParticipantsAudio = (props) => {
    const { participants, audioProps } = props;
    return (jsx(Fragment, { children: participants.map((participant) => {
            if (participant.isLocalParticipant)
                return null;
            const { audioStream, screenShareAudioStream, sessionId } = participant;
            const hasAudioTrack = hasAudio(participant);
            const audioTrackElement = hasAudioTrack && audioStream && (jsx(Audio, { ...audioProps, trackType: "audioTrack", participant: participant }));
            const hasScreenShareAudioTrack = hasScreenShareAudio(participant);
            const screenShareAudioTrackElement = hasScreenShareAudioTrack &&
                screenShareAudioStream && (jsx(Audio, { ...audioProps, trackType: "screenShareAudioTrack", participant: participant }));
            return (jsxs(Fragment$1, { children: [audioTrackElement, screenShareAudioTrackElement] }, sessionId));
        }) }));
};
ParticipantsAudio.displayName = 'ParticipantsAudio';

const ParticipantViewContext = createContext(undefined);
const useParticipantViewContext = () => useContext(ParticipantViewContext);

const useFloatingUIPreset = ({ middleware = [], placement, strategy, offset: offsetInPx = 10, }) => {
    const { refs, x, y, update, elements: { domReference, floating }, context, } = useFloating({
        placement,
        strategy,
        middleware: [
            offset(offsetInPx),
            shift(),
            flip(),
            size({
                padding: 10,
                apply: ({ availableHeight, elements }) => {
                    Object.assign(elements.floating.style, {
                        maxHeight: `${availableHeight}px`,
                    });
                },
            }),
            ...middleware,
        ],
    });
    // handle window resizing
    useEffect(() => {
        if (!domReference || !floating)
            return;
        const cleanup = autoUpdate(domReference, floating, update);
        return () => cleanup();
    }, [domReference, floating, update]);
    return { refs, x, y, domReference, floating, strategy, context };
};

const defaultDevice = 'default';
/**
 * This hook will apply and persist the device preferences from local storage.
 *
 * @param key the key to use for local storage.
 */
const usePersistedDevicePreferences = (key = '@stream-io/device-preferences') => {
    const { useCallSettings, useCameraState, useMicrophoneState, useSpeakerState, } = useCallStateHooks();
    const settings = useCallSettings();
    usePersistedDevicePreference(key, 'camera', useCameraState(), settings ? !settings.video.camera_default_on : undefined);
    usePersistedDevicePreference(key, 'microphone', useMicrophoneState(), settings ? !settings.audio.mic_default_on : undefined);
    usePersistedDevicePreference(key, 'speaker', useSpeakerState(), false);
};
const usePersistedDevicePreference = (key, deviceKey, state, defaultMuted) => {
    const { useCallCallingState } = useCallStateHooks();
    const callingState = useCallCallingState();
    const [applyingState, setApplyingState] = useState('idle');
    const manager = state[deviceKey];
    useEffect(function apply() {
        if (callingState === CallingState.LEFT ||
            !state.devices?.length ||
            typeof defaultMuted !== 'boolean' ||
            applyingState !== 'idle') {
            return;
        }
        const preferences = parseLocalDevicePreferences(key);
        const preference = preferences[deviceKey];
        setApplyingState('applying');
        if (!manager.state.selectedDevice) {
            const applyPromise = preference
                ? applyLocalDevicePreference(manager, [preference].flat(), state.devices)
                : applyMutedState(manager, defaultMuted);
            applyPromise
                .catch((err) => {
                console.warn(`Failed to apply ${deviceKey} device preferences`, err);
            })
                .finally(() => setApplyingState('applied'));
        }
        else {
            setApplyingState('applied');
        }
    }, [
        applyingState,
        callingState,
        defaultMuted,
        deviceKey,
        key,
        manager,
        state.devices,
    ]);
    useEffect(function persist() {
        if (callingState === CallingState.LEFT ||
            !state.devices?.length ||
            applyingState !== 'applied') {
            return;
        }
        try {
            patchLocalDevicePreference(key, deviceKey, {
                devices: state.devices,
                selectedDevice: state.selectedDevice,
                isMute: state.isMute,
            });
        }
        catch (err) {
            console.warn(`Failed to save ${deviceKey} device preferences`, err);
        }
    }, [
        applyingState,
        callingState,
        deviceKey,
        key,
        state.devices,
        state.isMute,
        state.selectedDevice,
    ]);
};
const parseLocalDevicePreferences = (key) => {
    const preferencesStr = window.localStorage.getItem(key);
    let preferences = {};
    if (preferencesStr) {
        try {
            preferences = JSON.parse(preferencesStr);
            if (Object.hasOwn(preferences, 'mic')) {
                // for backwards compatibility
                preferences.microphone = preferences.mic;
            }
        }
        catch {
            /* assume preferences are empty */
        }
    }
    return preferences;
};
const patchLocalDevicePreference = (key, deviceKey, state) => {
    const preferences = parseLocalDevicePreferences(key);
    const nextPreference = getSelectedDevicePreference(state.devices, state.selectedDevice);
    const preferenceHistory = [preferences[deviceKey] ?? []]
        .flat()
        .filter((p) => p.selectedDeviceId !== nextPreference.selectedDeviceId &&
        (p.selectedDeviceLabel === '' ||
            p.selectedDeviceLabel !== nextPreference.selectedDeviceLabel));
    window.localStorage.setItem(key, JSON.stringify({
        ...preferences,
        mic: undefined, // for backwards compatibility
        [deviceKey]: [
            {
                ...nextPreference,
                muted: state.isMute,
            },
            ...preferenceHistory,
        ].slice(0, 3),
    }));
};
const applyLocalDevicePreference = async (manager, preference, devices) => {
    let muted;
    for (const p of preference) {
        muted ?? (muted = p.muted);
        if (p.selectedDeviceId === defaultDevice) {
            break;
        }
        const device = devices.find((d) => d.deviceId === p.selectedDeviceId) ??
            devices.find((d) => d.label === p.selectedDeviceLabel);
        if (device) {
            await manager.select(device.deviceId);
            muted = p.muted;
            break;
        }
    }
    if (typeof muted === 'boolean') {
        await applyMutedState(manager, muted);
    }
};
const applyMutedState = async (manager, muted) => {
    await manager[muted ? 'disable' : 'enable']?.();
};
const getSelectedDevicePreference = (devices, selectedDevice) => ({
    selectedDeviceId: selectedDevice || defaultDevice,
    selectedDeviceLabel: devices?.find((d) => d.deviceId === selectedDevice)?.label ?? '',
});

const SCROLL_THRESHOLD = 10;
/**
 * Hook which observes element's scroll position and returns text value based on the
 * position of the scrollbar (`top`, `bottom`, `between` and `null` if no scrollbar is available)
 */
const useVerticalScrollPosition = (scrollElement, threshold = SCROLL_THRESHOLD) => {
    const [scrollPosition, setScrollPosition] = useState(null);
    useEffect(() => {
        if (!scrollElement)
            return;
        const scrollHandler = () => {
            const element = scrollElement;
            const hasVerticalScrollbar = element.scrollHeight > element.clientHeight;
            if (!hasVerticalScrollbar)
                return setScrollPosition(null);
            const isAtTheTop = element.scrollTop <= threshold;
            if (isAtTheTop)
                return setScrollPosition('top');
            const isAtTheBottom = Math.abs(element.scrollHeight - element.scrollTop - element.clientHeight) <= threshold;
            if (isAtTheBottom)
                return setScrollPosition('bottom');
            setScrollPosition('between');
        };
        const resizeObserver = new ResizeObserver(scrollHandler);
        resizeObserver.observe(scrollElement);
        scrollElement.addEventListener('scroll', scrollHandler);
        return () => {
            scrollElement.removeEventListener('scroll', scrollHandler);
            resizeObserver.disconnect();
        };
    }, [scrollElement, threshold]);
    return scrollPosition;
};
const useHorizontalScrollPosition = (scrollElement, threshold = SCROLL_THRESHOLD) => {
    const [scrollPosition, setScrollPosition] = useState(null);
    useEffect(() => {
        if (!scrollElement)
            return;
        const scrollHandler = () => {
            const element = scrollElement;
            const hasHorizontalScrollbar = element.scrollWidth > element.clientWidth;
            if (!hasHorizontalScrollbar)
                return setScrollPosition(null);
            const isAtTheStart = element.scrollLeft <= threshold;
            if (isAtTheStart)
                return setScrollPosition('start');
            const isAtTheEnd = Math.abs(element.scrollWidth - element.scrollLeft - element.clientWidth) <= threshold;
            if (isAtTheEnd)
                return setScrollPosition('end');
            setScrollPosition('between');
        };
        const resizeObserver = new ResizeObserver(scrollHandler);
        resizeObserver.observe(scrollElement);
        scrollElement.addEventListener('scroll', scrollHandler);
        return () => {
            scrollElement.removeEventListener('scroll', scrollHandler);
            resizeObserver.disconnect();
        };
    }, [scrollElement, threshold]);
    return scrollPosition;
};

const useRequestPermission = (permission) => {
    const call = useCall();
    const { useHasPermissions } = useCallStateHooks();
    const hasPermission = useHasPermissions(permission);
    const [isAwaitingPermission, setIsAwaitingPermission] = useState(false); // TODO: load with possibly pending state
    useEffect(() => {
        const reset = () => setIsAwaitingPermission(false);
        if (hasPermission)
            reset();
    }, [hasPermission]);
    const requestPermission = useCallback(async () => {
        if (hasPermission)
            return true;
        const canRequestPermission = !!call?.permissionsContext.canRequest(permission);
        if (isAwaitingPermission || !canRequestPermission)
            return false;
        setIsAwaitingPermission(true);
        try {
            await call?.requestPermissions({
                permissions: [permission],
            });
        }
        catch (error) {
            setIsAwaitingPermission(false);
            throw new Error(`requestPermission failed: ${error}`);
        }
        return false;
    }, [call, hasPermission, isAwaitingPermission, permission]);
    return {
        requestPermission,
        hasPermission,
        canRequestPermission: !!call?.permissionsContext.canRequest(permission),
        isAwaitingPermission,
    };
};

/**
 * Utility hook that helps render a list of devices or implement a device selector.
 * Compared to someting like `useCameraState().devices`, it has some handy features:
 * 1. Adds the "Default" device to the list if applicable (either the user did not
 * select a device, or a previously selected device is no longer available).
 * 2. Maps the device list to a format more suitable for rendering.
 */
function useDeviceList(devices, selectedDeviceId) {
    const { t } = useI18n();
    return useMemo(() => {
        let selectedDeviceInfo = null;
        let selectedIndex = null;
        const deviceList = devices.map((d, i) => {
            const isSelected = d.deviceId === selectedDeviceId;
            const device = { deviceId: d.deviceId, label: d.label, isSelected };
            if (isSelected) {
                selectedDeviceInfo = device;
                selectedIndex = i;
            }
            return device;
        });
        if (selectedDeviceInfo === null || selectedIndex === null) {
            const defaultDevice = {
                deviceId: 'default',
                label: t('Default'),
                isSelected: true,
            };
            selectedDeviceInfo = defaultDevice;
            selectedIndex = 0;
            deviceList.unshift(defaultDevice);
        }
        return { deviceList, selectedDeviceInfo, selectedIndex };
    }, [devices, selectedDeviceId, t]);
}

var MenuVisualType;
(function (MenuVisualType) {
    MenuVisualType["PORTAL"] = "portal";
    MenuVisualType["MENU"] = "menu";
})(MenuVisualType || (MenuVisualType = {}));
/**
 * Used to provide utility APIs to the components rendered inside the portal.
 */
const MenuContext = createContext({});
/**
 * Access to the closes MenuContext.
 */
const useMenuContext = () => {
    return useContext(MenuContext);
};
const MenuPortal = ({ children, refs, }) => {
    const portalId = useMemo(() => `str-video-portal-${Math.random().toString(36).substring(2, 9)}`, []);
    return (jsxs(Fragment, { children: [jsx("div", { id: portalId, className: "str-video__portal" }), jsx(FloatingOverlay, { children: jsx(FloatingPortal, { id: portalId, children: jsx("div", { className: "str-video__portal-content", ref: refs.setFloating, children: children }) }) })] }));
};
const MenuToggle = ({ ToggleButton, placement = 'top-start', strategy = 'absolute', offset, visualType = MenuVisualType.MENU, children, onToggle, }) => {
    const [menuShown, setMenuShown] = useState(false);
    const toggleHandler = useRef(onToggle);
    toggleHandler.current = onToggle;
    const { floating, domReference, refs, x, y } = useFloatingUIPreset({
        placement,
        strategy,
        offset,
    });
    useEffect(() => {
        const parentDocument = domReference?.ownerDocument;
        const handleClick = (event) => {
            if (!floating && domReference?.contains(event.target)) {
                setMenuShown(true);
                toggleHandler.current?.(true);
            }
            else if (floating && !floating?.contains(event.target)) {
                setMenuShown(false);
                toggleHandler.current?.(false);
            }
        };
        const handleKeyDown = (event) => {
            if (event.key && // key can be undefined in some browsers
                event.key.toLowerCase() === 'escape' &&
                !event.altKey &&
                !event.ctrlKey) {
                setMenuShown(false);
                toggleHandler.current?.(false);
            }
        };
        parentDocument?.addEventListener('click', handleClick, { capture: true });
        parentDocument?.addEventListener('keydown', handleKeyDown);
        return () => {
            parentDocument?.removeEventListener('click', handleClick, {
                capture: true,
            });
            parentDocument?.removeEventListener('keydown', handleKeyDown);
        };
    }, [floating, domReference]);
    return (jsxs(Fragment, { children: [menuShown && (jsx(MenuContext.Provider, { value: { close: () => setMenuShown(false) }, children: visualType === MenuVisualType.PORTAL ? (jsx(MenuPortal, { refs: refs, children: children })) : visualType === MenuVisualType.MENU ? (jsx("div", { className: "str-video__menu-container", ref: refs.setFloating, style: {
                        position: strategy,
                        top: y ?? 0,
                        left: x ?? 0,
                        overflowY: 'auto',
                    }, role: "menu", children: children })) : null })), jsx(ToggleButton, { menuShown: menuShown, ref: refs.setReference })] }));
};

const GenericMenu = ({ children, onItemClick, }) => {
    const ref = useRef(null);
    return (jsx("ul", { className: "str-video__generic-menu", ref: ref, onClick: (e) => {
            if (onItemClick &&
                e.target !== ref.current &&
                ref.current?.contains(e.target)) {
                onItemClick(e);
            }
        }, children: children }));
};
const GenericMenuButtonItem = ({ children, ...rest }) => {
    return (jsx("li", { className: "str-video__generic-menu--item", children: jsx("button", { ...rest, children: children }) }));
};

const Icon = ({ className, icon }) => (jsx("span", { className: clsx('str-video__icon', icon && `str-video__icon--${icon}`, className) }));

function usePictureInPictureState(videoElement) {
    const [isPiP, setIsPiP] = useState(document.pictureInPictureElement === videoElement);
    if (!videoElement && isPiP)
        setIsPiP(false);
    useEffect(() => {
        if (!videoElement)
            return;
        const handlePiP = () => {
            setIsPiP(document.pictureInPictureElement === videoElement);
        };
        videoElement.addEventListener('enterpictureinpicture', handlePiP);
        videoElement.addEventListener('leavepictureinpicture', handlePiP);
        return () => {
            videoElement.removeEventListener('enterpictureinpicture', handlePiP);
            videoElement.removeEventListener('leavepictureinpicture', handlePiP);
        };
    }, [videoElement]);
    return isPiP;
}

const ParticipantActionsContextMenu = () => {
    const { participant, participantViewElement, videoElement } = useParticipantViewContext();
    const [fullscreenModeOn, setFullscreenModeOn] = useState(!!document.fullscreenElement);
    const call = useCall();
    const isPiP = usePictureInPictureState(videoElement ?? undefined);
    const { t } = useI18n();
    const { pin, sessionId, userId } = participant;
    const hasAudioTrack = hasAudio(participant);
    const hasVideoTrack = hasVideo(participant);
    const hasScreenShareTrack = hasScreenShare(participant);
    const hasScreenShareAudioTrack = hasScreenShareAudio(participant);
    const blockUser = () => call?.blockUser(userId);
    const muteAudio = () => call?.muteUser(userId, 'audio');
    const muteVideo = () => call?.muteUser(userId, 'video');
    const muteScreenShare = () => call?.muteUser(userId, 'screenshare');
    const muteScreenShareAudio = () => call?.muteUser(userId, 'screenshare_audio');
    const grantPermission = (permission) => () => {
        call?.updateUserPermissions({
            user_id: userId,
            grant_permissions: [permission],
        });
    };
    const revokePermission = (permission) => () => {
        call?.updateUserPermissions({
            user_id: userId,
            revoke_permissions: [permission],
        });
    };
    const toggleParticipantPin = () => {
        if (pin) {
            call?.unpin(sessionId);
        }
        else {
            call?.pin(sessionId);
        }
    };
    const pinForEveryone = () => {
        call
            ?.pinForEveryone({
            user_id: userId,
            session_id: sessionId,
        })
            .catch((err) => {
            console.error(`Failed to pin participant ${userId}`, err);
        });
    };
    const unpinForEveryone = () => {
        call
            ?.unpinForEveryone({
            user_id: userId,
            session_id: sessionId,
        })
            .catch((err) => {
            console.error(`Failed to unpin participant ${userId}`, err);
        });
    };
    const toggleFullscreenMode = () => {
        if (!fullscreenModeOn) {
            return participantViewElement?.requestFullscreen().catch(console.error);
        }
        return document.exitFullscreen().catch(console.error);
    };
    useEffect(() => {
        // handles the case when fullscreen mode is toggled externally,
        // e.g., by pressing ESC key or some other keyboard shortcut
        const handleFullscreenChange = () => {
            setFullscreenModeOn(!!document.fullscreenElement);
        };
        document.addEventListener('fullscreenchange', handleFullscreenChange);
        return () => {
            document.removeEventListener('fullscreenchange', handleFullscreenChange);
        };
    }, []);
    const togglePictureInPicture = () => {
        if (videoElement && !isPiP) {
            return videoElement
                .requestPictureInPicture()
                .catch(console.error);
        }
        return document.exitPictureInPicture().catch(console.error);
    };
    const { close } = useMenuContext() || {};
    return (jsxs(GenericMenu, { onItemClick: close, children: [jsxs(GenericMenuButtonItem, { onClick: toggleParticipantPin, disabled: pin && !pin.isLocalPin, children: [jsx(Icon, { icon: "pin" }), pin ? t('Unpin') : t('Pin')] }), jsxs(Restricted, { requiredGrants: [OwnCapability.PIN_FOR_EVERYONE], children: [jsxs(GenericMenuButtonItem, { onClick: pinForEveryone, disabled: pin && !pin.isLocalPin, children: [jsx(Icon, { icon: "pin" }), t('Pin for everyone')] }), jsxs(GenericMenuButtonItem, { onClick: unpinForEveryone, disabled: !pin || pin.isLocalPin, children: [jsx(Icon, { icon: "pin" }), t('Unpin for everyone')] })] }), jsx(Restricted, { requiredGrants: [OwnCapability.BLOCK_USERS], children: jsxs(GenericMenuButtonItem, { onClick: blockUser, children: [jsx(Icon, { icon: "not-allowed" }), t('Block')] }) }), jsxs(Restricted, { requiredGrants: [OwnCapability.MUTE_USERS], children: [hasVideoTrack && (jsxs(GenericMenuButtonItem, { onClick: muteVideo, children: [jsx(Icon, { icon: "camera-off-outline" }), t('Turn off video')] })), hasScreenShareTrack && (jsxs(GenericMenuButtonItem, { onClick: muteScreenShare, children: [jsx(Icon, { icon: "screen-share-off" }), t('Turn off screen share')] })), hasAudioTrack && (jsxs(GenericMenuButtonItem, { onClick: muteAudio, children: [jsx(Icon, { icon: "no-audio" }), t('Mute audio')] })), hasScreenShareAudioTrack && (jsxs(GenericMenuButtonItem, { onClick: muteScreenShareAudio, children: [jsx(Icon, { icon: "no-audio" }), t('Mute screen share audio')] }))] }), participantViewElement &&
                typeof participantViewElement.requestFullscreen !== 'undefined' && (jsx(GenericMenuButtonItem, { onClick: toggleFullscreenMode, children: t('{{ direction }} fullscreen', {
                    direction: fullscreenModeOn ? t('Leave') : t('Enter'),
                }) })), videoElement && document.pictureInPictureEnabled && (jsx(GenericMenuButtonItem, { onClick: togglePictureInPicture, children: t('{{ direction }} picture-in-picture', {
                    direction: isPiP ? t('Leave') : t('Enter'),
                }) })), jsxs(Restricted, { requiredGrants: [OwnCapability.UPDATE_CALL_PERMISSIONS], children: [jsx(GenericMenuButtonItem, { onClick: grantPermission(OwnCapability.SEND_AUDIO), children: t('Allow audio') }), jsx(GenericMenuButtonItem, { onClick: grantPermission(OwnCapability.SEND_VIDEO), children: t('Allow video') }), jsx(GenericMenuButtonItem, { onClick: grantPermission(OwnCapability.SCREENSHARE), children: t('Allow screen sharing') }), jsx(GenericMenuButtonItem, { onClick: revokePermission(OwnCapability.SEND_AUDIO), children: t('Disable audio') }), jsx(GenericMenuButtonItem, { onClick: revokePermission(OwnCapability.SEND_VIDEO), children: t('Disable video') }), jsx(GenericMenuButtonItem, { onClick: revokePermission(OwnCapability.SCREENSHARE), children: t('Disable screen sharing') })] })] }));
};

const isComponentType = (elementOrComponent) => {
    return elementOrComponent === null
        ? false
        : !isValidElement(elementOrComponent);
};

const chunk = (array, size) => {
    const chunkCount = Math.ceil(array.length / size);
    return Array.from({ length: chunkCount }, (_, index) => array.slice(size * index, size * index + size));
};

const applyElementToRef = (ref, element) => {
    if (!ref)
        return;
    if (typeof ref === 'function')
        return ref(element);
    ref.current = element;
};

/**
 * @description Extends video element with `stream` property
 * (`srcObject`) to reactively handle stream changes
 */
const BaseVideo = forwardRef(function BaseVideo({ stream, ...rest }, ref) {
    const [videoElement, setVideoElement] = useState(null);
    useEffect(() => {
        if (!videoElement || !stream)
            return;
        if (stream === videoElement.srcObject)
            return;
        videoElement.srcObject = stream;
        if (Browsers.isSafari() || Browsers.isFirefox()) {
            // Firefox and Safari have some timing issue
            setTimeout(() => {
                videoElement.srcObject = stream;
                videoElement.play().catch((e) => {
                    console.error(`Failed to play stream`, e);
                });
            }, 0);
        }
        return () => {
            videoElement.pause();
            videoElement.srcObject = null;
        };
    }, [stream, videoElement]);
    return (jsx("video", { autoPlay: true, playsInline: true, ...rest, ref: (element) => {
            applyElementToRef(ref, element);
            setVideoElement(element);
        } }));
});

const BaseVideoPlaceholder = forwardRef(function DefaultVideoPlaceholder({ participant, style, children }, ref) {
    const [error, setError] = useState(false);
    const name = participant.name || participant.userId;
    return (jsxs("div", { className: "str-video__video-placeholder", style: style, ref: ref, children: [(!participant.image || error) &&
                (name ? (jsx(InitialsFallback, { name: name })) : (jsx("div", { className: "str-video__video-placeholder__no-video-label", children: children }))), participant.image && !error && (jsx("img", { onError: () => setError(true), alt: name, className: "str-video__video-placeholder__avatar", src: participant.image }))] }));
});
const InitialsFallback = (props) => {
    const { name } = props;
    const initials = name
        .split(' ')
        .slice(0, 2)
        .map((n) => n[0])
        .join('');
    return (jsx("div", { className: "str-video__video-placeholder__initials-fallback", children: initials }));
};

const DefaultVideoPlaceholder = forwardRef(function DefaultVideoPlaceholder(props, ref) {
    const { t } = useI18n();
    return (jsx(BaseVideoPlaceholder, { ref: ref, ...props, children: t('Video is disabled') }));
});

const DefaultPictureInPicturePlaceholder = forwardRef(function DefaultPictureInPicturePlaceholder(props, ref) {
    const { t } = useI18n();
    return (jsx(BaseVideoPlaceholder, { ref: ref, ...props, children: t('Video is playing in a popup') }));
});

const Video$1 = ({ enabled = true, mirror, trackType, participant, className, VideoPlaceholder = DefaultVideoPlaceholder, PictureInPicturePlaceholder = DefaultPictureInPicturePlaceholder, refs, ...rest }) => {
    const { sessionId, videoStream, screenShareStream, viewportVisibilityState, isLocalParticipant, userId, } = participant;
    const call = useCall();
    const [videoElement, setVideoElement] = useState(null);
    // start with true, will flip once the video starts playing
    const [isVideoPaused, setIsVideoPaused] = useState(true);
    const [isWideMode, setIsWideMode] = useState(true);
    const isPiP = usePictureInPictureState(videoElement ?? undefined);
    const stream = trackType === 'videoTrack'
        ? videoStream
        : trackType === 'screenShareTrack'
            ? screenShareStream
            : undefined;
    useLayoutEffect(() => {
        if (!call || !videoElement || trackType === 'none')
            return;
        const cleanup = call.bindVideoElement(videoElement, sessionId, trackType);
        return () => {
            cleanup?.();
        };
    }, [call, trackType, sessionId, videoElement]);
    useEffect(() => {
        if (!stream || !videoElement)
            return;
        const [track] = stream.getVideoTracks();
        if (!track)
            return;
        const handlePlayPause = () => {
            setIsVideoPaused(videoElement.paused);
            const { width = 0, height = 0 } = track.getSettings();
            setIsWideMode(width >= height);
        };
        // playback may have started before we had a chance to
        // attach the 'play/pause' event listener, so we set the state
        // here to make sure it's in sync
        setIsVideoPaused(videoElement.paused);
        videoElement.addEventListener('play', handlePlayPause);
        videoElement.addEventListener('pause', handlePlayPause);
        track.addEventListener('unmute', handlePlayPause);
        return () => {
            videoElement.removeEventListener('play', handlePlayPause);
            videoElement.removeEventListener('pause', handlePlayPause);
            track.removeEventListener('unmute', handlePlayPause);
            // reset the 'pause' state once we unmount the video element
            setIsVideoPaused(true);
        };
    }, [stream, videoElement]);
    if (!call)
        return null;
    const isPublishingTrack = trackType === 'videoTrack'
        ? hasVideo(participant)
        : trackType === 'screenShareTrack'
            ? hasScreenShare(participant)
            : false;
    const isInvisible = trackType === 'none' ||
        viewportVisibilityState?.[trackType] === VisibilityState.INVISIBLE;
    const hasNoVideoOrInvisible = !enabled || !isPublishingTrack || isInvisible;
    const mirrorVideo = mirror === undefined
        ? isLocalParticipant && trackType === 'videoTrack'
        : mirror;
    const isScreenShareTrack = trackType === 'screenShareTrack';
    return (jsxs(Fragment, { children: [!hasNoVideoOrInvisible && (jsx("video", { ...rest, className: clsx('str-video__video', className, {
                    'str-video__video--not-playing': isVideoPaused,
                    'str-video__video--tall': !isWideMode,
                    'str-video__video--mirror': mirrorVideo,
                    'str-video__video--screen-share': isScreenShareTrack,
                }), "data-user-id": userId, "data-session-id": sessionId, ref: (element) => {
                    setVideoElement(element);
                    refs?.setVideoElement?.(element);
                } })), isPiP && PictureInPicturePlaceholder && (jsx(PictureInPicturePlaceholder, { style: { position: 'absolute' }, participant: participant })), (hasNoVideoOrInvisible || isVideoPaused) && VideoPlaceholder && (jsx(VideoPlaceholder, { style: { position: 'absolute' }, participant: participant, ref: refs?.setVideoPlaceholderElement }))] }));
};
Video$1.displayName = 'Video';

const useTrackElementVisibility = ({ trackedElement, dynascaleManager: propsDynascaleManager, sessionId, trackType, }) => {
    const call = useCall();
    const manager = propsDynascaleManager ?? call?.dynascaleManager;
    useEffect(() => {
        if (!trackedElement || !manager || !call || trackType === 'none')
            return;
        const unobserve = manager.trackElementVisibility(trackedElement, sessionId, trackType);
        return () => {
            unobserve();
        };
    }, [trackedElement, manager, call, sessionId, trackType]);
};

const Avatar = ({ imageSrc, name, style, className, ...rest }) => {
    const [error, setError] = useState(false);
    return (jsxs(Fragment, { children: [(!imageSrc || error) && name && (jsx(AvatarFallback, { className: className, style: style, names: [name] })), imageSrc && !error && (jsx("img", { onError: () => setError(true), alt: "avatar", className: clsx('str-video__avatar', className), src: imageSrc, style: style, ...rest }))] }));
};
const AvatarFallback = ({ className, names, style, }) => {
    return (jsx("div", { className: clsx('str-video__avatar--initials-fallback', className), style: style, children: jsxs("div", { children: [names[0][0], names[1]?.[0]] }) }));
};

/**
 * The context for the background filters.
 */
const BackgroundFiltersContext = createContext(undefined);
/**
 * A hook to access the background filters context API.
 */
const useBackgroundFilters = () => {
    const context = useContext(BackgroundFiltersContext);
    if (!context) {
        throw new Error('useBackgroundFilters must be used within a BackgroundFiltersProvider');
    }
    return context;
};
/**
 * A provider component that enables the use of background filters in your app.
 *
 * Please make sure you have the `@stream-io/video-filters-web` package installed
 * in your project before using this component.
 */
const BackgroundFiltersProvider = (props) => {
    const { children, backgroundImages = [], backgroundFilter: bgFilterFromProps = undefined, backgroundImage: bgImageFromProps = undefined, backgroundBlurLevel: bgBlurLevelFromProps = undefined, tfFilePath, modelFilePath, basePath, onError, } = props;
    const [backgroundFilter, setBackgroundFilter] = useState(bgFilterFromProps);
    const [backgroundImage, setBackgroundImage] = useState(bgImageFromProps);
    const [backgroundBlurLevel, setBackgroundBlurLevel] = useState(bgBlurLevelFromProps);
    const applyBackgroundImageFilter = useCallback((imageUrl) => {
        setBackgroundFilter('image');
        setBackgroundImage(imageUrl);
    }, []);
    const applyBackgroundBlurFilter = useCallback((blurLevel = 'high') => {
        setBackgroundFilter('blur');
        setBackgroundBlurLevel(blurLevel);
    }, []);
    const disableBackgroundFilter = useCallback(() => {
        setBackgroundFilter(undefined);
        setBackgroundImage(undefined);
        setBackgroundBlurLevel(undefined);
    }, []);
    const [isSupported, setIsSupported] = useState(false);
    useEffect(() => {
        isPlatformSupported().then(setIsSupported);
    }, []);
    const [tfLite, setTfLite] = useState();
    useEffect(() => {
        // don't try to load TFLite if the platform is not supported
        if (!isSupported)
            return;
        loadTFLite({ basePath, modelFilePath, tfFilePath })
            .then(setTfLite)
            .catch((err) => console.error('Failed to load TFLite', err));
    }, [basePath, isSupported, modelFilePath, tfFilePath]);
    const handleError = useCallback((error) => {
        getLogger(['filters'])('warn', 'Filter encountered an error and will be disabled');
        disableBackgroundFilter();
        onError?.(error);
    }, [disableBackgroundFilter, onError]);
    return (jsxs(BackgroundFiltersContext.Provider, { value: {
            isSupported,
            isReady: !!tfLite,
            backgroundImage,
            backgroundBlurLevel,
            backgroundFilter,
            disableBackgroundFilter,
            applyBackgroundBlurFilter,
            applyBackgroundImageFilter,
            backgroundImages,
            tfFilePath,
            modelFilePath,
            basePath,
            onError: handleError,
        }, children: [children, tfLite && jsx(BackgroundFilters, { tfLite: tfLite })] }));
};
const BackgroundFilters = (props) => {
    const call = useCall();
    const { children, start } = useRenderer(props.tfLite);
    const { backgroundFilter, onError } = useBackgroundFilters();
    const handleErrorRef = useRef(undefined);
    handleErrorRef.current = onError;
    useEffect(() => {
        if (!call || !backgroundFilter)
            return;
        const { unregister } = call.camera.registerFilter((ms) => start(ms, (error) => handleErrorRef.current?.(error)));
        return () => {
            unregister();
        };
    }, [backgroundFilter, call, start]);
    return children;
};
const useRenderer = (tfLite) => {
    const { backgroundFilter, backgroundBlurLevel, backgroundImage } = useBackgroundFilters();
    const videoRef = useRef(null);
    const canvasRef = useRef(null);
    const bgImageRef = useRef(null);
    const [videoSize, setVideoSize] = useState({
        width: 1920,
        height: 1080,
    });
    const start = useCallback((ms, onError) => {
        let outputStream;
        let renderer;
        const output = new Promise((resolve, reject) => {
            if (!backgroundFilter) {
                reject(new Error('No filter specified'));
                return;
            }
            const videoEl = videoRef.current;
            const canvasEl = canvasRef.current;
            const bgImageEl = bgImageRef.current;
            if (!videoEl || !canvasEl || (backgroundImage && !bgImageEl)) {
                // You should start renderer in effect or event handlers
                reject(new Error('Renderer started before elements are ready'));
                return;
            }
            videoEl.srcObject = ms;
            videoEl.play().then(() => {
                const [track] = ms.getVideoTracks();
                if (!track) {
                    reject(new Error('No video tracks in input media stream'));
                    return;
                }
                const trackSettings = track.getSettings();
                flushSync(() => setVideoSize({
                    width: trackSettings.width ?? 0,
                    height: trackSettings.height ?? 0,
                }));
                renderer = createRenderer(tfLite, videoEl, canvasEl, {
                    backgroundFilter,
                    backgroundBlurLevel,
                    backgroundImage: bgImageEl ?? undefined,
                }, onError);
                outputStream = canvasEl.captureStream();
                resolve(outputStream);
            }, () => {
                reject(new Error('Could not play the source video stream'));
            });
        });
        return {
            output,
            stop: () => {
                renderer?.dispose();
                if (videoRef.current)
                    videoRef.current.srcObject = null;
                if (outputStream)
                    disposeOfMediaStream(outputStream);
            },
        };
    }, [backgroundBlurLevel, backgroundFilter, backgroundImage, tfLite]);
    const children = (jsxs("div", { className: "str-video__background-filters", children: [jsx("video", { className: clsx('str-video__background-filters__video', videoSize.height > videoSize.width &&
                    'str-video__background-filters__video--tall'), ref: videoRef, playsInline: true, muted: true, controls: false, ...videoSize }), backgroundImage && (jsx("img", { className: "str-video__background-filters__background-image", alt: "Background", ref: bgImageRef, src: backgroundImage, ...videoSize })), jsx("canvas", { className: "str-video__background-filters__target-canvas", ...videoSize, ref: canvasRef })] }));
    return {
        start,
        children,
    };
};

const IconButton = forwardRef(function IconButton(props, ref) {
    const { icon, enabled, variant, onClick, className, ...rest } = props;
    return (jsx("button", { className: clsx('str-video__call-controls__button', className, {
            [`str-video__call-controls__button--variant-${variant}`]: variant,
            'str-video__call-controls__button--enabled': enabled,
        }), onClick: (e) => {
            e.preventDefault();
            onClick?.(e);
        }, ref: ref, ...rest, children: jsx(Icon, { icon: icon }) }));
});

const CompositeButton = forwardRef(function CompositeButton({ disabled, caption, children, className, active, Menu, menuPlacement, menuOffset, title, ToggleMenuButton = DefaultToggleMenuButton, variant, onClick, onMenuToggle, ...restButtonProps }, ref) {
    return (jsxs("div", { className: clsx('str-video__composite-button', className, {
            'str-video__composite-button--caption': caption,
            'str-video__composite-button--menu': Menu,
        }), title: title, ref: ref, children: [jsxs("div", { className: clsx('str-video__composite-button__button-group', {
                    'str-video__composite-button__button-group--active': active,
                    'str-video__composite-button__button-group--active-primary': active && variant === 'primary',
                    'str-video__composite-button__button-group--active-secondary': active && variant === 'secondary',
                    'str-video__composite-button__button-group--disabled': disabled,
                }), children: [jsx("button", { type: "button", className: "str-video__composite-button__button", onClick: (e) => {
                            e.preventDefault();
                            onClick?.(e);
                        }, disabled: disabled, ...restButtonProps, children: children }), Menu && (jsx(MenuToggle, { offset: menuOffset, placement: menuPlacement, ToggleButton: ToggleMenuButton, onToggle: onMenuToggle, children: isComponentType(Menu) ? jsx(Menu, {}) : Menu }))] }), caption && (jsx("div", { className: "str-video__composite-button__caption", children: caption }))] }));
});
const DefaultToggleMenuButton = forwardRef(function DefaultToggleMenuButton({ menuShown }, ref) {
    return (jsx(IconButton, { className: clsx('str-video__menu-toggle-button', {
            'str-video__menu-toggle-button--active': menuShown,
        }), icon: menuShown ? 'caret-down' : 'caret-up', ref: ref }));
});

const TextButton = ({ children, ...rest }) => {
    return (jsx("button", { ...rest, className: "str-video__text-button", children: children }));
};

const AcceptCallButton = ({ disabled, onAccept, onClick, }) => {
    const call = useCall();
    const handleClick = useCallback(async (e) => {
        if (onClick) {
            onClick(e);
        }
        else if (call) {
            await call.join();
            onAccept?.();
        }
    }, [onClick, onAccept, call]);
    return (jsx(IconButton, { disabled: disabled, icon: "call-accept", variant: "success", "data-testid": "accept-call-button", onClick: handleClick }));
};

const Notification = (props) => {
    const { isVisible, message, children, visibilityTimeout, resetIsVisible, placement = 'top', iconClassName = 'str-video__notification__icon', close, } = props;
    const { refs, x, y, strategy } = useFloatingUIPreset({
        placement,
        strategy: 'absolute',
    });
    useEffect(() => {
        if (!isVisible || !visibilityTimeout || !resetIsVisible)
            return;
        const timeout = setTimeout(() => {
            resetIsVisible();
        }, visibilityTimeout);
        return () => clearTimeout(timeout);
    }, [isVisible, resetIsVisible, visibilityTimeout]);
    return (jsxs("div", { ref: refs.setReference, children: [isVisible && (jsxs("div", { className: "str-video__notification", ref: refs.setFloating, style: {
                    position: strategy,
                    top: y ?? 0,
                    left: x ?? 0,
                    overflowY: 'auto',
                }, children: [iconClassName && jsx("i", { className: iconClassName }), jsx("span", { className: "str-video__notification__message", children: message }), close ? (jsx("i", { className: "str-video__icon str-video__icon--close str-video__notification__close", onClick: close })) : null] })), children] }));
};

const PermissionNotification = (props) => {
    const { permission, isAwaitingApproval, messageApproved, messageAwaitingApproval, messageRevoked, visibilityTimeout = 3500, children, } = props;
    const { useHasPermissions } = useCallStateHooks();
    const hasPermission = useHasPermissions(permission);
    const prevHasPermission = useRef(hasPermission);
    const [showNotification, setShowNotification] = useState();
    useEffect(() => {
        if (hasPermission && !prevHasPermission.current) {
            setShowNotification('granted');
            prevHasPermission.current = true;
        }
        else if (!hasPermission && prevHasPermission.current) {
            setShowNotification('revoked');
            prevHasPermission.current = false;
        }
    }, [hasPermission]);
    const resetIsVisible = useCallback(() => setShowNotification(undefined), []);
    if (isAwaitingApproval) {
        return (jsx(Notification, { isVisible: isAwaitingApproval && !hasPermission, message: messageAwaitingApproval, children: children }));
    }
    return (jsx(Notification, { isVisible: !!showNotification, visibilityTimeout: visibilityTimeout, resetIsVisible: resetIsVisible, message: showNotification === 'granted' ? messageApproved : messageRevoked, children: children }));
};

const SpeakingWhileMutedNotification = ({ children, text, placement, }) => {
    const { useMicrophoneState } = useCallStateHooks();
    const { isSpeakingWhileMuted } = useMicrophoneState();
    const { t } = useI18n();
    const message = text ?? t('You are muted. Unmute to speak.');
    return (jsx(Notification, { message: message, isVisible: isSpeakingWhileMuted, placement: placement || 'top-start', children: children }));
};

const RecordingInProgressNotification = ({ children, text, }) => {
    const { t } = useI18n();
    const { isCallRecordingInProgress } = useToggleCallRecording();
    const [isVisible, setVisible] = useState(false);
    const message = text ?? t('Recording in progress...');
    useEffect(() => {
        if (isCallRecordingInProgress) {
            setVisible(true);
        }
        else {
            setVisible(false);
        }
    }, [isCallRecordingInProgress]);
    return (jsx(Notification, { message: message, iconClassName: "str-video__icon str-video__icon--recording-on", isVisible: isVisible, placement: "top-start", close: () => setVisible(false), children: children }));
};

const LoadingIndicator = ({ className, type = 'spinner', text, tooltip, }) => {
    return (jsxs("div", { className: clsx('str-video__loading-indicator', className), title: tooltip, children: [jsx("div", { className: clsx('str-video__loading-indicator__icon', type) }), text && jsx("p", { className: "str-video__loading-indicator-text", children: text })] }));
};

const Tooltip = ({ children, referenceElement, tooltipClassName, tooltipPlacement = 'top', visible = false, }) => {
    const arrowRef = useRef(null);
    const { refs, x, y, strategy, context } = useFloatingUIPreset({
        placement: tooltipPlacement,
        strategy: 'absolute',
        middleware: [arrow({ element: arrowRef })],
    });
    useEffect(() => {
        refs.setReference(referenceElement);
    }, [referenceElement, refs]);
    if (!visible)
        return null;
    return (jsxs("div", { className: clsx('str-video__tooltip', tooltipClassName), ref: refs.setFloating, style: {
            position: strategy,
            top: y ?? 0,
            left: x ?? 0,
        }, children: [jsx(FloatingArrow, { ref: arrowRef, context: context, fill: "var(--str-video__tooltip--background-color)" }), children] }));
};

const useEnterLeaveHandlers = ({ onMouseEnter, onMouseLeave, } = {}) => {
    const [tooltipVisible, setTooltipVisible] = useState(false);
    const handleMouseEnter = useCallback((e) => {
        setTooltipVisible(true);
        onMouseEnter?.(e);
    }, [onMouseEnter]);
    const handleMouseLeave = useCallback((e) => {
        setTooltipVisible(false);
        onMouseLeave?.(e);
    }, [onMouseLeave]);
    return { handleMouseEnter, handleMouseLeave, tooltipVisible };
};

// todo: duplicate of CallParticipantList.tsx#MediaIndicator - refactor to a single component
const WithTooltip = ({ title, tooltipClassName, tooltipPlacement, tooltipDisabled, ...props }) => {
    const { handleMouseEnter, handleMouseLeave, tooltipVisible } = useEnterLeaveHandlers();
    const [tooltipAnchor, setTooltipAnchor] = useState(null);
    const tooltipActuallyVisible = !tooltipDisabled && Boolean(title) && tooltipVisible;
    return (jsxs(Fragment, { children: [jsx(Tooltip, { referenceElement: tooltipAnchor, visible: tooltipActuallyVisible, tooltipClassName: tooltipClassName, tooltipPlacement: tooltipPlacement, children: title || '' }), jsx("div", { ref: setTooltipAnchor, onMouseEnter: handleMouseEnter, onMouseLeave: handleMouseLeave, ...props })] }));
};

const RecordEndConfirmation = () => {
    const { t } = useI18n();
    const { toggleCallRecording, isAwaitingResponse } = useToggleCallRecording();
    const { close } = useMenuContext();
    return (jsxs("div", { className: "str-video__end-recording__confirmation", children: [jsxs("div", { className: "str-video__end-recording__header", children: [jsx(Icon, { icon: "recording-on" }), jsx("h2", { className: "str-video__end-recording__heading", children: t('End recording') })] }), jsx("p", { className: "str-video__end-recording__description", children: t('Are you sure you want end the recording?') }), jsxs("div", { className: "str-video__end-recording__actions", children: [jsx(CompositeButton, { variant: "secondary", onClick: close, children: t('Cancel') }), jsx(CompositeButton, { variant: "primary", onClick: toggleCallRecording, children: isAwaitingResponse ? jsx(LoadingIndicator, {}) : t('End recording') })] })] }));
};
const ToggleEndRecordingMenuButton = forwardRef(function ToggleEndRecordingMenuButton(props, ref) {
    return (jsx(CompositeButton, { ref: ref, active: true, variant: "secondary", "data-testid": "recording-stop-button", children: jsx(Icon, { icon: "recording-off" }) }));
});
const RecordCallConfirmationButton = ({ caption, }) => {
    const { t } = useI18n();
    const { toggleCallRecording, isAwaitingResponse, isCallRecordingInProgress } = useToggleCallRecording();
    if (isCallRecordingInProgress) {
        return (jsx(Restricted, { requiredGrants: [
                OwnCapability.START_RECORD_CALL,
                OwnCapability.STOP_RECORD_CALL,
            ], children: jsx(MenuToggle, { ToggleButton: ToggleEndRecordingMenuButton, visualType: MenuVisualType.PORTAL, children: jsx(RecordEndConfirmation, {}) }) }));
    }
    const title = isAwaitingResponse
        ? t('Waiting for recording to start...')
        : (caption ?? t('Record call'));
    return (jsx(Restricted, { requiredGrants: [
            OwnCapability.START_RECORD_CALL,
            OwnCapability.STOP_RECORD_CALL,
        ], children: jsx(WithTooltip, { title: title, children: jsx(CompositeButton, { active: isCallRecordingInProgress, caption: caption, variant: "secondary", "data-testid": "recording-start-button", onClick: isAwaitingResponse ? undefined : toggleCallRecording, children: isAwaitingResponse ? (jsx(LoadingIndicator, {})) : (jsx(Icon, { icon: "recording-off" })) }) }) }));
};
const RecordCallButton = ({ caption }) => {
    const { t } = useI18n();
    const { toggleCallRecording, isAwaitingResponse, isCallRecordingInProgress } = useToggleCallRecording();
    let title = caption ?? t('Record call');
    if (isAwaitingResponse) {
        title = isCallRecordingInProgress
            ? t('Waiting for recording to stop...')
            : t('Waiting for recording to start...');
    }
    return (jsx(Restricted, { requiredGrants: [
            OwnCapability.START_RECORD_CALL,
            OwnCapability.STOP_RECORD_CALL,
        ], children: jsx(CompositeButton, { active: isCallRecordingInProgress, caption: caption, variant: "secondary", "data-testid": isCallRecordingInProgress
                ? 'recording-stop-button'
                : 'recording-start-button', title: title, onClick: isAwaitingResponse ? undefined : toggleCallRecording, children: isAwaitingResponse ? (jsx(LoadingIndicator, {})) : (jsx(Icon, { icon: isCallRecordingInProgress ? 'recording-on' : 'recording-off' })) }) }));
};

const defaultEmojiReactionMap = {
    ':like:': '',
    ':raise-hand:': '',
    ':fireworks:': '',
    ':dislike:': '',
    ':heart:': '',
    ':smile:': '',
};
const Reaction = ({ participant: { reaction, sessionId }, hideAfterTimeoutInMs = 5500, emojiReactionMap = defaultEmojiReactionMap, }) => {
    const call = useCall();
    useEffect(() => {
        if (!call || !reaction)
            return;
        const timeoutId = setTimeout(() => {
            call.resetReaction(sessionId);
        }, hideAfterTimeoutInMs);
        return () => {
            clearTimeout(timeoutId);
        };
    }, [call, hideAfterTimeoutInMs, reaction, sessionId]);
    if (!reaction)
        return null;
    const { emoji_code: emojiCode } = reaction;
    return (jsx("div", { className: "str-video__reaction", children: jsx("span", { className: "str-video__reaction__emoji", children: emojiCode && emojiReactionMap[emojiCode] }) }));
};

const defaultReactions = [
    {
        type: 'reaction',
        emoji_code: ':like:',
    },
    {
        // TODO OL: use `prompt` type?
        type: 'raised-hand',
        emoji_code: ':raise-hand:',
    },
    {
        type: 'reaction',
        emoji_code: ':fireworks:',
    },
    {
        type: 'reaction',
        emoji_code: ':dislike:',
    },
    {
        type: 'reaction',
        emoji_code: ':heart:',
    },
    {
        type: 'reaction',
        emoji_code: ':smile:',
    },
];
const ReactionsButton = ({ reactions = defaultReactions, }) => {
    return (jsx(Restricted, { requiredGrants: [OwnCapability.CREATE_REACTION], children: jsx(MenuToggle, { placement: "top", ToggleButton: ToggleReactionsMenuButton, visualType: MenuVisualType.MENU, children: jsx(DefaultReactionsMenu, { reactions: reactions }) }) }));
};
const ToggleReactionsMenuButton = forwardRef(function ToggleReactionsMenuButton({ menuShown }, ref) {
    const { t } = useI18n();
    return (jsx(WithTooltip, { title: t('Reactions'), tooltipDisabled: menuShown, children: jsx(CompositeButton, { ref: ref, active: menuShown, variant: "primary", children: jsx(Icon, { icon: "reactions" }) }) }));
});
const DefaultReactionsMenu = ({ reactions, layout = 'horizontal', }) => {
    const call = useCall();
    const { close } = useMenuContext();
    return (jsx("div", { className: clsx('str-video__reactions-menu', {
            'str-video__reactions-menu--horizontal': layout === 'horizontal',
            'str-video__reactions-menu--vertical': layout === 'vertical',
        }), children: reactions.map((reaction) => (jsx("button", { type: "button", className: "str-video__reactions-menu__button", onClick: () => {
                call?.sendReaction(reaction);
                close?.();
            }, children: reaction.emoji_code && defaultEmojiReactionMap[reaction.emoji_code] }, reaction.emoji_code))) }));
};

/**
 * Wraps an event handler, silencing and logging exceptions (excluding the NotAllowedError
 * DOMException, which is a normal situation handled by the SDK)
 *
 * @param props component props, including the onError callback
 * @param handler event handler to wrap
 */
const createCallControlHandler = (props, handler) => {
    const logger = getLogger(['react-sdk']);
    return async () => {
        try {
            await handler();
        }
        catch (error) {
            if (props.onError) {
                props.onError(error);
                return;
            }
            if (!isNotAllowedError(error)) {
                logger('error', 'Call control handler failed', error);
            }
        }
    };
};
function isNotAllowedError(error) {
    return error instanceof DOMException && error.name === 'NotAllowedError';
}

const ScreenShareButton = (props) => {
    const { t } = useI18n();
    const { caption } = props;
    const { useHasOngoingScreenShare, useScreenShareState, useCallSettings } = useCallStateHooks();
    const isSomeoneScreenSharing = useHasOngoingScreenShare();
    const { hasPermission, requestPermission, isAwaitingPermission } = useRequestPermission(OwnCapability.SCREENSHARE);
    const callSettings = useCallSettings();
    const isScreenSharingAllowed = callSettings?.screensharing.enabled;
    const { screenShare, optimisticIsMute } = useScreenShareState();
    const amIScreenSharing = !optimisticIsMute;
    const disableScreenShareButton = !amIScreenSharing &&
        (isSomeoneScreenSharing || isScreenSharingAllowed === false);
    const handleClick = createCallControlHandler(props, async () => {
        if (!hasPermission) {
            await requestPermission();
        }
        else {
            await screenShare.toggle();
        }
    });
    return (jsx(Restricted, { requiredGrants: [OwnCapability.SCREENSHARE], children: jsx(PermissionNotification, { permission: OwnCapability.SCREENSHARE, isAwaitingApproval: isAwaitingPermission, messageApproved: t('You can now share your screen.'), messageAwaitingApproval: t('Awaiting for an approval to share screen.'), messageRevoked: t('You can no longer share your screen.'), children: jsx(WithTooltip, { title: caption ?? t('Share screen'), children: jsx(CompositeButton, { active: isSomeoneScreenSharing || amIScreenSharing, caption: caption, variant: "primary", "data-testid": isSomeoneScreenSharing
                        ? 'screen-share-stop-button'
                        : 'screen-share-start-button', disabled: disableScreenShareButton, onClick: handleClick, children: jsx(Icon, { icon: isSomeoneScreenSharing ? 'screen-share-on' : 'screen-share-off' }) }) }) }) }));
};

const SelectContext = createContext({});
const Select = (props) => {
    const { children, icon, defaultSelectedLabel, defaultSelectedIndex, handleSelect: handleSelectProp, } = props;
    const [isOpen, setIsOpen] = useState(false);
    const [activeIndex, setActiveIndex] = useState(null);
    const [selectedIndex, setSelectedIndex] = useState(defaultSelectedIndex);
    const [selectedLabel, setSelectedLabel] = useState(defaultSelectedLabel);
    const { refs, context } = useFloating({
        placement: 'bottom-start',
        open: isOpen,
        onOpenChange: setIsOpen,
        whileElementsMounted: autoUpdate,
        middleware: [flip()],
    });
    const elementsRef = useRef([]);
    const labelsRef = useRef([]);
    const handleSelect = useCallback((index) => {
        setSelectedIndex(index);
        handleSelectProp(index || 0);
        setIsOpen(false);
        if (index !== null) {
            setSelectedLabel(labelsRef.current[index]);
        }
    }, [handleSelectProp]);
    const handleTypeaheadMatch = (index) => {
        if (isOpen) {
            setActiveIndex(index);
        }
        else {
            handleSelect(index);
        }
    };
    const listNav = useListNavigation(context, {
        listRef: elementsRef,
        activeIndex,
        selectedIndex,
        onNavigate: setActiveIndex,
    });
    const typeahead = useTypeahead(context, {
        listRef: labelsRef,
        activeIndex,
        selectedIndex,
        onMatch: handleTypeaheadMatch,
    });
    const click = useClick(context);
    const dismiss = useDismiss(context);
    const role = useRole(context, { role: 'listbox' });
    const { getReferenceProps, getFloatingProps, getItemProps } = useInteractions([listNav, typeahead, click, dismiss, role]);
    const selectContext = useMemo(() => ({
        activeIndex,
        selectedIndex,
        getItemProps,
        handleSelect,
    }), [activeIndex, selectedIndex, getItemProps, handleSelect]);
    return (jsxs("div", { className: "str-video__dropdown", children: [jsxs("div", { className: "str-video__dropdown-selected", ref: refs.setReference, tabIndex: 0, ...getReferenceProps(), children: [jsxs("label", { className: "str-video__dropdown-selected__label", children: [icon && (jsx(Icon, { className: "str-video__dropdown-selected__icon", icon: icon })), selectedLabel] }), jsx(Icon, { className: "str-video__dropdown-selected__chevron", icon: isOpen ? 'chevron-up' : 'chevron-down' })] }), jsx(SelectContext.Provider, { value: selectContext, children: isOpen && (jsx(FloatingFocusManager, { context: context, modal: false, children: jsx("div", { className: "str-video__dropdown-list", ref: refs.setFloating, ...getFloatingProps(), children: jsx(FloatingList, { elementsRef: elementsRef, labelsRef: labelsRef, children: children }) }) })) })] }));
};
const DropDownSelectOption = (props) => {
    const { selected, label, icon } = props;
    const { getItemProps, handleSelect } = useContext(SelectContext);
    const { ref, index } = useListItem();
    return (jsxs("div", { className: clsx('str-video__dropdown-option', {
            'str-video__dropdown-option--selected': selected,
        }), ref: ref, ...getItemProps({
            onClick: () => handleSelect(index),
        }), children: [icon && jsx(Icon, { className: "str-video__dropdown-icon", icon: icon }), jsx("span", { className: "str-video__dropdown-label", children: label })] }));
};
const DropDownSelect = (props) => {
    const { children, icon, handleSelect, defaultSelectedLabel, defaultSelectedIndex, } = props;
    return (jsx(Select, { icon: icon, handleSelect: handleSelect, defaultSelectedIndex: defaultSelectedIndex, defaultSelectedLabel: defaultSelectedLabel, children: children }));
};

const DeviceSelectorOption = ({ disabled, id, label, onChange, name, selected, defaultChecked, value, }) => {
    return (jsxs("label", { className: clsx('str-video__device-settings__option', {
            'str-video__device-settings__option--selected': selected,
            'str-video__device-settings__option--disabled': disabled,
        }), htmlFor: id, children: [jsx("input", { type: "radio", name: name, onChange: onChange, value: value, id: id, checked: selected, defaultChecked: defaultChecked, disabled: disabled }), label] }));
};
const DeviceSelectorList = (props) => {
    const { devices = [], selectedDeviceId, title, type, onChange } = props;
    const { close } = useMenuContext();
    const { deviceList } = useDeviceList(devices, selectedDeviceId);
    return (jsxs("div", { className: "str-video__device-settings__device-kind", children: [title && (jsx("div", { className: "str-video__device-settings__device-selector-title", children: title })), deviceList.map((device) => {
                return (jsx(DeviceSelectorOption, { id: `${type}--${device.deviceId}`, value: device.deviceId, label: device.label, onChange: (e) => {
                        const deviceId = e.target.value;
                        if (deviceId !== 'default') {
                            onChange?.(deviceId);
                        }
                        close?.();
                    }, name: type, selected: device.isSelected }, device.deviceId));
            })] }));
};
const DeviceSelectorDropdown = (props) => {
    const { devices = [], selectedDeviceId, title, onChange, icon } = props;
    const { deviceList, selectedDeviceInfo, selectedIndex } = useDeviceList(devices, selectedDeviceId);
    const handleSelect = useCallback((index) => {
        const deviceId = deviceList[index].deviceId;
        if (deviceId !== 'default') {
            onChange?.(deviceId);
        }
    }, [deviceList, onChange]);
    return (jsxs("div", { className: "str-video__device-settings__device-kind", children: [jsx("div", { className: "str-video__device-settings__device-selector-title", children: title }), jsx(DropDownSelect, { icon: icon, defaultSelectedIndex: selectedIndex, defaultSelectedLabel: selectedDeviceInfo.label, handleSelect: handleSelect, children: deviceList.map((device) => (jsx(DropDownSelectOption, { icon: icon, label: device.label, selected: device.isSelected }, device.deviceId))) })] }));
};
const DeviceSelector = (props) => {
    const { visualType = 'list', icon, ...rest } = props;
    if (visualType === 'list') {
        return jsx(DeviceSelectorList, { ...rest });
    }
    return jsx(DeviceSelectorDropdown, { ...rest, icon: icon });
};

const DeviceSelectorAudioInput = ({ title, visualType, }) => {
    const { useMicrophoneState } = useCallStateHooks();
    const { microphone, selectedDevice, devices } = useMicrophoneState();
    return (jsx(DeviceSelector, { devices: devices || [], selectedDeviceId: selectedDevice, type: "audioinput", onChange: async (deviceId) => {
            await microphone.select(deviceId);
        }, title: title, visualType: visualType, icon: "mic" }));
};
const DeviceSelectorAudioOutput = ({ title, visualType, }) => {
    const { useSpeakerState } = useCallStateHooks();
    const { speaker, selectedDevice, devices, isDeviceSelectionSupported } = useSpeakerState();
    if (!isDeviceSelectionSupported)
        return null;
    return (jsx(DeviceSelector, { devices: devices, type: "audiooutput", selectedDeviceId: selectedDevice, onChange: (deviceId) => {
            speaker.select(deviceId);
        }, title: title, visualType: visualType, icon: "speaker" }));
};

const DeviceSelectorVideo = ({ title, visualType, }) => {
    const { useCameraState } = useCallStateHooks();
    const { camera, devices, selectedDevice } = useCameraState();
    return (jsx(DeviceSelector, { devices: devices || [], type: "videoinput", selectedDeviceId: selectedDevice, onChange: async (deviceId) => {
            await camera.select(deviceId);
        }, title: title, visualType: visualType, icon: "camera" }));
};

const DeviceSettings = ({ visualType = MenuVisualType.MENU, }) => {
    return (jsx(MenuToggle, { placement: "bottom-end", ToggleButton: ToggleDeviceSettingsMenuButton, visualType: visualType, children: jsx(Menu, {}) }));
};
const Menu = () => {
    const { t } = useI18n();
    return (jsxs("div", { className: "str-video__device-settings", children: [jsx(DeviceSelectorVideo, { title: t('Select a Camera') }), jsx(DeviceSelectorAudioInput, { title: t('Select a Mic') }), jsx(DeviceSelectorAudioOutput, { title: t('Select Speakers') })] }));
};
const ToggleDeviceSettingsMenuButton = forwardRef(function ToggleDeviceSettingsMenuButton({ menuShown }, ref) {
    const { t } = useI18n();
    return (jsx(IconButton, { className: clsx('str-video__device-settings__button', {
            'str-video__device-settings__button--active': menuShown,
        }), title: t('Toggle device menu'), icon: "device-settings", ref: ref }));
});

const ToggleAudioPreviewButton = (props) => {
    const { caption, onMenuToggle, ...restCompositeButtonProps } = props;
    const { t } = useI18n();
    const { useMicrophoneState } = useCallStateHooks();
    const { microphone, optimisticIsMute, hasBrowserPermission, isPromptingPermission, } = useMicrophoneState();
    const [tooltipDisabled, setTooltipDisabled] = useState(false);
    const handleClick = createCallControlHandler(props, () => microphone.toggle());
    return (jsx(WithTooltip, { title: !hasBrowserPermission
            ? t('Check your browser audio permissions')
            : (caption ?? t('Mic')), tooltipDisabled: tooltipDisabled, children: jsxs(CompositeButton, { active: optimisticIsMute, caption: caption, className: clsx(!hasBrowserPermission && 'str-video__device-unavailable'), variant: "secondary", disabled: !hasBrowserPermission, "data-testid": optimisticIsMute
                ? 'preview-audio-unmute-button'
                : 'preview-audio-mute-button', onClick: handleClick, ...restCompositeButtonProps, onMenuToggle: (shown) => {
                setTooltipDisabled(shown);
                onMenuToggle?.(shown);
            }, children: [jsx(Icon, { icon: !optimisticIsMute ? 'mic' : 'mic-off' }), !hasBrowserPermission && (jsx("span", { className: "str-video__no-media-permission", title: t('Check your browser audio permissions'), children: "!" })), isPromptingPermission && (jsx("span", { className: "str-video__pending-permission", title: t('Waiting for permission'), children: "?" }))] }) }));
};
const ToggleAudioPublishingButton = (props) => {
    const { t } = useI18n();
    const { caption, Menu = jsx(DeviceSelectorAudioInput, { visualType: "list" }), menuPlacement = 'top', onMenuToggle, ...restCompositeButtonProps } = props;
    const { hasPermission, requestPermission, isAwaitingPermission } = useRequestPermission(OwnCapability.SEND_AUDIO);
    const { useMicrophoneState } = useCallStateHooks();
    const { microphone, optimisticIsMute, hasBrowserPermission, isPromptingPermission, } = useMicrophoneState();
    const [tooltipDisabled, setTooltipDisabled] = useState(false);
    const handleClick = createCallControlHandler(props, async () => {
        if (!hasPermission) {
            await requestPermission();
        }
        else {
            await microphone.toggle();
        }
    });
    return (jsx(Restricted, { requiredGrants: [OwnCapability.SEND_AUDIO], children: jsx(PermissionNotification, { permission: OwnCapability.SEND_AUDIO, isAwaitingApproval: isAwaitingPermission, messageApproved: t('You can now speak.'), messageAwaitingApproval: t('Awaiting for an approval to speak.'), messageRevoked: t('You can no longer speak.'), children: jsx(WithTooltip, { title: !hasPermission
                    ? t('You have no permission to share your audio')
                    : !hasBrowserPermission
                        ? t('Check your browser mic permissions')
                        : (caption ?? t('Mic')), tooltipDisabled: tooltipDisabled, children: jsxs(CompositeButton, { active: optimisticIsMute, caption: caption, variant: "secondary", disabled: !hasBrowserPermission || !hasPermission, "data-testid": optimisticIsMute ? 'audio-unmute-button' : 'audio-mute-button', onClick: handleClick, Menu: Menu, menuPlacement: menuPlacement, menuOffset: 16, ...restCompositeButtonProps, onMenuToggle: (shown) => {
                        setTooltipDisabled(shown);
                        onMenuToggle?.(shown);
                    }, children: [jsx(Icon, { icon: optimisticIsMute ? 'mic-off' : 'mic' }), (!hasBrowserPermission || !hasPermission) && (jsx("span", { className: "str-video__no-media-permission", children: "!" })), isPromptingPermission && (jsx("span", { className: "str-video__pending-permission", title: t('Waiting for permission'), children: "?" }))] }) }) }) }));
};

const ToggleVideoPreviewButton = (props) => {
    const { caption, Menu = DeviceSelectorVideo, menuPlacement = 'top', onMenuToggle, ...restCompositeButtonProps } = props;
    const { t } = useI18n();
    const { useCameraState } = useCallStateHooks();
    const { camera, optimisticIsMute, hasBrowserPermission, isPromptingPermission, } = useCameraState();
    const [tooltipDisabled, setTooltipDisabled] = useState(false);
    const handleClick = createCallControlHandler(props, () => camera.toggle());
    return (jsx(WithTooltip, { title: !hasBrowserPermission
            ? t('Check your browser video permissions')
            : (caption ?? t('Video')), tooltipDisabled: tooltipDisabled, children: jsxs(CompositeButton, { active: optimisticIsMute, caption: caption, className: clsx(!hasBrowserPermission && 'str-video__device-unavailable'), variant: "secondary", "data-testid": optimisticIsMute
                ? 'preview-video-unmute-button'
                : 'preview-video-mute-button', onClick: handleClick, disabled: !hasBrowserPermission, Menu: Menu, menuPlacement: menuPlacement, ...restCompositeButtonProps, onMenuToggle: (shown) => {
                setTooltipDisabled(shown);
                onMenuToggle?.(shown);
            }, children: [jsx(Icon, { icon: !optimisticIsMute ? 'camera' : 'camera-off' }), !hasBrowserPermission && (jsx("span", { className: "str-video__no-media-permission", title: t('Check your browser video permissions'), children: "!" })), isPromptingPermission && (jsx("span", { className: "str-video__pending-permission", title: t('Waiting for permission'), children: "?" }))] }) }));
};
const ToggleVideoPublishingButton = (props) => {
    const { t } = useI18n();
    const { caption, Menu = jsx(DeviceSelectorVideo, { visualType: "list" }), menuPlacement = 'top', onMenuToggle, ...restCompositeButtonProps } = props;
    const { hasPermission, requestPermission, isAwaitingPermission } = useRequestPermission(OwnCapability.SEND_VIDEO);
    const { useCameraState, useCallSettings } = useCallStateHooks();
    const { camera, optimisticIsMute, hasBrowserPermission, isPromptingPermission, } = useCameraState();
    const callSettings = useCallSettings();
    const isPublishingVideoAllowed = callSettings?.video.enabled;
    const [tooltipDisabled, setTooltipDisabled] = useState(false);
    const handleClick = createCallControlHandler(props, async () => {
        if (!hasPermission) {
            await requestPermission();
        }
        else {
            await camera.toggle();
        }
    });
    return (jsx(Restricted, { requiredGrants: [OwnCapability.SEND_VIDEO], children: jsx(PermissionNotification, { permission: OwnCapability.SEND_VIDEO, isAwaitingApproval: isAwaitingPermission, messageApproved: t('You can now share your video.'), messageAwaitingApproval: t('Awaiting for an approval to share your video.'), messageRevoked: t('You can no longer share your video.'), children: jsx(WithTooltip, { title: !hasPermission
                    ? t('You have no permission to share your video')
                    : !hasBrowserPermission
                        ? t('Check your browser video permissions')
                        : !isPublishingVideoAllowed
                            ? t('Video publishing is disabled by the system')
                            : caption || t('Video'), tooltipDisabled: tooltipDisabled, children: jsxs(CompositeButton, { active: optimisticIsMute, caption: caption, variant: "secondary", disabled: !hasBrowserPermission ||
                        !hasPermission ||
                        !isPublishingVideoAllowed, "data-testid": optimisticIsMute ? 'video-unmute-button' : 'video-mute-button', onClick: handleClick, Menu: Menu, menuPlacement: menuPlacement, menuOffset: 16, ...restCompositeButtonProps, onMenuToggle: (shown) => {
                        setTooltipDisabled(shown);
                        onMenuToggle?.(shown);
                    }, children: [jsx(Icon, { icon: optimisticIsMute ? 'camera-off' : 'camera' }), (!hasBrowserPermission ||
                            !hasPermission ||
                            !isPublishingVideoAllowed) && (jsx("span", { className: "str-video__no-media-permission", children: "!" })), isPromptingPermission && (jsx("span", { className: "str-video__pending-permission", title: t('Waiting for permission'), children: "?" }))] }) }) }) }));
};

const EndCallMenu = (props) => {
    const { onLeave, onEnd } = props;
    const { t } = useI18n();
    return (jsxs("div", { className: "str-video__end-call__confirmation", children: [jsxs("button", { className: "str-video__button str-video__end-call__leave", type: "button", "data-testid": "leave-call-button", onClick: onLeave, children: [jsx(Icon, { className: "str-video__button__icon str-video__end-call__leave-icon", icon: "logout" }), t('Leave call')] }), jsx(Restricted, { requiredGrants: [OwnCapability.END_CALL], children: jsxs("button", { className: "str-video__button str-video__end-call__end", type: "button", "data-testid": "end-call-for-all-button", onClick: onEnd, children: [jsx(Icon, { className: "str-video__button__icon str-video__end-call__end-icon", icon: "call-end" }), t('End call for all')] }) })] }));
};
const CancelCallToggleMenuButton = forwardRef(function CancelCallToggleMenuButton({ menuShown }, ref) {
    const { t } = useI18n();
    return (jsx(WithTooltip, { title: t('Leave call'), tooltipDisabled: menuShown, children: jsx(IconButton, { icon: menuShown ? 'close' : 'call-end', variant: menuShown ? 'active' : 'danger', "data-testid": "leave-call-button", ref: ref }) }));
});
const CancelCallConfirmButton = ({ onClick, onLeave, }) => {
    const call = useCall();
    const handleLeave = useCallback(async (e) => {
        if (onClick) {
            onClick(e);
        }
        else if (call) {
            await call.leave();
            onLeave?.();
        }
    }, [onClick, onLeave, call]);
    const handleEndCall = useCallback(async (e) => {
        if (onClick) {
            onClick(e);
        }
        else if (call) {
            await call.endCall();
            onLeave?.();
        }
    }, [onClick, onLeave, call]);
    return (jsx(MenuToggle, { placement: "top-start", ToggleButton: CancelCallToggleMenuButton, children: jsx(EndCallMenu, { onEnd: handleEndCall, onLeave: handleLeave }) }));
};
const CancelCallButton = ({ disabled, caption, onClick, onLeave, }) => {
    const call = useCall();
    const { t } = useI18n();
    const handleClick = useCallback(async (e) => {
        if (onClick) {
            onClick(e);
        }
        else if (call) {
            await call.leave();
            onLeave?.();
        }
    }, [onClick, onLeave, call]);
    return (jsx(IconButton, { disabled: disabled, icon: "call-end", variant: "danger", title: caption ?? t('Leave call'), "data-testid": "cancel-call-button", onClick: handleClick }));
};

const CallControls = ({ onLeave }) => (jsxs("div", { className: "str-video__call-controls", children: [jsx(Restricted, { requiredGrants: [OwnCapability.SEND_AUDIO], children: jsx(SpeakingWhileMutedNotification, { children: jsx(ToggleAudioPublishingButton, {}) }) }), jsx(Restricted, { requiredGrants: [OwnCapability.SEND_VIDEO], children: jsx(ToggleVideoPublishingButton, {}) }), jsx(Restricted, { requiredGrants: [OwnCapability.CREATE_REACTION], children: jsx(ReactionsButton, {}) }), jsx(Restricted, { requiredGrants: [OwnCapability.SCREENSHARE], children: jsx(ScreenShareButton, {}) }), jsx(Restricted, { requiredGrants: [
                OwnCapability.START_RECORD_CALL,
                OwnCapability.STOP_RECORD_CALL,
            ], children: jsx(RecordCallButton, {}) }), jsx(CancelCallButton, { onLeave: onLeave })] }));

const CallStatsLatencyChart = lazy(() => import('./latency-chart-Bj5OSYzg.es.js'));
var Status;
(function (Status) {
    Status["GOOD"] = "Good";
    Status["OK"] = "Ok";
    Status["BAD"] = "Bad";
})(Status || (Status = {}));
const CallStats = (props) => {
    const { latencyLowBound = 75, latencyHighBound = 400, showCodecInfo = false, LatencyChartSuspenseFallback = null, } = props;
    const [latencyBuffer, setLatencyBuffer] = useState(() => {
        const now = Date.now();
        return Array.from({ length: 20 }, (_, i) => ({ x: now + i, y: 0 }));
    });
    const { t } = useI18n();
    const [publishBitrate, setPublishBitrate] = useState('-');
    const [subscribeBitrate, setSubscribeBitrate] = useState('-');
    const previousStats = useRef();
    const { useCallStatsReport } = useCallStateHooks();
    const callStatsReport = useCallStatsReport();
    useEffect(() => {
        if (!callStatsReport)
            return;
        if (!previousStats.current) {
            previousStats.current = callStatsReport;
            return;
        }
        const previousCallStatsReport = previousStats.current;
        setPublishBitrate(() => {
            return calculatePublishBitrate(previousCallStatsReport, callStatsReport);
        });
        setSubscribeBitrate(() => {
            return calculateSubscribeBitrate(previousCallStatsReport, callStatsReport);
        });
        setLatencyBuffer((latencyBuf) => {
            const newLatencyBuffer = latencyBuf.slice(-19);
            newLatencyBuffer.push({
                x: callStatsReport.timestamp,
                y: callStatsReport.publisherStats.averageRoundTripTimeInMs,
            });
            return newLatencyBuffer;
        });
        previousStats.current = callStatsReport;
    }, [callStatsReport]);
    const latencyComparison = {
        lowBound: latencyLowBound,
        highBound: latencyHighBound,
        value: callStatsReport?.publisherStats.averageRoundTripTimeInMs || 0,
    };
    return (jsx("div", { className: "str-video__call-stats", children: callStatsReport && (jsxs(Fragment, { children: [jsxs("div", { className: "str-video__call-stats__header", children: [jsxs("h3", { className: "str-video__call-stats__heading", children: [jsx(Icon, { className: "str-video__call-stats__icon", icon: "call-latency" }), t('Call Latency')] }), jsx("p", { className: "str-video__call-stats__description", children: t('Very high latency values may reduce call quality, cause lag, and make the call less enjoyable.') })] }), jsx("div", { className: "str-video__call-stats__latencychart", children: jsx(Suspense, { fallback: LatencyChartSuspenseFallback, children: jsx(CallStatsLatencyChart, { values: latencyBuffer }) }) }), jsxs("div", { className: "str-video__call-stats__header", children: [jsxs("h3", { className: "str-video__call-stats__heading", children: [jsx(Icon, { className: "str-video__call-stats__icon", icon: "network-quality" }), t('Call performance')] }), jsx("p", { className: "str-video__call-stats__description", children: t('Review the key data points below to assess call performance') })] }), jsxs("div", { className: "str-video__call-stats__card-container", children: [jsx(StatCard, { label: t('Region'), value: callStatsReport.datacenter }), jsx(StatCard, { label: t('Latency'), value: `${callStatsReport.publisherStats.averageRoundTripTimeInMs} ms.`, comparison: latencyComparison }), jsx(StatCard, { label: t('Receive jitter'), value: `${callStatsReport.subscriberStats.averageJitterInMs} ms.`, comparison: {
                                ...latencyComparison,
                                value: callStatsReport.subscriberStats.averageJitterInMs,
                            } }), jsx(StatCard, { label: t('Publish jitter'), value: `${callStatsReport.publisherStats.averageJitterInMs} ms.`, comparison: {
                                ...latencyComparison,
                                value: callStatsReport.publisherStats.averageJitterInMs,
                            } }), jsx(StatCard, { label: `${t('Publish resolution')}${showCodecInfo ? formatCodec(callStatsReport) : ''}`, value: toFrameSize(callStatsReport.publisherStats) }), jsx(StatCard, { label: t('Publish quality drop reason'), value: callStatsReport.publisherStats.qualityLimitationReasons }), jsx(StatCard, { label: t('Receiving resolution'), value: toFrameSize(callStatsReport.subscriberStats) }), jsx(StatCard, { label: t('Receive quality drop reason'), value: callStatsReport.subscriberStats.qualityLimitationReasons }), jsx(StatCard, { label: t('Publish bitrate'), value: publishBitrate }), jsx(StatCard, { label: t('Receiving bitrate'), value: subscribeBitrate })] })] })) }));
};
const StatCardExplanation = (props) => {
    const { description } = props;
    const [isOpen, setIsOpen] = useState(false);
    const { refs, floatingStyles, context } = useFloating({
        open: isOpen,
        onOpenChange: setIsOpen,
    });
    const hover = useHover(context);
    const { getReferenceProps, getFloatingProps } = useInteractions([hover]);
    return (jsxs(Fragment, { children: [jsx("div", { className: "str-video__call-explanation", ref: refs.setReference, ...getReferenceProps(), children: jsx(Icon, { className: "str-video__call-explanation__icon", icon: "info" }) }), isOpen && (jsx("div", { className: "str-video__call-explanation__description", ref: refs.setFloating, style: floatingStyles, ...getFloatingProps(), children: description }))] }));
};
const StatsTag = (props) => {
    const { children, status } = props;
    return (jsx("div", { className: clsx('str-video__call-stats__tag', {
            'str-video__call-stats__tag--good': status === Status.GOOD,
            'str-video__call-stats__tag--ok': status === Status.OK,
            'str-video__call-stats__tag--bad': status === Status.BAD,
        }), children: jsx("div", { className: "str-video__call-stats__tag__text", children: children }) }));
};
const StatCard = (props) => {
    const { label, value, description, comparison } = props;
    const { t } = useI18n();
    const status = comparison ? toStatus(comparison) : undefined;
    return (jsxs("div", { className: "str-video__call-stats__card", children: [jsxs("div", { className: "str-video__call-stats__card-content", children: [jsxs("div", { className: "str-video__call-stats__card-label", children: [label, description && jsx(StatCardExplanation, { description: description })] }), jsx("div", { className: "str-video__call-stats__card-value", children: value })] }), status && jsx(StatsTag, { status: status, children: t(status) })] }));
};
const toStatus = (config) => {
    const { value, lowBound, highBound } = config;
    if (value <= lowBound)
        return Status.GOOD;
    if (value >= lowBound && value <= highBound)
        return Status.OK;
    if (value >= highBound)
        return Status.BAD;
    return Status.GOOD;
};
const toFrameSize = (stats) => {
    const { highestFrameWidth: w, highestFrameHeight: h, highestFramesPerSecond: fps, } = stats;
    let size = `-`;
    if (w && h) {
        size = `${w}x${h}`;
        if (fps) {
            size += `@${fps}fps.`;
        }
    }
    return size;
};
const formatCodec = (callStatsReport) => {
    const { codecPerTrackType } = callStatsReport.publisherStats;
    if (!codecPerTrackType || !codecPerTrackType[SfuModels.TrackType.VIDEO]) {
        return '';
    }
    const [, name] = codecPerTrackType[SfuModels.TrackType.VIDEO].split('/');
    return name ? ` (${name})` : '';
};
const calculatePublishBitrate = (previousCallStatsReport, callStatsReport) => {
    const { publisherStats: { totalBytesSent: previousTotalBytesSent, timestamp: previousTimestamp, }, } = previousCallStatsReport;
    const { publisherStats: { totalBytesSent, timestamp }, } = callStatsReport;
    const bytesSent = totalBytesSent - previousTotalBytesSent;
    const timeElapsed = timestamp - previousTimestamp;
    return `${((bytesSent * 8) / timeElapsed).toFixed(2)} kbps`;
};
const calculateSubscribeBitrate = (previousCallStatsReport, callStatsReport) => {
    const { subscriberStats: { totalBytesReceived: previousTotalBytesReceived, timestamp: previousTimestamp, }, } = previousCallStatsReport;
    const { subscriberStats: { totalBytesReceived, timestamp }, } = callStatsReport;
    const bytesReceived = totalBytesReceived - previousTotalBytesReceived;
    const timeElapsed = timestamp - previousTimestamp;
    return `${((bytesReceived * 8) / timeElapsed).toFixed(2)} kbps`;
};

const CallStatsButton = () => (jsx(MenuToggle, { placement: "top-end", ToggleButton: ToggleMenuButton, children: jsx(CallStats, {}) }));
const ToggleMenuButton = forwardRef(function ToggleMenuButton(props, ref) {
    const { t } = useI18n();
    const { caption, menuShown } = props;
    return (jsx(CompositeButton, { ref: ref, active: menuShown, caption: caption, title: caption || t('Statistics'), "data-testid": "stats-button", children: jsx(Icon, { icon: "stats" }) }));
});

const ToggleAudioOutputButton = (props) => {
    const { t } = useI18n();
    const { caption, Menu = DeviceSelectorAudioOutput, menuPlacement = 'top', onMenuToggle, } = props;
    const [tooltipDisabled, setTooltipDisabled] = useState(false);
    return (jsx(WithTooltip, { title: caption || t('Speakers'), tooltipDisabled: tooltipDisabled, children: jsx(CompositeButton, { Menu: Menu, menuPlacement: menuPlacement, caption: caption, "data-testid": "audio-output-button", onMenuToggle: (shown) => {
                setTooltipDisabled(shown);
                onMenuToggle?.(shown);
            }, children: jsx(Icon, { icon: "speaker" }) }) }));
};

const BlockedUserListing = ({ data }) => {
    if (!data.length)
        return null;
    return (jsx(Fragment, { children: jsx("div", { className: "str-video__participant-listing", children: data.map((userId) => (jsx(BlockedUserListingItem, { userId: userId }, userId))) }) }));
};
const BlockedUserListingItem = ({ userId }) => {
    const call = useCall();
    const unblockUserClickHandler = () => {
        if (userId)
            call?.unblockUser(userId);
    };
    return (jsxs("div", { className: "str-video__participant-listing-item", children: [jsx("div", { className: "str-video__participant-listing-item__display-name", children: userId }), jsx(Restricted, { requiredGrants: [OwnCapability.BLOCK_USERS], children: jsx(TextButton, { onClick: unblockUserClickHandler, children: "Unblock" }) })] }));
};

const CallParticipantListHeader = ({ onClose, }) => {
    const { useParticipants, useAnonymousParticipantCount } = useCallStateHooks();
    const participants = useParticipants();
    const anonymousParticipantCount = useAnonymousParticipantCount();
    const { t } = useI18n();
    return (jsxs("div", { className: "str-video__participant-list-header", children: [jsxs("div", { className: "str-video__participant-list-header__title", children: [t('Participants'), ' ', jsxs("span", { className: "str-video__participant-list-header__title-count", children: ["[", participants.length, "]"] }), anonymousParticipantCount > 0 && (jsx("span", { className: "str-video__participant-list-header__title-anonymous", children: t('Anonymous', { count: anonymousParticipantCount }) }))] }), jsx(IconButton, { onClick: onClose, className: "str-video__participant-list-header__close-button", icon: "close" })] }));
};

const CallParticipantListingItem = ({ participant, DisplayName = DefaultDisplayName, }) => {
    const isAudioOn = hasAudio(participant);
    const isVideoOn = hasVideo(participant);
    const isPinnedOn = isPinned(participant);
    const { t } = useI18n();
    return (jsxs("div", { className: "str-video__participant-listing-item", children: [jsx(Avatar, { name: participant.name, imageSrc: participant.image }), jsx(DisplayName, { participant: participant }), jsxs("div", { className: "str-video__participant-listing-item__media-indicator-group", children: [jsx(MediaIndicator, { title: isAudioOn ? t('Microphone on') : t('Microphone off'), className: clsx('str-video__participant-listing-item__icon', `str-video__participant-listing-item__icon-${isAudioOn ? 'mic' : 'mic-off'}`) }), jsx(MediaIndicator, { title: isVideoOn ? t('Camera on') : t('Camera off'), className: clsx('str-video__participant-listing-item__icon', `str-video__participant-listing-item__icon-${isVideoOn ? 'camera' : 'camera-off'}`) }), isPinnedOn && (jsx(MediaIndicator, { title: t('Pinned'), className: clsx('str-video__participant-listing-item__icon', 'str-video__participant-listing-item__icon-pinned') })), jsx(MenuToggle, { placement: "bottom-end", ToggleButton: ToggleButton$2, children: jsx(ParticipantViewContext.Provider, { value: { participant, trackType: 'none' }, children: jsx(ParticipantActionsContextMenu, {}) }) })] })] }));
};
const MediaIndicator = (props) => (jsx(WithTooltip, { ...props }));
const DefaultDisplayName = ({ participant }) => {
    const connectedUser = useConnectedUser();
    const { t } = useI18n();
    const meFlag = participant.userId === connectedUser?.id ? t('Me') : '';
    const nameOrId = participant.name || participant.userId || t('Unknown');
    let displayName;
    if (!participant.name) {
        displayName = meFlag || nameOrId || t('Unknown');
    }
    else if (meFlag) {
        displayName = `${nameOrId} (${meFlag})`;
    }
    else {
        displayName = nameOrId;
    }
    return (jsx(WithTooltip, { className: "str-video__participant-listing-item__display-name", title: displayName, children: displayName }));
};
const ToggleButton$2 = forwardRef(function ToggleButton(props, ref) {
    return jsx(IconButton, { enabled: props.menuShown, icon: "ellipsis", ref: ref });
});

const CallParticipantListing = ({ data, }) => (jsx("div", { className: "str-video__participant-listing", children: data.map((participant) => (jsx(CallParticipantListingItem, { participant: participant }, participant.sessionId))) }));

const EmptyParticipantSearchList = () => {
    const { t } = useI18n();
    return (jsx("div", { className: "str-video__participant-list--empty", children: t('No participants found') }));
};

const SearchInput = ({ exitSearch, isActive, ...rest }) => {
    const [inputElement, setInputElement] = useState(null);
    useEffect(() => {
        if (!inputElement)
            return;
        const handleKeyDown = (e) => {
            if (e.key.toLowerCase() === 'escape')
                exitSearch();
        };
        inputElement.addEventListener('keydown', handleKeyDown);
        return () => {
            inputElement.removeEventListener('keydown', handleKeyDown);
        };
    }, [exitSearch, inputElement]);
    return (jsxs("div", { className: clsx('str-video__search-input__container', {
            'str-video__search-input__container--active': isActive,
        }), children: [jsx("input", { placeholder: "Search", ...rest, ref: setInputElement }), isActive ? (jsx("button", { className: "str-video__search-input__clear-btn", onClick: exitSearch, children: jsx("span", { className: "str-video__search-input__icon--active" }) })) : (jsx("span", { className: "str-video__search-input__icon" }))] }));
};

function SearchResults({ EmptySearchResultComponent, LoadingIndicator: LoadingIndicator$1 = LoadingIndicator, searchQueryInProgress, searchResults, SearchResultList, }) {
    if (searchQueryInProgress) {
        return (jsx("div", { className: "str-video__search-results--loading", children: jsx(LoadingIndicator$1, {}) }));
    }
    if (!searchResults.length) {
        return jsx(EmptySearchResultComponent, {});
    }
    return jsx(SearchResultList, { data: searchResults });
}

const useSearch = ({ debounceInterval, searchFn, searchQuery = '', }) => {
    const [searchResults, setSearchResults] = useState([]);
    const [searchQueryInProgress, setSearchQueryInProgress] = useState(false);
    useEffect(() => {
        if (!searchQuery.length) {
            setSearchQueryInProgress(false);
            setSearchResults([]);
            return;
        }
        setSearchQueryInProgress(true);
        const timeout = setTimeout(async () => {
            try {
                const results = await searchFn(searchQuery);
                setSearchResults(results);
            }
            catch (error) {
                console.error(error);
            }
            finally {
                setSearchQueryInProgress(false);
            }
        }, debounceInterval);
        return () => {
            clearTimeout(timeout);
        };
    }, [debounceInterval, searchFn, searchQuery]);
    return {
        searchQueryInProgress,
        searchResults,
    };
};

const UserListTypes = {
    active: 'Active users',
    blocked: 'Blocked users',
};
const DEFAULT_DEBOUNCE_SEARCH_INTERVAL = 200;
const CallParticipantsList = ({ onClose, activeUsersSearchFn, blockedUsersSearchFn, debounceSearchInterval, }) => {
    const [searchQuery, setSearchQuery] = useState('');
    const [userListType, setUserListType] = useState('active');
    const exitSearch = useCallback(() => setSearchQuery(''), []);
    return (jsxs("div", { className: "str-video__participant-list", children: [jsx(CallParticipantListHeader, { onClose: onClose }), jsx(SearchInput, { value: searchQuery, onChange: ({ currentTarget }) => setSearchQuery(currentTarget.value), exitSearch: exitSearch, isActive: !!searchQuery }), jsx(CallParticipantListContentHeader, { userListType: userListType, setUserListType: setUserListType }), jsxs("div", { className: "str-video__participant-list__content", children: [userListType === 'active' && (jsx(ActiveUsersSearchResults, { searchQuery: searchQuery, activeUsersSearchFn: activeUsersSearchFn, debounceSearchInterval: debounceSearchInterval })), userListType === 'blocked' && (jsx(BlockedUsersSearchResults, { searchQuery: searchQuery, blockedUsersSearchFn: blockedUsersSearchFn, debounceSearchInterval: debounceSearchInterval }))] })] }));
};
const CallParticipantListContentHeader = ({ userListType, setUserListType, }) => {
    const call = useCall();
    const muteAll = () => {
        call?.muteAllUsers('audio');
    };
    return (jsxs("div", { className: "str-video__participant-list__content-header", children: [jsx("div", { className: "str-video__participant-list__content-header-title", children: userListType === 'active' && (jsx(Restricted, { requiredGrants: [OwnCapability.MUTE_USERS], hasPermissionsOnly: true, children: jsx(TextButton, { onClick: muteAll, children: "Mute all" }) })) }), jsx(MenuToggle, { placement: "bottom-end", ToggleButton: ToggleButton$1, children: jsx(GenericMenu, { children: Object.keys(UserListTypes).map((lt) => (jsx(GenericMenuButtonItem, { "aria-selected": lt === userListType, onClick: () => setUserListType(lt), children: UserListTypes[lt] }, lt))) }) })] }));
};
const ActiveUsersSearchResults = ({ searchQuery, activeUsersSearchFn: activeUsersSearchFnFromProps, debounceSearchInterval = DEFAULT_DEBOUNCE_SEARCH_INTERVAL, }) => {
    const { useParticipants } = useCallStateHooks();
    const participants = useParticipants({ sortBy: name });
    const activeUsersSearchFn = useCallback((queryString) => {
        const queryRegExp = new RegExp(queryString, 'i');
        return Promise.resolve(participants.filter((participant) => {
            return participant.name.match(queryRegExp);
        }));
    }, [participants]);
    const { searchQueryInProgress, searchResults } = useSearch({
        searchFn: activeUsersSearchFnFromProps ?? activeUsersSearchFn,
        debounceInterval: debounceSearchInterval,
        searchQuery,
    });
    return (jsx(SearchResults, { EmptySearchResultComponent: EmptyParticipantSearchList, LoadingIndicator: LoadingIndicator, searchQueryInProgress: searchQueryInProgress, searchResults: searchQuery ? searchResults : participants, SearchResultList: CallParticipantListing }));
};
const BlockedUsersSearchResults = ({ blockedUsersSearchFn: blockedUsersSearchFnFromProps, debounceSearchInterval = DEFAULT_DEBOUNCE_SEARCH_INTERVAL, searchQuery, }) => {
    const { useCallBlockedUserIds } = useCallStateHooks();
    const blockedUsers = useCallBlockedUserIds();
    const blockedUsersSearchFn = useCallback((queryString) => {
        const queryRegExp = new RegExp(queryString, 'i');
        return Promise.resolve(blockedUsers.filter((blockedUser) => {
            return blockedUser.match(queryRegExp);
        }));
    }, [blockedUsers]);
    const { searchQueryInProgress, searchResults } = useSearch({
        searchFn: blockedUsersSearchFnFromProps ?? blockedUsersSearchFn,
        debounceInterval: debounceSearchInterval,
        searchQuery,
    });
    return (jsx(SearchResults, { EmptySearchResultComponent: EmptyParticipantSearchList, LoadingIndicator: LoadingIndicator, searchQueryInProgress: searchQueryInProgress, searchResults: searchQuery ? searchResults : blockedUsers, SearchResultList: BlockedUserListing }));
};
const ToggleButton$1 = forwardRef(function ToggleButton(props, ref) {
    return jsx(IconButton, { enabled: props.menuShown, icon: "filter", ref: ref });
});

const CallPreview = (props) => {
    const { className, style } = props;
    const call = useCall();
    const { useCallThumbnail } = useCallStateHooks();
    const thumbnail = useCallThumbnail();
    const [imageRef, setImageRef] = useState(null);
    useEffect(() => {
        if (!imageRef || !call)
            return;
        const cleanup = call.bindCallThumbnailElement(imageRef);
        return () => cleanup();
    }, [imageRef, call]);
    if (!thumbnail)
        return null;
    return (jsx("img", { className: clsx('str-video__call-preview', className), style: style, alt: "Call Preview Thumbnail", ref: setImageRef }));
};

const CallRecordingListHeader = ({ callRecordings, onRefresh, }) => {
    const { t } = useI18n();
    return (jsxs("div", { className: "str-video__call-recording-list__header", children: [jsxs("div", { className: "str-video__call-recording-list__title", children: [jsx("span", { children: t('Call Recordings') }), callRecordings.length ? jsxs("span", { children: ["(", callRecordings.length, ")"] }) : null] }), onRefresh && (jsx(IconButton, { icon: "refresh", title: t('Refresh'), onClick: onRefresh }))] }));
};

const dateFormat = (date) => {
    const format = new Date(date);
    return format.toTimeString().split(' ')[0];
};
const CallRecordingListItem = ({ recording, }) => {
    return (jsxs("li", { className: "str-video__call-recording-list__item", children: [jsx("div", { className: "str-video__call-recording-list__table-cell str-video__call-recording-list__filename", children: recording.filename }), jsx("div", { className: "str-video__call-recording-list__table-cell str-video__call-recording-list__time", children: dateFormat(recording.start_time) }), jsx("div", { className: "str-video__call-recording-list__table-cell str-video__call-recording-list__time", children: dateFormat(recording.end_time) }), jsx("div", { className: "str-video__call-recording-list__table-cell str-video__call-recording-list__download", children: jsx("a", { className: clsx('str-video__call-recording-list-item__action-button', 'str-video__call-recording-list-item__action-button--download'), role: "button", href: recording.url, download: recording.filename, title: "Download the recording", children: jsx(Icon, { icon: "download" }) }) })] }));
};

const EmptyCallRecordingListing = () => {
    return (jsxs("div", { className: "str-video__call-recording-list__listing str-video__call-recording-list__listing--empty", children: [jsx("div", { className: "str-video__call-recording-list__listing--icon-empty" }), jsx("p", { className: "str-video__call-recording-list__listing--text-empty", children: "No recordings available" })] }));
};

const LoadingCallRecordingListing = ({ callRecordings, }) => {
    return (jsxs(Fragment, { children: [callRecordings.map((recording) => (jsx(CallRecordingListItem, { recording: recording }, recording.filename))), jsx(LoadingIndicator, { text: "Recording getting ready" })] }));
};

const CallRecordingList = ({ callRecordings, CallRecordingListHeader: CallRecordingListHeader$1 = CallRecordingListHeader, CallRecordingListItem: CallRecordingListItem$1 = CallRecordingListItem, EmptyCallRecordingList = EmptyCallRecordingListing, loading, LoadingCallRecordingList = LoadingCallRecordingListing, onRefresh, }) => {
    return (jsxs("div", { className: "str-video__call-recording-list", children: [jsx(CallRecordingListHeader$1, { callRecordings: callRecordings, onRefresh: onRefresh }), jsx("div", { className: "str-video__call-recording-list__listing", children: loading ? (jsx(LoadingCallRecordingList, { callRecordings: callRecordings })) : callRecordings.length ? (jsxs(Fragment, { children: [jsx("ul", { className: "str-video__call-recording-list__list", children: jsxs("li", { className: "str-video__call-recording-list__item", children: [jsx("div", { className: "str-video__call-recording-list__filename", children: "Name" }), jsx("div", { className: "str-video__call-recording-list__time", children: "Start time" }), jsx("div", { className: "str-video__call-recording-list__time", children: "End time" }), jsx("div", { className: "str-video__call-recording-list__download" })] }) }), jsx("ul", { className: "str-video__call-recording-list__list", children: callRecordings.map((recording) => (jsx(CallRecordingListItem$1, { recording: recording }, recording.filename))) })] })) : (jsx(EmptyCallRecordingList, {})) })] }));
};

const NoiseCancellationContext = createContext(null);
/**
 * Exposes the NoiseCancellation API.
 * Throws an error if used outside <NoiseCancellationProvider />.
 */
const useNoiseCancellation = () => {
    const context = useContext(NoiseCancellationContext);
    if (!context) {
        throw new Error('useNoiseCancellation must be used within a NoiseCancellationProvider');
    }
    return context;
};
const NoiseCancellationProvider = (props) => {
    const { children, noiseCancellation } = props;
    const call = useCall();
    const { useCallSettings, useHasPermissions } = useCallStateHooks();
    const settings = useCallSettings();
    const noiseCancellationAllowed = !!(settings &&
        settings.audio.noise_cancellation &&
        settings.audio.noise_cancellation.mode !==
            NoiseCancellationSettingsModeEnum.DISABLED);
    const hasCapability = useHasPermissions(OwnCapability.ENABLE_NOISE_CANCELLATION);
    const [isSupportedByBrowser, setIsSupportedByBrowser] = useState(undefined);
    useEffect(() => {
        const result = noiseCancellation.isSupported();
        if (typeof result === 'boolean') {
            setIsSupportedByBrowser(result);
        }
        else {
            result
                .then((_isSupportedByBrowser) => setIsSupportedByBrowser(_isSupportedByBrowser))
                .catch((err) => console.error(`Can't determine if noise cancellation is supported`, err));
        }
    }, [noiseCancellation]);
    const isSupported = isSupportedByBrowser && hasCapability && noiseCancellationAllowed;
    const [isEnabled, setIsEnabled] = useState(false);
    const deinit = useRef();
    useEffect(() => {
        if (!call || !isSupported)
            return;
        const unsubscribe = noiseCancellation.on('change', (v) => setIsEnabled(v));
        const init = (deinit.current || Promise.resolve())
            .then(() => noiseCancellation.init())
            .then(() => call.microphone.enableNoiseCancellation(noiseCancellation))
            .catch((err) => console.error(`Can't initialize noise suppression`, err));
        return () => {
            deinit.current = init
                .then(() => call.microphone.disableNoiseCancellation())
                .then(() => noiseCancellation.dispose())
                .then(() => unsubscribe());
        };
    }, [call, isSupported, noiseCancellation]);
    return (jsx(NoiseCancellationContext.Provider, { value: {
            isSupported,
            isEnabled,
            setEnabled: (enabledOrSetter) => {
                if (!noiseCancellation)
                    return;
                const enable = typeof enabledOrSetter === 'function'
                    ? enabledOrSetter(isEnabled)
                    : enabledOrSetter;
                if (enable) {
                    noiseCancellation.enable();
                }
                else {
                    noiseCancellation.disable();
                }
            },
        }, children: children }));
};

const RingingCallControls = () => {
    const call = useCall();
    const { useCallCallingState } = useCallStateHooks();
    const callCallingState = useCallCallingState();
    if (!call)
        return null;
    const buttonsDisabled = callCallingState !== CallingState.RINGING;
    return (jsx("div", { className: "str-video__pending-call-controls", children: call.isCreatedByMe ? (jsx(CancelCallButton, { disabled: buttonsDisabled })) : (jsxs(Fragment, { children: [jsx(AcceptCallButton, { disabled: buttonsDisabled }), jsx(CancelCallButton, { onClick: () => {
                        const reason = call.isCreatedByMe ? 'cancel' : 'decline';
                        call.leave({ reject: true, reason });
                    }, disabled: buttonsDisabled })] })) }));
};

const CALLING_STATE_TO_LABEL = {
    [CallingState.JOINING]: 'Joining',
    [CallingState.RINGING]: 'Ringing',
    [CallingState.MIGRATING]: 'Migrating',
    [CallingState.RECONNECTING]: 'Re-connecting',
    [CallingState.RECONNECTING_FAILED]: 'Failed',
    [CallingState.OFFLINE]: 'No internet connection',
    [CallingState.IDLE]: '',
    [CallingState.UNKNOWN]: '',
    [CallingState.JOINED]: 'Joined',
    [CallingState.LEFT]: 'Left call',
};
const RingingCall = (props) => {
    const { includeSelf = false, totalMembersToShow = 3 } = props;
    const call = useCall();
    const { t } = useI18n();
    const { useCallCallingState, useCallMembers } = useCallStateHooks();
    const callingState = useCallCallingState();
    const members = useCallMembers();
    const connectedUser = useConnectedUser();
    if (!call)
        return null;
    // take the first N members to show their avatars
    const membersToShow = (members || [])
        .slice(0, totalMembersToShow)
        .map(({ user }) => user)
        .filter((user) => user.id !== connectedUser?.id || includeSelf);
    if (includeSelf &&
        !membersToShow.find((user) => user.id === connectedUser?.id)) {
        // if the current user is not in the initial batch of members,
        // replace the first item in membersToShow array with the current user
        const self = members.find(({ user }) => user.id === connectedUser?.id);
        if (self) {
            membersToShow.splice(0, 1, self.user);
        }
    }
    const callingStateLabel = CALLING_STATE_TO_LABEL[callingState];
    return (jsxs("div", { className: "str-video__call-panel str-video__call-panel--ringing", children: [jsx("div", { className: "str-video__call-panel__members-list", children: membersToShow.map((user) => (jsxs("div", { className: "str-video__call-panel__member-box", children: [jsx(Avatar, { name: user.name, imageSrc: user.image }), user.name && (jsx("div", { className: "str-video__member_details", children: jsx("span", { className: "str-video__member_name", children: user.name }) }))] }, user.id))) }), callingStateLabel && (jsx("div", { className: "str-video__call-panel__calling-state-label", children: t(callingStateLabel) })), [CallingState.RINGING, CallingState.JOINING].includes(callingState) && (jsx(RingingCallControls, {}))] }));
};

const byNameOrId = (a, b) => {
    if (a.name && b.name && a.name < b.name)
        return -1;
    if (a.name && b.name && a.name > b.name)
        return 1;
    if (a.id < b.id)
        return -1;
    if (a.id > b.id)
        return 1;
    return 0;
};
const PermissionRequests = () => {
    const call = useCall();
    const { useLocalParticipant, useHasPermissions } = useCallStateHooks();
    const localParticipant = useLocalParticipant();
    const [expanded, setExpanded] = useState(false);
    const [permissionRequests, setPermissionRequests] = useState([]);
    const canUpdateCallPermissions = useHasPermissions(OwnCapability.UPDATE_CALL_PERMISSIONS);
    const localUserId = localParticipant?.userId;
    useEffect(() => {
        if (!call || !canUpdateCallPermissions)
            return;
        return call.on('call.permission_request', (event) => {
            if (event.user.id !== localUserId) {
                setPermissionRequests((requests) => [...requests, event].sort((a, b) => byNameOrId(a.user, b.user)));
            }
        });
    }, [call, canUpdateCallPermissions, localUserId]);
    const handleUpdatePermission = (request, type) => {
        return async () => {
            const { user, permissions } = request;
            switch (type) {
                case 'grant':
                    await call?.grantPermissions(user.id, permissions);
                    break;
                case 'revoke':
                    await call?.revokePermissions(user.id, permissions);
                    break;
            }
            setPermissionRequests((requests) => requests.filter((r) => r !== request));
        };
    };
    const { refs, x, y, strategy } = useFloatingUIPreset({
        placement: 'bottom',
        strategy: 'absolute',
    });
    // don't render anything if there are no permission requests
    if (permissionRequests.length === 0)
        return null;
    return (jsxs("div", { className: "str-video__permission-requests", ref: refs.setReference, children: [jsxs("div", { className: "str-video__permission-requests__notification", children: [jsxs("span", { className: "str-video__permission-requests__notification__message", children: [permissionRequests.length, " pending permission requests"] }), jsx(Button, { type: "button", onClick: () => {
                            setExpanded((e) => !e);
                        }, children: expanded ? 'Hide requests' : 'Show requests' })] }), expanded && (jsx(PermissionRequestList, { ref: refs.setFloating, style: {
                    position: strategy,
                    top: y ?? 0,
                    left: x ?? 0,
                    overflowY: 'auto',
                }, permissionRequests: permissionRequests, handleUpdatePermission: handleUpdatePermission }))] }));
};
const PermissionRequestList = forwardRef(function PermissionRequestList(props, ref) {
    const { permissionRequests, handleUpdatePermission, ...rest } = props;
    const { t } = useI18n();
    return (jsx("div", { className: "str-video__permission-requests-list", ref: ref, ...rest, children: permissionRequests.map((request, reqIndex) => {
            const { user, permissions } = request;
            return (jsx(Fragment$1, { children: permissions.map((permission) => (jsxs("div", { className: "str-video__permission-request", children: [jsx("div", { className: "str-video__permission-request__message", children: messageForPermission(user.name || user.id, permission, t) }), jsx(Button, { className: "str-video__permission-request__button--allow", type: "button", onClick: handleUpdatePermission(request, 'grant'), children: t('Allow') }), jsx(Button, { className: "str-video__permission-request__button--reject", type: "button", onClick: handleUpdatePermission(request, 'revoke'), children: t('Revoke') }), jsx(Button, { className: "str-video__permission-request__button--reject", type: "button", onClick: handleUpdatePermission(request, 'dismiss'), children: t('Dismiss') })] }, permission))) }, `${user.id}/${reqIndex}`));
        }) }));
});
const Button = (props) => {
    const { className, ...rest } = props;
    return (jsx("button", { className: clsx('str-video__permission-request__button', className), ...rest }));
};
const messageForPermission = (userName, permission, t) => {
    switch (permission) {
        case OwnCapability.SEND_AUDIO:
            return t('{{ userName }} is requesting to speak', { userName });
        case OwnCapability.SEND_VIDEO:
            return t('{{ userName }} is requesting to share their camera', {
                userName,
            });
        case OwnCapability.SCREENSHARE:
            return t('{{ userName }} is requesting to present their screen', {
                userName,
            });
        default:
            return t('{{ userName }} is requesting permission: {{ permission }}', {
                userName,
                permission,
            });
    }
};

const StreamTheme = ({ as: Component = 'div', className, children, ...props }) => {
    return (jsx(Component, { ...props, className: clsx('str-video', className), children: children }));
};

const DefaultDisabledVideoPreview = () => {
    const { t } = useI18n();
    return (jsx("div", { className: "str_video__video-preview__disabled-video-preview", children: t('Video is disabled') }));
};
const DefaultNoCameraPreview = () => {
    const { t } = useI18n();
    return (jsx("div", { className: "str_video__video-preview__no-camera-preview", children: t('No camera found') }));
};
const VideoPreview = ({ className, mirror = true, DisabledVideoPreview = DefaultDisabledVideoPreview, NoCameraPreview = DefaultNoCameraPreview, StartingCameraPreview = LoadingIndicator, }) => {
    const { useCameraState } = useCallStateHooks();
    const { devices, status, isMute, mediaStream } = useCameraState();
    let contents;
    if (isMute && devices?.length === 0) {
        contents = jsx(NoCameraPreview, {});
    }
    else if (status === 'enabled') {
        const loading = !mediaStream;
        contents = (jsxs(Fragment, { children: [mediaStream && (jsx(BaseVideo, { stream: mediaStream, className: clsx('str-video__video-preview', {
                        'str-video__video-preview--mirror': mirror,
                        'str-video__video-preview--loading': loading,
                    }) })), loading && jsx(StartingCameraPreview, {})] }));
    }
    else {
        contents = jsx(DisabledVideoPreview, {});
    }
    return (jsx("div", { className: clsx('str-video__video-preview-container', className), children: contents }));
};

const ToggleButton = forwardRef(function ToggleButton(props, ref) {
    return jsx(IconButton, { enabled: props.menuShown, icon: "ellipsis", ref: ref });
});
const DefaultScreenShareOverlay = () => {
    const call = useCall();
    const { t } = useI18n();
    const stopScreenShare = () => {
        call?.screenShare.disable();
    };
    return (jsxs("div", { className: "str-video__screen-share-overlay", children: [jsx(Icon, { icon: "screen-share-off" }), jsx("span", { className: "str-video__screen-share-overlay__title", children: t('You are presenting your screen') }), jsxs("button", { onClick: stopScreenShare, className: "str-video__screen-share-overlay__button", children: [jsx(Icon, { icon: "close" }), " ", t('Stop Screen Sharing')] })] }));
};
const DefaultParticipantViewUI = ({ indicatorsVisible = true, menuPlacement = 'bottom-start', showMenuButton = true, ParticipantActionsContextMenu: ParticipantActionsContextMenu$1 = ParticipantActionsContextMenu, }) => {
    const { participant, trackType } = useParticipantViewContext();
    const isScreenSharing = hasScreenShare(participant);
    if (participant.isLocalParticipant &&
        isScreenSharing &&
        trackType === 'screenShareTrack') {
        return (jsxs(Fragment, { children: [jsx(DefaultScreenShareOverlay, {}), jsx(ParticipantDetails, { indicatorsVisible: indicatorsVisible })] }));
    }
    return (jsxs(Fragment, { children: [showMenuButton && (jsx(MenuToggle, { strategy: "fixed", placement: menuPlacement, ToggleButton: ToggleButton, children: jsx(ParticipantActionsContextMenu$1, {}) })), jsx(Reaction, { participant: participant }), jsx(ParticipantDetails, { indicatorsVisible: indicatorsVisible })] }));
};
const ParticipantDetails = ({ indicatorsVisible = true, }) => {
    const { participant } = useParticipantViewContext();
    const { isLocalParticipant, connectionQuality, pin, sessionId, name, userId, } = participant;
    const call = useCall();
    const { t } = useI18n();
    const connectionQualityAsString = !!connectionQuality &&
        SfuModels.ConnectionQuality[connectionQuality].toLowerCase();
    const hasAudioTrack = hasAudio(participant);
    const hasVideoTrack = hasVideo(participant);
    const canUnpin = !!pin && pin.isLocalPin;
    return (jsxs(Fragment, { children: [jsx("div", { className: "str-video__participant-details", children: jsxs("span", { className: "str-video__participant-details__name", children: [name || userId, indicatorsVisible && !hasAudioTrack && (jsx("span", { className: "str-video__participant-details__name--audio-muted" })), indicatorsVisible && !hasVideoTrack && (jsx("span", { className: "str-video__participant-details__name--video-muted" })), indicatorsVisible && canUnpin && (
                        // TODO: remove this monstrosity once we have a proper design
                        jsx("span", { title: t('Unpin'), onClick: () => call?.unpin(sessionId), className: "str-video__participant-details__name--pinned" })), indicatorsVisible && jsx(SpeechIndicator, {})] }) }), indicatorsVisible && (jsx(Notification, { isVisible: isLocalParticipant &&
                    connectionQuality === SfuModels.ConnectionQuality.POOR, message: t('Poor connection quality'), children: connectionQualityAsString && (jsx("span", { className: clsx('str-video__participant-details__connection-quality', `str-video__participant-details__connection-quality--${connectionQualityAsString}`), title: connectionQualityAsString })) }))] }));
};
const SpeechIndicator = () => {
    const { participant } = useParticipantViewContext();
    const { isSpeaking, isDominantSpeaker } = participant;
    return (jsxs("span", { className: clsx('str-video__speech-indicator', isSpeaking && 'str-video__speech-indicator--speaking', isDominantSpeaker && 'str-video__speech-indicator--dominant'), children: [jsx("span", { className: "str-video__speech-indicator__bar" }), jsx("span", { className: "str-video__speech-indicator__bar" }), jsx("span", { className: "str-video__speech-indicator__bar" })] }));
};

const ParticipantView = forwardRef(function ParticipantView({ participant, trackType = 'videoTrack', mirror, muteAudio, refs: { setVideoElement, setVideoPlaceholderElement } = {}, className, VideoPlaceholder, PictureInPicturePlaceholder, ParticipantViewUI = DefaultParticipantViewUI, }, ref) {
    const { isLocalParticipant, isSpeaking, isDominantSpeaker, sessionId } = participant;
    const hasAudioTrack = hasAudio(participant);
    const hasVideoTrack = hasVideo(participant);
    const hasScreenShareAudioTrack = hasScreenShareAudio(participant);
    const [trackedElement, setTrackedElement] = useState(null);
    const [contextVideoElement, setContextVideoElement] = useState(null);
    const [contextVideoPlaceholderElement, setContextVideoPlaceholderElement] = useState(null);
    // TODO: allow to pass custom ViewportTracker instance from props
    useTrackElementVisibility({
        sessionId,
        trackedElement,
        trackType,
    });
    const { useIncomingVideoSettings } = useCallStateHooks();
    const { isParticipantVideoEnabled } = useIncomingVideoSettings();
    const participantViewContextValue = useMemo(() => ({
        participant,
        participantViewElement: trackedElement,
        videoElement: contextVideoElement,
        videoPlaceholderElement: contextVideoPlaceholderElement,
        trackType,
    }), [
        contextVideoElement,
        contextVideoPlaceholderElement,
        participant,
        trackedElement,
        trackType,
    ]);
    const videoRefs = useMemo(() => ({
        setVideoElement: (element) => {
            setVideoElement?.(element);
            setContextVideoElement(element);
        },
        setVideoPlaceholderElement: (element) => {
            setVideoPlaceholderElement?.(element);
            setContextVideoPlaceholderElement(element);
        },
    }), [setVideoElement, setVideoPlaceholderElement]);
    return (jsx("div", { "data-testid": "participant-view", ref: (element) => {
            applyElementToRef(ref, element);
            setTrackedElement(element);
        }, className: clsx('str-video__participant-view', isDominantSpeaker && 'str-video__participant-view--dominant-speaker', isSpeaking && 'str-video__participant-view--speaking', !hasVideoTrack && 'str-video__participant-view--no-video', !hasAudioTrack && 'str-video__participant-view--no-audio', className), children: jsxs(ParticipantViewContext.Provider, { value: participantViewContextValue, children: [!isLocalParticipant && !muteAudio && (jsxs(Fragment, { children: [hasAudioTrack && (jsx(Audio, { participant: participant, trackType: "audioTrack" })), hasScreenShareAudioTrack && (jsx(Audio, { participant: participant, trackType: "screenShareAudioTrack" }))] })), jsx(Video$1, { VideoPlaceholder: VideoPlaceholder, PictureInPicturePlaceholder: PictureInPicturePlaceholder, participant: participant, trackType: trackType, refs: videoRefs, enabled: isLocalParticipant ||
                        trackType !== 'videoTrack' ||
                        isParticipantVideoEnabled(participant.sessionId), mirror: mirror, autoPlay: true }), isComponentType(ParticipantViewUI) ? (jsx(ParticipantViewUI, {})) : (ParticipantViewUI)] }) }));
});
ParticipantView.displayName = 'ParticipantView';

// re-exporting the StreamCallProvider as StreamCall
const StreamCall = StreamCallProvider;
StreamCall.displayName = 'StreamCall';

var Joining = "Joining";
var Mic = "Mic";
var Ringing = "Ringing";
var Speakers = "Speakers";
var Video = "Video";
var Live = "Live";
var Reactions = "Reactions";
var Statistics = "Statistics";
var Invite = "Invite";
var Join = "Join";
var You = "You";
var Me = "Me";
var Unknown = "Unknown";
var Default = "Default";
var Refresh = "Refresh";
var Allow = "Allow";
var Revoke = "Revoke";
var Dismiss = "Dismiss";
var Pinned = "Pinned";
var Unpin = "Unpin";
var Pin = "Pin";
var Block = "Block";
var Enter = "Enter";
var Leave = "Leave";
var Participants = "Participants";
var Anonymous = ", and ({{ count }}) anonymous";
var en = {
	Joining: Joining,
	Mic: Mic,
	"No internet connection": "No internet connection",
	"Re-connecting": "Re-connecting",
	Ringing: Ringing,
	"Screen Share": "Screen Share",
	"Select a Camera": "Select a Camera",
	"Select a Mic": "Select a Mic",
	"Select Speakers": "Select Speakers",
	Speakers: Speakers,
	Video: Video,
	"You are muted. Unmute to speak.": "You are muted. Unmute to speak.",
	Live: Live,
	"You can now speak.": "You can now speak.",
	"Awaiting for an approval to speak.": "Awaiting for an approval to speak.",
	"You can no longer speak.": "You can no longer speak.",
	"You can now share your video.": "You can now share your video.",
	"Awaiting for an approval to share your video.": "Awaiting for an approval to share your video.",
	"You can no longer share your video.": "You can no longer share your video.",
	"Waiting for recording to stop...": "Waiting for recording to stop...",
	"Waiting for recording to start...": "Waiting for recording to start...",
	"Record call": "Record call",
	Reactions: Reactions,
	Statistics: Statistics,
	"You can now share your screen.": "You can now share your screen.",
	"Awaiting for an approval to share screen.": "Awaiting for an approval to share screen.",
	"You can no longer share your screen.": "You can no longer share your screen.",
	"Share screen": "Share screen",
	"Incoming Call...": "Incoming Call...",
	"Calling...": "Calling...",
	"Mute All": "Mute All",
	Invite: Invite,
	Join: Join,
	You: You,
	Me: Me,
	Unknown: Unknown,
	"Toggle device menu": "Toggle device menu",
	Default: Default,
	"Call Recordings": "Call Recordings",
	Refresh: Refresh,
	"Check your browser video permissions": "Check your browser video permissions",
	"Video publishing is disabled by the system": "Video publishing is disabled by the system",
	"You have no permission to share your video": "You have no permission to share your video",
	"You have no permission to share your audio": "You have no permission to share your audio",
	"You are presenting your screen": "You are presenting your screen",
	"Stop Screen Sharing": "Stop Screen Sharing",
	Allow: Allow,
	Revoke: Revoke,
	Dismiss: Dismiss,
	"Microphone on": "Microphone on",
	"Microphone off": "Microphone off",
	"Camera on": "Camera on",
	"Camera off": "Camera off",
	"No camera found": "No camera found",
	"Video is disabled": "Video is disabled",
	Pinned: Pinned,
	Unpin: Unpin,
	Pin: Pin,
	"Pin for everyone": "Pin for everyone",
	"Unpin for everyone": "Unpin for everyone",
	Block: Block,
	"Turn off video": "Turn off video",
	"Turn off screen share": "Turn off screen share",
	"Mute audio": "Mute audio",
	"Mute screen share audio": "Mute screen share audio",
	"Allow audio": "Allow audio",
	"Allow video": "Allow video",
	"Allow screen sharing": "Allow screen sharing",
	"Disable audio": "Disable audio",
	"Disable video": "Disable video",
	"Disable screen sharing": "Disable screen sharing",
	Enter: Enter,
	Leave: Leave,
	"Leave call": "Leave call",
	"End call for all": "End call for all",
	"{{ direction }} fullscreen": "{{ direction }} fullscreen",
	"{{ direction }} picture-in-picture": "{{ direction }} picture-in-picture",
	"Dominant Speaker": "Dominant Speaker",
	"Poor connection quality": "Poor connection quality. Please check your internet connection.",
	Participants: Participants,
	Anonymous: Anonymous,
	"No participants found": "No participants found",
	"Participants ({{ numberOfParticipants }})": "Participants ({{ numberOfParticipants }})",
	"{{ userName }} is sharing their screen": "{{ userName }} is sharing their screen",
	"{{ userName }} is requesting to speak": "{{ userName }} is requesting to speak",
	"{{ userName }} is requesting to share their camera": "{{ userName }} is requesting to share their camera",
	"{{ userName }} is requesting to present their screen": "{{ userName }} is requesting to present their screen",
	"{{ userName }} is requesting permission: {{ permission }}": "{{ userName }} is requesting permission: {{ permission }}"
};

const translations = { en };

const StreamVideo = (props) => {
    return (jsx(StreamVideoProvider, { translationsOverrides: translations, ...props }));
};
StreamVideo.displayName = 'StreamVideo';

function applyFilter(obj, filter) {
    if ('$and' in filter) {
        return filter.$and.every((f) => applyFilter(obj, f));
    }
    if ('$or' in filter) {
        return filter.$or.some((f) => applyFilter(obj, f));
    }
    if ('$not' in filter) {
        return !applyFilter(obj, filter.$not);
    }
    return checkConditions(obj, filter);
}
function checkConditions(obj, conditions) {
    let match = true;
    for (const key of Object.keys(conditions)) {
        const operator = conditions[key];
        const maybeOperator = operator && typeof operator === 'object';
        const value = obj[key];
        if (maybeOperator && '$eq' in operator) {
            const eqOperator = operator;
            match && (match = eqOperator.$eq === value);
        }
        else if (maybeOperator && '$neq' in operator) {
            const neqOperator = operator;
            match && (match = neqOperator.$neq !== value);
        }
        else if (maybeOperator && '$in' in operator) {
            const inOperator = operator;
            match && (match = inOperator.$in.includes(value));
        }
        else if (maybeOperator && '$contains' in operator) {
            if (Array.isArray(value)) {
                const containsOperator = operator;
                match && (match = value.includes(containsOperator.$contains));
            }
            else {
                match = false;
            }
        }
        else {
            const eqValue = operator;
            match && (match = eqValue === value);
        }
        if (!match) {
            return false;
        }
    }
    return true;
}

const useFilteredParticipants = ({ excludeLocalParticipant = false, filterParticipants, }) => {
    const { useParticipants, useRemoteParticipants } = useCallStateHooks();
    const allParticipants = useParticipants();
    const remoteParticipants = useRemoteParticipants();
    return useMemo(() => {
        const unfilteredParticipants = excludeLocalParticipant
            ? remoteParticipants
            : allParticipants;
        return filterParticipants
            ? applyParticipantsFilter(unfilteredParticipants, filterParticipants)
            : unfilteredParticipants;
    }, [
        allParticipants,
        remoteParticipants,
        excludeLocalParticipant,
        filterParticipants,
    ]);
};
const applyParticipantsFilter = (participants, filter) => {
    const filterCallback = typeof filter === 'function'
        ? filter
        : (participant) => applyFilter({
            userId: participant.userId,
            isSpeaking: participant.isSpeaking,
            isDominantSpeaker: participant.isDominantSpeaker,
            name: participant.name,
            roles: participant.roles,
            isPinned: isPinned(participant),
            hasVideo: hasVideo(participant),
            hasAudio: hasAudio(participant),
        }, filter);
    return participants.filter(filterCallback);
};
const usePaginatedLayoutSortPreset = (call) => {
    useEffect(() => {
        if (!call)
            return;
        call.setSortParticipantsBy(paginatedLayoutSortPreset);
        return () => {
            resetSortPreset(call);
        };
    }, [call]);
};
const useSpeakerLayoutSortPreset = (call, isOneOnOneCall) => {
    useEffect(() => {
        if (!call)
            return;
        // always show the remote participant in the spotlight
        if (isOneOnOneCall) {
            call.setSortParticipantsBy(combineComparators(screenSharing, loggedIn));
        }
        else {
            call.setSortParticipantsBy(speakerLayoutSortPreset);
        }
        return () => {
            resetSortPreset(call);
        };
    }, [call, isOneOnOneCall]);
};
const resetSortPreset = (call) => {
    // reset the sorting to the default for the call type
    const callConfig = CallTypes.get(call.type);
    call.setSortParticipantsBy(callConfig.options.sortParticipantsBy || defaultSortPreset);
};
const loggedIn = (a, b) => {
    if (a.isLocalParticipant)
        return 1;
    if (b.isLocalParticipant)
        return -1;
    return 0;
};

const LivestreamLayout = (props) => {
    const { useParticipants, useRemoteParticipants, useHasOngoingScreenShare } = useCallStateHooks();
    const call = useCall();
    const participants = useParticipants();
    const [currentSpeaker] = participants;
    const remoteParticipants = useRemoteParticipants();
    const hasOngoingScreenShare = useHasOngoingScreenShare();
    const presenter = hasOngoingScreenShare
        ? participants.find(hasScreenShare)
        : undefined;
    usePaginatedLayoutSortPreset(call);
    const Overlay = (jsx(ParticipantOverlay, { showParticipantCount: props.showParticipantCount, showDuration: props.showDuration, showLiveBadge: props.showLiveBadge, showSpeakerName: props.showSpeakerName }));
    const { floatingParticipantProps, muted } = props;
    const FloatingParticipantOverlay = hasOngoingScreenShare && (jsx(ParticipantOverlay
    // these elements aren't needed for the video feed
    , { 
        // these elements aren't needed for the video feed
        showParticipantCount: floatingParticipantProps?.showParticipantCount ?? false, showDuration: floatingParticipantProps?.showDuration ?? false, showLiveBadge: floatingParticipantProps?.showLiveBadge ?? false, showSpeakerName: floatingParticipantProps?.showSpeakerName ?? true }));
    return (jsxs("div", { className: "str-video__livestream-layout__wrapper", children: [!muted && jsx(ParticipantsAudio, { participants: remoteParticipants }), hasOngoingScreenShare && presenter && (jsx(ParticipantView, { className: "str-video__livestream-layout__screen-share", participant: presenter, ParticipantViewUI: Overlay, trackType: "screenShareTrack", muteAudio // audio is rendered by ParticipantsAudio
                : true })), currentSpeaker && (jsx(ParticipantView, { className: clsx(hasOngoingScreenShare &&
                    clsx('str-video__livestream-layout__floating-participant', `str-video__livestream-layout__floating-participant--${floatingParticipantProps?.position ?? 'top-right'}`)), participant: currentSpeaker, ParticipantViewUI: FloatingParticipantOverlay || Overlay, mirror: props.mirrorLocalParticipantVideo !== false ? undefined : false, muteAudio // audio is rendered by ParticipantsAudio
                : true }))] }));
};
const ParticipantOverlay = (props) => {
    const { enableFullScreen = true, showParticipantCount = true, showDuration = true, showLiveBadge = true, showSpeakerName = false, } = props;
    const { participant } = useParticipantViewContext();
    const { useParticipantCount } = useCallStateHooks();
    const participantCount = useParticipantCount();
    const duration = useUpdateCallDuration();
    const toggleFullScreen = useToggleFullScreen();
    const { t } = useI18n();
    return (jsx("div", { className: "str-video__livestream-layout__overlay", children: jsxs("div", { className: "str-video__livestream-layout__overlay__bar", children: [showLiveBadge && (jsx("span", { className: "str-video__livestream-layout__live-badge", children: t('Live') })), showParticipantCount && (jsx("span", { className: "str-video__livestream-layout__viewers-count", children: participantCount })), showSpeakerName && (jsx("span", { className: "str-video__livestream-layout__speaker-name", title: participant.name || participant.userId || '', children: participant.name || participant.userId || '' })), showDuration && (jsx("span", { className: "str-video__livestream-layout__duration", children: formatDuration(duration) })), enableFullScreen && (jsx("span", { className: "str-video__livestream-layout__go-fullscreen", onClick: toggleFullScreen }))] }) }));
};
LivestreamLayout.displayName = 'LivestreamLayout';
const useUpdateCallDuration = () => {
    const { useIsCallLive, useCallSession } = useCallStateHooks();
    const isCallLive = useIsCallLive();
    const session = useCallSession();
    const [duration, setDuration] = useState(() => {
        if (!session || !session.live_started_at)
            return 0;
        const liveStartTime = new Date(session.live_started_at);
        const now = new Date();
        return Math.floor((now.getTime() - liveStartTime.getTime()) / 1000);
    });
    useEffect(() => {
        if (!isCallLive)
            return;
        const interval = setInterval(() => {
            setDuration((d) => d + 1);
        }, 1000);
        return () => {
            clearInterval(interval);
        };
    }, [isCallLive]);
    return duration;
};
const useToggleFullScreen = () => {
    const { participantViewElement } = useParticipantViewContext();
    const [isFullscreen, setIsFullscreen] = useState(false);
    return useCallback(() => {
        if (isFullscreen) {
            document.exitFullscreen().then(() => {
                setIsFullscreen(false);
            });
        }
        else {
            participantViewElement?.requestFullscreen().then(() => {
                setIsFullscreen(true);
            });
        }
    }, [isFullscreen, participantViewElement]);
};
const formatDuration = (durationInMs) => {
    const days = Math.floor(durationInMs / 86400);
    const hours = Math.floor(durationInMs / 3600);
    const minutes = Math.floor((durationInMs % 3600) / 60);
    const seconds = durationInMs % 60;
    return `${days ? days + ' ' : ''}${hours ? hours + ':' : ''}${minutes < 10 ? '0' : ''}${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
};

const GROUP_SIZE = 16;
const PaginatedGridLayoutGroup = ({ group, mirror, VideoPlaceholder, PictureInPicturePlaceholder, ParticipantViewUI, }) => {
    return (jsx("div", { className: clsx('str-video__paginated-grid-layout__group', {
            'str-video__paginated-grid-layout--one': group.length === 1,
            'str-video__paginated-grid-layout--two-four': group.length >= 2 && group.length <= 4,
            'str-video__paginated-grid-layout--five-nine': group.length >= 5 && group.length <= 9,
        }), children: group.map((participant) => (jsx(ParticipantView, { participant: participant, muteAudio: true, mirror: mirror, VideoPlaceholder: VideoPlaceholder, PictureInPicturePlaceholder: PictureInPicturePlaceholder, ParticipantViewUI: ParticipantViewUI }, participant.sessionId))) }));
};
const PaginatedGridLayout = (props) => {
    const { groupSize = (props.groupSize || 0) > 0
        ? props.groupSize || GROUP_SIZE
        : GROUP_SIZE, excludeLocalParticipant = false, filterParticipants, mirrorLocalParticipantVideo = true, pageArrowsVisible = true, VideoPlaceholder, ParticipantViewUI = DefaultParticipantViewUI, PictureInPicturePlaceholder, muted, } = props;
    const [page, setPage] = useState(0);
    const [paginatedGridLayoutWrapperElement, setPaginatedGridLayoutWrapperElement,] = useState(null);
    const call = useCall();
    const { useRemoteParticipants } = useCallStateHooks();
    const remoteParticipants = useRemoteParticipants();
    const participants = useFilteredParticipants({
        excludeLocalParticipant,
        filterParticipants,
    });
    usePaginatedLayoutSortPreset(call);
    useEffect(() => {
        if (!paginatedGridLayoutWrapperElement || !call)
            return;
        const cleanup = call.setViewport(paginatedGridLayoutWrapperElement);
        return () => cleanup();
    }, [paginatedGridLayoutWrapperElement, call]);
    // only used to render video elements
    const participantGroups = useMemo(() => chunk(participants, groupSize), [participants, groupSize]);
    const pageCount = participantGroups.length;
    // update page when page count is reduced and selected page no longer exists
    useEffect(() => {
        if (page > pageCount - 1) {
            setPage(Math.max(0, pageCount - 1));
        }
    }, [page, pageCount]);
    const selectedGroup = participantGroups[page];
    const mirror = mirrorLocalParticipantVideo ? undefined : false;
    if (!call)
        return null;
    return (jsxs("div", { className: "str-video__paginated-grid-layout__wrapper", ref: setPaginatedGridLayoutWrapperElement, children: [!muted && jsx(ParticipantsAudio, { participants: remoteParticipants }), jsxs("div", { className: "str-video__paginated-grid-layout", children: [pageArrowsVisible && pageCount > 1 && (jsx(IconButton, { icon: "caret-left", disabled: page === 0, onClick: () => setPage((currentPage) => Math.max(0, currentPage - 1)) })), selectedGroup && (jsx(PaginatedGridLayoutGroup, { group: selectedGroup, mirror: mirror, VideoPlaceholder: VideoPlaceholder, ParticipantViewUI: ParticipantViewUI, PictureInPicturePlaceholder: PictureInPicturePlaceholder })), pageArrowsVisible && pageCount > 1 && (jsx(IconButton, { disabled: page === pageCount - 1, icon: "caret-right", onClick: () => setPage((currentPage) => Math.min(pageCount - 1, currentPage + 1)) }))] })] }));
};
PaginatedGridLayout.displayName = 'PaginatedGridLayout';

const useCalculateHardLimit = (
/**
 * Element that stretches to 100% of the whole layout component
 */
wrapperElement, 
/**
 * Element that directly hosts individual `ParticipantView` (or wrapper) elements
 */
hostElement, limit) => {
    const [calculatedLimit, setCalculatedLimit] = useState({
        vertical: typeof limit === 'number' ? limit : null,
        horizontal: typeof limit === 'number' ? limit : null,
    });
    useEffect(() => {
        if (!hostElement ||
            !wrapperElement ||
            typeof limit === 'number' ||
            typeof limit === 'undefined')
            return;
        let childWidth = null;
        let childHeight = null;
        const resizeObserver = new ResizeObserver((entries, observer) => {
            // this part should ideally run as little times as possible
            // get child measurements and disconnect
            // does not consider dynamically sized children
            // this hook is for SpeakerLayout use only, where children in the bar are fixed size
            if (entries.length > 1) {
                const child = hostElement.firstChild;
                if (child) {
                    childHeight = child.clientHeight;
                    childWidth = child.clientWidth;
                    observer.unobserve(hostElement);
                }
            }
            // keep the state at { vertical: 1, horizontal: 1 }
            // until we get the proper child measurements
            if (childHeight === null || childWidth === null)
                return;
            const vertical = Math.floor(wrapperElement.clientHeight / childHeight);
            const horizontal = Math.floor(wrapperElement.clientWidth / childWidth);
            setCalculatedLimit((pv) => {
                if (pv.vertical !== vertical || pv.horizontal !== horizontal)
                    return { vertical, horizontal };
                return pv;
            });
        });
        resizeObserver.observe(wrapperElement);
        resizeObserver.observe(hostElement);
        return () => {
            resizeObserver.disconnect();
        };
    }, [hostElement, limit, wrapperElement]);
    return calculatedLimit;
};

const DefaultParticipantViewUIBar = () => (jsx(DefaultParticipantViewUI, { menuPlacement: "top-end" }));
const SpeakerLayout = ({ ParticipantViewUIBar = DefaultParticipantViewUIBar, ParticipantViewUISpotlight = DefaultParticipantViewUI, VideoPlaceholder, PictureInPicturePlaceholder, participantsBarPosition = 'bottom', participantsBarLimit, mirrorLocalParticipantVideo = true, excludeLocalParticipant = false, filterParticipants, pageArrowsVisible = true, muted, }) => {
    const call = useCall();
    const { useParticipants, useRemoteParticipants } = useCallStateHooks();
    const allParticipants = useParticipants();
    const remoteParticipants = useRemoteParticipants();
    const [participantInSpotlight, ...otherParticipants] = useFilteredParticipants({ excludeLocalParticipant, filterParticipants });
    const [participantsBarWrapperElement, setParticipantsBarWrapperElement] = useState(null);
    const [participantsBarElement, setParticipantsBarElement] = useState(null);
    const [buttonsWrapperElement, setButtonsWrapperElement] = useState(null);
    const isSpeakerScreenSharing = participantInSpotlight && hasScreenShare(participantInSpotlight);
    const hardLimit = useCalculateHardLimit(buttonsWrapperElement, participantsBarElement, participantsBarLimit);
    const isVertical = participantsBarPosition === 'left' || participantsBarPosition === 'right';
    const isHorizontal = participantsBarPosition === 'top' || participantsBarPosition === 'bottom';
    useEffect(() => {
        if (!participantsBarWrapperElement || !call)
            return;
        const cleanup = call.setViewport(participantsBarWrapperElement);
        return () => cleanup();
    }, [participantsBarWrapperElement, call]);
    const isOneOnOneCall = allParticipants.length === 2;
    useSpeakerLayoutSortPreset(call, isOneOnOneCall);
    let participantsWithAppliedLimit = otherParticipants;
    const hardLimitToApply = isVertical
        ? hardLimit.vertical
        : hardLimit.horizontal;
    if (typeof participantsBarLimit !== 'undefined' &&
        hardLimitToApply !== null) {
        participantsWithAppliedLimit = otherParticipants.slice(0, 
        // subtract 1 if speaker is sharing screen as
        // that one is rendered independently from otherParticipants array
        hardLimitToApply - (isSpeakerScreenSharing ? 1 : 0));
    }
    const mirror = mirrorLocalParticipantVideo ? undefined : false;
    if (!call)
        return null;
    const renderParticipantsBar = participantsBarPosition &&
        (participantsWithAppliedLimit.length > 0 || isSpeakerScreenSharing);
    return (jsxs("div", { className: "str-video__speaker-layout__wrapper", children: [!muted && jsx(ParticipantsAudio, { participants: remoteParticipants }), jsxs("div", { className: clsx('str-video__speaker-layout', participantsBarPosition &&
                    `str-video__speaker-layout--variant-${participantsBarPosition}`), children: [jsx("div", { className: "str-video__speaker-layout__spotlight", children: participantInSpotlight && (jsx(ParticipantView, { participant: participantInSpotlight, muteAudio: true, mirror: mirror, trackType: isSpeakerScreenSharing ? 'screenShareTrack' : 'videoTrack', ParticipantViewUI: ParticipantViewUISpotlight, VideoPlaceholder: VideoPlaceholder, PictureInPicturePlaceholder: PictureInPicturePlaceholder })) }), renderParticipantsBar && (jsxs("div", { ref: setButtonsWrapperElement, className: "str-video__speaker-layout__participants-bar-buttons-wrapper", children: [jsx("div", { className: "str-video__speaker-layout__participants-bar-wrapper", ref: setParticipantsBarWrapperElement, children: jsxs("div", { ref: setParticipantsBarElement, className: "str-video__speaker-layout__participants-bar", children: [isSpeakerScreenSharing && (jsx("div", { className: "str-video__speaker-layout__participant-tile", children: jsx(ParticipantView, { participant: participantInSpotlight, ParticipantViewUI: ParticipantViewUIBar, VideoPlaceholder: VideoPlaceholder, PictureInPicturePlaceholder: PictureInPicturePlaceholder, mirror: mirror, muteAudio: true }) }, participantInSpotlight.sessionId)), participantsWithAppliedLimit.map((participant) => (jsx("div", { className: "str-video__speaker-layout__participant-tile", children: jsx(ParticipantView, { participant: participant, ParticipantViewUI: ParticipantViewUIBar, VideoPlaceholder: VideoPlaceholder, PictureInPicturePlaceholder: PictureInPicturePlaceholder, mirror: mirror, muteAudio: true }) }, participant.sessionId)))] }) }), pageArrowsVisible && isVertical && (jsx(VerticalScrollButtons, { scrollWrapper: participantsBarWrapperElement })), pageArrowsVisible && isHorizontal && (jsx(HorizontalScrollButtons, { scrollWrapper: participantsBarWrapperElement }))] }))] })] }));
};
SpeakerLayout.displayName = 'SpeakerLayout';
const HorizontalScrollButtons = ({ scrollWrapper, }) => {
    const scrollPosition = useHorizontalScrollPosition(scrollWrapper);
    const scrollStartClickHandler = () => {
        scrollWrapper?.scrollBy({ left: -150, behavior: 'smooth' });
    };
    const scrollEndClickHandler = () => {
        scrollWrapper?.scrollBy({ left: 150, behavior: 'smooth' });
    };
    return (jsxs(Fragment, { children: [scrollPosition && scrollPosition !== 'start' && (jsx(IconButton, { onClick: scrollStartClickHandler, icon: "caret-left", className: "str-video__speaker-layout__participants-bar--button-left" })), scrollPosition && scrollPosition !== 'end' && (jsx(IconButton, { onClick: scrollEndClickHandler, icon: "caret-right", className: "str-video__speaker-layout__participants-bar--button-right" }))] }));
};
const VerticalScrollButtons = ({ scrollWrapper, }) => {
    const scrollPosition = useVerticalScrollPosition(scrollWrapper);
    const scrollTopClickHandler = () => {
        scrollWrapper?.scrollBy({ top: -150, behavior: 'smooth' });
    };
    const scrollBottomClickHandler = () => {
        scrollWrapper?.scrollBy({ top: 150, behavior: 'smooth' });
    };
    return (jsxs(Fragment, { children: [scrollPosition && scrollPosition !== 'top' && (jsx(IconButton, { onClick: scrollTopClickHandler, icon: "caret-up", className: "str-video__speaker-layout__participants-bar--button-top" })), scrollPosition && scrollPosition !== 'bottom' && (jsx(IconButton, { onClick: scrollBottomClickHandler, icon: "caret-down", className: "str-video__speaker-layout__participants-bar--button-bottom" }))] }));
};

const Pip = (props) => {
    const { t } = useI18n();
    const { excludeLocalParticipant = false, filterParticipants, mirrorLocalParticipantVideo = true, VideoPlaceholder, ParticipantViewUI = DefaultParticipantViewUI, } = props;
    const [layoutWrapperElement, setLayoutWrapperElement] = useState(null);
    const call = useCall();
    const participants = useFilteredParticipants({
        excludeLocalParticipant,
        filterParticipants,
    });
    const screenSharingParticipant = participants.find((p) => hasScreenShare(p));
    usePaginatedLayoutSortPreset(call);
    useEffect(() => {
        if (!layoutWrapperElement || !call)
            return;
        return call.setViewport(layoutWrapperElement);
    }, [layoutWrapperElement, call]);
    const mirror = mirrorLocalParticipantVideo ? undefined : false;
    if (!call)
        return null;
    return (jsxs("div", { className: "str-video__pip-layout", ref: setLayoutWrapperElement, children: [screenSharingParticipant &&
                (screenSharingParticipant.isLocalParticipant ? (jsxs("div", { className: "str-video__pip-screen-share-local", children: [jsx(Icon, { icon: "screen-share-off" }), jsx("span", { className: "str-video__pip-screen-share-local__title", children: t('You are presenting your screen') })] })) : (jsx(ParticipantView, { participant: screenSharingParticipant, trackType: "screenShareTrack", muteAudio: true, mirror: false, VideoPlaceholder: VideoPlaceholder, ParticipantViewUI: ParticipantViewUI }))), participants.map((participant) => (jsx(ParticipantView, { participant: participant, muteAudio: true, mirror: mirror, VideoPlaceholder: VideoPlaceholder, ParticipantViewUI: ParticipantViewUI }, participant.sessionId)))] }));
};
Pip.displayName = 'PipLayout.Pip';
const Host = () => {
    const { useRemoteParticipants } = useCallStateHooks();
    const remoteParticipants = useRemoteParticipants();
    return jsx(ParticipantsAudio, { participants: remoteParticipants });
};
Host.displayName = 'PipLayout.Host';
const PipLayout = { Pip, Host };

const LivestreamPlayer = (props) => {
    const { callType, callId, layoutProps } = props;
    const client = useStreamVideoClient();
    const [call, setCall] = useState();
    useEffect(() => {
        if (!client)
            return;
        const myCall = client.call(callType, callId);
        setCall(myCall);
        myCall.join().catch((e) => {
            console.error('Failed to join call', e);
        });
        return () => {
            myCall.leave().catch((e) => {
                console.error('Failed to leave call', e);
            });
            setCall(undefined);
        };
    }, [callId, callType, client]);
    if (!call)
        return null;
    return (jsx(StreamCall, { call: call, children: jsx(LivestreamLayout, { ...layoutProps }) }));
};

const [major, minor, patch] = ("1.14.4").split('.');
setSdkInfo({
    type: SfuModels.SdkType.REACT,
    major,
    minor,
    patch,
});

export { AcceptCallButton, Audio, Avatar, AvatarFallback, BackgroundFiltersProvider, BaseVideo, CallControls, CallParticipantListing, CallParticipantListingItem, CallParticipantsList, CallPreview, CallRecordingList, CallRecordingListHeader, CallRecordingListItem, CallStats, CallStatsButton, CancelCallButton, CancelCallConfirmButton, CompositeButton, DefaultParticipantViewUI, DefaultReactionsMenu, DefaultScreenShareOverlay, DefaultVideoPlaceholder, DeviceSelector, DeviceSelectorAudioInput, DeviceSelectorAudioOutput, DeviceSelectorVideo, DeviceSettings, DropDownSelect, DropDownSelectOption, EmptyCallRecordingListing, GenericMenu, GenericMenuButtonItem, Icon, IconButton, LivestreamLayout, LivestreamPlayer, LoadingCallRecordingListing, LoadingIndicator, MenuToggle, MenuVisualType, NoiseCancellationProvider, Notification, PaginatedGridLayout, ParticipantActionsContextMenu, ParticipantDetails, ParticipantView, ParticipantViewContext, ParticipantsAudio, PermissionNotification, PermissionRequestList, PermissionRequests, PipLayout, ReactionsButton, RecordCallButton, RecordCallConfirmationButton, RecordingInProgressNotification, RingingCall, RingingCallControls, ScreenShareButton, SearchInput, SearchResults, SpeakerLayout, SpeakingWhileMutedNotification, SpeechIndicator, StatCard, StreamCall, StreamTheme, StreamVideo, TextButton, ToggleAudioOutputButton, ToggleAudioPreviewButton, ToggleAudioPublishingButton, ToggleVideoPreviewButton, ToggleVideoPublishingButton, Tooltip, Video$1 as Video, VideoPreview, WithTooltip, defaultReactions, translations, useBackgroundFilters, useDeviceList, useFilteredParticipants, useHorizontalScrollPosition, useMenuContext, useNoiseCancellation, useParticipantViewContext, usePersistedDevicePreferences, useRequestPermission, useTrackElementVisibility, useVerticalScrollPosition };
//# sourceMappingURL=index.es.js.map
